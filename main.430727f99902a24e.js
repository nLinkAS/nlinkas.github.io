(self.webpackChunkml_iframe=self.webpackChunkml_iframe||[]).push([[179],{819:(xt,yt,Z)=>{"use strict";var Ue={};Z.r(Ue),Z.d(Ue,{browserFiles:()=>Hne,browserHTTPRequest:()=>Kne,concatenateArrayBuffers:()=>Zb,copyModel:()=>Nne,decodeWeights:()=>qP,encodeWeights:()=>jE,fromMemory:()=>Yne,fromMemorySync:()=>mL,getLoadHandlers:()=>yne,getModelArtifactsForJSON:()=>KE,getModelArtifactsForJSONSync:()=>ZP,getModelArtifactsInfoForJSON:()=>vp,getSaveHandlers:()=>JP,getWeightSpecs:()=>QP,http:()=>cI,isHTTPScheme:()=>lI,listModels:()=>Tne,loadWeights:()=>Wne,moveModel:()=>Ane,registerLoadRouter:()=>gne,registerSaveRouter:()=>mne,removeModel:()=>kne,weightsLoaderFactory:()=>dL,withSaveHandler:()=>Zne,withSaveHandlerSync:()=>Qne});var Zn={};Z.r(Zn),Z.d(Zn,{assertParamsValid:()=>pI,computeFlatOffset:()=>yI,computeOutShape:()=>mI,getNormalizedAxes:()=>ore,isSliceContinous:()=>gI,maskToAxes:()=>ire,parseSliceParams:()=>e_,sliceInfo:()=>bI,startForAxis:()=>SL,startIndicesWithElidedDims:()=>xL,stopForAxis:()=>EL,stopIndicesWithElidedDims:()=>wL,stridesForAxis:()=>CL,stridesWithElidedDims:()=>bL});var Ke={};Z.r(Ke),Z.d(Ke,{conv2d:()=>DV,depthwiseConv2d:()=>Mae,matMul:()=>oD});var mn={};Z.r(mn),Z.d(mn,{collectGatherOpShapeInfo:()=>zD,computeOutShape:()=>lB,segOpComputeOptimalWindowSize:()=>aB});var lt={};Z.r(lt),Z.d(lt,{ERF_A1:()=>DD,ERF_A2:()=>TD,ERF_A3:()=>kD,ERF_A4:()=>ND,ERF_A5:()=>AD,ERF_P:()=>ID,PARALLELIZE_THRESHOLD:()=>xD,RowPartitionType:()=>Ai,SELU_SCALE:()=>N_,SELU_SCALEALPHA:()=>k_,applyActivation:()=>E_,assertAndGetBroadcastShape:()=>Je,assertAxesAreInnerMostDims:()=>kr,assertParamsConsistent:()=>vD,assignToTypedArray:()=>jV,axesAreInnerMostDims:()=>NI,calculateShapes:()=>Op,checkEinsumDimSizes:()=>$D,checkPadOnDimRoundingMode:()=>Kr,combineLocations:()=>eV,combineRaggedTensorToTensorShapes:()=>LV,complexWithEvenIndex:()=>HV,complexWithOddIndex:()=>WV,computeConv2DInfo:()=>vr,computeConv3DInfo:()=>nl,computeDefaultPad:()=>xI,computeDilation2DInfo:()=>xp,computeOptimalWindowSize:()=>T_,computeOutAndReduceShapes:()=>xr,computeOutShape:()=>Fo,computePool2DInfo:()=>Ii,computePool3DInfo:()=>pa,convertConv2DDataFormat:()=>ma,decodeEinsumEquation:()=>FD,eitherStridesOrDilationsAreOne:()=>Tr,expandShapeToKeepDim:()=>Vn,exponent:()=>qV,exponents:()=>GV,fromStringArrayToUint8:()=>cB,fromUint8ToStringArray:()=>mc,getAxesPermutation:()=>En,getBroadcastDims:()=>sd,getComplexWithIndex:()=>RD,getEinsumComputePath:()=>PD,getEinsumPermutation:()=>OD,getFusedBiasGradient:()=>S_,getFusedDyActivation:()=>C_,getImageCenter:()=>wD,getInnerMostAxes:()=>Bn,getPermuted:()=>Pp,getRaggedRank:()=>BV,getReductionAxes:()=>nr,getReshaped:()=>$p,getReshapedPermuted:()=>Lp,getRowPartitionTypesHelper:()=>VV,getSliceBeginCoords:()=>CD,getSliceSize:()=>SD,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>YV,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>ZV,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>QV,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>tB,getSparseReshapeInputOutputMismatchErrorMessage:()=>rB,getSparseReshapeInputOutputMultipleErrorMessage:()=>nB,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>JV,getSparseReshapeNegativeOutputDimErrorMessage:()=>eB,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>oB,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>BD,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>sB,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>iB,getUndoAxesPermutation:()=>il,isIdentityPermutation:()=>LD,log:()=>Ote,mergeRealAndImagArrays:()=>_a,prepareAndValidate:()=>ED,prepareSplitSize:()=>VD,segment_util:()=>mn,shouldFuse:()=>I_,slice_util:()=>Zn,splitRealAndImagArrays:()=>UV,tupleValuesAreOne:()=>rl,upcastType:()=>Ds,validateDefaultValueShape:()=>zV,validateInput:()=>SV,validateUpdateShape:()=>CV,warn:()=>Zs});var Be={};Z.r(Be),Z.d(Be,{json:()=>hfe});var rt={};Z.r(rt),Z.d(rt,{json:()=>ffe});var Ie={};Z.r(Ie),Z.d(Ie,{json:()=>pfe});var U={};Z.r(U),Z.d(U,{json:()=>mfe});var pe={};Z.r(pe),Z.d(pe,{json:()=>gfe});var be={};Z.r(be),Z.d(be,{json:()=>yfe});var re={};Z.r(re),Z.d(re,{json:()=>bfe});var fe={};Z.r(fe),Z.d(fe,{json:()=>_fe});var Ne={};Z.r(Ne),Z.d(Ne,{json:()=>vfe});var Fe={};Z.r(Fe),Z.d(Fe,{json:()=>xfe});var Lt={};Z.r(Lt),Z.d(Lt,{json:()=>wfe});var Qn={};Z.r(Qn),Z.d(Qn,{json:()=>Cfe});var Hn={};Z.r(Hn),Z.d(Hn,{json:()=>Sfe});var hi={};Z.r(hi),Z.d(hi,{json:()=>Efe});var Os={};Z.r(Os),Z.d(Os,{json:()=>Ife});var wt={};Z.r(wt),Z.d(wt,{json:()=>Dfe});var At={};Z.r(At),Z.d(At,{json:()=>Tfe});var Rt={};Z.r(Rt),Z.d(Rt,{json:()=>kfe});var ce={};Z.r(ce),Z.d(ce,{json:()=>Nfe});var Q={};Z.r(Q),Z.d(Q,{OP_SCOPE_SUFFIX:()=>GP,abs:()=>rr,acos:()=>TL,acosh:()=>kL,add:()=>le,addN:()=>yre,all:()=>vI,any:()=>n_,argMax:()=>od,argMin:()=>NL,asin:()=>AL,asinh:()=>RL,atan:()=>ML,atan2:()=>FL,atanh:()=>OL,avgPool:()=>s_,avgPool3d:()=>$L,basicLSTMCell:()=>zre,batchNorm:()=>wp,batchNorm2d:()=>PL,batchNorm3d:()=>LL,batchNorm4d:()=>VL,batchToSpaceND:()=>i_,bincount:()=>BL,booleanMaskAsync:()=>fae,broadcastArgs:()=>Yre,broadcastTo:()=>cd,buffer:()=>it,cast:()=>ve,ceil:()=>zL,clipByValue:()=>Ts,clone:()=>ha,complex:()=>Qa,concat:()=>Xn,concat1d:()=>UL,concat2d:()=>HL,concat3d:()=>WL,concat4d:()=>jL,conv1d:()=>CI,conv2d:()=>sl,conv2dTranspose:()=>EI,conv3d:()=>GL,conv3dTranspose:()=>KL,cos:()=>o_,cosh:()=>II,cosineWindow:()=>rD,cumprod:()=>a_,cumsum:()=>DI,denseBincount:()=>TI,depthToSpace:()=>XL,depthwiseConv2d:()=>Cp,diag:()=>_se,dilation2d:()=>YL,div:()=>$e,divNoNan:()=>ZL,dot:()=>QL,dropout:()=>EV,einsum:()=>kse,elu:()=>Sp,enclosingPowerOfTwo:()=>IV,equal:()=>oo,erf:()=>JL,euclideanNorm:()=>nV,exp:()=>Js,expandDims:()=>hs,expm1:()=>rV,eye:()=>AI,fft:()=>x_,fill:()=>ud,floor:()=>Dp,floorDiv:()=>kI,fused:()=>Ke,gather:()=>Tp,gatherND:()=>Cae,greater:()=>ks,greaterEqual:()=>al,ifft:()=>Mp,imag:()=>l_,image:()=>ba,inTopKAsync:()=>Dae,irfft:()=>YI,isFinite:()=>sV,isInf:()=>iV,isNaN:()=>oV,leakyRelu:()=>c_,less:()=>RI,lessEqual:()=>hc,linalg:()=>$V,linspace:()=>nie,localResponseNormalization:()=>aV,log:()=>ei,log1p:()=>u_,logSigmoid:()=>lV,logSoftmax:()=>MI,logSumExp:()=>FI,logicalAnd:()=>Ro,logicalNot:()=>d_,logicalOr:()=>OI,logicalXor:()=>cV,losses:()=>ace,lowerBound:()=>yie,matMul:()=>pt,max:()=>Di,maxPool:()=>f_,maxPool3d:()=>uV,maxPoolWithArgmax:()=>xie,maximum:()=>ga,mean:()=>Mn,meshgrid:()=>Sie,min:()=>Ep,minimum:()=>kp,mirrorPad:()=>dV,mod:()=>hV,moments:()=>p_,movingAverage:()=>gae,mul:()=>M,multiRNNCell:()=>Nie,multinomial:()=>Rie,neg:()=>yn,norm:()=>Ip,notEqual:()=>hd,oneHot:()=>PI,ones:()=>ti,onesLike:()=>ni,op:()=>A,outerProduct:()=>Pie,pad:()=>ll,pad1d:()=>Bie,pad2d:()=>Uie,pad3d:()=>Wie,pad4d:()=>Gie,pool:()=>fV,pow:()=>ol,prelu:()=>g_,print:()=>aL,prod:()=>pV,raggedGather:()=>eoe,raggedRange:()=>noe,raggedTensorToTensor:()=>soe,rand:()=>ooe,randomGamma:()=>foe,randomNormal:()=>BI,randomStandardNormal:()=>goe,randomUniform:()=>Np,range:()=>fd,real:()=>Ap,reciprocal:()=>mV,relu:()=>Mo,relu6:()=>zI,reshape:()=>F,reverse:()=>ki,reverse1d:()=>Soe,reverse2d:()=>Ioe,reverse3d:()=>Toe,reverse4d:()=>Noe,rfft:()=>w_,round:()=>UI,rsqrt:()=>HI,scalar:()=>Le,scatterND:()=>bae,searchSorted:()=>$I,selu:()=>WI,separableConv2d:()=>jI,setdiff1dAsync:()=>$oe,sigmoid:()=>Ao,sign:()=>gV,signal:()=>oce,sin:()=>qI,sinh:()=>KI,slice:()=>Dt,slice1d:()=>b_,slice2d:()=>XI,slice3d:()=>__,slice4d:()=>Rp,softmax:()=>v_,softplus:()=>dd,spaceToBatchND:()=>m_,sparse:()=>lce,sparseToDense:()=>xae,spectral:()=>ice,split:()=>Ns,sqrt:()=>Pr,square:()=>Yt,squaredDifference:()=>ZI,squeeze:()=>fc,stack:()=>ri,step:()=>pd,stridedSlice:()=>yV,string:()=>cce,sub:()=>De,sum:()=>Ae,tan:()=>bV,tanh:()=>ld,tensor:()=>so,tensor1d:()=>fs,tensor2d:()=>Fp,tensor3d:()=>gL,tensor4d:()=>nae,tensor5d:()=>rae,tensor6d:()=>sae,tile:()=>Ti,topk:()=>_V,transpose:()=>vt,truncatedNormal:()=>QI,unique:()=>vV,unsortedSegmentSum:()=>JI,unstack:()=>Ni,upperBound:()=>uae,variable:()=>xV,where:()=>ds,whereAsync:()=>wV,zeros:()=>sr,zerosLike:()=>Tt});var k={};function ae(n){return"function"==typeof n}function je(n){const e=n(r=>{Error.call(r),r.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}Z.r(k),Z.d(k,{addImpl:()=>v3,bincountImpl:()=>e1,bincountReduceImpl:()=>I3,castImpl:()=>_3,ceilImpl:()=>D3,concatImpl:()=>T3,equalImpl:()=>A3,expImpl:()=>M3,expm1Impl:()=>O3,floorImpl:()=>L3,gatherNdImpl:()=>V3,gatherV2Impl:()=>B3,greaterEqualImpl:()=>U3,greaterImpl:()=>z3,lessEqualImpl:()=>W3,lessImpl:()=>H3,linSpaceImpl:()=>j3,logImpl:()=>G3,maxImpl:()=>q3,maximumImpl:()=>X3,minimumImpl:()=>Y3,multiplyImpl:()=>t1,negImpl:()=>Q3,notEqualImpl:()=>J3,prodImpl:()=>rU,raggedGatherImpl:()=>iU,raggedRangeImpl:()=>aU,raggedTensorToTensorImpl:()=>uU,rangeImpl:()=>dU,rsqrtImpl:()=>hU,scatterImpl:()=>Dd,sigmoidImpl:()=>Jpe,simpleAbsImpl:()=>w3,sliceImpl:()=>E3,sparseFillEmptyRowsImpl:()=>pU,sparseReshapeImpl:()=>mU,sparseSegmentReductionImpl:()=>l1,sqrtImpl:()=>wve,squaredDifferenceImpl:()=>gU,stridedSliceImpl:()=>yU,stringNGramsImpl:()=>bU,stringSplitImpl:()=>_U,stringToHashBucketFastImpl:()=>vU,subImpl:()=>$3,tileImpl:()=>xU,topKImpl:()=>CU,transposeImpl:()=>QT,uniqueImpl:()=>EU});const Ct=je(n=>function(e){n(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((r,s)=>`${s+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function ct(n,t){if(n){const e=n.indexOf(t);0<=e&&n.splice(e,1)}}class He{constructor(t){this.initialTeardown=t,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const i of e)i.remove(this);else e.remove(this);const{initialTeardown:r}=this;if(ae(r))try{r()}catch(i){t=i instanceof Ct?i.errors:[i]}const{_finalizers:s}=this;if(s){this._finalizers=null;for(const i of s)try{ur(i)}catch(o){t=t??[],o instanceof Ct?t=[...t,...o.errors]:t.push(o)}}if(t)throw new Ct(t)}}add(t){var e;if(t&&t!==this)if(this.closed)ur(t);else{if(t instanceof He){if(t.closed||t._hasParent(this))return;t._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(t)}}_hasParent(t){const{_parentage:e}=this;return e===t||Array.isArray(e)&&e.includes(t)}_addParent(t){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(t),e):e?[e,t]:t}_removeParent(t){const{_parentage:e}=this;e===t?this._parentage=null:Array.isArray(e)&&ct(e,t)}remove(t){const{_finalizers:e}=this;e&&ct(e,t),t instanceof He&&t._removeParent(this)}}He.EMPTY=(()=>{const n=new He;return n.closed=!0,n})();const On=He.EMPTY;function Wn(n){return n instanceof He||n&&"closed"in n&&ae(n.remove)&&ae(n.add)&&ae(n.unsubscribe)}function ur(n){ae(n)?n():n.unsubscribe()}const qt={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},Rr={setTimeout(n,t,...e){const{delegate:r}=Rr;return r?.setTimeout?r.setTimeout(n,t,...e):setTimeout(n,t,...e)},clearTimeout(n){const{delegate:t}=Rr;return(t?.clearTimeout||clearTimeout)(n)},delegate:void 0};function jn(n){Rr.setTimeout(()=>{const{onUnhandledError:t}=qt;if(!t)throw n;t(n)})}function Mr(){}const Bc=Ex("C",void 0,void 0);function Ex(n,t,e){return{kind:n,value:t,error:e}}let Ml=null;function Mm(n){if(qt.useDeprecatedSynchronousErrorHandling){const t=!Ml;if(t&&(Ml={errorThrown:!1,error:null}),n(),t){const{errorThrown:e,error:r}=Ml;if(Ml=null,e)throw r}}else n()}class Ix extends He{constructor(t){super(),this.isStopped=!1,t?(this.destination=t,Wn(t)&&t.add(this)):this.destination=cG}static create(t,e,r){return new Zd(t,e,r)}next(t){this.isStopped?Tx(function sG(n){return Ex("N",n,void 0)}(t),this):this._next(t)}error(t){this.isStopped?Tx(function rG(n){return Ex("E",void 0,n)}(t),this):(this.isStopped=!0,this._error(t))}complete(){this.isStopped?Tx(Bc,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(t){this.destination.next(t)}_error(t){try{this.destination.error(t)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const oG=Function.prototype.bind;function Dx(n,t){return oG.call(n,t)}class aG{constructor(t){this.partialObserver=t}next(t){const{partialObserver:e}=this;if(e.next)try{e.next(t)}catch(r){Fm(r)}}error(t){const{partialObserver:e}=this;if(e.error)try{e.error(t)}catch(r){Fm(r)}else Fm(t)}complete(){const{partialObserver:t}=this;if(t.complete)try{t.complete()}catch(e){Fm(e)}}}class Zd extends Ix{constructor(t,e,r){let s;if(super(),ae(t)||!t)s={next:t??void 0,error:e??void 0,complete:r??void 0};else{let i;this&&qt.useDeprecatedNextContext?(i=Object.create(t),i.unsubscribe=()=>this.unsubscribe(),s={next:t.next&&Dx(t.next,i),error:t.error&&Dx(t.error,i),complete:t.complete&&Dx(t.complete,i)}):s=t}this.destination=new aG(s)}}function Fm(n){qt.useDeprecatedSynchronousErrorHandling?function iG(n){qt.useDeprecatedSynchronousErrorHandling&&Ml&&(Ml.errorThrown=!0,Ml.error=n)}(n):jn(n)}function Tx(n,t){const{onStoppedNotification:e}=qt;e&&Rr.setTimeout(()=>e(n,t))}const cG={closed:!0,next:Mr,error:function lG(n){throw n},complete:Mr},kx="function"==typeof Symbol&&Symbol.observable||"@@observable";function Aa(n){return n}function Wk(n){return 0===n.length?Aa:1===n.length?n[0]:function(e){return n.reduce((r,s)=>s(r),e)}}let xn=(()=>{class n{constructor(e){e&&(this._subscribe=e)}lift(e){const r=new n;return r.source=this,r.operator=e,r}subscribe(e,r,s){const i=function hG(n){return n&&n instanceof Ix||function dG(n){return n&&ae(n.next)&&ae(n.error)&&ae(n.complete)}(n)&&Wn(n)}(e)?e:new Zd(e,r,s);return Mm(()=>{const{operator:o,source:a}=this;i.add(o?o.call(i,a):a?this._subscribe(i):this._trySubscribe(i))}),i}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return new(r=jk(r))((s,i)=>{const o=new Zd({next:a=>{try{e(a)}catch(l){i(l),o.unsubscribe()}},error:i,complete:s});this.subscribe(o)})}_subscribe(e){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(e)}[kx](){return this}pipe(...e){return Wk(e)(this)}toPromise(e){return new(e=jk(e))((r,s)=>{let i;this.subscribe(o=>i=o,o=>s(o),()=>r(i))})}}return n.create=t=>new n(t),n})();function jk(n){var t;return null!==(t=n??qt.Promise)&&void 0!==t?t:Promise}const fG=je(n=>function(){n(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let Wt=(()=>{class n extends xn{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const r=new Gk(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new fG}next(e){Mm(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(e)}})}error(e){Mm(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){Mm(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:r,isStopped:s,observers:i}=this;return r||s?On:(this.currentObservers=null,i.push(e),new He(()=>{this.currentObservers=null,ct(i,e)}))}_checkFinalizedStatuses(e){const{hasError:r,thrownError:s,isStopped:i}=this;r?e.error(s):i&&e.complete()}asObservable(){const e=new xn;return e.source=this,e}}return n.create=(t,e)=>new Gk(t,e),n})();class Gk extends Wt{constructor(t,e){super(),this.destination=t,this.source=e}next(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===r||r.call(e,t)}error(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===r||r.call(e,t)}complete(){var t,e;null===(e=null===(t=this.destination)||void 0===t?void 0:t.complete)||void 0===e||e.call(t)}_subscribe(t){var e,r;return null!==(r=null===(e=this.source)||void 0===e?void 0:e.subscribe(t))&&void 0!==r?r:On}}function qk(n){return ae(n?.lift)}function Dn(n){return t=>{if(qk(t))return t.lift(function(e){try{return n(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function ln(n,t,e,r,s){return new pG(n,t,e,r,s)}class pG extends Ix{constructor(t,e,r,s,i,o){super(t),this.onFinalize=i,this.shouldUnsubscribe=o,this._next=e?function(a){try{e(a)}catch(l){t.error(l)}}:super._next,this._error=s?function(a){try{s(a)}catch(l){t.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){t.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(t=this.onFinalize)||void 0===t||t.call(this))}}}function ze(n,t){return Dn((e,r)=>{let s=0;e.subscribe(ln(r,i=>{r.next(n.call(t,i,s++))}))})}function Fl(n){return this instanceof Fl?(this.v=n,this):new Fl(n)}function yG(n,t,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s,r=e.apply(n,t||[]),i=[];return s={},o("next"),o("throw"),o("return"),s[Symbol.asyncIterator]=function(){return this},s;function o(h){r[h]&&(s[h]=function(f){return new Promise(function(p,m){i.push([h,f,p,m])>1||a(h,f)})})}function a(h,f){try{!function l(h){h.value instanceof Fl?Promise.resolve(h.value.v).then(c,u):d(i[0][2],h)}(r[h](f))}catch(p){d(i[0][3],p)}}function c(h){a("next",h)}function u(h){a("throw",h)}function d(h,f){h(f),i.shift(),i.length&&a(i[0][0],i[0][1])}}function bG(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,t=n[Symbol.asyncIterator];return t?t.call(n):(n=function Yk(n){var t="function"==typeof Symbol&&Symbol.iterator,e=t&&n[t],r=0;if(e)return e.call(n);if(n&&"number"==typeof n.length)return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(n),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(i){e[i]=n[i]&&function(o){return new Promise(function(a,l){!function s(i,o,a,l){Promise.resolve(l).then(function(c){i({value:c,done:a})},o)}(a,l,(o=n[i](o)).done,o.value)})}}}const Ax=n=>n&&"number"==typeof n.length&&"function"!=typeof n;function Zk(n){return ae(n?.then)}function Qk(n){return ae(n[kx])}function Jk(n){return Symbol.asyncIterator&&ae(n?.[Symbol.asyncIterator])}function eN(n){return new TypeError(`You provided ${null!==n&&"object"==typeof n?"an invalid object":`'${n}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const tN=function vG(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function nN(n){return ae(n?.[tN])}function rN(n){return yG(this,arguments,function*(){const e=n.getReader();try{for(;;){const{value:r,done:s}=yield Fl(e.read());if(s)return yield Fl(void 0);yield yield Fl(r)}}finally{e.releaseLock()}})}function sN(n){return ae(n?.getReader)}function Vr(n){if(n instanceof xn)return n;if(null!=n){if(Qk(n))return function xG(n){return new xn(t=>{const e=n[kx]();if(ae(e.subscribe))return e.subscribe(t);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(n);if(Ax(n))return function wG(n){return new xn(t=>{for(let e=0;e<n.length&&!t.closed;e++)t.next(n[e]);t.complete()})}(n);if(Zk(n))return function CG(n){return new xn(t=>{n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,jn)})}(n);if(Jk(n))return iN(n);if(nN(n))return function SG(n){return new xn(t=>{for(const e of n)if(t.next(e),t.closed)return;t.complete()})}(n);if(sN(n))return function EG(n){return iN(rN(n))}(n)}throw eN(n)}function iN(n){return new xn(t=>{(function IG(n,t){var e,r,s,i;return function mG(n,t,e,r){return new(e||(e=Promise))(function(i,o){function a(u){try{c(r.next(u))}catch(d){o(d)}}function l(u){try{c(r.throw(u))}catch(d){o(d)}}function c(u){u.done?i(u.value):function s(i){return i instanceof e?i:new e(function(o){o(i)})}(u.value).then(a,l)}c((r=r.apply(n,t||[])).next())})}(this,void 0,void 0,function*(){try{for(e=bG(n);!(r=yield e.next()).done;)if(t.next(r.value),t.closed)return}catch(o){s={error:o}}finally{try{r&&!r.done&&(i=e.return)&&(yield i.call(e))}finally{if(s)throw s.error}}t.complete()})})(n,t).catch(e=>t.error(e))})}function jo(n,t,e,r=0,s=!1){const i=t.schedule(function(){e(),s?n.add(this.schedule(null,r)):this.unsubscribe()},r);if(n.add(i),!s)return i}function Er(n,t,e=1/0){return ae(t)?Er((r,s)=>ze((i,o)=>t(r,i,s,o))(Vr(n(r,s))),e):("number"==typeof t&&(e=t),Dn((r,s)=>function DG(n,t,e,r,s,i,o,a){const l=[];let c=0,u=0,d=!1;const h=()=>{d&&!l.length&&!c&&t.complete()},f=m=>c<r?p(m):l.push(m),p=m=>{i&&t.next(m),c++;let g=!1;Vr(e(m,u++)).subscribe(ln(t,y=>{s?.(y),i?f(y):t.next(y)},()=>{g=!0},void 0,()=>{if(g)try{for(c--;l.length&&c<r;){const y=l.shift();o?jo(t,o,()=>p(y)):p(y)}h()}catch(y){t.error(y)}}))};return n.subscribe(ln(t,f,()=>{d=!0,h()})),()=>{a?.()}}(r,s,n,e)))}function zc(n=1/0){return Er(Aa,n)}const Go=new xn(n=>n.complete());function oN(n){return n&&ae(n.schedule)}function Rx(n){return n[n.length-1]}function aN(n){return ae(Rx(n))?n.pop():void 0}function Qd(n){return oN(Rx(n))?n.pop():void 0}function lN(n,t=0){return Dn((e,r)=>{e.subscribe(ln(r,s=>jo(r,n,()=>r.next(s),t),()=>jo(r,n,()=>r.complete(),t),s=>jo(r,n,()=>r.error(s),t)))})}function cN(n,t=0){return Dn((e,r)=>{r.add(n.schedule(()=>e.subscribe(r),t))})}function uN(n,t){if(!n)throw new Error("Iterable cannot be null");return new xn(e=>{jo(e,t,()=>{const r=n[Symbol.asyncIterator]();jo(e,t,()=>{r.next().then(s=>{s.done?e.complete():e.next(s.value)})},0,!0)})})}function $n(n,t){return t?function OG(n,t){if(null!=n){if(Qk(n))return function NG(n,t){return Vr(n).pipe(cN(t),lN(t))}(n,t);if(Ax(n))return function RG(n,t){return new xn(e=>{let r=0;return t.schedule(function(){r===n.length?e.complete():(e.next(n[r++]),e.closed||this.schedule())})})}(n,t);if(Zk(n))return function AG(n,t){return Vr(n).pipe(cN(t),lN(t))}(n,t);if(Jk(n))return uN(n,t);if(nN(n))return function MG(n,t){return new xn(e=>{let r;return jo(e,t,()=>{r=n[tN](),jo(e,t,()=>{let s,i;try{({value:s,done:i}=r.next())}catch(o){return void e.error(o)}i?e.complete():e.next(s)},0,!0)}),()=>ae(r?.return)&&r.return()})}(n,t);if(sN(n))return function FG(n,t){return uN(rN(n),t)}(n,t)}throw eN(n)}(n,t):Vr(n)}function Jd(...n){const t=Qd(n),e=function kG(n,t){return"number"==typeof Rx(n)?n.pop():t}(n,1/0),r=n;return r.length?1===r.length?Vr(r[0]):zc(e)($n(r,t)):Go}function dN(n={}){const{connector:t=(()=>new Wt),resetOnError:e=!0,resetOnComplete:r=!0,resetOnRefCountZero:s=!0}=n;return i=>{let o,a,l,c=0,u=!1,d=!1;const h=()=>{a?.unsubscribe(),a=void 0},f=()=>{h(),o=l=void 0,u=d=!1},p=()=>{const m=o;f(),m?.unsubscribe()};return Dn((m,g)=>{c++,!d&&!u&&h();const y=l=l??t();g.add(()=>{c--,0===c&&!d&&!u&&(a=Mx(p,s))}),y.subscribe(g),!o&&c>0&&(o=new Zd({next:b=>y.next(b),error:b=>{d=!0,h(),a=Mx(f,e,b),y.error(b)},complete:()=>{u=!0,h(),a=Mx(f,r),y.complete()}}),Vr(m).subscribe(o))})(i)}}function Mx(n,t,...e){if(!0===t)return void n();if(!1===t)return;const r=new Zd({next:()=>{r.unsubscribe(),n()}});return t(...e).subscribe(r)}function Qt(n){for(let t in n)if(n[t]===Qt)return t;throw Error("Could not find renamed property on target object.")}function Fx(n,t){for(const e in t)t.hasOwnProperty(e)&&!n.hasOwnProperty(e)&&(n[e]=t[e])}function Jt(n){if("string"==typeof n)return n;if(Array.isArray(n))return"["+n.map(Jt).join(", ")+"]";if(null==n)return""+n;if(n.overriddenName)return`${n.overriddenName}`;if(n.name)return`${n.name}`;const t=n.toString();if(null==t)return""+t;const e=t.indexOf("\n");return-1===e?t:t.substring(0,e)}function Ox(n,t){return null==n||""===n?null===t?"":t:null==t||""===t?n:n+" "+t}const $G=Qt({__forward_ref__:Qt});function cn(n){return n.__forward_ref__=cn,n.toString=function(){return Jt(this())},n}function Ge(n){return $x(n)?n():n}function $x(n){return"function"==typeof n&&n.hasOwnProperty($G)&&n.__forward_ref__===cn}function Px(n){return n&&!!n.\u0275providers}const Om="https://g.co/ng/security#xss";class te extends Error{constructor(t,e){super(function $m(n,t){return`NG0${Math.abs(n)}${t?": "+t.trim():""}`}(t,e)),this.code=t}}function tt(n){return"string"==typeof n?n:null==n?"":String(n)}function Pm(n,t){throw new te(-201,!1)}function Ps(n,t){null==n&&function Bt(n,t,e,r){throw new Error(`ASSERTION ERROR: ${n}`+(null==r?"":` [Expected=> ${e} ${r} ${t} <=Actual]`))}(t,n,null,"!=")}function Ce(n){return{token:n.token,providedIn:n.providedIn||null,factory:n.factory,value:void 0}}function jt(n){return{providers:n.providers||[],imports:n.imports||[]}}function Lm(n){return hN(n,Vm)||hN(n,pN)}function hN(n,t){return n.hasOwnProperty(t)?n[t]:null}function fN(n){return n&&(n.hasOwnProperty(Lx)||n.hasOwnProperty(jG))?n[Lx]:null}const Vm=Qt({\u0275prov:Qt}),Lx=Qt({\u0275inj:Qt}),pN=Qt({ngInjectableDef:Qt}),jG=Qt({ngInjectorDef:Qt});var qe=(()=>((qe=qe||{})[qe.Default=0]="Default",qe[qe.Host=1]="Host",qe[qe.Self=2]="Self",qe[qe.SkipSelf=4]="SkipSelf",qe[qe.Optional=8]="Optional",qe))();let Vx;function fi(n){const t=Vx;return Vx=n,t}function mN(n,t,e){const r=Lm(n);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:e&qe.Optional?null:void 0!==t?t:void Pm(Jt(n))}const un=(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)(),eh={},Bx="__NG_DI_FLAG__",Bm="ngTempTokenPath",KG=/\n/gm,gN="__source";let th;function Uc(n){const t=th;return th=n,t}function YG(n,t=qe.Default){if(void 0===th)throw new te(-203,!1);return null===th?mN(n,void 0,t):th.get(n,t&qe.Optional?null:void 0,t)}function J(n,t=qe.Default){return(function GG(){return Vx}()||YG)(Ge(n),t)}function Mt(n,t=qe.Default){return J(n,zm(t))}function zm(n){return typeof n>"u"||"number"==typeof n?n:0|(n.optional&&8)|(n.host&&1)|(n.self&&2)|(n.skipSelf&&4)}function zx(n){const t=[];for(let e=0;e<n.length;e++){const r=Ge(n[e]);if(Array.isArray(r)){if(0===r.length)throw new te(900,!1);let s,i=qe.Default;for(let o=0;o<r.length;o++){const a=r[o],l=ZG(a);"number"==typeof l?-1===l?s=a.token:i|=l:s=a}t.push(J(s,i))}else t.push(J(r))}return t}function nh(n,t){return n[Bx]=t,n.prototype[Bx]=t,n}function ZG(n){return n[Bx]}function Ra(n){return{toString:n}.toString()}var Hi=(()=>((Hi=Hi||{})[Hi.OnPush=0]="OnPush",Hi[Hi.Default=1]="Default",Hi))(),Wi=(()=>{return(n=Wi||(Wi={}))[n.Emulated=0]="Emulated",n[n.None=2]="None",n[n.ShadowDom=3]="ShadowDom",Wi;var n})();const Ko={},$t=[],Um=Qt({\u0275cmp:Qt}),Ux=Qt({\u0275dir:Qt}),Hx=Qt({\u0275pipe:Qt}),bN=Qt({\u0275mod:Qt}),Xo=Qt({\u0275fac:Qt}),rh=Qt({__NG_ELEMENT_ID__:Qt});let e5=0;function pi(n){return Ra(()=>{const e=!0===n.standalone,r={},s={type:n.type,providersResolver:null,decls:n.decls,vars:n.vars,factory:null,template:n.template||null,consts:n.consts||null,ngContentSelectors:n.ngContentSelectors,hostBindings:n.hostBindings||null,hostVars:n.hostVars||0,hostAttrs:n.hostAttrs||null,contentQueries:n.contentQueries||null,declaredInputs:r,inputs:null,outputs:null,exportAs:n.exportAs||null,onPush:n.changeDetection===Hi.OnPush,directiveDefs:null,pipeDefs:null,standalone:e,dependencies:e&&n.dependencies||null,getStandaloneInjector:null,selectors:n.selectors||$t,viewQuery:n.viewQuery||null,features:n.features||null,data:n.data||{},encapsulation:n.encapsulation||Wi.Emulated,id:"c"+e5++,styles:n.styles||$t,_:null,setInput:null,schemas:n.schemas||null,tView:null,findHostDirectiveDefs:null,hostDirectives:null},i=n.dependencies,o=n.features;return s.inputs=xN(n.inputs,r),s.outputs=xN(n.outputs),o&&o.forEach(a=>a(s)),s.directiveDefs=i?()=>("function"==typeof i?i():i).map(_N).filter(vN):null,s.pipeDefs=i?()=>("function"==typeof i?i():i).map(ns).filter(vN):null,s})}function _N(n){return zt(n)||Br(n)}function vN(n){return null!==n}function Kt(n){return Ra(()=>({type:n.type,bootstrap:n.bootstrap||$t,declarations:n.declarations||$t,imports:n.imports||$t,exports:n.exports||$t,transitiveCompileScopes:null,schemas:n.schemas||null,id:n.id||null}))}function xN(n,t){if(null==n)return Ko;const e={};for(const r in n)if(n.hasOwnProperty(r)){let s=n[r],i=s;Array.isArray(s)&&(i=s[1],s=s[0]),e[s]=r,t&&(t[s]=i)}return e}const Ve=pi;function _s(n){return{type:n.type,name:n.name,factory:null,pure:!1!==n.pure,standalone:!0===n.standalone,onDestroy:n.type.prototype.ngOnDestroy||null}}function zt(n){return n[Um]||null}function Br(n){return n[Ux]||null}function ns(n){return n[Hx]||null}function Ls(n,t){const e=n[bN]||null;if(!e&&!0===t)throw new Error(`Type ${Jt(n)} does not have '\u0275mod' property.`);return e}function vs(n){return Array.isArray(n)&&"object"==typeof n[1]}function Gi(n){return Array.isArray(n)&&!0===n[1]}function Gx(n){return 0!=(4&n.flags)}function Gm(n){return n.componentOffset>-1}function qm(n){return 1==(1&n.flags)}function qi(n){return null!==n.template}function o5(n){return 0!=(256&n[2])}function Vl(n,t){return n.hasOwnProperty(Xo)?n[Xo]:null}class c5{constructor(t,e,r){this.previousValue=t,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}}function xs(){return SN}function SN(n){return n.type.prototype.ngOnChanges&&(n.setInput=d5),u5}function u5(){const n=IN(this),t=n?.current;if(t){const e=n.previous;if(e===Ko)n.previous=t;else for(let r in t)e[r]=t[r];n.current=null,this.ngOnChanges(t)}}function d5(n,t,e,r){const s=this.declaredInputs[e],i=IN(n)||function h5(n,t){return n[EN]=t}(n,{previous:Ko,current:null}),o=i.current||(i.current={}),a=i.previous,l=a[s];o[s]=new c5(l&&l.currentValue,t,a===Ko),n[r]=t}xs.ngInherit=!0;const EN="__ngSimpleChanges__";function IN(n){return n[EN]||null}function dr(n){for(;Array.isArray(n);)n=n[0];return n}function Km(n,t){return dr(t[n])}function Bs(n,t){return dr(t[n.index])}function Zx(n,t){return n.data[t]}function qc(n,t){return n[t]}function zs(n,t){const e=t[n];return vs(e)?e:e[0]}function Xm(n){return 64==(64&n[2])}function Ma(n,t){return null==t?null:n[t]}function DN(n){n[18]=0}function Qx(n,t){n[5]+=t;let e=n,r=n[3];for(;null!==r&&(1===t&&1===e[5]||-1===t&&0===e[5]);)r[5]+=t,e=r,r=r[3]}const Qe={lFrame:PN(null),bindingsEnabled:!0};function kN(){return Qe.bindingsEnabled}function oe(){return Qe.lFrame.lView}function Nt(){return Qe.lFrame.tView}function lh(n){return Qe.lFrame.contextLView=n,n[8]}function ch(n){return Qe.lFrame.contextLView=null,n}function Fr(){let n=NN();for(;null!==n&&64===n.type;)n=n.parent;return n}function NN(){return Qe.lFrame.currentTNode}function go(n,t){const e=Qe.lFrame;e.currentTNode=n,e.isParent=t}function Jx(){return Qe.lFrame.isParent}function e0(){Qe.lFrame.isParent=!1}function rs(){const n=Qe.lFrame;let t=n.bindingRootIndex;return-1===t&&(t=n.bindingRootIndex=n.tView.bindingStartIndex),t}function Kc(){return Qe.lFrame.bindingIndex++}function Zo(n){const t=Qe.lFrame,e=t.bindingIndex;return t.bindingIndex=t.bindingIndex+n,e}function D5(n,t){const e=Qe.lFrame;e.bindingIndex=e.bindingRootIndex=n,t0(t)}function t0(n){Qe.lFrame.currentDirectiveIndex=n}function FN(){return Qe.lFrame.currentQueryIndex}function r0(n){Qe.lFrame.currentQueryIndex=n}function k5(n){const t=n[1];return 2===t.type?t.declTNode:1===t.type?n[6]:null}function ON(n,t,e){if(e&qe.SkipSelf){let s=t,i=n;for(;!(s=s.parent,null!==s||e&qe.Host||(s=k5(i),null===s||(i=i[15],10&s.type))););if(null===s)return!1;t=s,n=i}const r=Qe.lFrame=$N();return r.currentTNode=t,r.lView=n,!0}function s0(n){const t=$N(),e=n[1];Qe.lFrame=t,t.currentTNode=e.firstChild,t.lView=n,t.tView=e,t.contextLView=n,t.bindingIndex=e.bindingStartIndex,t.inI18n=!1}function $N(){const n=Qe.lFrame,t=null===n?null:n.child;return null===t?PN(n):t}function PN(n){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:n,child:null,inI18n:!1};return null!==n&&(n.child=t),t}function LN(){const n=Qe.lFrame;return Qe.lFrame=n.parent,n.currentTNode=null,n.lView=null,n}const VN=LN;function o0(){const n=LN();n.isParent=!0,n.tView=null,n.selectedIndex=-1,n.contextLView=null,n.elementDepthCount=0,n.currentDirectiveIndex=-1,n.currentNamespace=null,n.bindingRootIndex=-1,n.bindingIndex=-1,n.currentQueryIndex=0}function ss(){return Qe.lFrame.selectedIndex}function Bl(n){Qe.lFrame.selectedIndex=n}function Tn(){const n=Qe.lFrame;return Zx(n.tView,n.selectedIndex)}function dh(){Qe.lFrame.currentNamespace="svg"}function a0(){!function M5(){Qe.lFrame.currentNamespace=null}()}function Ym(n,t){for(let e=t.directiveStart,r=t.directiveEnd;e<r;e++){const i=n.data[e].type.prototype,{ngAfterContentInit:o,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:c,ngOnDestroy:u}=i;o&&(n.contentHooks||(n.contentHooks=[])).push(-e,o),a&&((n.contentHooks||(n.contentHooks=[])).push(e,a),(n.contentCheckHooks||(n.contentCheckHooks=[])).push(e,a)),l&&(n.viewHooks||(n.viewHooks=[])).push(-e,l),c&&((n.viewHooks||(n.viewHooks=[])).push(e,c),(n.viewCheckHooks||(n.viewCheckHooks=[])).push(e,c)),null!=u&&(n.destroyHooks||(n.destroyHooks=[])).push(e,u)}}function Zm(n,t,e){BN(n,t,3,e)}function Qm(n,t,e,r){(3&n[2])===e&&BN(n,t,e,r)}function l0(n,t){let e=n[2];(3&e)===t&&(e&=2047,e+=1,n[2]=e)}function BN(n,t,e,r){const i=r??-1,o=t.length-1;let a=0;for(let l=void 0!==r?65535&n[18]:0;l<o;l++)if("number"==typeof t[l+1]){if(a=t[l],null!=r&&a>=r)break}else t[l]<0&&(n[18]+=65536),(a<i||-1==i)&&($5(n,e,t,l),n[18]=(4294901760&n[18])+l+2),l++}function $5(n,t,e,r){const s=e[r]<0,i=e[r+1],a=n[s?-e[r]:e[r]];if(s){if(n[2]>>11<n[18]>>16&&(3&n[2])===t){n[2]+=2048;try{i.call(a)}finally{}}}else try{i.call(a)}finally{}}class hh{constructor(t,e,r){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}}function u0(n,t,e){let r=0;for(;r<e.length;){const s=e[r];if("number"==typeof s){if(0!==s)break;r++;const i=e[r++],o=e[r++],a=e[r++];n.setAttribute(t,o,a,i)}else{const i=s,o=e[++r];UN(i)?n.setProperty(t,i,o):n.setAttribute(t,i,o),r++}}return r}function zN(n){return 3===n||4===n||6===n}function UN(n){return 64===n.charCodeAt(0)}function ph(n,t){if(null!==t&&0!==t.length)if(null===n||0===n.length)n=t.slice();else{let e=-1;for(let r=0;r<t.length;r++){const s=t[r];"number"==typeof s?e=s:0===e||HN(n,e,s,null,-1===e||2===e?t[++r]:null)}}return n}function HN(n,t,e,r,s){let i=0,o=n.length;if(-1===t)o=-1;else for(;i<n.length;){const a=n[i++];if("number"==typeof a){if(a===t){o=-1;break}if(a>t){o=i-1;break}}}for(;i<n.length;){const a=n[i];if("number"==typeof a)break;if(a===e){if(null===r)return void(null!==s&&(n[i+1]=s));if(r===n[i+1])return void(n[i+2]=s)}i++,null!==r&&i++,null!==s&&i++}-1!==o&&(n.splice(o,0,t),i=o+1),n.splice(i++,0,e),null!==r&&n.splice(i++,0,r),null!==s&&n.splice(i++,0,s)}function WN(n){return-1!==n}function Xc(n){return 32767&n}function Yc(n,t){let e=function z5(n){return n>>16}(n),r=t;for(;e>0;)r=r[15],e--;return r}let d0=!0;function Jm(n){const t=d0;return d0=n,t}let U5=0;const yo={};function eg(n,t){const e=f0(n,t);if(-1!==e)return e;const r=t[1];r.firstCreatePass&&(n.injectorIndex=t.length,h0(r.data,n),h0(t,null),h0(r.blueprint,null));const s=tg(n,t),i=n.injectorIndex;if(WN(s)){const o=Xc(s),a=Yc(s,t),l=a[1].data;for(let c=0;c<8;c++)t[i+c]=a[o+c]|l[o+c]}return t[i+8]=s,i}function h0(n,t){n.push(0,0,0,0,0,0,0,0,t)}function f0(n,t){return-1===n.injectorIndex||n.parent&&n.parent.injectorIndex===n.injectorIndex||null===t[n.injectorIndex+8]?-1:n.injectorIndex}function tg(n,t){if(n.parent&&-1!==n.parent.injectorIndex)return n.parent.injectorIndex;let e=0,r=null,s=t;for(;null!==s;){if(r=JN(s),null===r)return-1;if(e++,s=s[15],-1!==r.injectorIndex)return r.injectorIndex|e<<16}return-1}function p0(n,t,e){!function H5(n,t,e){let r;"string"==typeof e?r=e.charCodeAt(0)||0:e.hasOwnProperty(rh)&&(r=e[rh]),null==r&&(r=e[rh]=U5++);const s=255&r;t.data[n+(s>>5)]|=1<<s}(n,t,e)}function qN(n,t,e){if(e&qe.Optional||void 0!==n)return n;Pm()}function KN(n,t,e,r){if(e&qe.Optional&&void 0===r&&(r=null),0==(e&(qe.Self|qe.Host))){const s=n[9],i=fi(void 0);try{return s?s.get(t,r,e&qe.Optional):mN(t,r,e&qe.Optional)}finally{fi(i)}}return qN(r,0,e)}function XN(n,t,e,r=qe.Default,s){if(null!==n){if(1024&t[2]){const o=function K5(n,t,e,r,s){let i=n,o=t;for(;null!==i&&null!==o&&1024&o[2]&&!(256&o[2]);){const a=YN(i,o,e,r|qe.Self,yo);if(a!==yo)return a;let l=i.parent;if(!l){const c=o[21];if(c){const u=c.get(e,yo,r);if(u!==yo)return u}l=JN(o),o=o[15]}i=l}return s}(n,t,e,r,yo);if(o!==yo)return o}const i=YN(n,t,e,r,yo);if(i!==yo)return i}return KN(t,e,r,s)}function YN(n,t,e,r,s){const i=function G5(n){if("string"==typeof n)return n.charCodeAt(0)||0;const t=n.hasOwnProperty(rh)?n[rh]:void 0;return"number"==typeof t?t>=0?255&t:q5:t}(e);if("function"==typeof i){if(!ON(t,n,r))return r&qe.Host?qN(s,0,r):KN(t,e,r,s);try{const o=i(r);if(null!=o||r&qe.Optional)return o;Pm()}finally{VN()}}else if("number"==typeof i){let o=null,a=f0(n,t),l=-1,c=r&qe.Host?t[16][6]:null;for((-1===a||r&qe.SkipSelf)&&(l=-1===a?tg(n,t):t[a+8],-1!==l&&QN(r,!1)?(o=t[1],a=Xc(l),t=Yc(l,t)):a=-1);-1!==a;){const u=t[1];if(ZN(i,a,u.data)){const d=j5(a,t,e,o,r,c);if(d!==yo)return d}l=t[a+8],-1!==l&&QN(r,t[1].data[a+8]===c)&&ZN(i,a,t)?(o=u,a=Xc(l),t=Yc(l,t)):a=-1}}return s}function j5(n,t,e,r,s,i){const o=t[1],a=o.data[n+8],u=ng(a,o,e,null==r?Gm(a)&&d0:r!=o&&0!=(3&a.type),s&qe.Host&&i===a);return null!==u?Zc(t,o,u,a):yo}function ng(n,t,e,r,s){const i=n.providerIndexes,o=t.data,a=1048575&i,l=n.directiveStart,u=i>>20,h=s?a+u:n.directiveEnd;for(let f=r?a:a+u;f<h;f++){const p=o[f];if(f<l&&e===p||f>=l&&p.type===e)return f}if(s){const f=o[l];if(f&&qi(f)&&f.type===e)return l}return null}function Zc(n,t,e,r){let s=n[e];const i=t.data;if(function P5(n){return n instanceof hh}(s)){const o=s;o.resolving&&function PG(n,t){const e=t?`. Dependency path: ${t.join(" > ")} > ${n}`:"";throw new te(-200,`Circular dependency in DI detected for ${n}${e}`)}(function Vt(n){return"function"==typeof n?n.name||n.toString():"object"==typeof n&&null!=n&&"function"==typeof n.type?n.type.name||n.type.toString():tt(n)}(i[e]));const a=Jm(o.canSeeViewProviders);o.resolving=!0;const l=o.injectImpl?fi(o.injectImpl):null;ON(n,r,qe.Default);try{s=n[e]=o.factory(void 0,i,n,r),t.firstCreatePass&&e>=r.directiveStart&&function O5(n,t,e){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:i}=t.type.prototype;if(r){const o=SN(t);(e.preOrderHooks||(e.preOrderHooks=[])).push(n,o),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n,o)}s&&(e.preOrderHooks||(e.preOrderHooks=[])).push(0-n,s),i&&((e.preOrderHooks||(e.preOrderHooks=[])).push(n,i),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n,i))}(e,i[e],t)}finally{null!==l&&fi(l),Jm(a),o.resolving=!1,VN()}}return s}function ZN(n,t,e){return!!(e[t+(n>>5)]&1<<n)}function QN(n,t){return!(n&qe.Self||n&qe.Host&&t)}class Qc{constructor(t,e){this._tNode=t,this._lView=e}get(t,e,r){return XN(this._tNode,this._lView,t,zm(r),e)}}function q5(){return new Qc(Fr(),oe())}function Dr(n){return Ra(()=>{const t=n.prototype.constructor,e=t[Xo]||m0(t),r=Object.prototype;let s=Object.getPrototypeOf(n.prototype).constructor;for(;s&&s!==r;){const i=s[Xo]||m0(s);if(i&&i!==e)return i;s=Object.getPrototypeOf(s)}return i=>new i})}function m0(n){return $x(n)?()=>{const t=m0(Ge(n));return t&&t()}:Vl(n)}function JN(n){const t=n[1],e=t.type;return 2===e?t.declTNode:1===e?n[6]:null}function Jc(n){return function W5(n,t){if("class"===t)return n.classes;if("style"===t)return n.styles;const e=n.attrs;if(e){const r=e.length;let s=0;for(;s<r;){const i=e[s];if(zN(i))break;if(0===i)s+=2;else if("number"==typeof i)for(s++;s<r&&"string"==typeof e[s];)s++;else{if(i===t)return e[s+1];s+=2}}}return null}(Fr(),n)}const tu="__parameters__";function ru(n,t,e){return Ra(()=>{const r=function g0(n){return function(...e){if(n){const r=n(...e);for(const s in r)this[s]=r[s]}}}(t);function s(...i){if(this instanceof s)return r.apply(this,i),this;const o=new s(...i);return a.annotation=o,a;function a(l,c,u){const d=l.hasOwnProperty(tu)?l[tu]:Object.defineProperty(l,tu,{value:[]})[tu];for(;d.length<=u;)d.push(null);return(d[u]=d[u]||[]).push(o),l}}return e&&(s.prototype=Object.create(e.prototype)),s.prototype.ngMetadataName=n,s.annotationCls=s,s})}class me{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=Ce({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}function Us(n,t){void 0===t&&(t=n);for(let e=0;e<n.length;e++){let r=n[e];Array.isArray(r)?(t===n&&(t=n.slice(0,e)),Us(r,t)):t!==n&&t.push(r)}return t}function zl(n,t){n.forEach(e=>Array.isArray(e)?zl(e,t):t(e))}function tA(n,t,e){t>=n.length?n.push(e):n.splice(t,0,e)}function rg(n,t){return t>=n.length-1?n.pop():n.splice(t,1)[0]}function yh(n,t){const e=[];for(let r=0;r<n;r++)e.push(t);return e}function Hs(n,t,e){let r=su(n,t);return r>=0?n[1|r]=e:(r=~r,function Q5(n,t,e,r){let s=n.length;if(s==t)n.push(e,r);else if(1===s)n.push(r,n[0]),n[0]=e;else{for(s--,n.push(n[s-1],n[s]);s>t;)n[s]=n[s-2],s--;n[t]=e,n[t+1]=r}}(n,r,t,e)),r}function b0(n,t){const e=su(n,t);if(e>=0)return n[1|e]}function su(n,t){return function sA(n,t,e){let r=0,s=n.length>>e;for(;s!==r;){const i=r+(s-r>>1),o=n[i<<e];if(t===o)return i<<e;o>t?s=i:r=i+1}return~(s<<e)}(n,t,1)}const Oa=nh(ru("Optional"),8),iu=nh(ru("SkipSelf"),4);var ws=(()=>((ws=ws||{})[ws.Important=1]="Important",ws[ws.DashCase=2]="DashCase",ws))();const S0=new Map;let vq=0;const I0="__ngContext__";function Hr(n,t){vs(t)?(n[I0]=t[20],function wq(n){S0.set(n[20],n)}(t)):n[I0]=t}function T0(n,t){return undefined(n,t)}function xh(n){const t=n[3];return Gi(t)?t[3]:t}function k0(n){return EA(n[13])}function N0(n){return EA(n[4])}function EA(n){for(;null!==n&&!Gi(n);)n=n[4];return n}function au(n,t,e,r,s){if(null!=r){let i,o=!1;Gi(r)?i=r:vs(r)&&(o=!0,r=r[0]);const a=dr(r);0===n&&null!==e?null==s?AA(t,e,a):Ul(t,e,a,s||null,!0):1===n&&null!==e?Ul(t,e,a,s||null,!0):2===n?function P0(n,t,e){const r=ag(n,t);r&&function Hq(n,t,e,r){n.removeChild(t,e,r)}(n,r,t,e)}(t,a,o):3===n&&t.destroyNode(a),null!=i&&function Gq(n,t,e,r,s){const i=e[7];i!==dr(e)&&au(t,n,r,i,s);for(let a=10;a<e.length;a++){const l=e[a];wh(l[1],l,n,t,r,i)}}(t,n,i,e,s)}}function R0(n,t,e){return n.createElement(t,e)}function DA(n,t){const e=n[9],r=e.indexOf(t),s=t[3];512&t[2]&&(t[2]&=-513,Qx(s,-1)),e.splice(r,1)}function M0(n,t){if(n.length<=10)return;const e=10+t,r=n[e];if(r){const s=r[17];null!==s&&s!==n&&DA(s,r),t>0&&(n[e-1][4]=r[4]);const i=rg(n,10+t);!function Oq(n,t){wh(n,t,t[11],2,null,null),t[0]=null,t[6]=null}(r[1],r);const o=i[19];null!==o&&o.detachView(i[1]),r[3]=null,r[4]=null,r[2]&=-65}return r}function TA(n,t){if(!(128&t[2])){const e=t[11];e.destroyNode&&wh(n,t,e,3,null,null),function Lq(n){let t=n[13];if(!t)return F0(n[1],n);for(;t;){let e=null;if(vs(t))e=t[13];else{const r=t[10];r&&(e=r)}if(!e){for(;t&&!t[4]&&t!==n;)vs(t)&&F0(t[1],t),t=t[3];null===t&&(t=n),vs(t)&&F0(t[1],t),e=t&&t[4]}t=e}}(t)}}function F0(n,t){if(!(128&t[2])){t[2]&=-65,t[2]|=128,function Uq(n,t){let e;if(null!=n&&null!=(e=n.destroyHooks))for(let r=0;r<e.length;r+=2){const s=t[e[r]];if(!(s instanceof hh)){const i=e[r+1];if(Array.isArray(i))for(let o=0;o<i.length;o+=2){const a=s[i[o]],l=i[o+1];try{l.call(a)}finally{}}else try{i.call(s)}finally{}}}}(n,t),function zq(n,t){const e=n.cleanup,r=t[7];let s=-1;if(null!==e)for(let i=0;i<e.length-1;i+=2)if("string"==typeof e[i]){const o=e[i+3];o>=0?r[s=o]():r[s=-o].unsubscribe(),i+=2}else{const o=r[s=e[i+1]];e[i].call(o)}if(null!==r){for(let i=s+1;i<r.length;i++)(0,r[i])();t[7]=null}}(n,t),1===t[1].type&&t[11].destroy();const e=t[17];if(null!==e&&Gi(t[3])){e!==t[3]&&DA(e,t);const r=t[19];null!==r&&r.detachView(n)}!function Cq(n){S0.delete(n[20])}(t)}}function kA(n,t,e){return function NA(n,t,e){let r=t;for(;null!==r&&40&r.type;)r=(t=r).parent;if(null===r)return e[0];{const{componentOffset:s}=r;if(s>-1){const{encapsulation:i}=n.data[r.directiveStart+s];if(i===Wi.None||i===Wi.Emulated)return null}return Bs(r,e)}}(n,t.parent,e)}function Ul(n,t,e,r,s){n.insertBefore(t,e,r,s)}function AA(n,t,e){n.appendChild(t,e)}function RA(n,t,e,r,s){null!==r?Ul(n,t,e,r,s):AA(n,t,e)}function ag(n,t){return n.parentNode(t)}function MA(n,t,e){return OA(n,t,e)}let ug,B0,OA=function FA(n,t,e){return 40&n.type?Bs(n,e):null};function lg(n,t,e,r){const s=kA(n,r,t),i=t[11],a=MA(r.parent||t[6],r,t);if(null!=s)if(Array.isArray(e))for(let l=0;l<e.length;l++)RA(i,s,e[l],a,!1);else RA(i,s,e,a,!1)}function cg(n,t){if(null!==t){const e=t.type;if(3&e)return Bs(t,n);if(4&e)return $0(-1,n[t.index]);if(8&e){const r=t.child;if(null!==r)return cg(n,r);{const s=n[t.index];return Gi(s)?$0(-1,s):dr(s)}}if(32&e)return T0(t,n)()||dr(n[t.index]);{const r=PA(n,t);return null!==r?Array.isArray(r)?r[0]:cg(xh(n[16]),r):cg(n,t.next)}}return null}function PA(n,t){return null!==t?n[16][6].projection[t.projection]:null}function $0(n,t){const e=10+n+1;if(e<t.length){const r=t[e],s=r[1].firstChild;if(null!==s)return cg(r,s)}return t[7]}function L0(n,t,e,r,s,i,o){for(;null!=e;){const a=r[e.index],l=e.type;if(o&&0===t&&(a&&Hr(dr(a),r),e.flags|=2),32!=(32&e.flags))if(8&l)L0(n,t,e.child,r,s,i,!1),au(t,n,s,a,i);else if(32&l){const c=T0(e,r);let u;for(;u=c();)au(t,n,s,u,i);au(t,n,s,a,i)}else 16&l?LA(n,t,r,e,s,i):au(t,n,s,a,i);e=o?e.projectionNext:e.next}}function wh(n,t,e,r,s,i){L0(e,r,n.firstChild,t,s,i,!1)}function LA(n,t,e,r,s,i){const o=e[16],l=o[6].projection[r.projection];if(Array.isArray(l))for(let c=0;c<l.length;c++)au(t,n,s,l[c],i);else L0(n,t,l,o[3],s,i,!0)}function VA(n,t,e){""===e?n.removeAttribute(t,"class"):n.setAttribute(t,"class",e)}function BA(n,t,e){const{mergedAttrs:r,classes:s,styles:i}=e;null!==r&&u0(n,t,r),null!==s&&VA(n,t,s),null!==i&&function Kq(n,t,e){n.setAttribute(t,"style",e)}(n,t,i)}function Hl(n){return function V0(){if(void 0===ug&&(ug=null,un.trustedTypes))try{ug=un.trustedTypes.createPolicy("angular",{createHTML:n=>n,createScript:n=>n,createScriptURL:n=>n})}catch{}return ug}()?.createHTML(n)||n}class Wl{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Om})`}}class Jq extends Wl{getTypeName(){return"HTML"}}class e8 extends Wl{getTypeName(){return"Style"}}class t8 extends Wl{getTypeName(){return"Script"}}class n8 extends Wl{getTypeName(){return"URL"}}class r8 extends Wl{getTypeName(){return"ResourceURL"}}function Ws(n){return n instanceof Wl?n.changingThisBreaksApplicationSecurity:n}function bo(n,t){const e=function s8(n){return n instanceof Wl&&n.getTypeName()||null}(n);if(null!=e&&e!==t){if("ResourceURL"===e&&"URL"===t)return!0;throw new Error(`Required a safe ${t}, got a ${e} (see ${Om})`)}return e===t}class u8{constructor(t){this.inertDocumentHelper=t}getInertBodyElement(t){t="<body><remove></remove>"+t;try{const e=(new window.DOMParser).parseFromString(Hl(t),"text/html").body;return null===e?this.inertDocumentHelper.getInertBodyElement(t):(e.removeChild(e.firstChild),e)}catch{return null}}}class d8{constructor(t){if(this.defaultDoc=t,this.inertDocument=this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"),null==this.inertDocument.body){const e=this.inertDocument.createElement("html");this.inertDocument.appendChild(e);const r=this.inertDocument.createElement("body");e.appendChild(r)}}getInertBodyElement(t){const e=this.inertDocument.createElement("template");if("content"in e)return e.innerHTML=Hl(t),e;const r=this.inertDocument.createElement("body");return r.innerHTML=Hl(t),this.defaultDoc.documentMode&&this.stripCustomNsAttrs(r),r}stripCustomNsAttrs(t){const e=t.attributes;for(let s=e.length-1;0<s;s--){const o=e.item(s).name;("xmlns:ns1"===o||0===o.indexOf("ns1:"))&&t.removeAttribute(o)}let r=t.firstChild;for(;r;)r.nodeType===Node.ELEMENT_NODE&&this.stripCustomNsAttrs(r),r=r.nextSibling}}const f8=/^(?:(?:https?|mailto|data|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi;function hg(n){return(n=String(n)).match(f8)?n:"unsafe:"+n}function Qo(n){const t={};for(const e of n.split(","))t[e]=!0;return t}function Ch(...n){const t={};for(const e of n)for(const r in e)e.hasOwnProperty(r)&&(t[r]=!0);return t}const GA=Qo("area,br,col,hr,img,wbr"),qA=Qo("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),KA=Qo("rp,rt"),U0=Ch(GA,Ch(qA,Qo("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),Ch(KA,Qo("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),Ch(KA,qA)),H0=Qo("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),XA=Ch(H0,Qo("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),Qo("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),p8=Qo("script,style,template");class m8{constructor(){this.sanitizedSomething=!1,this.buf=[]}sanitizeChildren(t){let e=t.firstChild,r=!0;for(;e;)if(e.nodeType===Node.ELEMENT_NODE?r=this.startElement(e):e.nodeType===Node.TEXT_NODE?this.chars(e.nodeValue):this.sanitizedSomething=!0,r&&e.firstChild)e=e.firstChild;else for(;e;){e.nodeType===Node.ELEMENT_NODE&&this.endElement(e);let s=this.checkClobberedElement(e,e.nextSibling);if(s){e=s;break}e=this.checkClobberedElement(e,e.parentNode)}return this.buf.join("")}startElement(t){const e=t.nodeName.toLowerCase();if(!U0.hasOwnProperty(e))return this.sanitizedSomething=!0,!p8.hasOwnProperty(e);this.buf.push("<"),this.buf.push(e);const r=t.attributes;for(let s=0;s<r.length;s++){const i=r.item(s),o=i.name,a=o.toLowerCase();if(!XA.hasOwnProperty(a)){this.sanitizedSomething=!0;continue}let l=i.value;H0[a]&&(l=hg(l)),this.buf.push(" ",o,'="',YA(l),'"')}return this.buf.push(">"),!0}endElement(t){const e=t.nodeName.toLowerCase();U0.hasOwnProperty(e)&&!GA.hasOwnProperty(e)&&(this.buf.push("</"),this.buf.push(e),this.buf.push(">"))}chars(t){this.buf.push(YA(t))}checkClobberedElement(t,e){if(e&&(t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_CONTAINED_BY)===Node.DOCUMENT_POSITION_CONTAINED_BY)throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`);return e}}const g8=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,y8=/([^\#-~ |!])/g;function YA(n){return n.replace(/&/g,"&amp;").replace(g8,function(t){return"&#"+(1024*(t.charCodeAt(0)-55296)+(t.charCodeAt(1)-56320)+65536)+";"}).replace(y8,function(t){return"&#"+t.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}let fg;function ZA(n,t){let e=null;try{fg=fg||function jA(n){const t=new d8(n);return function h8(){try{return!!(new window.DOMParser).parseFromString(Hl(""),"text/html")}catch{return!1}}()?new u8(t):t}(n);let r=t?String(t):"";e=fg.getInertBodyElement(r);let s=5,i=r;do{if(0===s)throw new Error("Failed to sanitize html because the input is unstable");s--,r=i,i=e.innerHTML,e=fg.getInertBodyElement(r)}while(r!==i);return Hl((new m8).sanitizeChildren(W0(e)||e))}finally{if(e){const r=W0(e)||e;for(;r.firstChild;)r.removeChild(r.firstChild)}}}function W0(n){return"content"in n&&function b8(n){return n.nodeType===Node.ELEMENT_NODE&&"TEMPLATE"===n.nodeName}(n)?n.content:null}var Pt=(()=>((Pt=Pt||{})[Pt.NONE=0]="NONE",Pt[Pt.HTML=1]="HTML",Pt[Pt.STYLE=2]="STYLE",Pt[Pt.SCRIPT=3]="SCRIPT",Pt[Pt.URL=4]="URL",Pt[Pt.RESOURCE_URL=5]="RESOURCE_URL",Pt))();const pg=new me("ENVIRONMENT_INITIALIZER"),tR=new me("INJECTOR",-1),nR=new me("INJECTOR_DEF_TYPES");class rR{get(t,e=eh){if(e===eh){const r=new Error(`NullInjectorError: No provider for ${Jt(t)}!`);throw r.name="NullInjectorError",r}return e}}function E8(...n){return{\u0275providers:sR(0,n),\u0275fromNgModule:!0}}function sR(n,...t){const e=[],r=new Set;let s;return zl(t,i=>{const o=i;j0(o,e,[],r)&&(s||(s=[]),s.push(o))}),void 0!==s&&iR(s,e),e}function iR(n,t){for(let e=0;e<n.length;e++){const{providers:s}=n[e];G0(s,i=>{t.push(i)})}}function j0(n,t,e,r){if(!(n=Ge(n)))return!1;let s=null,i=fN(n);const o=!i&&zt(n);if(i||o){if(o&&!o.standalone)return!1;s=n}else{const l=n.ngModule;if(i=fN(l),!i)return!1;s=l}const a=r.has(s);if(o){if(a)return!1;if(r.add(s),o.dependencies){const l="function"==typeof o.dependencies?o.dependencies():o.dependencies;for(const c of l)j0(c,t,e,r)}}else{if(!i)return!1;{if(null!=i.imports&&!a){let c;r.add(s);try{zl(i.imports,u=>{j0(u,t,e,r)&&(c||(c=[]),c.push(u))})}finally{}void 0!==c&&iR(c,t)}if(!a){const c=Vl(s)||(()=>new s);t.push({provide:s,useFactory:c,deps:$t},{provide:nR,useValue:s,multi:!0},{provide:pg,useValue:()=>J(s),multi:!0})}const l=i.providers;null==l||a||G0(l,u=>{t.push(u)})}}return s!==n&&void 0!==n.providers}function G0(n,t){for(let e of n)Px(e)&&(e=e.\u0275providers),Array.isArray(e)?G0(e,t):t(e)}const I8=Qt({provide:String,useValue:Qt});function q0(n){return null!==n&&"object"==typeof n&&I8 in n}function jl(n){return"function"==typeof n}const K0=new me("Set Injector scope."),mg={},T8={};let X0;function gg(){return void 0===X0&&(X0=new rR),X0}class $a{}class lR extends $a{constructor(t,e,r,s){super(),this.parent=e,this.source=r,this.scopes=s,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,Z0(t,o=>this.processProvider(o)),this.records.set(tR,lu(void 0,this)),s.has("environment")&&this.records.set($a,lu(void 0,this));const i=this.records.get(K0);null!=i&&"string"==typeof i.value&&this.scopes.add(i.value),this.injectorDefTypes=new Set(this.get(nR.multi,$t,qe.Self))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const t of this._ngOnDestroyHooks)t.ngOnDestroy();for(const t of this._onDestroyHooks)t()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),this._onDestroyHooks.length=0}}onDestroy(t){this._onDestroyHooks.push(t)}runInContext(t){this.assertNotDestroyed();const e=Uc(this),r=fi(void 0);try{return t()}finally{Uc(e),fi(r)}}get(t,e=eh,r=qe.Default){this.assertNotDestroyed(),r=zm(r);const s=Uc(this),i=fi(void 0);try{if(!(r&qe.SkipSelf)){let a=this.records.get(t);if(void 0===a){const l=function M8(n){return"function"==typeof n||"object"==typeof n&&n instanceof me}(t)&&Lm(t);a=l&&this.injectableDefInScope(l)?lu(Y0(t),mg):null,this.records.set(t,a)}if(null!=a)return this.hydrate(t,a)}return(r&qe.Self?gg():this.parent).get(t,e=r&qe.Optional&&e===eh?null:e)}catch(o){if("NullInjectorError"===o.name){if((o[Bm]=o[Bm]||[]).unshift(Jt(t)),s)throw o;return function QG(n,t,e,r){const s=n[Bm];throw t[gN]&&s.unshift(t[gN]),n.message=function JG(n,t,e,r=null){n=n&&"\n"===n.charAt(0)&&"\u0275"==n.charAt(1)?n.slice(2):n;let s=Jt(t);if(Array.isArray(t))s=t.map(Jt).join(" -> ");else if("object"==typeof t){let i=[];for(let o in t)if(t.hasOwnProperty(o)){let a=t[o];i.push(o+":"+("string"==typeof a?JSON.stringify(a):Jt(a)))}s=`{${i.join(", ")}}`}return`${e}${r?"("+r+")":""}[${s}]: ${n.replace(KG,"\n  ")}`}("\n"+n.message,s,e,r),n.ngTokenPath=s,n[Bm]=null,n}(o,t,"R3InjectorError",this.source)}throw o}finally{fi(i),Uc(s)}}resolveInjectorInitializers(){const t=Uc(this),e=fi(void 0);try{const r=this.get(pg.multi,$t,qe.Self);for(const s of r)s()}finally{Uc(t),fi(e)}}toString(){const t=[],e=this.records;for(const r of e.keys())t.push(Jt(r));return`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new te(205,!1)}processProvider(t){let e=jl(t=Ge(t))?t:Ge(t&&t.provide);const r=function N8(n){return q0(n)?lu(void 0,n.useValue):lu(cR(n),mg)}(t);if(jl(t)||!0!==t.multi)this.records.get(e);else{let s=this.records.get(e);s||(s=lu(void 0,mg,!0),s.factory=()=>zx(s.multi),this.records.set(e,s)),e=t,s.multi.push(t)}this.records.set(e,r)}hydrate(t,e){return e.value===mg&&(e.value=T8,e.value=e.factory()),"object"==typeof e.value&&e.value&&function R8(n){return null!==n&&"object"==typeof n&&"function"==typeof n.ngOnDestroy}(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}injectableDefInScope(t){if(!t.providedIn)return!1;const e=Ge(t.providedIn);return"string"==typeof e?"any"===e||this.scopes.has(e):this.injectorDefTypes.has(e)}}function Y0(n){const t=Lm(n),e=null!==t?t.factory:Vl(n);if(null!==e)return e;if(n instanceof me)throw new te(204,!1);if(n instanceof Function)return function k8(n){const t=n.length;if(t>0)throw yh(t,"?"),new te(204,!1);const e=function HG(n){const t=n&&(n[Vm]||n[pN]);if(t){const e=function WG(n){if(n.hasOwnProperty("name"))return n.name;const t=(""+n).match(/^function\s*([^\s(]+)/);return null===t?"":t[1]}(n);return console.warn(`DEPRECATED: DI is instantiating a token "${e}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${e}" class.`),t}return null}(n);return null!==e?()=>e.factory(n):()=>new n}(n);throw new te(204,!1)}function cR(n,t,e){let r;if(jl(n)){const s=Ge(n);return Vl(s)||Y0(s)}if(q0(n))r=()=>Ge(n.useValue);else if(function aR(n){return!(!n||!n.useFactory)}(n))r=()=>n.useFactory(...zx(n.deps||[]));else if(function oR(n){return!(!n||!n.useExisting)}(n))r=()=>J(Ge(n.useExisting));else{const s=Ge(n&&(n.useClass||n.provide));if(!function A8(n){return!!n.deps}(n))return Vl(s)||Y0(s);r=()=>new s(...zx(n.deps))}return r}function lu(n,t,e=!1){return{factory:n,value:t,multi:e?[]:void 0}}function Z0(n,t){for(const e of n)Array.isArray(e)?Z0(e,t):e&&Px(e)?Z0(e.\u0275providers,t):t(e)}class F8{}class uR{}class $8{resolveComponentFactory(t){throw function O8(n){const t=Error(`No component factory found for ${Jt(n)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=n,t}(t)}}let cu=(()=>{class n{}return n.NULL=new $8,n})();function P8(){return uu(Fr(),oe())}function uu(n,t){return new Cn(Bs(n,t))}let Cn=(()=>{class n{constructor(e){this.nativeElement=e}}return n.__NG_ELEMENT_ID__=P8,n})();function L8(n){return n instanceof Cn?n.nativeElement:n}class Eh{}let Jo=(()=>{class n{}return n.__NG_ELEMENT_ID__=()=>function V8(){const n=oe(),e=zs(Fr().index,n);return(vs(e)?e:n)[11]}(),n})(),B8=(()=>{class n{}return n.\u0275prov=Ce({token:n,providedIn:"root",factory:()=>null}),n})();class Gl{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const z8=new Gl("15.0.1"),Q0={};function ew(n){return n.ngOriginalError}class ea{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t);this._console.error("ERROR",t),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(t){let e=t&&ew(t);for(;e&&ew(e);)e=ew(e);return e||null}}function ta(n){return n instanceof Function?n():n}function fR(n,t,e){let r=n.length;for(;;){const s=n.indexOf(t,e);if(-1===s)return s;if(0===s||n.charCodeAt(s-1)<=32){const i=t.length;if(s+i===r||n.charCodeAt(s+i)<=32)return s}e=s+1}}const pR="ng-template";function Q8(n,t,e){let r=0;for(;r<n.length;){let s=n[r++];if(e&&"class"===s){if(s=n[r],-1!==fR(s.toLowerCase(),t,0))return!0}else if(1===s){for(;r<n.length&&"string"==typeof(s=n[r++]);)if(s.toLowerCase()===t)return!0;return!1}}return!1}function mR(n){return 4===n.type&&n.value!==pR}function J8(n,t,e){return t===(4!==n.type||e?n.value:pR)}function e6(n,t,e){let r=4;const s=n.attrs||[],i=function r6(n){for(let t=0;t<n.length;t++)if(zN(n[t]))return t;return n.length}(s);let o=!1;for(let a=0;a<t.length;a++){const l=t[a];if("number"!=typeof l){if(!o)if(4&r){if(r=2|1&r,""!==l&&!J8(n,l,e)||""===l&&1===t.length){if(Ki(r))return!1;o=!0}}else{const c=8&r?l:t[++a];if(8&r&&null!==n.attrs){if(!Q8(n.attrs,c,e)){if(Ki(r))return!1;o=!0}continue}const d=t6(8&r?"class":l,s,mR(n),e);if(-1===d){if(Ki(r))return!1;o=!0;continue}if(""!==c){let h;h=d>i?"":s[d+1].toLowerCase();const f=8&r?h:null;if(f&&-1!==fR(f,c,0)||2&r&&c!==h){if(Ki(r))return!1;o=!0}}}}else{if(!o&&!Ki(r)&&!Ki(l))return!1;if(o&&Ki(l))continue;o=!1,r=l|1&r}}return Ki(r)||o}function Ki(n){return 0==(1&n)}function t6(n,t,e,r){if(null===t)return-1;let s=0;if(r||!e){let i=!1;for(;s<t.length;){const o=t[s];if(o===n)return s;if(3===o||6===o)i=!0;else{if(1===o||2===o){let a=t[++s];for(;"string"==typeof a;)a=t[++s];continue}if(4===o)break;if(0===o){s+=4;continue}}s+=i?1:2}return-1}return function s6(n,t){let e=n.indexOf(4);if(e>-1)for(e++;e<n.length;){const r=n[e];if("number"==typeof r)return-1;if(r===t)return e;e++}return-1}(t,n)}function gR(n,t,e=!1){for(let r=0;r<t.length;r++)if(e6(n,t[r],e))return!0;return!1}function i6(n,t){e:for(let e=0;e<t.length;e++){const r=t[e];if(n.length===r.length){for(let s=0;s<n.length;s++)if(n[s]!==r[s])continue e;return!0}}return!1}function yR(n,t){return n?":not("+t.trim()+")":t}function o6(n){let t=n[0],e=1,r=2,s="",i=!1;for(;e<n.length;){let o=n[e];if("string"==typeof o)if(2&r){const a=n[++e];s+="["+o+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?s+="."+o:4&r&&(s+=" "+o);else""!==s&&!Ki(o)&&(t+=yR(i,s),s=""),r=o,i=i||!Ki(r);e++}return""!==s&&(t+=yR(i,s)),t}const nt={};function en(n){bR(Nt(),oe(),ss()+n,!1)}function bR(n,t,e,r){if(!r)if(3==(3&t[2])){const i=n.preOrderCheckHooks;null!==i&&Zm(t,i,e)}else{const i=n.preOrderHooks;null!==i&&Qm(t,i,0,e)}Bl(e)}function wR(n,t=null,e=null,r){const s=CR(n,t,e,r);return s.resolveInjectorInitializers(),s}function CR(n,t=null,e=null,r,s=new Set){const i=[e||$t,E8(n)];return r=r||("object"==typeof n?void 0:Jt(n)),new lR(i,t||gg(),r||null,s)}let os=(()=>{class n{static create(e,r){if(Array.isArray(e))return wR({name:""},r,e,"");{const s=e.name??"";return wR({name:s},e.parent,e.providers,s)}}}return n.THROW_IF_NOT_FOUND=eh,n.NULL=new rR,n.\u0275prov=Ce({token:n,providedIn:"any",factory:()=>J(tR)}),n.__NG_ELEMENT_ID__=-1,n})();function K(n,t=qe.Default){const e=oe();return null===e?J(n,t):XN(Fr(),e,Ge(n),t)}function Ih(){throw new Error("invalid")}function bg(n,t){return n<<17|t<<2}function Xi(n){return n>>17&32767}function iw(n){return 2|n}function na(n){return(131068&n)>>2}function ow(n,t){return-131069&n|t<<2}function aw(n){return 1|n}function BR(n,t){const e=n.contentQueries;if(null!==e)for(let r=0;r<e.length;r+=2){const s=e[r],i=e[r+1];if(-1!==i){const o=n.data[i];r0(s),o.contentQueries(2,t[i],i)}}}function xg(n,t,e,r,s,i,o,a,l,c,u){const d=t.blueprint.slice();return d[0]=s,d[2]=76|r,(null!==u||n&&1024&n[2])&&(d[2]|=1024),DN(d),d[3]=d[15]=n,d[8]=e,d[10]=o||n&&n[10],d[11]=a||n&&n[11],d[12]=l||n&&n[12]||null,d[9]=c||n&&n[9]||null,d[6]=i,d[20]=function xq(){return vq++}(),d[21]=u,d[16]=2==t.type?n[16]:d,d}function fu(n,t,e,r,s){let i=n.data[t];if(null===i)i=function mw(n,t,e,r,s){const i=NN(),o=Jx(),l=n.data[t]=function U6(n,t,e,r,s,i){return{type:e,index:r,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:0,providerIndexes:0,value:s,attrs:i,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,o?i:i&&i.parent,e,t,r,s);return null===n.firstChild&&(n.firstChild=l),null!==i&&(o?null==i.child&&null!==l.parent&&(i.child=l):null===i.next&&(i.next=l)),l}(n,t,e,r,s),function I5(){return Qe.lFrame.inI18n}()&&(i.flags|=32);else if(64&i.type){i.type=e,i.value=r,i.attrs=s;const o=function uh(){const n=Qe.lFrame,t=n.currentTNode;return n.isParent?t:t.parent}();i.injectorIndex=null===o?-1:o.injectorIndex}return go(i,!0),i}function Dh(n,t,e,r){if(0===e)return-1;const s=t.length;for(let i=0;i<e;i++)t.push(r),n.blueprint.push(r),n.data.push(null);return s}function gw(n,t,e){s0(t);try{const r=n.viewQuery;null!==r&&Iw(1,r,e);const s=n.template;null!==s&&zR(n,t,s,1,e),n.firstCreatePass&&(n.firstCreatePass=!1),n.staticContentQueries&&BR(n,t),n.staticViewQueries&&Iw(2,n.viewQuery,e);const i=n.components;null!==i&&function V6(n,t){for(let e=0;e<t.length;e++)aK(n,t[e])}(t,i)}catch(r){throw n.firstCreatePass&&(n.incompleteFirstPass=!0,n.firstCreatePass=!1),r}finally{t[2]&=-5,o0()}}function wg(n,t,e,r){const s=t[2];if(128!=(128&s)){s0(t);try{DN(t),function RN(n){return Qe.lFrame.bindingIndex=n}(n.bindingStartIndex),null!==e&&zR(n,t,e,2,r);const o=3==(3&s);if(o){const c=n.preOrderCheckHooks;null!==c&&Zm(t,c,null)}else{const c=n.preOrderHooks;null!==c&&Qm(t,c,0,null),l0(t,0)}if(function iK(n){for(let t=k0(n);null!==t;t=N0(t)){if(!t[2])continue;const e=t[9];for(let r=0;r<e.length;r++){const s=e[r],i=s[3];0==(512&s[2])&&Qx(i,1),s[2]|=512}}}(t),function sK(n){for(let t=k0(n);null!==t;t=N0(t))for(let e=10;e<t.length;e++){const r=t[e],s=r[1];Xm(r)&&wg(s,r,s.template,r[8])}}(t),null!==n.contentQueries&&BR(n,t),o){const c=n.contentCheckHooks;null!==c&&Zm(t,c)}else{const c=n.contentHooks;null!==c&&Qm(t,c,1),l0(t,1)}!function P6(n,t){const e=n.hostBindingOpCodes;if(null!==e)try{for(let r=0;r<e.length;r++){const s=e[r];if(s<0)Bl(~s);else{const i=s,o=e[++r],a=e[++r];D5(o,i),a(2,t[i])}}}finally{Bl(-1)}}(n,t);const a=n.components;null!==a&&function L6(n,t){for(let e=0;e<t.length;e++)oK(n,t[e])}(t,a);const l=n.viewQuery;if(null!==l&&Iw(2,l,r),o){const c=n.viewCheckHooks;null!==c&&Zm(t,c)}else{const c=n.viewHooks;null!==c&&Qm(t,c,2),l0(t,2)}!0===n.firstUpdatePass&&(n.firstUpdatePass=!1),t[2]&=-41,512&t[2]&&(t[2]&=-513,Qx(t[3],-1))}finally{o0()}}}function zR(n,t,e,r,s){const i=ss(),o=2&r;try{Bl(-1),o&&t.length>22&&bR(n,t,22,!1),e(r,s)}finally{Bl(i)}}function yw(n,t,e){if(Gx(t)){const s=t.directiveEnd;for(let i=t.directiveStart;i<s;i++){const o=n.data[i];o.contentQueries&&o.contentQueries(1,e[i],i)}}}function bw(n,t,e){!kN()||(function K6(n,t,e,r){const s=e.directiveStart,i=e.directiveEnd;n.firstCreatePass||eg(e,t),Hr(r,t);const o=e.initialInputs;for(let a=s;a<i;a++){const l=n.data[a],c=qi(l);c&&tK(t,e,l);const u=Zc(t,n,a,e);Hr(u,t),null!==o&&nK(0,a-s,u,l,0,o),c&&(zs(e.index,t)[8]=u)}}(n,t,e,Bs(e,t)),64==(64&e.flags)&&KR(n,t,e))}function _w(n,t,e=Bs){const r=t.localNames;if(null!==r){let s=t.index+1;for(let i=0;i<r.length;i+=2){const o=r[i+1],a=-1===o?e(t,n):n[o];n[s++]=a}}}function UR(n){const t=n.tView;return null===t||t.incompleteFirstPass?n.tView=vw(1,null,n.template,n.decls,n.vars,n.directiveDefs,n.pipeDefs,n.viewQuery,n.schemas,n.consts):t}function vw(n,t,e,r,s,i,o,a,l,c){const u=22+r,d=u+s,h=function B6(n,t){const e=[];for(let r=0;r<t;r++)e.push(r<n?null:nt);return e}(u,d),f="function"==typeof c?c():c;return h[1]={type:n,blueprint:h,template:e,queries:null,viewQuery:a,declTNode:t,data:h.slice().fill(null,u),bindingStartIndex:u,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof i?i():i,pipeRegistry:"function"==typeof o?o():o,firstChild:null,schemas:l,consts:f,incompleteFirstPass:!1}}function HR(n,t,e,r){const s=YR(t);null===e?s.push(r):(s.push(e),n.firstCreatePass&&ZR(n).push(r,s.length-1))}function WR(n,t,e,r){for(let s in n)if(n.hasOwnProperty(s)){e=null===e?{}:e;const i=n[s];null===r?jR(e,t,s,i):r.hasOwnProperty(s)&&jR(e,t,r[s],i)}return e}function jR(n,t,e,r){n.hasOwnProperty(e)?n[e].push(t,r):n[e]=[t,r]}function js(n,t,e,r,s,i,o,a){const l=Bs(t,e);let u,c=t.inputs;!a&&null!=c&&(u=c[r])?(Dw(n,e,u,r,s),Gm(t)&&GR(e,t.index)):3&t.type&&(r=function W6(n){return"class"===n?"className":"for"===n?"htmlFor":"formaction"===n?"formAction":"innerHtml"===n?"innerHTML":"readonly"===n?"readOnly":"tabindex"===n?"tabIndex":n}(r),s=null!=o?o(s,t.value||"",r):s,i.setProperty(l,r,s))}function GR(n,t){const e=zs(t,n);16&e[2]||(e[2]|=32)}function xw(n,t,e,r){let s=!1;if(kN()){const i=null===r?null:{"":-1},o=function Y6(n,t){const e=n.directiveRegistry;let r=null,s=null;if(e)for(let i=0;i<e.length;i++){const o=e[i];if(gR(t,o.selectors,!1))if(r||(r=[]),qi(o))if(null!==o.findHostDirectiveDefs){const a=[];s=s||new Map,o.findHostDirectiveDefs(o,a,s),r.unshift(...a,o),ww(n,t,a.length)}else r.unshift(o),ww(n,t,0);else s=s||new Map,o.findHostDirectiveDefs?.(o,r,s),r.push(o)}return null===r?null:[r,s]}(n,e);let a,l;null===o?a=l=null:[a,l]=o,null!==a&&(s=!0,qR(n,t,e,a,i,l)),i&&function Z6(n,t,e){if(t){const r=n.localNames=[];for(let s=0;s<t.length;s+=2){const i=e[t[s+1]];if(null==i)throw new te(-301,!1);r.push(t[s],i)}}}(e,r,i)}return e.mergedAttrs=ph(e.mergedAttrs,e.attrs),s}function qR(n,t,e,r,s,i){for(let c=0;c<r.length;c++)p0(eg(e,t),n,r[c].type);!function J6(n,t,e){n.flags|=1,n.directiveStart=t,n.directiveEnd=t+e,n.providerIndexes=t}(e,n.data.length,r.length);for(let c=0;c<r.length;c++){const u=r[c];u.providersResolver&&u.providersResolver(u)}let o=!1,a=!1,l=Dh(n,t,r.length,null);for(let c=0;c<r.length;c++){const u=r[c];e.mergedAttrs=ph(e.mergedAttrs,u.hostAttrs),eK(n,e,t,l,u),Q6(l,u,s),null!==u.contentQueries&&(e.flags|=4),(null!==u.hostBindings||null!==u.hostAttrs||0!==u.hostVars)&&(e.flags|=64);const d=u.type.prototype;!o&&(d.ngOnChanges||d.ngOnInit||d.ngDoCheck)&&((n.preOrderHooks||(n.preOrderHooks=[])).push(e.index),o=!0),!a&&(d.ngOnChanges||d.ngDoCheck)&&((n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e.index),a=!0),l++}!function H6(n,t,e){const s=t.directiveEnd,i=n.data,o=t.attrs,a=[];let l=null,c=null;for(let u=t.directiveStart;u<s;u++){const d=i[u],h=e?e.get(d):null,p=h?h.outputs:null;l=WR(d.inputs,u,l,h?h.inputs:null),c=WR(d.outputs,u,c,p);const m=null===l||null===o||mR(t)?null:rK(l,u,o);a.push(m)}null!==l&&(l.hasOwnProperty("class")&&(t.flags|=8),l.hasOwnProperty("style")&&(t.flags|=16)),t.initialInputs=a,t.inputs=l,t.outputs=c}(n,e,i)}function KR(n,t,e){const r=e.directiveStart,s=e.directiveEnd,i=e.index,o=function T5(){return Qe.lFrame.currentDirectiveIndex}();try{Bl(i);for(let a=r;a<s;a++){const l=n.data[a],c=t[a];t0(a),(null!==l.hostBindings||0!==l.hostVars||null!==l.hostAttrs)&&X6(l,c)}}finally{Bl(-1),t0(o)}}function X6(n,t){null!==n.hostBindings&&n.hostBindings(1,t)}function ww(n,t,e){t.componentOffset=e,(n.components||(n.components=[])).push(t.index)}function Q6(n,t,e){if(e){if(t.exportAs)for(let r=0;r<t.exportAs.length;r++)e[t.exportAs[r]]=n;qi(t)&&(e[""]=n)}}function eK(n,t,e,r,s){n.data[r]=s;const i=s.factory||(s.factory=Vl(s.type)),o=new hh(i,qi(s),K);n.blueprint[r]=o,e[r]=o,function G6(n,t,e,r,s){const i=s.hostBindings;if(i){let o=n.hostBindingOpCodes;null===o&&(o=n.hostBindingOpCodes=[]);const a=~t.index;(function q6(n){let t=n.length;for(;t>0;){const e=n[--t];if("number"==typeof e&&e<0)return e}return 0})(o)!=a&&o.push(a),o.push(e,r,i)}}(n,t,r,Dh(n,e,s.hostVars,nt),s)}function tK(n,t,e){const r=Bs(t,n),s=UR(e),i=n[10],o=Cg(n,xg(n,s,null,e.onPush?32:16,r,t,i,i.createRenderer(r,e),null,null,null));n[t.index]=o}function _o(n,t,e,r,s,i){const o=Bs(n,t);!function Cw(n,t,e,r,s,i,o){if(null==i)n.removeAttribute(t,s,e);else{const a=null==o?tt(i):o(i,r||"",s);n.setAttribute(t,s,a,e)}}(t[11],o,i,n.value,e,r,s)}function nK(n,t,e,r,s,i){const o=i[t];if(null!==o){const a=r.setInput;for(let l=0;l<o.length;){const c=o[l++],u=o[l++],d=o[l++];null!==a?r.setInput(e,d,c,u):e[u]=d}}}function rK(n,t,e){let r=null,s=0;for(;s<e.length;){const i=e[s];if(0!==i)if(5!==i){if("number"==typeof i)break;if(n.hasOwnProperty(i)){null===r&&(r=[]);const o=n[i];for(let a=0;a<o.length;a+=2)if(o[a]===t){r.push(i,o[a+1],e[s+1]);break}}s+=2}else s+=2;else s+=4}return r}function XR(n,t,e,r){return new Array(n,!0,!1,t,null,0,r,e,null,null)}function oK(n,t){const e=zs(t,n);if(Xm(e)){const r=e[1];48&e[2]?wg(r,e,r.template,e[8]):e[5]>0&&Sw(e)}}function Sw(n){for(let r=k0(n);null!==r;r=N0(r))for(let s=10;s<r.length;s++){const i=r[s];if(Xm(i))if(512&i[2]){const o=i[1];wg(o,i,o.template,i[8])}else i[5]>0&&Sw(i)}const e=n[1].components;if(null!==e)for(let r=0;r<e.length;r++){const s=zs(e[r],n);Xm(s)&&s[5]>0&&Sw(s)}}function aK(n,t){const e=zs(t,n),r=e[1];(function lK(n,t){for(let e=t.length;e<n.blueprint.length;e++)t.push(n.blueprint[e])})(r,e),gw(r,e,e[8])}function Cg(n,t){return n[13]?n[14][4]=t:n[13]=t,n[14]=t,t}function Ew(n){for(;n;){n[2]|=32;const t=xh(n);if(o5(n)&&!t)return n;n=t}return null}function Sg(n,t,e,r=!0){const s=t[10];s.begin&&s.begin();try{wg(n,t,n.template,e)}catch(o){throw r&&JR(t,o),o}finally{s.end&&s.end()}}function Iw(n,t,e){r0(0),t(n,e)}function YR(n){return n[7]||(n[7]=[])}function ZR(n){return n.cleanup||(n.cleanup=[])}function JR(n,t){const e=n[9],r=e?e.get(ea,null):null;r&&r.handleError(t)}function Dw(n,t,e,r,s){for(let i=0;i<e.length;){const o=e[i++],a=e[i++],l=t[o],c=n.data[o];null!==c.setInput?c.setInput(l,s,r,a):l[a]=s}}function Eg(n,t,e){let r=e?n.styles:null,s=e?n.classes:null,i=0;if(null!==t)for(let o=0;o<t.length;o++){const a=t[o];"number"==typeof a?i=a:1==i?s=Ox(s,a):2==i&&(r=Ox(r,a+": "+t[++o]+";"))}e?n.styles=r:n.stylesWithoutHost=r,e?n.classes=s:n.classesWithoutHost=s}function Ig(n,t,e,r,s=!1){for(;null!==e;){const i=t[e.index];if(null!==i&&r.push(dr(i)),Gi(i))for(let a=10;a<i.length;a++){const l=i[a],c=l[1].firstChild;null!==c&&Ig(l[1],l,c,r)}const o=e.type;if(8&o)Ig(n,t,e.child,r);else if(32&o){const a=T0(e,t);let l;for(;l=a();)r.push(l)}else if(16&o){const a=PA(t,e);if(Array.isArray(a))r.push(...a);else{const l=xh(t[16]);Ig(l[1],l,a,r,!0)}}e=s?e.projectionNext:e.next}return r}class Th{constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const t=this._lView,e=t[1];return Ig(e,t,e.firstChild,[])}get context(){return this._lView[8]}set context(t){this._lView[8]=t}get destroyed(){return 128==(128&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[3];if(Gi(t)){const e=t[8],r=e?e.indexOf(this):-1;r>-1&&(M0(t,r),rg(e,r))}this._attachedToViewContainer=!1}TA(this._lView[1],this._lView)}onDestroy(t){HR(this._lView[1],this._lView,null,t)}markForCheck(){Ew(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-65}reattach(){this._lView[2]|=64}detectChanges(){Sg(this._lView[1],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new te(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function Pq(n,t){wh(n,t,t[11],2,null,null)}(this._lView[1],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new te(902,!1);this._appRef=t}}class cK extends Th{constructor(t){super(t),this._view=t}detectChanges(){const t=this._view;Sg(t[1],t,t[8],!1)}checkNoChanges(){}get context(){return null}}class Tw extends cu{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=zt(t);return new kh(e,this.ngModule)}}function eM(n){const t=[];for(let e in n)n.hasOwnProperty(e)&&t.push({propName:n[e],templateName:e});return t}class dK{constructor(t,e){this.injector=t,this.parentInjector=e}get(t,e,r){r=zm(r);const s=this.injector.get(t,Q0,r);return s!==Q0||e===Q0?s:this.parentInjector.get(t,e,r)}}class kh extends uR{constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=function a6(n){return n.map(o6).join(",")}(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return eM(this.componentDef.inputs)}get outputs(){return eM(this.componentDef.outputs)}create(t,e,r,s){let i=(s=s||this.ngModule)instanceof $a?s:s?.injector;i&&null!==this.componentDef.getStandaloneInjector&&(i=this.componentDef.getStandaloneInjector(i)||i);const o=i?new dK(t,i):t,a=o.get(Eh,null);if(null===a)throw new te(407,!1);const l=o.get(B8,null),c=a.createRenderer(null,this.componentDef),u=this.componentDef.selectors[0][0]||"div",d=r?function z6(n,t,e){return n.selectRootElement(t,e===Wi.ShadowDom)}(c,r,this.componentDef.encapsulation):R0(c,u,function uK(n){const t=n.toLowerCase();return"svg"===t?"svg":"math"===t?"math":null}(u)),h=this.componentDef.onPush?288:272,f=vw(0,null,null,1,0,null,null,null,null,null),p=xg(null,f,null,h,null,null,a,c,l,o,null);let m,g;s0(p);try{const y=this.componentDef;let b,_=null;y.findHostDirectiveDefs?(b=[],_=new Map,y.findHostDirectiveDefs(y,b,_),b.push(y)):b=[y];const v=function pK(n,t){const e=n[1];return n[22]=t,fu(e,22,2,"#host",null)}(p,d),w=function mK(n,t,e,r,s,i,o,a){const l=s[1];!function gK(n,t,e,r){for(const s of n)t.mergedAttrs=ph(t.mergedAttrs,s.hostAttrs);null!==t.mergedAttrs&&(Eg(t,t.mergedAttrs,!0),null!==e&&BA(r,e,t))}(r,n,t,o);const c=i.createRenderer(t,e),u=xg(s,UR(e),null,e.onPush?32:16,s[n.index],n,i,c,a||null,null,null);return l.firstCreatePass&&ww(l,n,r.length-1),Cg(s,u),s[n.index]=u}(v,d,y,b,p,a,c);g=Zx(f,22),d&&function bK(n,t,e,r){if(r)u0(n,e,["ng-version",z8.full]);else{const{attrs:s,classes:i}=function l6(n){const t=[],e=[];let r=1,s=2;for(;r<n.length;){let i=n[r];if("string"==typeof i)2===s?""!==i&&t.push(i,n[++r]):8===s&&e.push(i);else{if(!Ki(s))break;s=i}r++}return{attrs:t,classes:e}}(t.selectors[0]);s&&u0(n,e,s),i&&i.length>0&&VA(n,e,i.join(" "))}}(c,y,d,r),void 0!==e&&function _K(n,t,e){const r=n.projection=[];for(let s=0;s<t.length;s++){const i=e[s];r.push(null!=i?Array.from(i):null)}}(g,this.ngContentSelectors,e),m=function yK(n,t,e,r,s,i){const o=Fr(),a=s[1],l=Bs(o,s);qR(a,s,o,e,null,r);for(let u=0;u<e.length;u++)Hr(Zc(s,a,o.directiveStart+u,o),s);KR(a,s,o),l&&Hr(l,s);const c=Zc(s,a,o.directiveStart+o.componentOffset,o);if(n[8]=s[8]=c,null!==i)for(const u of i)u(c,t);return yw(a,o,n),c}(w,y,b,_,p,[vK]),gw(f,p,null)}finally{o0()}return new fK(this.componentType,m,uu(g,p),p,g)}}class fK extends F8{constructor(t,e,r,s,i){super(),this.location=r,this._rootLView=s,this._tNode=i,this.instance=e,this.hostView=this.changeDetectorRef=new cK(s),this.componentType=t}setInput(t,e){const r=this._tNode.inputs;let s;if(null!==r&&(s=r[t])){const i=this._rootLView;Dw(i[1],i,s,t,e),GR(i,this._tNode.index)}}get injector(){return new Qc(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}function vK(){const n=Fr();Ym(oe()[1],n)}function bt(n){let t=function tM(n){return Object.getPrototypeOf(n.prototype).constructor}(n.type),e=!0;const r=[n];for(;t;){let s;if(qi(n))s=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new te(903,!1);s=t.\u0275dir}if(s){if(e){r.push(s);const o=n;o.inputs=kw(n.inputs),o.declaredInputs=kw(n.declaredInputs),o.outputs=kw(n.outputs);const a=s.hostBindings;a&&SK(n,a);const l=s.viewQuery,c=s.contentQueries;if(l&&wK(n,l),c&&CK(n,c),Fx(n.inputs,s.inputs),Fx(n.declaredInputs,s.declaredInputs),Fx(n.outputs,s.outputs),qi(s)&&s.data.animation){const u=n.data;u.animation=(u.animation||[]).concat(s.data.animation)}}const i=s.features;if(i)for(let o=0;o<i.length;o++){const a=i[o];a&&a.ngInherit&&a(n),a===bt&&(e=!1)}}t=Object.getPrototypeOf(t)}!function xK(n){let t=0,e=null;for(let r=n.length-1;r>=0;r--){const s=n[r];s.hostVars=t+=s.hostVars,s.hostAttrs=ph(s.hostAttrs,e=ph(e,s.hostAttrs))}}(r)}function kw(n){return n===Ko?{}:n===$t?[]:n}function wK(n,t){const e=n.viewQuery;n.viewQuery=e?(r,s)=>{t(r,s),e(r,s)}:t}function CK(n,t){const e=n.contentQueries;n.contentQueries=e?(r,s,i)=>{t(r,s,i),e(r,s,i)}:t}function SK(n,t){const e=n.hostBindings;n.hostBindings=e?(r,s)=>{t(r,s),e(r,s)}:t}let Dg=null;function ql(){if(!Dg){const n=un.Symbol;if(n&&n.iterator)Dg=n.iterator;else{const t=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e<t.length;++e){const r=t[e];"entries"!==r&&"size"!==r&&Map.prototype[r]===Map.prototype.entries&&(Dg=r)}}}return Dg}function Nh(n){return!!Nw(n)&&(Array.isArray(n)||!(n instanceof Map)&&ql()in n)}function Nw(n){return null!==n&&("function"==typeof n||"object"==typeof n)}function vo(n,t,e){return n[t]=e}function Wr(n,t,e){return!Object.is(n[t],e)&&(n[t]=e,!0)}function kn(n,t,e,r){const s=oe();return Wr(s,Kc(),t)&&(Nt(),_o(Tn(),s,n,t,e,r)),kn}function mu(n,t,e,r){return Wr(n,Kc(),e)?t+tt(e)+r:nt}function bi(n,t,e,r,s,i,o,a){const l=oe(),c=Nt(),u=n+22,d=c.firstCreatePass?function FK(n,t,e,r,s,i,o,a,l){const c=t.consts,u=fu(t,n,4,o||null,Ma(c,a));xw(t,e,u,Ma(c,l)),Ym(t,u);const d=u.tViews=vw(2,u,r,s,i,t.directiveRegistry,t.pipeRegistry,null,t.schemas,c);return null!==t.queries&&(t.queries.template(t,u),d.queries=t.queries.embeddedTView(u)),u}(u,c,l,t,e,r,s,i,o):c.data[u];go(d,!1);const h=l[11].createComment("");lg(c,l,h,d),Hr(h,l),Cg(l,l[u]=XR(h,l,h,d)),qm(d)&&bw(c,l,d),null!=o&&_w(l,d,a)}function Rh(n){return qc(function E5(){return Qe.lFrame.contextLView}(),22+n)}function tn(n,t,e){const r=oe();return Wr(r,Kc(),t)&&js(Nt(),Tn(),r,n,t,r[11],e,!1),tn}function Aw(n,t,e,r,s){const o=s?"class":"style";Dw(n,e,t.inputs[o],o,r)}function Xt(n,t,e,r){const s=oe(),i=Nt(),o=22+n,a=s[11],l=s[o]=R0(a,t,function F5(){return Qe.lFrame.currentNamespace}()),c=i.firstCreatePass?function $K(n,t,e,r,s,i,o){const a=t.consts,c=fu(t,n,2,s,Ma(a,i));return xw(t,e,c,Ma(a,o)),null!==c.attrs&&Eg(c,c.attrs,!1),null!==c.mergedAttrs&&Eg(c,c.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,c),c}(o,i,s,0,t,e,r):i.data[o];return go(c,!0),BA(a,l,c),32!=(32&c.flags)&&lg(i,s,l,c),0===function v5(){return Qe.lFrame.elementDepthCount}()&&Hr(l,s),function x5(){Qe.lFrame.elementDepthCount++}(),qm(c)&&(bw(i,s,c),yw(i,c,s)),null!==r&&_w(s,c),Xt}function Nn(){let n=Fr();Jx()?e0():(n=n.parent,go(n,!1));const t=n;!function w5(){Qe.lFrame.elementDepthCount--}();const e=Nt();return e.firstCreatePass&&(Ym(e,n),Gx(n)&&e.queries.elementEnd(n)),null!=t.classesWithoutHost&&function V5(n){return 0!=(8&n.flags)}(t)&&Aw(e,t,oe(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function B5(n){return 0!=(16&n.flags)}(t)&&Aw(e,t,oe(),t.stylesWithoutHost,!1),Nn}function as(n,t,e,r){return Xt(n,t,e,r),Nn(),as}function Rw(n,t,e){const r=oe(),s=Nt(),i=n+22,o=s.firstCreatePass?function PK(n,t,e,r,s){const i=t.consts,o=Ma(i,r),a=fu(t,n,8,"ng-container",o);return null!==o&&Eg(a,o,!0),xw(t,e,a,Ma(i,s)),null!==t.queries&&t.queries.elementStart(t,a),a}(i,s,r,t,e):s.data[i];go(o,!0);const a=r[i]=r[11].createComment("");return lg(s,r,a,o),Hr(a,r),qm(o)&&(bw(s,r,o),yw(s,o,r)),null!=e&&_w(r,o),Rw}function Mw(){let n=Fr();const t=Nt();return Jx()?e0():(n=n.parent,go(n,!1)),t.firstCreatePass&&(Ym(t,n),Gx(n)&&t.queries.elementEnd(n)),Mw}function Mh(n,t,e){return Rw(n,t,e),Mw(),Mh}function kg(){return oe()}function Fh(n){return!!n&&"function"==typeof n.then}const Fw=function pM(n){return!!n&&"function"==typeof n.subscribe};function Gn(n,t,e,r){const s=oe(),i=Nt(),o=Fr();return function gM(n,t,e,r,s,i,o){const a=qm(r),c=n.firstCreatePass&&ZR(n),u=t[8],d=YR(t);let h=!0;if(3&r.type||o){const m=Bs(r,t),g=o?o(m):m,y=d.length,b=o?v=>o(dr(v[r.index])):r.index;let _=null;if(!o&&a&&(_=function LK(n,t,e,r){const s=n.cleanup;if(null!=s)for(let i=0;i<s.length-1;i+=2){const o=s[i];if(o===e&&s[i+1]===r){const a=t[7],l=s[i+2];return a.length>l?a[l]:null}"string"==typeof o&&(i+=2)}return null}(n,t,s,r.index)),null!==_)(_.__ngLastListenerFn__||_).__ngNextListenerFn__=i,_.__ngLastListenerFn__=i,h=!1;else{i=bM(r,t,u,i,!1);const v=e.listen(g,s,i);d.push(i,v),c&&c.push(s,b,y,y+1)}}else i=bM(r,t,u,i,!1);const f=r.outputs;let p;if(h&&null!==f&&(p=f[s])){const m=p.length;if(m)for(let g=0;g<m;g+=2){const w=t[p[g]][p[g+1]].subscribe(i),C=d.length;d.push(i,w),c&&c.push(s,r.index,C,-(C+1))}}}(i,s,s[11],o,n,t,r),Gn}function yM(n,t,e,r){try{return!1!==e(r)}catch(s){return JR(n,s),!1}}function bM(n,t,e,r,s){return function i(o){if(o===Function)return r;Ew(n.componentOffset>-1?zs(n.index,t):t);let l=yM(t,0,r,o),c=i.__ngNextListenerFn__;for(;c;)l=yM(t,0,c,o)&&l,c=c.__ngNextListenerFn__;return s&&!1===l&&(o.preventDefault(),o.returnValue=!1),l}}function Yi(n=1){return function N5(n){return(Qe.lFrame.contextLView=function A5(n,t){for(;n>0;)t=t[15],n--;return t}(n,Qe.lFrame.contextLView))[8]}(n)}function VK(n,t){let e=null;const r=function n6(n){const t=n.attrs;if(null!=t){const e=t.indexOf(5);if(0==(1&e))return t[e+1]}return null}(n);for(let s=0;s<t.length;s++){const i=t[s];if("*"!==i){if(null===r?gR(n,i,!0):i6(r,i))return s}else e=s}return e}function Cu(n){const t=oe()[16][6];if(!t.projection){const r=t.projection=yh(n?n.length:1,null),s=r.slice();let i=t.child;for(;null!==i;){const o=n?VK(i,n):0;null!==o&&(s[o]?s[o].projectionNext=i:r[o]=i,s[o]=i),i=i.next}}}function sa(n,t=0,e){const r=oe(),s=Nt(),i=fu(s,22+n,16,null,e||null);null===i.projection&&(i.projection=t),e0(),32!=(32&i.flags)&&function jq(n,t,e){LA(t[11],0,t,e,kA(n,e,t),MA(e.parent||t[6],e,t))}(s,r,i)}function TM(n,t,e,r,s){const i=n[e+1],o=null===t;let a=r?Xi(i):na(i),l=!1;for(;0!==a&&(!1===l||o);){const u=n[a+1];UK(n[a],t)&&(l=!0,n[a+1]=r?aw(u):iw(u)),a=r?Xi(u):na(u)}l&&(n[e+1]=r?iw(i):aw(i))}function UK(n,t){return null===n||null==t||(Array.isArray(n)?n[1]:n)===t||!(!Array.isArray(n)||"string"!=typeof t)&&su(n,t)>=0}const fr={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function kM(n){return n.substring(fr.key,fr.keyEnd)}function NM(n,t){const e=fr.textEnd;return e===t?-1:(t=fr.keyEnd=function GK(n,t,e){for(;t<e&&n.charCodeAt(t)>32;)t++;return t}(n,fr.key=t,e),Su(n,t,e))}function Su(n,t,e){for(;t<e&&n.charCodeAt(t)<=32;)t++;return t}function Oh(n,t,e){return Zi(n,t,e,!1),Oh}function Gs(n,t){return Zi(n,t,null,!0),Gs}function wo(n,t){for(let e=function WK(n){return function RM(n){fr.key=0,fr.keyEnd=0,fr.value=0,fr.valueEnd=0,fr.textEnd=n.length}(n),NM(n,Su(n,0,fr.textEnd))}(t);e>=0;e=NM(t,e))Hs(n,kM(t),!0)}function Zi(n,t,e,r){const s=oe(),i=Nt(),o=Zo(2);i.firstUpdatePass&&$M(i,n,o,r),t!==nt&&Wr(s,o,t)&&LM(i,i.data[ss()],s,s[11],n,s[o+1]=function rX(n,t){return null==n||("string"==typeof t?n+=t:"object"==typeof n&&(n=Jt(Ws(n)))),n}(t,e),r,o)}function OM(n,t){return t>=n.expandoStartIndex}function $M(n,t,e,r){const s=n.data;if(null===s[e+1]){const i=s[ss()],o=OM(n,e);BM(i,r)&&null===t&&!o&&(t=!1),t=function ZK(n,t,e,r){const s=function n0(n){const t=Qe.lFrame.currentDirectiveIndex;return-1===t?null:n[t]}(n);let i=r?t.residualClasses:t.residualStyles;if(null===s)0===(r?t.classBindings:t.styleBindings)&&(e=$h(e=$w(null,n,t,e,r),t.attrs,r),i=null);else{const o=t.directiveStylingLast;if(-1===o||n[o]!==s)if(e=$w(s,n,t,e,r),null===i){let l=function QK(n,t,e){const r=e?t.classBindings:t.styleBindings;if(0!==na(r))return n[Xi(r)]}(n,t,r);void 0!==l&&Array.isArray(l)&&(l=$w(null,n,t,l[1],r),l=$h(l,t.attrs,r),function JK(n,t,e,r){n[Xi(e?t.classBindings:t.styleBindings)]=r}(n,t,r,l))}else i=function eX(n,t,e){let r;const s=t.directiveEnd;for(let i=1+t.directiveStylingLast;i<s;i++)r=$h(r,n[i].hostAttrs,e);return $h(r,t.attrs,e)}(n,t,r)}return void 0!==i&&(r?t.residualClasses=i:t.residualStyles=i),e}(s,i,t,r),function BK(n,t,e,r,s,i){let o=i?t.classBindings:t.styleBindings,a=Xi(o),l=na(o);n[r]=e;let u,c=!1;if(Array.isArray(e)){const d=e;u=d[1],(null===u||su(d,u)>0)&&(c=!0)}else u=e;if(s)if(0!==l){const h=Xi(n[a+1]);n[r+1]=bg(h,a),0!==h&&(n[h+1]=ow(n[h+1],r)),n[a+1]=function D6(n,t){return 131071&n|t<<17}(n[a+1],r)}else n[r+1]=bg(a,0),0!==a&&(n[a+1]=ow(n[a+1],r)),a=r;else n[r+1]=bg(l,0),0===a?a=r:n[l+1]=ow(n[l+1],r),l=r;c&&(n[r+1]=iw(n[r+1])),TM(n,u,r,!0),TM(n,u,r,!1),function zK(n,t,e,r,s){const i=s?n.residualClasses:n.residualStyles;null!=i&&"string"==typeof t&&su(i,t)>=0&&(e[r+1]=aw(e[r+1]))}(t,u,n,r,i),o=bg(a,l),i?t.classBindings=o:t.styleBindings=o}(s,i,t,e,o,r)}}function $w(n,t,e,r,s){let i=null;const o=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<o&&(i=t[a],r=$h(r,i.hostAttrs,s),i!==n);)a++;return null!==n&&(e.directiveStylingLast=a),r}function $h(n,t,e){const r=e?1:2;let s=-1;if(null!==t)for(let i=0;i<t.length;i++){const o=t[i];"number"==typeof o?s=o:s===r&&(Array.isArray(n)||(n=void 0===n?[]:["",n]),Hs(n,o,!!e||t[++i]))}return void 0===n?null:n}function LM(n,t,e,r,s,i,o,a){if(!(3&t.type))return;const l=n.data,c=l[a+1];Ng(function RR(n){return 1==(1&n)}(c)?VM(l,t,e,s,na(c),o):void 0)||(Ng(i)||function AR(n){return 2==(2&n)}(c)&&(i=VM(l,null,e,s,a,o)),function qq(n,t,e,r,s){if(t)s?n.addClass(e,r):n.removeClass(e,r);else{let i=-1===r.indexOf("-")?void 0:ws.DashCase;null==s?n.removeStyle(e,r,i):("string"==typeof s&&s.endsWith("!important")&&(s=s.slice(0,-10),i|=ws.Important),n.setStyle(e,r,s,i))}}(r,o,Km(ss(),e),s,i))}function VM(n,t,e,r,s,i){const o=null===t;let a;for(;s>0;){const l=n[s],c=Array.isArray(l),u=c?l[1]:l,d=null===u;let h=e[s+1];h===nt&&(h=d?$t:void 0);let f=d?b0(h,r):u===r?h:void 0;if(c&&!Ng(f)&&(f=b0(l,r)),Ng(f)&&(a=f,o))return a;const p=n[s+1];s=o?Xi(p):na(p)}if(null!==t){let l=i?t.residualClasses:t.residualStyles;null!=l&&(a=b0(l,r))}return a}function Ng(n){return void 0!==n}function BM(n,t){return 0!=(n.flags&(t?8:16))}function Xl(n,t=""){const e=oe(),r=Nt(),s=n+22,i=r.firstCreatePass?fu(r,s,1,t,null):r.data[s],o=e[s]=function A0(n,t){return n.createText(t)}(e[11],t);lg(r,e,o,i),go(i,!1)}function Ph(n){return Ag("",n,""),Ph}function Ag(n,t,e){const r=oe(),s=mu(r,n,t,e);return s!==nt&&function ra(n,t,e){const r=Km(t,n);!function IA(n,t,e){n.setValue(t,e)}(n[11],r,e)}(r,ss(),s),Ag}function XM(n,t,e){!function Qi(n,t,e,r){const s=Nt(),i=Zo(2);s.firstUpdatePass&&$M(s,null,i,r);const o=oe();if(e!==nt&&Wr(o,i,e)){const a=s.data[ss()];if(BM(a,r)&&!OM(s,i)){let l=r?a.classesWithoutHost:a.stylesWithoutHost;null!==l&&(e=Ox(l,e||"")),Aw(s,a,o,e,r)}else!function nX(n,t,e,r,s,i,o,a){s===nt&&(s=$t);let l=0,c=0,u=0<s.length?s[0]:null,d=0<i.length?i[0]:null;for(;null!==u||null!==d;){const h=l<s.length?s[l+1]:void 0,f=c<i.length?i[c+1]:void 0;let m,p=null;u===d?(l+=2,c+=2,h!==f&&(p=d,m=f)):null===d||null!==u&&u<d?(l+=2,p=u):(c+=2,p=d,m=f),null!==p&&LM(n,t,e,r,p,m,o,a),u=l<s.length?s[l]:null,d=c<i.length?i[c]:null}}(s,a,o,o[11],o[i+1],o[i+1]=function tX(n,t,e){if(null==e||""===e)return $t;const r=[],s=Ws(e);if(Array.isArray(s))for(let i=0;i<s.length;i++)n(r,s[i],!0);else if("object"==typeof s)for(const i in s)s.hasOwnProperty(i)&&n(r,i,s[i]);else"string"==typeof s&&t(r,s);return r}(n,t,e),r,i)}}(Hs,wo,mu(oe(),n,t,e),!0)}function Pw(n,t,e){const r=oe();return Wr(r,Kc(),t)&&js(Nt(),Tn(),r,n,t,r[11],e,!0),Pw}const Iu="en-US";let lF=Iu;function Bw(n,t,e,r,s){if(n=Ge(n),Array.isArray(n))for(let i=0;i<n.length;i++)Bw(n[i],t,e,r,s);else{const i=Nt(),o=oe();let a=jl(n)?n:Ge(n.provide),l=cR(n);const c=Fr(),u=1048575&c.providerIndexes,d=c.directiveStart,h=c.providerIndexes>>20;if(jl(n)||!n.multi){const f=new hh(l,s,K),p=Uw(a,t,s?u:u+h,d);-1===p?(p0(eg(c,o),i,a),zw(i,n,t.length),t.push(a),c.directiveStart++,c.directiveEnd++,s&&(c.providerIndexes+=1048576),e.push(f),o.push(f)):(e[p]=f,o[p]=f)}else{const f=Uw(a,t,u+h,d),p=Uw(a,t,u,u+h),m=f>=0&&e[f],g=p>=0&&e[p];if(s&&!g||!s&&!m){p0(eg(c,o),i,a);const y=function vY(n,t,e,r,s){const i=new hh(n,e,K);return i.multi=[],i.index=t,i.componentProviders=0,MF(i,s,r&&!e),i}(s?_Y:bY,e.length,s,r,l);!s&&g&&(e[p].providerFactory=y),zw(i,n,t.length,0),t.push(a),c.directiveStart++,c.directiveEnd++,s&&(c.providerIndexes+=1048576),e.push(y),o.push(y)}else zw(i,n,f>-1?f:p,MF(e[s?p:f],l,!s&&r));!s&&r&&g&&e[p].componentProviders++}}}function zw(n,t,e,r){const s=jl(t),i=function D8(n){return!!n.useClass}(t);if(s||i){const l=(i?Ge(t.useClass):t).prototype.ngOnDestroy;if(l){const c=n.destroyHooks||(n.destroyHooks=[]);if(!s&&t.multi){const u=c.indexOf(e);-1===u?c.push(e,[r,l]):c[u+1].push(r,l)}else c.push(e,l)}}}function MF(n,t,e){return e&&n.componentProviders++,n.multi.push(t)-1}function Uw(n,t,e,r){for(let s=e;s<r;s++)if(t[s]===n)return s;return-1}function bY(n,t,e,r){return Hw(this.multi,[])}function _Y(n,t,e,r){const s=this.multi;let i;if(this.providerFactory){const o=this.providerFactory.componentProviders,a=Zc(e,e[1],this.providerFactory.index,r);i=a.slice(0,o),Hw(s,i);for(let l=o;l<a.length;l++)i.push(a[l])}else i=[],Hw(s,i);return i}function Hw(n,t){for(let e=0;e<n.length;e++)t.push((0,n[e])());return t}function gn(n,t=[]){return e=>{e.providersResolver=(r,s)=>function yY(n,t,e){const r=Nt();if(r.firstCreatePass){const s=qi(n);Bw(e,r.data,r.blueprint,s,!0),Bw(t,r.data,r.blueprint,s,!1)}}(r,s?s(n):n,t)}}class Zl{}class FF{}class OF extends Zl{constructor(t,e){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new Tw(this);const r=Ls(t);this._bootstrapComponents=ta(r.bootstrap),this._r3Injector=CR(t,e,[{provide:Zl,useValue:this},{provide:cu,useValue:this.componentFactoryResolver}],Jt(t),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(t)}get injector(){return this._r3Injector}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class Ww extends FF{constructor(t){super(),this.moduleType=t}create(t){return new OF(this.moduleType,t)}}class wY extends Zl{constructor(t,e,r){super(),this.componentFactoryResolver=new Tw(this),this.instance=null;const s=new lR([...t,{provide:Zl,useValue:this},{provide:cu,useValue:this.componentFactoryResolver}],e||gg(),r,new Set(["environment"]));this.injector=s,s.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(t){this.injector.onDestroy(t)}}function $g(n,t,e=null){return new wY(n,t,e).injector}let CY=(()=>{class n{constructor(e){this._injector=e,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e.id)){const r=sR(0,e.type),s=r.length>0?$g([r],this._injector,`Standalone[${e.type.name}]`):null;this.cachedInjectors.set(e.id,s)}return this.cachedInjectors.get(e.id)}ngOnDestroy(){try{for(const e of this.cachedInjectors.values())null!==e&&e.destroy()}finally{this.cachedInjectors.clear()}}}return n.\u0275prov=Ce({token:n,providedIn:"environment",factory:()=>new n(J($a))}),n})();function $F(n){n.getStandaloneInjector=t=>t.get(CY).getOrCreateStandaloneInjector(n)}function WF(n,t,e,r,s,i){const o=t+e;return Wr(n,o,s)?vo(n,o+1,i?r.call(i,s):r(s)):function Hh(n,t){const e=n[t];return e===nt?void 0:e}(n,o+1)}function Gw(n){return t=>{setTimeout(n,void 0,t)}}const Ft=class GY extends Wt{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,r){let s=t,i=e||(()=>null),o=r;if(t&&"object"==typeof t){const l=t;s=l.next?.bind(l),i=l.error?.bind(l),o=l.complete?.bind(l)}this.__isAsync&&(i=Gw(i),s&&(s=Gw(s)),o&&(o=Gw(o)));const a=super.subscribe({next:s,error:i,complete:o});return t instanceof He&&t.add(a),a}};function qY(){return this._results[ql()]()}class jh{constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=ql(),r=jh.prototype;r[e]||(r[e]=qY)}get changes(){return this._changes||(this._changes=new Ft)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){const r=this;r.dirty=!1;const s=Us(t);(this._changesDetected=!function Y5(n,t,e){if(n.length!==t.length)return!1;for(let r=0;r<n.length;r++){let s=n[r],i=t[r];if(e&&(s=e(s),i=e(i)),i!==s)return!1}return!0}(r._results,s,e))&&(r._results=s,r.length=s.length,r.last=s[this.length-1],r.first=s[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}let Co=(()=>{class n{}return n.__NG_ELEMENT_ID__=YY,n})();const KY=Co,XY=class extends KY{constructor(t,e,r){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=r}createEmbeddedView(t,e){const r=this._declarationTContainer.tViews,s=xg(this._declarationLView,r,t,16,null,r.declTNode,null,null,null,null,e||null);s[17]=this._declarationLView[this._declarationTContainer.index];const o=this._declarationLView[19];return null!==o&&(s[19]=o.createEmbeddedView(r)),gw(r,s,t),new Th(s)}};function YY(){return Pg(Fr(),oe())}function Pg(n,t){return 4&n.type?new XY(t,n,uu(n,t)):null}let _i=(()=>{class n{}return n.__NG_ELEMENT_ID__=ZY,n})();function ZY(){return JF(Fr(),oe())}const QY=_i,ZF=class extends QY{constructor(t,e,r){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=r}get element(){return uu(this._hostTNode,this._hostLView)}get injector(){return new Qc(this._hostTNode,this._hostLView)}get parentInjector(){const t=tg(this._hostTNode,this._hostLView);if(WN(t)){const e=Yc(t,this._hostLView),r=Xc(t);return new Qc(e[1].data[r+8],e)}return new Qc(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=QF(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-10}createEmbeddedView(t,e,r){let s,i;"number"==typeof r?s=r:null!=r&&(s=r.index,i=r.injector);const o=t.createEmbeddedView(e||{},i);return this.insert(o,s),o}createComponent(t,e,r,s,i){const o=t&&!function gh(n){return"function"==typeof n}(t);let a;if(o)a=e;else{const d=e||{};a=d.index,r=d.injector,s=d.projectableNodes,i=d.environmentInjector||d.ngModuleRef}const l=o?t:new kh(zt(t)),c=r||this.parentInjector;if(!i&&null==l.ngModule){const h=(o?c:this.parentInjector).get($a,null);h&&(i=h)}const u=l.create(c,s,void 0,i);return this.insert(u.hostView,a),u}insert(t,e){const r=t._lView,s=r[1];if(function _5(n){return Gi(n[3])}(r)){const u=this.indexOf(t);if(-1!==u)this.detach(u);else{const d=r[3],h=new ZF(d,d[6],d[3]);h.detach(h.indexOf(t))}}const i=this._adjustIndex(e),o=this._lContainer;!function Vq(n,t,e,r){const s=10+r,i=e.length;r>0&&(e[s-1][4]=t),r<i-10?(t[4]=e[s],tA(e,10+r,t)):(e.push(t),t[4]=null),t[3]=e;const o=t[17];null!==o&&e!==o&&function Bq(n,t){const e=n[9];t[16]!==t[3][3][16]&&(n[2]=!0),null===e?n[9]=[t]:e.push(t)}(o,t);const a=t[19];null!==a&&a.insertView(n),t[2]|=64}(s,r,o,i);const a=$0(i,o),l=r[11],c=ag(l,o[7]);return null!==c&&function $q(n,t,e,r,s,i){r[0]=s,r[6]=t,wh(n,r,e,1,s,i)}(s,o[6],l,r,c,a),t.attachToViewContainerRef(),tA(qw(o),i,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=QF(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),r=M0(this._lContainer,e);r&&(rg(qw(this._lContainer),e),TA(r[1],r))}detach(t){const e=this._adjustIndex(t,-1),r=M0(this._lContainer,e);return r&&null!=rg(qw(this._lContainer),e)?new Th(r):null}_adjustIndex(t,e=0){return t??this.length+e}};function QF(n){return n[8]}function qw(n){return n[8]||(n[8]=[])}function JF(n,t){let e;const r=t[n.index];if(Gi(r))e=r;else{let s;if(8&n.type)s=dr(r);else{const i=t[11];s=i.createComment("");const o=Bs(n,t);Ul(i,ag(i,o),s,function Wq(n,t){return n.nextSibling(t)}(i,o),!1)}t[n.index]=e=XR(r,t,s,n),Cg(t,e)}return new ZF(e,n,t)}class Kw{constructor(t){this.queryList=t,this.matches=null}clone(){return new Kw(this.queryList)}setDirty(){this.queryList.setDirty()}}class Xw{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const r=null!==t.contentQueries?t.contentQueries[0]:e.length,s=[];for(let i=0;i<r;i++){const o=e.getByIndex(i);s.push(this.queries[o.indexInDeclarationView].clone())}return new Xw(s)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==sO(t,e).matches&&this.queries[e].setDirty()}}class eO{constructor(t,e,r=null){this.predicate=t,this.flags=e,this.read=r}}class Yw{constructor(t=[]){this.queries=t}elementStart(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let r=0;r<this.length;r++){const s=null!==e?e.length:0,i=this.getByIndex(r).embeddedTView(t,s);i&&(i.indexInDeclarationView=r,null!==e?e.push(i):e=[i])}return null!==e?new Yw(e):null}template(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class Zw{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new Zw(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let r=t.parent;for(;null!==r&&8&r.type&&r.index!==e;)r=r.parent;return e===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const r=this.metadata.predicate;if(Array.isArray(r))for(let s=0;s<r.length;s++){const i=r[s];this.matchTNodeWithReadOption(t,e,t7(e,i)),this.matchTNodeWithReadOption(t,e,ng(e,t,i,!1,!1))}else r===Co?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,ng(e,t,r,!1,!1))}matchTNodeWithReadOption(t,e,r){if(null!==r){const s=this.metadata.read;if(null!==s)if(s===Cn||s===_i||s===Co&&4&e.type)this.addMatch(e.index,-2);else{const i=ng(e,t,s,!1,!1);null!==i&&this.addMatch(e.index,i)}else this.addMatch(e.index,r)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function t7(n,t){const e=n.localNames;if(null!==e)for(let r=0;r<e.length;r+=2)if(e[r]===t)return e[r+1];return null}function r7(n,t,e,r){return-1===e?function n7(n,t){return 11&n.type?uu(n,t):4&n.type?Pg(n,t):null}(t,n):-2===e?function s7(n,t,e){return e===Cn?uu(t,n):e===Co?Pg(t,n):e===_i?JF(t,n):void 0}(n,t,r):Zc(n,n[1],e,t)}function tO(n,t,e,r){const s=t[19].queries[r];if(null===s.matches){const i=n.data,o=e.matches,a=[];for(let l=0;l<o.length;l+=2){const c=o[l];a.push(c<0?null:r7(t,i[c],o[l+1],e.metadata.read))}s.matches=a}return s.matches}function Qw(n,t,e,r){const s=n.queries.getByIndex(e),i=s.matches;if(null!==i){const o=tO(n,t,s,e);for(let a=0;a<i.length;a+=2){const l=i[a];if(l>0)r.push(o[a/2]);else{const c=i[a+1],u=t[-l];for(let d=10;d<u.length;d++){const h=u[d];h[17]===h[3]&&Qw(h[1],h,c,r)}if(null!==u[9]){const d=u[9];for(let h=0;h<d.length;h++){const f=d[h];Qw(f[1],f,c,r)}}}}}return r}function qs(n){const t=oe(),e=Nt(),r=FN();r0(r+1);const s=sO(e,r);if(n.dirty&&function b5(n){return 4==(4&n[2])}(t)===(2==(2&s.metadata.flags))){if(null===s.matches)n.reset([]);else{const i=s.crossesNgTemplate?Qw(e,t,r,[]):tO(e,t,s,r);n.reset(i,L8),n.notifyOnChanges()}return!0}return!1}function ia(n,t,e){const r=Nt();r.firstCreatePass&&(rO(r,new eO(n,t,e),-1),2==(2&t)&&(r.staticViewQueries=!0)),nO(r,oe(),t)}function Gh(n,t,e,r){const s=Nt();if(s.firstCreatePass){const i=Fr();rO(s,new eO(t,e,r),i.index),function o7(n,t){const e=n.contentQueries||(n.contentQueries=[]);t!==(e.length?e[e.length-1]:-1)&&e.push(n.queries.length-1,t)}(s,n),2==(2&e)&&(s.staticContentQueries=!0)}nO(s,oe(),e)}function Ks(){return function i7(n,t){return n[19].queries[t].queryList}(oe(),FN())}function nO(n,t,e){const r=new jh(4==(4&e));HR(n,t,r,r.destroy),null===t[19]&&(t[19]=new Xw),t[19].queries.push(new Kw(r))}function rO(n,t,e){null===n.queries&&(n.queries=new Yw),n.queries.track(new Zw(t,e))}function sO(n,t){return n.queries.getByIndex(t)}function iO(n,t){return Pg(n,t)}function Vg(...n){}const Bg=new me("Application Initializer");let zg=(()=>{class n{constructor(e){this.appInits=e,this.resolve=Vg,this.reject=Vg,this.initialized=!1,this.done=!1,this.donePromise=new Promise((r,s)=>{this.resolve=r,this.reject=s})}runInitializers(){if(this.initialized)return;const e=[],r=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let s=0;s<this.appInits.length;s++){const i=this.appInits[s]();if(Fh(i))e.push(i);else if(Fw(i)){const o=new Promise((a,l)=>{i.subscribe({complete:a,error:l})});e.push(o)}}Promise.all(e).then(()=>{r()}).catch(s=>{this.reject(s)}),0===e.length&&r(),this.initialized=!0}}return n.\u0275fac=function(e){return new(e||n)(J(Bg,8))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const Kh=new me("AppId",{providedIn:"root",factory:function SO(){return`${rC()}${rC()}${rC()}`}});function rC(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const EO=new me("Platform Initializer"),sC=new me("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),IO=new me("appBootstrapListener"),Va=new me("AnimationModuleType");let I7=(()=>{class n{log(e){console.log(e)}warn(e){console.warn(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();const So=new me("LocaleId",{providedIn:"root",factory:()=>Mt(So,qe.Optional|qe.SkipSelf)||function D7(){return typeof $localize<"u"&&$localize.locale||Iu}()});class k7{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}let iC=(()=>{class n{compileModuleSync(e){return new Ww(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const r=this.compileModuleSync(e),i=ta(Ls(e).declarations).reduce((o,a)=>{const l=zt(a);return l&&o.push(new kh(l)),o},[]);return new k7(r,i)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const R7=(()=>Promise.resolve(0))();function oC(n){typeof Zone>"u"?R7.then(()=>{n&&n.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",n)}class St{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Ft(!1),this.onMicrotaskEmpty=new Ft(!1),this.onStable=new Ft(!1),this.onError=new Ft(!1),typeof Zone>"u")throw new te(908,!1);Zone.assertZonePatched();const s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!r&&e,s.shouldCoalesceRunChangeDetection=r,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function M7(){let n=un.requestAnimationFrame,t=un.cancelAnimationFrame;if(typeof Zone<"u"&&n&&t){const e=n[Zone.__symbol__("OriginalDelegate")];e&&(n=e);const r=t[Zone.__symbol__("OriginalDelegate")];r&&(t=r)}return{nativeRequestAnimationFrame:n,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function $7(n){const t=()=>{!function O7(n){n.isCheckStableRunning||-1!==n.lastRequestAnimationFrameId||(n.lastRequestAnimationFrameId=n.nativeRequestAnimationFrame.call(un,()=>{n.fakeTopEventTask||(n.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{n.lastRequestAnimationFrameId=-1,lC(n),n.isCheckStableRunning=!0,aC(n),n.isCheckStableRunning=!1},void 0,()=>{},()=>{})),n.fakeTopEventTask.invoke()}),lC(n))}(n)};n._inner=n._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,s,i,o,a)=>{try{return kO(n),e.invokeTask(s,i,o,a)}finally{(n.shouldCoalesceEventChangeDetection&&"eventTask"===i.type||n.shouldCoalesceRunChangeDetection)&&t(),NO(n)}},onInvoke:(e,r,s,i,o,a,l)=>{try{return kO(n),e.invoke(s,i,o,a,l)}finally{n.shouldCoalesceRunChangeDetection&&t(),NO(n)}},onHasTask:(e,r,s,i)=>{e.hasTask(s,i),r===s&&("microTask"==i.change?(n._hasPendingMicrotasks=i.microTask,lC(n),aC(n)):"macroTask"==i.change&&(n.hasPendingMacrotasks=i.macroTask))},onHandleError:(e,r,s,i)=>(e.handleError(s,i),n.runOutsideAngular(()=>n.onError.emit(i)),!1)})}(s)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!St.isInAngularZone())throw new te(909,!1)}static assertNotInAngularZone(){if(St.isInAngularZone())throw new te(909,!1)}run(t,e,r){return this._inner.run(t,e,r)}runTask(t,e,r,s){const i=this._inner,o=i.scheduleEventTask("NgZoneEvent: "+s,t,F7,Vg,Vg);try{return i.runTask(o,e,r)}finally{i.cancelTask(o)}}runGuarded(t,e,r){return this._inner.runGuarded(t,e,r)}runOutsideAngular(t){return this._outer.run(t)}}const F7={};function aC(n){if(0==n._nesting&&!n.hasPendingMicrotasks&&!n.isStable)try{n._nesting++,n.onMicrotaskEmpty.emit(null)}finally{if(n._nesting--,!n.hasPendingMicrotasks)try{n.runOutsideAngular(()=>n.onStable.emit(null))}finally{n.isStable=!0}}}function lC(n){n.hasPendingMicrotasks=!!(n._hasPendingMicrotasks||(n.shouldCoalesceEventChangeDetection||n.shouldCoalesceRunChangeDetection)&&-1!==n.lastRequestAnimationFrameId)}function kO(n){n._nesting++,n.isStable&&(n.isStable=!1,n.onUnstable.emit(null))}function NO(n){n._nesting--,aC(n)}class P7{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Ft,this.onMicrotaskEmpty=new Ft,this.onStable=new Ft,this.onError=new Ft}run(t,e,r){return t.apply(e,r)}runGuarded(t,e,r){return t.apply(e,r)}runOutsideAngular(t){return t()}runTask(t,e,r,s){return t.apply(e,r)}}const AO=new me(""),Ug=new me("");let dC,cC=(()=>{class n{constructor(e,r,s){this._ngZone=e,this.registry=r,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,dC||(function L7(n){dC=n}(s),s.addToWindow(r)),this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{St.assertNotInAngularZone(),oC(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())oC(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(e)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,r,s){let i=-1;r&&r>0&&(i=setTimeout(()=>{this._callbacks=this._callbacks.filter(o=>o.timeoutId!==i),e(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:e,timeoutId:i,updateCb:s})}whenStable(e,r,s){if(s&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,r,s),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(e){this.registry.registerApplication(e,this)}unregisterApplication(e){this.registry.unregisterApplication(e)}findProviders(e,r,s){return[]}}return n.\u0275fac=function(e){return new(e||n)(J(St),J(uC),J(Ug))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac}),n})(),uC=(()=>{class n{constructor(){this._applications=new Map}registerApplication(e,r){this._applications.set(e,r)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,r=!0){return dC?.findTestabilityInTree(this,e,r)??null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})(),Ba=null;const RO=new me("AllowMultipleToken"),hC=new me("PlatformDestroyListeners");class MO{constructor(t,e){this.name=t,this.token=e}}function OO(n,t,e=[]){const r=`Platform: ${t}`,s=new me(r);return(i=[])=>{let o=fC();if(!o||o.injector.get(RO,!1)){const a=[...e,...i,{provide:s,useValue:!0}];n?n(a):function z7(n){if(Ba&&!Ba.get(RO,!1))throw new te(400,!1);Ba=n;const t=n.get(PO);(function FO(n){const t=n.get(EO,null);t&&t.forEach(e=>e())})(n)}(function $O(n=[],t){return os.create({name:t,providers:[{provide:K0,useValue:"platform"},{provide:hC,useValue:new Set([()=>Ba=null])},...n]})}(a,r))}return function H7(n){const t=fC();if(!t)throw new te(401,!1);return t}()}}function fC(){return Ba?.get(PO)??null}let PO=(()=>{class n{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,r){const s=function VO(n,t){let e;return e="noop"===n?new P7:("zone.js"===n?void 0:n)||new St(t),e}(r?.ngZone,function LO(n){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:!(!n||!n.ngZoneEventCoalescing)||!1,shouldCoalesceRunChangeDetection:!(!n||!n.ngZoneRunCoalescing)||!1}}(r)),i=[{provide:St,useValue:s}];return s.run(()=>{const o=os.create({providers:i,parent:this.injector,name:e.moduleType.name}),a=e.create(o),l=a.injector.get(ea,null);if(!l)throw new te(402,!1);return s.runOutsideAngular(()=>{const c=s.onError.subscribe({next:u=>{l.handleError(u)}});a.onDestroy(()=>{Hg(this._modules,a),c.unsubscribe()})}),function BO(n,t,e){try{const r=e();return Fh(r)?r.catch(s=>{throw t.runOutsideAngular(()=>n.handleError(s)),s}):r}catch(r){throw t.runOutsideAngular(()=>n.handleError(r)),r}}(l,s,()=>{const c=a.injector.get(zg);return c.runInitializers(),c.donePromise.then(()=>(function cF(n){Ps(n,"Expected localeId to be defined"),"string"==typeof n&&(lF=n.toLowerCase().replace(/_/g,"-"))}(a.injector.get(So,Iu)||Iu),this._moduleDoBootstrap(a),a))})})}bootstrapModule(e,r=[]){const s=zO({},r);return function V7(n,t,e){const r=new Ww(e);return Promise.resolve(r)}(0,0,e).then(i=>this.bootstrapModuleFactory(i,s))}_moduleDoBootstrap(e){const r=e.injector.get(ku);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(s=>r.bootstrap(s));else{if(!e.instance.ngDoBootstrap)throw new te(403,!1);e.instance.ngDoBootstrap(r)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new te(404,!1);this._modules.slice().forEach(r=>r.destroy()),this._destroyListeners.forEach(r=>r());const e=this._injector.get(hC,null);e&&(e.forEach(r=>r()),e.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return n.\u0275fac=function(e){return new(e||n)(J(os))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();function zO(n,t){return Array.isArray(t)?t.reduce(zO,n):{...n,...t}}let ku=(()=>{class n{constructor(e,r,s){this._zone=e,this._injector=r,this._exceptionHandler=s,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this._destroyed=!1,this._destroyListeners=[],this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const i=new xn(a=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{a.next(this._stable),a.complete()})}),o=new xn(a=>{let l;this._zone.runOutsideAngular(()=>{l=this._zone.onStable.subscribe(()=>{St.assertNotInAngularZone(),oC(()=>{!this._stable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks&&(this._stable=!0,a.next(!0))})})});const c=this._zone.onUnstable.subscribe(()=>{St.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{a.next(!1)}))});return()=>{l.unsubscribe(),c.unsubscribe()}});this.isStable=Jd(i,o.pipe(dN()))}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(e,r){const s=e instanceof uR;if(!this._injector.get(zg).done)throw!s&&function Hc(n){const t=zt(n)||Br(n)||ns(n);return null!==t&&t.standalone}(e),new te(405,false);let o;o=s?e:this._injector.get(cu).resolveComponentFactory(e),this.componentTypes.push(o.componentType);const a=function B7(n){return n.isBoundToModule}(o)?void 0:this._injector.get(Zl),c=o.create(os.NULL,[],r||o.selector,a),u=c.location.nativeElement,d=c.injector.get(AO,null);return d?.registerApplication(u),c.onDestroy(()=>{this.detachView(c.hostView),Hg(this.components,c),d?.unregisterApplication(u)}),this._loadComponent(c),c}tick(){if(this._runningTick)throw new te(101,!1);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){const r=e;Hg(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get(IO,[]).concat(this._bootstrapListeners).forEach(s=>s(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>Hg(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new te(406,!1);const e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return n.\u0275fac=function(e){return new(e||n)(J(St),J($a),J(ea))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function Hg(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}let Nu=(()=>{class n{}return n.__NG_ELEMENT_ID__=j7,n})();function j7(n){return function G7(n,t,e){if(Gm(n)&&!e){const r=zs(n.index,t);return new Th(r,r)}return 47&n.type?new Th(t[16],t):null}(Fr(),oe(),16==(16&n))}class GO{constructor(){}supports(t){return Nh(t)}create(t){return new Q7(t)}}const Z7=(n,t)=>t;class Q7{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||Z7}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,r=this._removalsHead,s=0,i=null;for(;e||r;){const o=!r||e&&e.currentIndex<KO(r,s,i)?e:r,a=KO(o,s,i),l=o.currentIndex;if(o===r)s--,r=r._nextRemoved;else if(e=e._next,null==o.previousIndex)s++;else{i||(i=[]);const c=a-s,u=l-s;if(c!=u){for(let h=0;h<c;h++){const f=h<i.length?i[h]:i[h]=0,p=f+h;u<=p&&p<c&&(i[h]=f+1)}i[o.previousIndex]=u-c}}a!==l&&t(o,a,l)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!Nh(t))throw new te(900,!1);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let s,i,o,e=this._itHead,r=!1;if(Array.isArray(t)){this.length=t.length;for(let a=0;a<this.length;a++)i=t[a],o=this._trackByFn(a,i),null!==e&&Object.is(e.trackById,o)?(r&&(e=this._verifyReinsertion(e,i,o,a)),Object.is(e.item,i)||this._addIdentityChange(e,i)):(e=this._mismatch(e,i,o,a),r=!0),e=e._next}else s=0,function AK(n,t){if(Array.isArray(n))for(let e=0;e<n.length;e++)t(n[e]);else{const e=n[ql()]();let r;for(;!(r=e.next()).done;)t(r.value)}}(t,a=>{o=this._trackByFn(s,a),null!==e&&Object.is(e.trackById,o)?(r&&(e=this._verifyReinsertion(e,a,o,s)),Object.is(e.item,a)||this._addIdentityChange(e,a)):(e=this._mismatch(e,a,o,s),r=!0),e=e._next,s++}),this.length=s;return this._truncate(e),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,r,s){let i;return null===t?i=this._itTail:(i=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,i,s)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(r,s))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,i,s)):t=this._addAfter(new J7(e,r),i,s),t}_verifyReinsertion(t,e,r,s){let i=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null);return null!==i?t=this._reinsertAfter(i,t._prev,s):t.currentIndex!=s&&(t.currentIndex=s,this._addToMoves(t,s)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,r){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const s=t._prevRemoved,i=t._nextRemoved;return null===s?this._removalsHead=i:s._nextRemoved=i,null===i?this._removalsTail=s:i._prevRemoved=s,this._insertAfter(t,e,r),this._addToMoves(t,r),t}_moveAfter(t,e,r){return this._unlink(t),this._insertAfter(t,e,r),this._addToMoves(t,r),t}_addAfter(t,e,r){return this._insertAfter(t,e,r),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,r){const s=null===e?this._itHead:e._next;return t._next=s,t._prev=e,null===s?this._itTail=t:s._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new qO),this._linkedRecords.put(t),t.currentIndex=r,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,r=t._next;return null===e?this._itHead=r:e._next=r,null===r?this._itTail=e:r._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new qO),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class J7{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class e9{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let r;for(r=this._head;null!==r;r=r._nextDup)if((null===e||e<=r.currentIndex)&&Object.is(r.trackById,t))return r;return null}remove(t){const e=t._prevDup,r=t._nextDup;return null===e?this._head=r:e._nextDup=r,null===r?this._tail=e:r._prevDup=e,null===this._head}}class qO{constructor(){this.map=new Map}put(t){const e=t.trackById;let r=this.map.get(e);r||(r=new e9,this.map.set(e,r)),r.add(t)}get(t,e){const s=this.map.get(t);return s?s.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function KO(n,t,e){const r=n.previousIndex;if(null===r)return r;let s=0;return e&&r<e.length&&(s=e[r]),r+t+s}class XO{constructor(){}supports(t){return t instanceof Map||Nw(t)}create(){return new t9}}class t9{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let e;for(e=this._mapHead;null!==e;e=e._next)t(e)}forEachPreviousItem(t){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)t(e)}forEachChangedItem(t){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}diff(t){if(t){if(!(t instanceof Map||Nw(t)))throw new te(900,!1)}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(t,(r,s)=>{if(e&&e.key===s)this._maybeAddToChanges(e,r),this._appendAfter=e,e=e._next;else{const i=this._getOrCreateRecordForKey(s,r);e=this._insertBeforeOrAppend(e,i)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let r=e;null!==r;r=r._nextRemoved)r===this._mapHead&&(this._mapHead=null),this._records.delete(r.key),r._nextRemoved=r._next,r.previousValue=r.currentValue,r.currentValue=null,r._prev=null,r._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,e){if(t){const r=t._prev;return e._next=t,e._prev=r,t._prev=e,r&&(r._next=e),t===this._mapHead&&(this._mapHead=e),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(t,e){if(this._records.has(t)){const s=this._records.get(t);this._maybeAddToChanges(s,e);const i=s._prev,o=s._next;return i&&(i._next=o),o&&(o._prev=i),s._next=null,s._prev=null,s}const r=new n9(t);return this._records.set(t,r),r.currentValue=e,this._addToAdditions(r),r}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,e){Object.is(e,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=e,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,e){t instanceof Map?t.forEach(e):Object.keys(t).forEach(r=>e(t[r],r))}}class n9{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function YO(){return new Gg([new GO])}let Gg=(()=>{class n{constructor(e){this.factories=e}static create(e,r){if(null!=r){const s=r.factories.slice();e=e.concat(s)}return new n(e)}static extend(e){return{provide:n,useFactory:r=>n.create(e,r||YO()),deps:[[n,new iu,new Oa]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(null!=r)return r;throw new te(901,!1)}}return n.\u0275prov=Ce({token:n,providedIn:"root",factory:YO}),n})();function ZO(){return new Xh([new XO])}let Xh=(()=>{class n{constructor(e){this.factories=e}static create(e,r){if(r){const s=r.factories.slice();e=e.concat(s)}return new n(e)}static extend(e){return{provide:n,useFactory:r=>n.create(e,r||ZO()),deps:[[n,new iu,new Oa]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(r)return r;throw new te(901,!1)}}return n.\u0275prov=Ce({token:n,providedIn:"root",factory:ZO}),n})();const i9=OO(null,"core",[]);let o9=(()=>{class n{constructor(e){}}return n.\u0275fac=function(e){return new(e||n)(J(ku))},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({}),n})();let qg=null;function Eo(){return qg}class c9{}const Et=new me("DocumentToken");let bC=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:function(){return function u9(){return J(QO)}()},providedIn:"platform"}),n})();const d9=new me("Location Initialized");let QO=(()=>{class n extends bC{constructor(e){super(),this._doc=e,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Eo().getBaseHref(this._doc)}onPopState(e){const r=Eo().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){const r=Eo().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(e){this.location.pathname=e}pushState(e,r,s){JO()?this._history.pushState(e,r,s):this.location.hash=s}replaceState(e,r,s){JO()?this._history.replaceState(e,r,s):this.location.hash=s}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return n.\u0275fac=function(e){return new(e||n)(J(Et))},n.\u0275prov=Ce({token:n,factory:function(){return function h9(){return new QO(J(Et))}()},providedIn:"platform"}),n})();function JO(){return!!window.history.pushState}function _C(n,t){if(0==n.length)return t;if(0==t.length)return n;let e=0;return n.endsWith("/")&&e++,t.startsWith("/")&&e++,2==e?n+t.substring(1):1==e?n+t:n+"/"+t}function e2(n){const t=n.match(/#|\?|$/),e=t&&t.index||n.length;return n.slice(0,e-("/"===n[e-1]?1:0))+n.slice(e)}function aa(n){return n&&"?"!==n[0]?"?"+n:n}let Jl=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:function(){return Mt(n2)},providedIn:"root"}),n})();const t2=new me("appBaseHref");let n2=(()=>{class n extends Jl{constructor(e,r){super(),this._platformLocation=e,this._removeListenerFns=[],this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??Mt(Et).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return _C(this._baseHref,e)}path(e=!1){const r=this._platformLocation.pathname+aa(this._platformLocation.search),s=this._platformLocation.hash;return s&&e?`${r}${s}`:r}pushState(e,r,s,i){const o=this.prepareExternalUrl(s+aa(i));this._platformLocation.pushState(e,r,o)}replaceState(e,r,s,i){const o=this.prepareExternalUrl(s+aa(i));this._platformLocation.replaceState(e,r,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return n.\u0275fac=function(e){return new(e||n)(J(bC),J(t2,8))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),f9=(()=>{class n extends Jl{constructor(e,r){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let r=this._platformLocation.hash;return null==r&&(r="#"),r.length>0?r.substring(1):r}prepareExternalUrl(e){const r=_C(this._baseHref,e);return r.length>0?"#"+r:r}pushState(e,r,s,i){let o=this.prepareExternalUrl(s+aa(i));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.pushState(e,r,o)}replaceState(e,r,s,i){let o=this.prepareExternalUrl(s+aa(i));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.replaceState(e,r,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return n.\u0275fac=function(e){return new(e||n)(J(bC),J(t2,8))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac}),n})(),Kg=(()=>{class n{constructor(e){this._subject=new Ft,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=e;const r=this._locationStrategy.getBaseHref();this._baseHref=e2(r2(r)),this._locationStrategy.onPopState(s=>{this._subject.emit({url:this.path(!0),pop:!0,state:s.state,type:s.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+aa(r))}normalize(e){return n.stripTrailingSlash(function m9(n,t){return n&&t.startsWith(n)?t.substring(n.length):t}(this._baseHref,r2(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,r="",s=null){this._locationStrategy.pushState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+aa(r)),s)}replaceState(e,r="",s=null){this._locationStrategy.replaceState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+aa(r)),s)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)})),()=>{const r=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(r,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(s=>s(e,r))}subscribe(e,r,s){return this._subject.subscribe({next:e,error:r,complete:s})}}return n.normalizeQueryParams=aa,n.joinWithSlash=_C,n.stripTrailingSlash=e2,n.\u0275fac=function(e){return new(e||n)(J(Jl))},n.\u0275prov=Ce({token:n,factory:function(){return function p9(){return new Kg(J(Jl))}()},providedIn:"root"}),n})();function r2(n){return n.replace(/\/index.html$/,"")}let f2=(()=>{class n{constructor(e,r,s,i){this._iterableDiffers=e,this._keyValueDiffers=r,this._ngEl=s,this._renderer=i,this._iterableDiffer=null,this._keyValueDiffer=null,this._initialClasses=[],this._rawClass=null}set klass(e){this._removeClasses(this._initialClasses),this._initialClasses="string"==typeof e?e.split(/\s+/):[],this._applyClasses(this._initialClasses),this._applyClasses(this._rawClass)}set ngClass(e){this._removeClasses(this._rawClass),this._applyClasses(this._initialClasses),this._iterableDiffer=null,this._keyValueDiffer=null,this._rawClass="string"==typeof e?e.split(/\s+/):e,this._rawClass&&(Nh(this._rawClass)?this._iterableDiffer=this._iterableDiffers.find(this._rawClass).create():this._keyValueDiffer=this._keyValueDiffers.find(this._rawClass).create())}ngDoCheck(){if(this._iterableDiffer){const e=this._iterableDiffer.diff(this._rawClass);e&&this._applyIterableChanges(e)}else if(this._keyValueDiffer){const e=this._keyValueDiffer.diff(this._rawClass);e&&this._applyKeyValueChanges(e)}}_applyKeyValueChanges(e){e.forEachAddedItem(r=>this._toggleClass(r.key,r.currentValue)),e.forEachChangedItem(r=>this._toggleClass(r.key,r.currentValue)),e.forEachRemovedItem(r=>{r.previousValue&&this._toggleClass(r.key,!1)})}_applyIterableChanges(e){e.forEachAddedItem(r=>{if("string"!=typeof r.item)throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${Jt(r.item)}`);this._toggleClass(r.item,!0)}),e.forEachRemovedItem(r=>this._toggleClass(r.item,!1))}_applyClasses(e){e&&(Array.isArray(e)||e instanceof Set?e.forEach(r=>this._toggleClass(r,!0)):Object.keys(e).forEach(r=>this._toggleClass(r,!!e[r])))}_removeClasses(e){e&&(Array.isArray(e)||e instanceof Set?e.forEach(r=>this._toggleClass(r,!1)):Object.keys(e).forEach(r=>this._toggleClass(r,!1)))}_toggleClass(e,r){(e=e.trim())&&e.split(/\s+/g).forEach(s=>{r?this._renderer.addClass(this._ngEl.nativeElement,s):this._renderer.removeClass(this._ngEl.nativeElement,s)})}}return n.\u0275fac=function(e){return new(e||n)(K(Gg),K(Xh),K(Cn),K(Jo))},n.\u0275dir=Ve({type:n,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"},standalone:!0}),n})();class eZ{constructor(t,e,r,s){this.$implicit=t,this.ngForOf=e,this.index=r,this.count=s}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let g2=(()=>{class n{constructor(e,r,s){this._viewContainer=e,this._template=r,this._differs=s,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const e=this._ngForOf;!this._differ&&e&&(this._differ=this._differs.find(e).create(this.ngForTrackBy))}if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const r=this._viewContainer;e.forEachOperation((s,i,o)=>{if(null==s.previousIndex)r.createEmbeddedView(this._template,new eZ(s.item,this._ngForOf,-1,-1),null===o?void 0:o);else if(null==o)r.remove(null===i?void 0:i);else if(null!==i){const a=r.get(i);r.move(a,o),y2(a,s)}});for(let s=0,i=r.length;s<i;s++){const a=r.get(s).context;a.index=s,a.count=i,a.ngForOf=this._ngForOf}e.forEachIdentityChange(s=>{y2(r.get(s.currentIndex),s)})}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(K(_i),K(Co),K(Gg))},n.\u0275dir=Ve({type:n,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"},standalone:!0}),n})();function y2(n,t){n.context.$implicit=t.item}let kC=(()=>{class n{constructor(e,r){this._viewContainer=e,this._context=new nZ,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=r}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){b2("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){b2("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(K(_i),K(Co))},n.\u0275dir=Ve({type:n,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0}),n})();class nZ{constructor(){this.$implicit=null,this.ngIf=null}}function b2(n,t){if(t&&!t.createEmbeddedView)throw new Error(`${n} must be a TemplateRef, but received '${Jt(t)}'.`)}class NC{constructor(t,e){this._viewContainerRef=t,this._templateRef=e,this._created=!1}create(){this._created=!0,this._viewContainerRef.createEmbeddedView(this._templateRef)}destroy(){this._created=!1,this._viewContainerRef.clear()}enforceState(t){t&&!this._created?this.create():!t&&this._created&&this.destroy()}}let sy=(()=>{class n{constructor(){this._defaultUsed=!1,this._caseCount=0,this._lastCaseCheckIndex=0,this._lastCasesMatched=!1}set ngSwitch(e){this._ngSwitch=e,0===this._caseCount&&this._updateDefaultCases(!0)}_addCase(){return this._caseCount++}_addDefault(e){this._defaultViews||(this._defaultViews=[]),this._defaultViews.push(e)}_matchCase(e){const r=e==this._ngSwitch;return this._lastCasesMatched=this._lastCasesMatched||r,this._lastCaseCheckIndex++,this._lastCaseCheckIndex===this._caseCount&&(this._updateDefaultCases(!this._lastCasesMatched),this._lastCaseCheckIndex=0,this._lastCasesMatched=!1),r}_updateDefaultCases(e){if(this._defaultViews&&e!==this._defaultUsed){this._defaultUsed=e;for(let r=0;r<this._defaultViews.length;r++)this._defaultViews[r].enforceState(e)}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=Ve({type:n,selectors:[["","ngSwitch",""]],inputs:{ngSwitch:"ngSwitch"},standalone:!0}),n})(),_2=(()=>{class n{constructor(e,r,s){this.ngSwitch=s,s._addCase(),this._view=new NC(e,r)}ngDoCheck(){this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))}}return n.\u0275fac=function(e){return new(e||n)(K(_i),K(Co),K(sy,9))},n.\u0275dir=Ve({type:n,selectors:[["","ngSwitchCase",""]],inputs:{ngSwitchCase:"ngSwitchCase"},standalone:!0}),n})(),v2=(()=>{class n{constructor(e,r,s){s._addDefault(new NC(e,r))}}return n.\u0275fac=function(e){return new(e||n)(K(_i),K(Co),K(sy,9))},n.\u0275dir=Ve({type:n,selectors:[["","ngSwitchDefault",""]],standalone:!0}),n})(),w2=(()=>{class n{constructor(e,r,s){this._ngEl=e,this._differs=r,this._renderer=s,this._ngStyle=null,this._differ=null}set ngStyle(e){this._ngStyle=e,!this._differ&&e&&(this._differ=this._differs.find(e).create())}ngDoCheck(){if(this._differ){const e=this._differ.diff(this._ngStyle);e&&this._applyChanges(e)}}_setStyle(e,r){const[s,i]=e.split("."),o=-1===s.indexOf("-")?void 0:ws.DashCase;null!=r?this._renderer.setStyle(this._ngEl.nativeElement,s,i?`${r}${i}`:r,o):this._renderer.removeStyle(this._ngEl.nativeElement,s,o)}_applyChanges(e){e.forEachRemovedItem(r=>this._setStyle(r.key,null)),e.forEachAddedItem(r=>this._setStyle(r.key,r.currentValue)),e.forEachChangedItem(r=>this._setStyle(r.key,r.currentValue))}}return n.\u0275fac=function(e){return new(e||n)(K(Cn),K(Xh),K(Jo))},n.\u0275dir=Ve({type:n,selectors:[["","ngStyle",""]],inputs:{ngStyle:"ngStyle"},standalone:!0}),n})(),C2=(()=>{class n{constructor(e){this._viewContainerRef=e,this._viewRef=null,this.ngTemplateOutletContext=null,this.ngTemplateOutlet=null,this.ngTemplateOutletInjector=null}ngOnChanges(e){if(e.ngTemplateOutlet||e.ngTemplateOutletInjector){const r=this._viewContainerRef;if(this._viewRef&&r.remove(r.indexOf(this._viewRef)),this.ngTemplateOutlet){const{ngTemplateOutlet:s,ngTemplateOutletContext:i,ngTemplateOutletInjector:o}=this;this._viewRef=r.createEmbeddedView(s,i,o?{injector:o}:void 0)}else this._viewRef=null}else this._viewRef&&e.ngTemplateOutletContext&&this.ngTemplateOutletContext&&(this._viewRef.context=this.ngTemplateOutletContext)}}return n.\u0275fac=function(e){return new(e||n)(K(_i))},n.\u0275dir=Ve({type:n,selectors:[["","ngTemplateOutlet",""]],inputs:{ngTemplateOutletContext:"ngTemplateOutletContext",ngTemplateOutlet:"ngTemplateOutlet",ngTemplateOutletInjector:"ngTemplateOutletInjector"},standalone:!0,features:[xs]}),n})(),S2=(()=>{class n{constructor(e){this.differs=e,this.keyValues=[],this.compareFn=E2}transform(e,r=E2){if(!e||!(e instanceof Map)&&"object"!=typeof e)return null;this.differ||(this.differ=this.differs.find(e).create());const s=this.differ.diff(e),i=r!==this.compareFn;return s&&(this.keyValues=[],s.forEachItem(o=>{this.keyValues.push(function xZ(n,t){return{key:n,value:t}}(o.key,o.currentValue))})),(s||i)&&(this.keyValues.sort(r),this.compareFn=r),this.keyValues}}return n.\u0275fac=function(e){return new(e||n)(K(Xh,16))},n.\u0275pipe=_s({name:"keyvalue",type:n,pure:!1,standalone:!0}),n})();function E2(n,t){const e=n.key,r=t.key;if(e===r)return 0;if(void 0===e)return 1;if(void 0===r)return-1;if(null===e)return 1;if(null===r)return-1;if("string"==typeof e&&"string"==typeof r)return e<r?-1:1;if("number"==typeof e&&"number"==typeof r)return e-r;if("boolean"==typeof e&&"boolean"==typeof r)return e<r?-1:1;const s=String(e),i=String(r);return s==i?0:s<i?-1:1}let Ru=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({}),n})();const I2="browser";let NZ=(()=>{class n{}return n.\u0275prov=Ce({token:n,providedIn:"root",factory:()=>new AZ(J(Et),window)}),n})();class AZ{constructor(t,e){this.document=t,this.window=e,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(t){this.supportsScrolling()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){if(!this.supportsScrolling())return;const e=function RZ(n,t){const e=n.getElementById(t)||n.getElementsByName(t)[0];if(e)return e;if("function"==typeof n.createTreeWalker&&n.body&&(n.body.createShadowRoot||n.body.attachShadow)){const r=n.createTreeWalker(n.body,NodeFilter.SHOW_ELEMENT);let s=r.currentNode;for(;s;){const i=s.shadowRoot;if(i){const o=i.getElementById(t)||i.querySelector(`[name="${t}"]`);if(o)return o}s=r.nextNode()}}return null}(this.document,t);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),r=e.left+this.window.pageXOffset,s=e.top+this.window.pageYOffset,i=this.offset();this.window.scrollTo(r-i[0],s-i[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const t=D2(this.window.history)||D2(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&&!t.set)}catch{return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch{return!1}}}function D2(n){return Object.getOwnPropertyDescriptor(n,"scrollRestoration")}class oQ extends c9{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class OC extends oQ{static makeCurrent(){!function l9(n){qg||(qg=n)}(new OC)}onAndCancel(t,e,r){return t.addEventListener(e,r,!1),()=>{t.removeEventListener(e,r,!1)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){t.parentNode&&t.parentNode.removeChild(t)}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getBaseHref(t){const e=function aQ(){return Jh=Jh||document.querySelector("base"),Jh?Jh.getAttribute("href"):null}();return null==e?null:function lQ(n){oy=oy||document.createElement("a"),oy.setAttribute("href",n);const t=oy.pathname;return"/"===t.charAt(0)?t:`/${t}`}(e)}resetBaseElement(){Jh=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return function Q9(n,t){t=encodeURIComponent(t);for(const e of n.split(";")){const r=e.indexOf("="),[s,i]=-1==r?[e,""]:[e.slice(0,r),e.slice(r+1)];if(s.trim()===t)return decodeURIComponent(i)}return null}(document.cookie,t)}}let oy,Jh=null;const M2=new me("TRANSITION_ID"),uQ=[{provide:Bg,useFactory:function cQ(n,t,e){return()=>{e.get(zg).donePromise.then(()=>{const r=Eo(),s=t.querySelectorAll(`style[ng-transition="${n}"]`);for(let i=0;i<s.length;i++)r.remove(s[i])})}},deps:[M2,Et,os],multi:!0}];let hQ=(()=>{class n{build(){return new XMLHttpRequest}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:n.\u0275fac}),n})();const ay=new me("EventManagerPlugins");let ly=(()=>{class n{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(s=>s.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,r,s){return this._findPluginFor(r).addEventListener(e,r,s)}addGlobalEventListener(e,r,s){return this._findPluginFor(r).addGlobalEventListener(e,r,s)}getZone(){return this._zone}_findPluginFor(e){const r=this._eventNameToPlugin.get(e);if(r)return r;const s=this._plugins;for(let i=0;i<s.length;i++){const o=s[i];if(o.supports(e))return this._eventNameToPlugin.set(e,o),o}throw new Error(`No event manager plugin found for event ${e}`)}}return n.\u0275fac=function(e){return new(e||n)(J(ay),J(St))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac}),n})();class F2{constructor(t){this._doc=t}addGlobalEventListener(t,e,r){const s=Eo().getGlobalEventTarget(this._doc,t);if(!s)throw new Error(`Unsupported event target ${s} for event ${e}`);return this.addEventListener(s,e,r)}}let O2=(()=>{class n{constructor(){this._stylesSet=new Set}addStyles(e){const r=new Set;e.forEach(s=>{this._stylesSet.has(s)||(this._stylesSet.add(s),r.add(s))}),this.onStylesAdded(r)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:n.\u0275fac}),n})(),ef=(()=>{class n extends O2{constructor(e){super(),this._doc=e,this._hostNodes=new Map,this._hostNodes.set(e.head,[])}_addStylesToHost(e,r,s){e.forEach(i=>{const o=this._doc.createElement("style");o.textContent=i,s.push(r.appendChild(o))})}addHost(e){const r=[];this._addStylesToHost(this._stylesSet,e,r),this._hostNodes.set(e,r)}removeHost(e){const r=this._hostNodes.get(e);r&&r.forEach($2),this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach((r,s)=>{this._addStylesToHost(e,s,r)})}ngOnDestroy(){this._hostNodes.forEach(e=>e.forEach($2))}}return n.\u0275fac=function(e){return new(e||n)(J(Et))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac}),n})();function $2(n){Eo().remove(n)}const $C={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},PC=/%COMP%/g;function cy(n,t,e){for(let r=0;r<t.length;r++){let s=t[r];Array.isArray(s)?cy(n,s,e):(s=s.replace(PC,n),e.push(s))}return e}function V2(n){return t=>{if("__ngUnwrap__"===t)return n;!1===n(t)&&(t.preventDefault(),t.returnValue=!1)}}let uy=(()=>{class n{constructor(e,r,s){this.eventManager=e,this.sharedStylesHost=r,this.appId=s,this.rendererByCompId=new Map,this.defaultRenderer=new LC(e)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;switch(r.encapsulation){case Wi.Emulated:{let s=this.rendererByCompId.get(r.id);return s||(s=new bQ(this.eventManager,this.sharedStylesHost,r,this.appId),this.rendererByCompId.set(r.id,s)),s.applyToHost(e),s}case 1:case Wi.ShadowDom:return new _Q(this.eventManager,this.sharedStylesHost,e,r);default:if(!this.rendererByCompId.has(r.id)){const s=cy(r.id,r.styles,[]);this.sharedStylesHost.addStyles(s),this.rendererByCompId.set(r.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return n.\u0275fac=function(e){return new(e||n)(J(ly),J(ef),J(Kh))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac}),n})();class LC{constructor(t){this.eventManager=t,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(t,e){return e?document.createElementNS($C[e]||e,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,e){(z2(t)?t.content:t).appendChild(e)}insertBefore(t,e,r){t&&(z2(t)?t.content:t).insertBefore(e,r)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let r="string"==typeof t?document.querySelector(t):t;if(!r)throw new Error(`The selector "${t}" did not match any elements`);return e||(r.textContent=""),r}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,r,s){if(s){e=s+":"+e;const i=$C[s];i?t.setAttributeNS(i,e,r):t.setAttribute(e,r)}else t.setAttribute(e,r)}removeAttribute(t,e,r){if(r){const s=$C[r];s?t.removeAttributeNS(s,e):t.removeAttribute(`${r}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,r,s){s&(ws.DashCase|ws.Important)?t.style.setProperty(e,r,s&ws.Important?"important":""):t.style[e]=r}removeStyle(t,e,r){r&ws.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,r){t[e]=r}setValue(t,e){t.nodeValue=e}listen(t,e,r){return"string"==typeof t?this.eventManager.addGlobalEventListener(t,e,V2(r)):this.eventManager.addEventListener(t,e,V2(r))}}function z2(n){return"TEMPLATE"===n.tagName&&void 0!==n.content}class bQ extends LC{constructor(t,e,r,s){super(t),this.component=r;const i=cy(s+"-"+r.id,r.styles,[]);e.addStyles(i),this.contentAttr=function mQ(n){return"_ngcontent-%COMP%".replace(PC,n)}(s+"-"+r.id),this.hostAttr=function gQ(n){return"_nghost-%COMP%".replace(PC,n)}(s+"-"+r.id)}applyToHost(t){super.setAttribute(t,this.hostAttr,"")}createElement(t,e){const r=super.createElement(t,e);return super.setAttribute(r,this.contentAttr,""),r}}class _Q extends LC{constructor(t,e,r,s){super(t),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const i=cy(s.id,s.styles,[]);for(let o=0;o<i.length;o++){const a=document.createElement("style");a.textContent=i[o],this.shadowRoot.appendChild(a)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,r){return super.insertBefore(this.nodeOrShadowRoot(t),e,r)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}}let vQ=(()=>{class n extends F2{constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,s){return e.addEventListener(r,s,!1),()=>this.removeEventListener(e,r,s)}removeEventListener(e,r,s){return e.removeEventListener(r,s)}}return n.\u0275fac=function(e){return new(e||n)(J(Et))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac}),n})();const U2=["alt","control","meta","shift"],xQ={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},wQ={alt:n=>n.altKey,control:n=>n.ctrlKey,meta:n=>n.metaKey,shift:n=>n.shiftKey};let CQ=(()=>{class n extends F2{constructor(e){super(e)}supports(e){return null!=n.parseEventName(e)}addEventListener(e,r,s){const i=n.parseEventName(r),o=n.eventCallback(i.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Eo().onAndCancel(e,i.domEventName,o))}static parseEventName(e){const r=e.toLowerCase().split("."),s=r.shift();if(0===r.length||"keydown"!==s&&"keyup"!==s)return null;const i=n._normalizeKey(r.pop());let o="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),o="code."),U2.forEach(c=>{const u=r.indexOf(c);u>-1&&(r.splice(u,1),o+=c+".")}),o+=i,0!=r.length||0===i.length)return null;const l={};return l.domEventName=s,l.fullKey=o,l}static matchEventFullKeyCode(e,r){let s=xQ[e.key]||e.key,i="";return r.indexOf("code.")>-1&&(s=e.code,i="code."),!(null==s||!s)&&(s=s.toLowerCase()," "===s?s="space":"."===s&&(s="dot"),U2.forEach(o=>{o!==s&&(0,wQ[o])(e)&&(i+=o+".")}),i+=s,i===r)}static eventCallback(e,r,s){return i=>{n.matchEventFullKeyCode(i,e)&&s.runGuarded(()=>r(i))}}static _normalizeKey(e){return"esc"===e?"escape":e}}return n.\u0275fac=function(e){return new(e||n)(J(Et))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac}),n})();const DQ=OO(i9,"browser",[{provide:sC,useValue:I2},{provide:EO,useValue:function SQ(){OC.makeCurrent()},multi:!0},{provide:Et,useFactory:function IQ(){return function Qq(n){B0=n}(document),document},deps:[]}]),j2=new me(""),G2=[{provide:Ug,useClass:class dQ{addToWindow(t){un.getAngularTestability=(r,s=!0)=>{const i=t.findTestabilityInTree(r,s);if(null==i)throw new Error("Could not find testability for element.");return i},un.getAllAngularTestabilities=()=>t.getAllTestabilities(),un.getAllAngularRootElements=()=>t.getAllRootElements(),un.frameworkStabilizers||(un.frameworkStabilizers=[]),un.frameworkStabilizers.push(r=>{const s=un.getAllAngularTestabilities();let i=s.length,o=!1;const a=function(l){o=o||l,i--,0==i&&r(o)};s.forEach(function(l){l.whenStable(a)})})}findTestabilityInTree(t,e,r){return null==e?null:t.getTestability(e)??(r?Eo().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null)}},deps:[]},{provide:AO,useClass:cC,deps:[St,uC,Ug]},{provide:cC,useClass:cC,deps:[St,uC,Ug]}],q2=[{provide:K0,useValue:"root"},{provide:ea,useFactory:function EQ(){return new ea},deps:[]},{provide:ay,useClass:vQ,multi:!0,deps:[Et,St,sC]},{provide:ay,useClass:CQ,multi:!0,deps:[Et]},{provide:uy,useClass:uy,deps:[ly,ef,Kh]},{provide:Eh,useExisting:uy},{provide:O2,useExisting:ef},{provide:ef,useClass:ef,deps:[Et]},{provide:ly,useClass:ly,deps:[ay,St]},{provide:class MZ{},useClass:hQ,deps:[]},[]];let K2=(()=>{class n{constructor(e){}static withServerTransition(e){return{ngModule:n,providers:[{provide:Kh,useValue:e.appId},{provide:M2,useExisting:Kh},uQ]}}}return n.\u0275fac=function(e){return new(e||n)(J(j2,12))},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({providers:[...q2,...G2],imports:[Ru,o9]}),n})(),X2=(()=>{class n{constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}}return n.\u0275fac=function(e){return new(e||n)(J(Et))},n.\u0275prov=Ce({token:n,factory:function(e){let r=null;return r=e?new e:function kQ(){return new X2(J(Et))}(),r},providedIn:"root"}),n})();typeof window<"u"&&window;let zC=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:function(e){let r=null;return r=e?new(e||n):J(Q2),r},providedIn:"root"}),n})(),Q2=(()=>{class n extends zC{constructor(e){super(),this._doc=e}sanitize(e,r){if(null==r)return null;switch(e){case Pt.NONE:return r;case Pt.HTML:return bo(r,"HTML")?Ws(r):ZA(this._doc,String(r)).toString();case Pt.STYLE:return bo(r,"Style")?Ws(r):r;case Pt.SCRIPT:if(bo(r,"Script"))return Ws(r);throw new Error("unsafe value used in a script context");case Pt.URL:return bo(r,"URL")?Ws(r):hg(String(r));case Pt.RESOURCE_URL:if(bo(r,"ResourceURL"))return Ws(r);throw new Error(`unsafe value used in a resource URL context (see ${Om})`);default:throw new Error(`Unexpected SecurityContext ${e} (see ${Om})`)}}bypassSecurityTrustHtml(e){return function i8(n){return new Jq(n)}(e)}bypassSecurityTrustStyle(e){return function o8(n){return new e8(n)}(e)}bypassSecurityTrustScript(e){return function a8(n){return new t8(n)}(e)}bypassSecurityTrustUrl(e){return function l8(n){return new n8(n)}(e)}bypassSecurityTrustResourceUrl(e){return function c8(n){return new r8(n)}(e)}}return n.\u0275fac=function(e){return new(e||n)(J(Et))},n.\u0275prov=Ce({token:n,factory:function(e){let r=null;return r=e?new e:function $Q(n){return new Q2(n.get(Et))}(J(os)),r},providedIn:"root"}),n})();function Oe(...n){return $n(n,Qd(n))}class wi extends Wt{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return!e.closed&&t.next(this._value),e}getValue(){const{hasError:t,thrownError:e,_value:r}=this;if(t)throw e;return this._throwIfClosed(),r}next(t){super.next(this._value=t)}}const dy=je(n=>function(){n(this),this.name="EmptyError",this.message="no elements in sequence"}),{isArray:PQ}=Array,{getPrototypeOf:LQ,prototype:VQ,keys:BQ}=Object;function J2(n){if(1===n.length){const t=n[0];if(PQ(t))return{args:t,keys:null};if(function zQ(n){return n&&"object"==typeof n&&LQ(n)===VQ}(t)){const e=BQ(t);return{args:e.map(r=>t[r]),keys:e}}}return{args:n,keys:null}}const{isArray:UQ}=Array;function UC(n){return ze(t=>function HQ(n,t){return UQ(t)?n(...t):n(t)}(n,t))}function e$(n,t){return n.reduce((e,r,s)=>(e[r]=t[s],e),{})}function HC(...n){const t=Qd(n),e=aN(n),{args:r,keys:s}=J2(n);if(0===r.length)return $n([],t);const i=new xn(function WQ(n,t,e=Aa){return r=>{t$(t,()=>{const{length:s}=n,i=new Array(s);let o=s,a=s;for(let l=0;l<s;l++)t$(t,()=>{const c=$n(n[l],t);let u=!1;c.subscribe(ln(r,d=>{i[l]=d,u||(u=!0,a--),a||r.next(e(i.slice()))},()=>{--o||r.complete()}))},r)},r)}}(r,t,s?o=>e$(s,o):Aa));return e?i.pipe(UC(e)):i}function t$(n,t,e){n?jo(e,n,t):t()}function hy(...n){return function jQ(){return zc(1)}()($n(n,Qd(n)))}function fy(n){return new xn(t=>{Vr(n()).subscribe(t)})}function Mu(n,t){const e=ae(n)?n:()=>n,r=s=>s.error(e());return new xn(t?s=>t.schedule(r,0,s):r)}function WC(){return Dn((n,t)=>{let e=null;n._refCount++;const r=ln(t,void 0,void 0,void 0,()=>{if(!n||n._refCount<=0||0<--n._refCount)return void(e=null);const s=n._connection,i=e;e=null,s&&(!i||s===i)&&s.unsubscribe(),t.unsubscribe()});n.subscribe(r),r.closed||(e=n.connect())})}class n$ extends xn{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,qk(t)&&(this.lift=t.lift)}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return(!t||t.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:t}=this;this._subject=this._connection=null,t?.unsubscribe()}connect(){let t=this._connection;if(!t){t=this._connection=new He;const e=this.getSubject();t.add(this.source.subscribe(ln(e,void 0,()=>{this._teardown(),e.complete()},r=>{this._teardown(),e.error(r)},()=>this._teardown()))),t.closed&&(this._connection=null,t=He.EMPTY)}return t}refCount(){return WC()(this)}}function Xs(n,t){return Dn((e,r)=>{let s=null,i=0,o=!1;const a=()=>o&&!s&&r.complete();e.subscribe(ln(r,l=>{s?.unsubscribe();let c=0;const u=i++;Vr(n(l,u)).subscribe(s=ln(r,d=>r.next(t?t(l,d,u,c++):d),()=>{s=null,a()}))},()=>{o=!0,a()}))})}function no(n){return n<=0?()=>Go:Dn((t,e)=>{let r=0;t.subscribe(ln(e,s=>{++r<=n&&(e.next(s),n<=r&&e.complete())}))})}function py(...n){const t=Qd(n);return Dn((e,r)=>{(t?hy(n,e,t):hy(n,e)).subscribe(r)})}function Ss(n,t){return Dn((e,r)=>{let s=0;e.subscribe(ln(r,i=>n.call(t,i,s++)&&r.next(i)))})}function my(n){return Dn((t,e)=>{let r=!1;t.subscribe(ln(e,s=>{r=!0,e.next(s)},()=>{r||e.next(n),e.complete()}))})}function r$(n=GQ){return Dn((t,e)=>{let r=!1;t.subscribe(ln(e,s=>{r=!0,e.next(s)},()=>r?e.complete():e.error(n())))})}function GQ(){return new dy}function Ua(n,t){const e=arguments.length>=2;return r=>r.pipe(n?Ss((s,i)=>n(s,i,r)):Aa,no(1),e?my(t):r$(()=>new dy))}function Ha(n,t){return ae(t)?Er(n,t,1):Er(n,1)}function tr(n,t,e){const r=ae(n)||t||e?{next:n,error:t,complete:e}:n;return r?Dn((s,i)=>{var o;null===(o=r.subscribe)||void 0===o||o.call(r);let a=!0;s.subscribe(ln(i,l=>{var c;null===(c=r.next)||void 0===c||c.call(r,l),i.next(l)},()=>{var l;a=!1,null===(l=r.complete)||void 0===l||l.call(r),i.complete()},l=>{var c;a=!1,null===(c=r.error)||void 0===c||c.call(r,l),i.error(l)},()=>{var l,c;a&&(null===(l=r.unsubscribe)||void 0===l||l.call(r)),null===(c=r.finalize)||void 0===c||c.call(r)}))}):Aa}function ca(n){return Dn((t,e)=>{let i,r=null,s=!1;r=t.subscribe(ln(e,void 0,void 0,o=>{i=Vr(n(o,ca(n)(t))),r?(r.unsubscribe(),r=null,i.subscribe(e)):s=!0})),s&&(r.unsubscribe(),r=null,i.subscribe(e))})}function qQ(n,t,e,r,s){return(i,o)=>{let a=e,l=t,c=0;i.subscribe(ln(o,u=>{const d=c++;l=a?n(l,u,d):(a=!0,u),r&&o.next(l)},s&&(()=>{a&&o.next(l),o.complete()})))}}function s$(n,t){return Dn(qQ(n,t,arguments.length>=2,!0))}function jC(n){return n<=0?()=>Go:Dn((t,e)=>{let r=[];t.subscribe(ln(e,s=>{r.push(s),n<r.length&&r.shift()},()=>{for(const s of r)e.next(s);e.complete()},void 0,()=>{r=null}))})}function i$(n,t){const e=arguments.length>=2;return r=>r.pipe(n?Ss((s,i)=>n(s,i,r)):Aa,jC(1),e?my(t):r$(()=>new dy))}function o$(n,t=!1){return Dn((e,r)=>{let s=0;e.subscribe(ln(r,i=>{const o=n(i,s++);(o||t)&&r.next(i),!o&&r.complete()}))})}function gy(n){return Dn((t,e)=>{try{t.subscribe(e)}finally{e.add(n)}})}const ft="primary",nf=Symbol("RouteTitle");class XQ{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function Fu(n){return new XQ(n)}function YQ(n,t,e){const r=e.path.split("/");if(r.length>n.length||"full"===e.pathMatch&&(t.hasChildren()||r.length<n.length))return null;const s={};for(let i=0;i<r.length;i++){const o=r[i],a=n[i];if(o.startsWith(":"))s[o.substring(1)]=a;else if(o!==a.path)return null}return{consumed:n.slice(0,r.length),posParams:s}}function Io(n,t){const e=n?Object.keys(n):void 0,r=t?Object.keys(t):void 0;if(!e||!r||e.length!=r.length)return!1;let s;for(let i=0;i<e.length;i++)if(s=e[i],!a$(n[s],t[s]))return!1;return!0}function a$(n,t){if(Array.isArray(n)&&Array.isArray(t)){if(n.length!==t.length)return!1;const e=[...n].sort(),r=[...t].sort();return e.every((s,i)=>r[i]===s)}return n===t}function l$(n){return Array.prototype.concat.apply([],n)}function c$(n){return n.length>0?n[n.length-1]:null}function Or(n,t){for(const e in n)n.hasOwnProperty(e)&&t(n[e],e)}function Wa(n){return Fw(n)?n:Fh(n)?$n(Promise.resolve(n)):Oe(n)}const yy=!1,QQ={exact:function h$(n,t,e){if(!tc(n.segments,t.segments)||!by(n.segments,t.segments,e)||n.numberOfChildren!==t.numberOfChildren)return!1;for(const r in t.children)if(!n.children[r]||!h$(n.children[r],t.children[r],e))return!1;return!0},subset:f$},u$={exact:function JQ(n,t){return Io(n,t)},subset:function eJ(n,t){return Object.keys(t).length<=Object.keys(n).length&&Object.keys(t).every(e=>a$(n[e],t[e]))},ignored:()=>!0};function d$(n,t,e){return QQ[e.paths](n.root,t.root,e.matrixParams)&&u$[e.queryParams](n.queryParams,t.queryParams)&&!("exact"===e.fragment&&n.fragment!==t.fragment)}function f$(n,t,e){return p$(n,t,t.segments,e)}function p$(n,t,e,r){if(n.segments.length>e.length){const s=n.segments.slice(0,e.length);return!(!tc(s,e)||t.hasChildren()||!by(s,e,r))}if(n.segments.length===e.length){if(!tc(n.segments,e)||!by(n.segments,e,r))return!1;for(const s in t.children)if(!n.children[s]||!f$(n.children[s],t.children[s],r))return!1;return!0}{const s=e.slice(0,n.segments.length),i=e.slice(n.segments.length);return!!(tc(n.segments,s)&&by(n.segments,s,r)&&n.children[ft])&&p$(n.children[ft],t,i,r)}}function by(n,t,e){return t.every((r,s)=>u$[e](n[s].parameters,r.parameters))}class ec{constructor(t=new gt([],{}),e={},r=null){this.root=t,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Fu(this.queryParams)),this._queryParamMap}toString(){return rJ.serialize(this)}}class gt{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Or(e,(r,s)=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return _y(this)}}class rf{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=Fu(this.parameters)),this._parameterMap}toString(){return b$(this)}}function tc(n,t){return n.length===t.length&&n.every((e,r)=>e.path===t[r].path)}let m$=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:function(){return new GC},providedIn:"root"}),n})();class GC{parse(t){const e=new hJ(t);return new ec(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){const e=`/${sf(t.root,!0)}`,r=function oJ(n){const t=Object.keys(n).map(e=>{const r=n[e];return Array.isArray(r)?r.map(s=>`${vy(e)}=${vy(s)}`).join("&"):`${vy(e)}=${vy(r)}`}).filter(e=>!!e);return t.length?`?${t.join("&")}`:""}(t.queryParams);return`${e}${r}${"string"==typeof t.fragment?`#${function sJ(n){return encodeURI(n)}(t.fragment)}`:""}`}}const rJ=new GC;function _y(n){return n.segments.map(t=>b$(t)).join("/")}function sf(n,t){if(!n.hasChildren())return _y(n);if(t){const e=n.children[ft]?sf(n.children[ft],!1):"",r=[];return Or(n.children,(s,i)=>{i!==ft&&r.push(`${i}:${sf(s,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}{const e=function nJ(n,t){let e=[];return Or(n.children,(r,s)=>{s===ft&&(e=e.concat(t(r,s)))}),Or(n.children,(r,s)=>{s!==ft&&(e=e.concat(t(r,s)))}),e}(n,(r,s)=>s===ft?[sf(n.children[ft],!1)]:[`${s}:${sf(r,!1)}`]);return 1===Object.keys(n.children).length&&null!=n.children[ft]?`${_y(n)}/${e[0]}`:`${_y(n)}/(${e.join("//")})`}}function g$(n){return encodeURIComponent(n).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function vy(n){return g$(n).replace(/%3B/gi,";")}function qC(n){return g$(n).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function xy(n){return decodeURIComponent(n)}function y$(n){return xy(n.replace(/\+/g,"%20"))}function b$(n){return`${qC(n.path)}${function iJ(n){return Object.keys(n).map(t=>`;${qC(t)}=${qC(n[t])}`).join("")}(n.parameters)}`}const aJ=/^[^\/()?;=#]+/;function wy(n){const t=n.match(aJ);return t?t[0]:""}const lJ=/^[^=?&#]+/,uJ=/^[^&#]+/;class hJ{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new gt([],{}):new gt([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(r[ft]=new gt(t,e)),r}parseSegment(){const t=wy(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new te(4009,yy);return this.capture(t),new rf(xy(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=wy(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const s=wy(this.remaining);s&&(r=s,this.capture(r))}t[xy(e)]=xy(r)}parseQueryParam(t){const e=function cJ(n){const t=n.match(lJ);return t?t[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const o=function dJ(n){const t=n.match(uJ);return t?t[0]:""}(this.remaining);o&&(r=o,this.capture(r))}const s=y$(e),i=y$(r);if(t.hasOwnProperty(s)){let o=t[s];Array.isArray(o)||(o=[o],t[s]=o),o.push(i)}else t[s]=i}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=wy(this.remaining),s=this.remaining[r.length];if("/"!==s&&")"!==s&&";"!==s)throw new te(4010,yy);let i;r.indexOf(":")>-1?(i=r.slice(0,r.indexOf(":")),this.capture(i),this.capture(":")):t&&(i=ft);const o=this.parseChildren();e[i]=1===Object.keys(o).length?o[ft]:new gt([],o),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new te(4011,yy)}}function KC(n){return n.segments.length>0?new gt([],{[ft]:n}):n}function Cy(n){const t={};for(const r of Object.keys(n.children)){const i=Cy(n.children[r]);(i.segments.length>0||i.hasChildren())&&(t[r]=i)}return function fJ(n){if(1===n.numberOfChildren&&n.children[ft]){const t=n.children[ft];return new gt(n.segments.concat(t.segments),t.children)}return n}(new gt(n.segments,t))}function nc(n){return n instanceof ec}function gJ(n,t,e,r,s){if(0===e.length)return Ou(t.root,t.root,t.root,r,s);const i=function x$(n){if("string"==typeof n[0]&&1===n.length&&"/"===n[0])return new v$(!0,0,n);let t=0,e=!1;const r=n.reduce((s,i,o)=>{if("object"==typeof i&&null!=i){if(i.outlets){const a={};return Or(i.outlets,(l,c)=>{a[c]="string"==typeof l?l.split("/"):l}),[...s,{outlets:a}]}if(i.segmentPath)return[...s,i.segmentPath]}return"string"!=typeof i?[...s,i]:0===o?(i.split("/").forEach((a,l)=>{0==l&&"."===a||(0==l&&""===a?e=!0:".."===a?t++:""!=a&&s.push(a))}),s):[...s,i]},[]);return new v$(e,t,r)}(e);return i.toRoot()?Ou(t.root,t.root,new gt([],{}),r,s):function o(l){const c=function bJ(n,t,e,r){if(n.isAbsolute)return new $u(t.root,!0,0);if(-1===r)return new $u(e,e===t.root,0);return function w$(n,t,e){let r=n,s=t,i=e;for(;i>s;){if(i-=s,r=r.parent,!r)throw new te(4005,!1);s=r.segments.length}return new $u(r,!1,s-i)}(e,r+(af(n.commands[0])?0:1),n.numberOfDoubleDots)}(i,t,n.snapshot?._urlSegment,l),u=c.processChildren?cf(c.segmentGroup,c.index,i.commands):YC(c.segmentGroup,c.index,i.commands);return Ou(t.root,c.segmentGroup,u,r,s)}(n.snapshot?._lastPathIndex)}function af(n){return"object"==typeof n&&null!=n&&!n.outlets&&!n.segmentPath}function lf(n){return"object"==typeof n&&null!=n&&n.outlets}function Ou(n,t,e,r,s){let o,i={};r&&Or(r,(l,c)=>{i[c]=Array.isArray(l)?l.map(u=>`${u}`):`${l}`}),o=n===t?e:_$(n,t,e);const a=KC(Cy(o));return new ec(a,i,s)}function _$(n,t,e){const r={};return Or(n.children,(s,i)=>{r[i]=s===t?e:_$(s,t,e)}),new gt(n.segments,r)}class v${constructor(t,e,r){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=r,t&&r.length>0&&af(r[0]))throw new te(4003,!1);const s=r.find(lf);if(s&&s!==c$(r))throw new te(4004,!1)}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class $u{constructor(t,e,r){this.segmentGroup=t,this.processChildren=e,this.index=r}}function YC(n,t,e){if(n||(n=new gt([],{})),0===n.segments.length&&n.hasChildren())return cf(n,t,e);const r=function vJ(n,t,e){let r=0,s=t;const i={match:!1,pathIndex:0,commandIndex:0};for(;s<n.segments.length;){if(r>=e.length)return i;const o=n.segments[s],a=e[r];if(lf(a))break;const l=`${a}`,c=r<e.length-1?e[r+1]:null;if(s>0&&void 0===l)break;if(l&&c&&"object"==typeof c&&void 0===c.outlets){if(!S$(l,c,o))return i;r+=2}else{if(!S$(l,{},o))return i;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(n,t,e),s=e.slice(r.commandIndex);if(r.match&&r.pathIndex<n.segments.length){const i=new gt(n.segments.slice(0,r.pathIndex),{});return i.children[ft]=new gt(n.segments.slice(r.pathIndex),n.children),cf(i,0,s)}return r.match&&0===s.length?new gt(n.segments,{}):r.match&&!n.hasChildren()?ZC(n,t,e):r.match?cf(n,0,s):ZC(n,t,e)}function cf(n,t,e){if(0===e.length)return new gt(n.segments,{});{const r=function _J(n){return lf(n[0])?n[0].outlets:{[ft]:n}}(e),s={};return Or(r,(i,o)=>{"string"==typeof i&&(i=[i]),null!==i&&(s[o]=YC(n.children[o],t,i))}),Or(n.children,(i,o)=>{void 0===r[o]&&(s[o]=i)}),new gt(n.segments,s)}}function ZC(n,t,e){const r=n.segments.slice(0,t);let s=0;for(;s<e.length;){const i=e[s];if(lf(i)){const l=xJ(i.outlets);return new gt(r,l)}if(0===s&&af(e[0])){r.push(new rf(n.segments[t].path,C$(e[0]))),s++;continue}const o=lf(i)?i.outlets[ft]:`${i}`,a=s<e.length-1?e[s+1]:null;o&&a&&af(a)?(r.push(new rf(o,C$(a))),s+=2):(r.push(new rf(o,{})),s++)}return new gt(r,{})}function xJ(n){const t={};return Or(n,(e,r)=>{"string"==typeof e&&(e=[e]),null!==e&&(t[r]=ZC(new gt([],{}),0,e))}),t}function C$(n){const t={};return Or(n,(e,r)=>t[r]=`${e}`),t}function S$(n,t,e){return n==e.path&&Io(t,e.parameters)}class ua{constructor(t,e){this.id=t,this.url=e}}class QC extends ua{constructor(t,e,r="imperative",s=null){super(t,e),this.type=0,this.navigationTrigger=r,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class rc extends ua{constructor(t,e,r){super(t,e),this.urlAfterRedirects=r,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Sy extends ua{constructor(t,e,r,s){super(t,e),this.reason=r,this.code=s,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class E$ extends ua{constructor(t,e,r,s){super(t,e),this.error=r,this.target=s,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class wJ extends ua{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class CJ extends ua{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class SJ extends ua{constructor(t,e,r,s,i){super(t,e),this.urlAfterRedirects=r,this.state=s,this.shouldActivate=i,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class EJ extends ua{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class IJ extends ua{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class DJ{constructor(t){this.route=t,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class TJ{constructor(t){this.route=t,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class kJ{constructor(t){this.snapshot=t,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class NJ{constructor(t){this.snapshot=t,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class AJ{constructor(t){this.snapshot=t,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class RJ{constructor(t){this.snapshot=t,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class I${constructor(t,e,r){this.routerEvent=t,this.position=e,this.anchor=r,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class D${constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=JC(t,this._root);return e?e.children.map(r=>r.value):[]}firstChild(t){const e=JC(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=eS(t,this._root);return e.length<2?[]:e[e.length-2].children.map(s=>s.value).filter(s=>s!==t)}pathFromRoot(t){return eS(t,this._root).map(e=>e.value)}}function JC(n,t){if(n===t.value)return t;for(const e of t.children){const r=JC(n,e);if(r)return r}return null}function eS(n,t){if(n===t.value)return[t];for(const e of t.children){const r=eS(n,e);if(r.length)return r.unshift(t),r}return[]}class da{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function Pu(n){const t={};return n&&n.children.forEach(e=>t[e.value.outlet]=e),t}class T$ extends D${constructor(t,e){super(t),this.snapshot=e,tS(this,t)}toString(){return this.snapshot.toString()}}function k$(n,t){const e=function FJ(n,t){const o=new Ey([],{},{},"",{},ft,t,null,n.root,-1,{});return new A$("",new da(o,[]))}(n,t),r=new wi([new rf("",{})]),s=new wi({}),i=new wi({}),o=new wi({}),a=new wi(""),l=new Lu(r,s,o,a,i,ft,t,e.root);return l.snapshot=e.root,new T$(new da(l,[]),e)}class Lu{constructor(t,e,r,s,i,o,a,l){this.url=t,this.params=e,this.queryParams=r,this.fragment=s,this.data=i,this.outlet=o,this.component=a,this.title=this.data?.pipe(ze(c=>c[nf]))??Oe(void 0),this._futureSnapshot=l}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(ze(t=>Fu(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(ze(t=>Fu(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function N$(n,t="emptyOnly"){const e=n.pathFromRoot;let r=0;if("always"!==t)for(r=e.length-1;r>=1;){const s=e[r],i=e[r-1];if(s.routeConfig&&""===s.routeConfig.path)r--;else{if(i.component)break;r--}}return function OJ(n){return n.reduce((t,e)=>({params:{...t.params,...e.params},data:{...t.data,...e.data},resolve:{...e.data,...t.resolve,...e.routeConfig?.data,...e._resolvedData}}),{params:{},data:{},resolve:{}})}(e.slice(r))}class Ey{constructor(t,e,r,s,i,o,a,l,c,u,d){this.url=t,this.params=e,this.queryParams=r,this.fragment=s,this.data=i,this.outlet=o,this.component=a,this.routeConfig=l,this._urlSegment=c,this._lastPathIndex=u,this._resolve=d}get title(){return this.data?.[nf]}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=Fu(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Fu(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class A$ extends D${constructor(t,e){super(e),this.url=t,tS(this,e)}toString(){return R$(this._root)}}function tS(n,t){t.value._routerState=n,t.children.forEach(e=>tS(n,e))}function R$(n){const t=n.children.length>0?` { ${n.children.map(R$).join(", ")} } `:"";return`${n.value}${t}`}function nS(n){if(n.snapshot){const t=n.snapshot,e=n._futureSnapshot;n.snapshot=e,Io(t.queryParams,e.queryParams)||n.queryParams.next(e.queryParams),t.fragment!==e.fragment&&n.fragment.next(e.fragment),Io(t.params,e.params)||n.params.next(e.params),function ZQ(n,t){if(n.length!==t.length)return!1;for(let e=0;e<n.length;++e)if(!Io(n[e],t[e]))return!1;return!0}(t.url,e.url)||n.url.next(e.url),Io(t.data,e.data)||n.data.next(e.data)}else n.snapshot=n._futureSnapshot,n.data.next(n._futureSnapshot.data)}function rS(n,t){const e=Io(n.params,t.params)&&function tJ(n,t){return tc(n,t)&&n.every((e,r)=>Io(e.parameters,t[r].parameters))}(n.url,t.url);return e&&!(!n.parent!=!t.parent)&&(!n.parent||rS(n.parent,t.parent))}function uf(n,t,e){if(e&&n.shouldReuseRoute(t.value,e.value.snapshot)){const r=e.value;r._futureSnapshot=t.value;const s=function PJ(n,t,e){return t.children.map(r=>{for(const s of e.children)if(n.shouldReuseRoute(r.value,s.value.snapshot))return uf(n,r,s);return uf(n,r)})}(n,t,e);return new da(r,s)}{if(n.shouldAttach(t.value)){const i=n.retrieve(t.value);if(null!==i){const o=i.route;return o.value._futureSnapshot=t.value,o.children=t.children.map(a=>uf(n,a)),o}}const r=function LJ(n){return new Lu(new wi(n.url),new wi(n.params),new wi(n.queryParams),new wi(n.fragment),new wi(n.data),n.outlet,n.component,n)}(t.value),s=t.children.map(i=>uf(n,i));return new da(r,s)}}const sS="ngNavigationCancelingError";function M$(n,t){const{redirectTo:e,navigationBehaviorOptions:r}=nc(t)?{redirectTo:t,navigationBehaviorOptions:void 0}:t,s=F$(!1,0,t);return s.url=e,s.navigationBehaviorOptions=r,s}function F$(n,t,e){const r=new Error("NavigationCancelingError: "+(n||""));return r[sS]=!0,r.cancellationCode=t,e&&(r.url=e),r}function O$(n){return $$(n)&&nc(n.url)}function $$(n){return n&&n[sS]}class VJ{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.injector=null,this.children=new df,this.attachRef=null}}let df=(()=>{class n{constructor(){this.contexts=new Map}onChildOutletCreated(e,r){const s=this.getOrCreateContext(e);s.outlet=r,this.contexts.set(e,s)}onChildOutletDestroyed(e){const r=this.getContext(e);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let r=this.getContext(e);return r||(r=new VJ,this.contexts.set(e,r)),r}getContext(e){return this.contexts.get(e)||null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const Iy=!1;let P$=(()=>{class n{constructor(){this.activated=null,this._activatedRoute=null,this.name=ft,this.activateEvents=new Ft,this.deactivateEvents=new Ft,this.attachEvents=new Ft,this.detachEvents=new Ft,this.parentContexts=Mt(df),this.location=Mt(_i),this.changeDetector=Mt(Nu),this.environmentInjector=Mt($a)}ngOnChanges(e){if(e.name){const{firstChange:r,previousValue:s}=e.name;if(r)return;this.isTrackedInParentContexts(s)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(s)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new te(4012,Iy);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new te(4012,Iy);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new te(4012,Iy);this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new te(4013,Iy);this._activatedRoute=e;const s=this.location,o=e.snapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,l=new BJ(e,a,s.injector);if(r&&function zJ(n){return!!n.resolveComponentFactory}(r)){const c=r.resolveComponentFactory(o);this.activated=s.createComponent(c,s.length,l)}else this.activated=s.createComponent(o,{index:s.length,injector:l,environmentInjector:r??this.environmentInjector});this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=Ve({type:n,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[xs]}),n})();class BJ{constructor(t,e,r){this.route=t,this.childContexts=e,this.parent=r}get(t,e){return t===Lu?this.route:t===df?this.childContexts:this.parent.get(t,e)}}let iS=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=pi({type:n,selectors:[["ng-component"]],standalone:!0,features:[$F],decls:1,vars:0,template:function(e,r){1&e&&as(0,"router-outlet")},dependencies:[P$],encapsulation:2}),n})();function L$(n,t){return n.providers&&!n._injector&&(n._injector=$g(n.providers,t,`Route: ${n.path}`)),n._injector??t}function aS(n){const t=n.children&&n.children.map(aS),e=t?{...n,children:t}:{...n};return!e.component&&!e.loadComponent&&(t||e.loadChildren)&&e.outlet&&e.outlet!==ft&&(e.component=iS),e}function Ci(n){return n.outlet||ft}function V$(n,t){const e=n.filter(r=>Ci(r)===t);return e.push(...n.filter(r=>Ci(r)!==t)),e}function hf(n){if(!n)return null;if(n.routeConfig?._injector)return n.routeConfig._injector;for(let t=n.parent;t;t=t.parent){const e=t.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}class GJ{constructor(t,e,r,s){this.routeReuseStrategy=t,this.futureState=e,this.currState=r,this.forwardEvent=s}activate(t){const e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,t),nS(this.futureState.root),this.activateChildRoutes(e,r,t)}deactivateChildRoutes(t,e,r){const s=Pu(e);t.children.forEach(i=>{const o=i.value.outlet;this.deactivateRoutes(i,s[o],r),delete s[o]}),Or(s,(i,o)=>{this.deactivateRouteAndItsChildren(i,r)})}deactivateRoutes(t,e,r){const s=t.value,i=e?e.value:null;if(s===i)if(s.component){const o=r.getContext(s.outlet);o&&this.deactivateChildRoutes(t,e,o.children)}else this.deactivateChildRoutes(t,e,r);else i&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(t,e){t.value.component&&this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const r=e.getContext(t.value.outlet),s=r&&t.value.component?r.children:e,i=Pu(t);for(const o of Object.keys(i))this.deactivateRouteAndItsChildren(i[o],s);if(r&&r.outlet){const o=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:o,route:t,contexts:a})}}deactivateRouteAndOutlet(t,e){const r=e.getContext(t.value.outlet),s=r&&t.value.component?r.children:e,i=Pu(t);for(const o of Object.keys(i))this.deactivateRouteAndItsChildren(i[o],s);r&&r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated(),r.attachRef=null,r.resolver=null,r.route=null)}activateChildRoutes(t,e,r){const s=Pu(e);t.children.forEach(i=>{this.activateRoutes(i,s[i.value.outlet],r),this.forwardEvent(new RJ(i.value.snapshot))}),t.children.length&&this.forwardEvent(new NJ(t.value.snapshot))}activateRoutes(t,e,r){const s=t.value,i=e?e.value:null;if(nS(s),s===i)if(s.component){const o=r.getOrCreateContext(s.outlet);this.activateChildRoutes(t,e,o.children)}else this.activateChildRoutes(t,e,r);else if(s.component){const o=r.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const a=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),o.children.onOutletReAttached(a.contexts),o.attachRef=a.componentRef,o.route=a.route.value,o.outlet&&o.outlet.attach(a.componentRef,a.route.value),nS(a.route.value),this.activateChildRoutes(t,null,o.children)}else{const a=hf(s.snapshot),l=a?.get(cu)??null;o.attachRef=null,o.route=s,o.resolver=l,o.injector=a,o.outlet&&o.outlet.activateWith(s,o.injector),this.activateChildRoutes(t,null,o.children)}}else this.activateChildRoutes(t,null,r)}}class B${constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class Dy{constructor(t,e){this.component=t,this.route=e}}function qJ(n,t,e){const r=n._root;return ff(r,t?t._root:null,e,[r.value])}function Vu(n,t){const e=Symbol(),r=t.get(n,e);return r===e?"function"!=typeof n||function UG(n){return null!==Lm(n)}(n)?t.get(n):n:r}function ff(n,t,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const i=Pu(t);return n.children.forEach(o=>{(function XJ(n,t,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const i=n.value,o=t?t.value:null,a=e?e.getContext(n.value.outlet):null;if(o&&i.routeConfig===o.routeConfig){const l=function YJ(n,t,e){if("function"==typeof e)return e(n,t);switch(e){case"pathParamsChange":return!tc(n.url,t.url);case"pathParamsOrQueryParamsChange":return!tc(n.url,t.url)||!Io(n.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!rS(n,t)||!Io(n.queryParams,t.queryParams);default:return!rS(n,t)}}(o,i,i.routeConfig.runGuardsAndResolvers);l?s.canActivateChecks.push(new B$(r)):(i.data=o.data,i._resolvedData=o._resolvedData),ff(n,t,i.component?a?a.children:null:e,r,s),l&&a&&a.outlet&&a.outlet.isActivated&&s.canDeactivateChecks.push(new Dy(a.outlet.component,o))}else o&&pf(t,a,s),s.canActivateChecks.push(new B$(r)),ff(n,null,i.component?a?a.children:null:e,r,s)})(o,i[o.value.outlet],e,r.concat([o.value]),s),delete i[o.value.outlet]}),Or(i,(o,a)=>pf(o,e.getContext(a),s)),s}function pf(n,t,e){const r=Pu(n),s=n.value;Or(r,(i,o)=>{pf(i,s.component?t?t.children.getContext(o):null:t,e)}),e.canDeactivateChecks.push(new Dy(s.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,s))}function mf(n){return"function"==typeof n}function lS(n){return n instanceof dy||"EmptyError"===n?.name}const Ty=Symbol("INITIAL_VALUE");function Bu(){return Xs(n=>HC(n.map(t=>t.pipe(no(1),py(Ty)))).pipe(ze(t=>{for(const e of t)if(!0!==e){if(e===Ty)return Ty;if(!1===e||e instanceof ec)return e}return!0}),Ss(t=>t!==Ty),no(1)))}function z$(n){return function uG(...n){return Wk(n)}(tr(t=>{if(nc(t))throw M$(0,t)}),ze(t=>!0===t))}const cS={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function U$(n,t,e,r,s){const i=uS(n,t,e);return i.matched?function fee(n,t,e,r){const s=t.canMatch;return s&&0!==s.length?Oe(s.map(o=>{const a=Vu(o,n);return Wa(function nee(n){return n&&mf(n.canMatch)}(a)?a.canMatch(t,e):n.runInContext(()=>a(t,e)))})).pipe(Bu(),z$()):Oe(!0)}(r=L$(t,r),t,e).pipe(ze(o=>!0===o?i:{...cS})):Oe(i)}function uS(n,t,e){if(""===t.path)return"full"===t.pathMatch&&(n.hasChildren()||e.length>0)?{...cS}:{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const s=(t.matcher||YQ)(e,n,t);if(!s)return{...cS};const i={};Or(s.posParams,(a,l)=>{i[l]=a.path});const o=s.consumed.length>0?{...i,...s.consumed[s.consumed.length-1].parameters}:i;return{matched:!0,consumedSegments:s.consumed,remainingSegments:e.slice(s.consumed.length),parameters:o,positionalParamSegments:s.posParams??{}}}function ky(n,t,e,r){if(e.length>0&&function gee(n,t,e){return e.some(r=>Ny(n,t,r)&&Ci(r)!==ft)}(n,e,r)){const i=new gt(t,function mee(n,t,e,r){const s={};s[ft]=r,r._sourceSegment=n,r._segmentIndexShift=t.length;for(const i of e)if(""===i.path&&Ci(i)!==ft){const o=new gt([],{});o._sourceSegment=n,o._segmentIndexShift=t.length,s[Ci(i)]=o}return s}(n,t,r,new gt(e,n.children)));return i._sourceSegment=n,i._segmentIndexShift=t.length,{segmentGroup:i,slicedSegments:[]}}if(0===e.length&&function yee(n,t,e){return e.some(r=>Ny(n,t,r))}(n,e,r)){const i=new gt(n.segments,function pee(n,t,e,r,s){const i={};for(const o of r)if(Ny(n,e,o)&&!s[Ci(o)]){const a=new gt([],{});a._sourceSegment=n,a._segmentIndexShift=t.length,i[Ci(o)]=a}return{...s,...i}}(n,t,e,r,n.children));return i._sourceSegment=n,i._segmentIndexShift=t.length,{segmentGroup:i,slicedSegments:e}}const s=new gt(n.segments,n.children);return s._sourceSegment=n,s._segmentIndexShift=t.length,{segmentGroup:s,slicedSegments:e}}function Ny(n,t,e){return(!(n.hasChildren()||t.length>0)||"full"!==e.pathMatch)&&""===e.path}function H$(n,t,e,r){return!!(Ci(n)===r||r!==ft&&Ny(t,e,n))&&("**"===n.path||uS(t,n,e).matched)}function W$(n,t,e){return 0===t.length&&!n.children[e]}const Ay=!1;class Ry{constructor(t){this.segmentGroup=t||null}}class j${constructor(t){this.urlTree=t}}function gf(n){return Mu(new Ry(n))}function G$(n){return Mu(new j$(n))}class xee{constructor(t,e,r,s,i){this.injector=t,this.configLoader=e,this.urlSerializer=r,this.urlTree=s,this.config=i,this.allowRedirects=!0}apply(){const t=ky(this.urlTree.root,[],[],this.config).segmentGroup,e=new gt(t.segments,t.children);return this.expandSegmentGroup(this.injector,this.config,e,ft).pipe(ze(i=>this.createUrlTree(Cy(i),this.urlTree.queryParams,this.urlTree.fragment))).pipe(ca(i=>{if(i instanceof j$)return this.allowRedirects=!1,this.match(i.urlTree);throw i instanceof Ry?this.noMatchError(i):i}))}match(t){return this.expandSegmentGroup(this.injector,this.config,t.root,ft).pipe(ze(s=>this.createUrlTree(Cy(s),t.queryParams,t.fragment))).pipe(ca(s=>{throw s instanceof Ry?this.noMatchError(s):s}))}noMatchError(t){return new te(4002,Ay)}createUrlTree(t,e,r){const s=KC(t);return new ec(s,e,r)}expandSegmentGroup(t,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.expandChildren(t,e,r).pipe(ze(i=>new gt([],i))):this.expandSegment(t,r,e,r.segments,s,!0)}expandChildren(t,e,r){const s=[];for(const i of Object.keys(r.children))"primary"===i?s.unshift(i):s.push(i);return $n(s).pipe(Ha(i=>{const o=r.children[i],a=V$(e,i);return this.expandSegmentGroup(t,a,o,i).pipe(ze(l=>({segment:l,outlet:i})))}),s$((i,o)=>(i[o.outlet]=o.segment,i),{}),i$())}expandSegment(t,e,r,s,i,o){return $n(r).pipe(Ha(a=>this.expandSegmentAgainstRoute(t,e,r,a,s,i,o).pipe(ca(c=>{if(c instanceof Ry)return Oe(null);throw c}))),Ua(a=>!!a),ca((a,l)=>{if(lS(a))return W$(e,s,i)?Oe(new gt([],{})):gf(e);throw a}))}expandSegmentAgainstRoute(t,e,r,s,i,o,a){return H$(s,e,i,o)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(t,e,s,i,o):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o):gf(e):gf(e)}expandSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,r,s,o):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,r,s){const i=this.applyRedirectCommands([],r.redirectTo,{});return r.redirectTo.startsWith("/")?G$(i):this.lineralizeSegments(r,i).pipe(Er(o=>{const a=new gt(o,{});return this.expandSegment(t,a,e,o,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o){const{matched:a,consumedSegments:l,remainingSegments:c,positionalParamSegments:u}=uS(e,s,i);if(!a)return gf(e);const d=this.applyRedirectCommands(l,s.redirectTo,u);return s.redirectTo.startsWith("/")?G$(d):this.lineralizeSegments(s,d).pipe(Er(h=>this.expandSegment(t,e,r,h.concat(c),o,!1)))}matchSegmentAgainstRoute(t,e,r,s,i){return"**"===r.path?(t=L$(r,t),r.loadChildren?(r._loadedRoutes?Oe({routes:r._loadedRoutes,injector:r._loadedInjector}):this.configLoader.loadChildren(t,r)).pipe(ze(a=>(r._loadedRoutes=a.routes,r._loadedInjector=a.injector,new gt(s,{})))):Oe(new gt(s,{}))):U$(e,r,s,t).pipe(Xs(({matched:o,consumedSegments:a,remainingSegments:l})=>o?this.getChildConfig(t=r._injector??t,r,s).pipe(Er(u=>{const d=u.injector??t,h=u.routes,{segmentGroup:f,slicedSegments:p}=ky(e,a,l,h),m=new gt(f.segments,f.children);if(0===p.length&&m.hasChildren())return this.expandChildren(d,h,m).pipe(ze(_=>new gt(a,_)));if(0===h.length&&0===p.length)return Oe(new gt(a,{}));const g=Ci(r)===i;return this.expandSegment(d,m,h,p,g?ft:i,!0).pipe(ze(b=>new gt(a.concat(b.segments),b.children)))})):gf(e)))}getChildConfig(t,e,r){return e.children?Oe({routes:e.children,injector:t}):e.loadChildren?void 0!==e._loadedRoutes?Oe({routes:e._loadedRoutes,injector:e._loadedInjector}):function hee(n,t,e,r){const s=t.canLoad;return void 0===s||0===s.length?Oe(!0):Oe(s.map(o=>{const a=Vu(o,n);return Wa(function QJ(n){return n&&mf(n.canLoad)}(a)?a.canLoad(t,e):n.runInContext(()=>a(t,e)))})).pipe(Bu(),z$())}(t,e,r).pipe(Er(s=>s?this.configLoader.loadChildren(t,e).pipe(tr(i=>{e._loadedRoutes=i.routes,e._loadedInjector=i.injector})):function _ee(n){return Mu(F$(Ay,3))}())):Oe({routes:[],injector:t})}lineralizeSegments(t,e){let r=[],s=e.root;for(;;){if(r=r.concat(s.segments),0===s.numberOfChildren)return Oe(r);if(s.numberOfChildren>1||!s.children[ft])return Mu(new te(4e3,Ay));s=s.children[ft]}}applyRedirectCommands(t,e,r){return this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),t,r)}applyRedirectCreateUrlTree(t,e,r,s){const i=this.createSegmentGroup(t,e.root,r,s);return new ec(i,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const r={};return Or(t,(s,i)=>{if("string"==typeof s&&s.startsWith(":")){const a=s.substring(1);r[i]=e[a]}else r[i]=s}),r}createSegmentGroup(t,e,r,s){const i=this.createSegments(t,e.segments,r,s);let o={};return Or(e.children,(a,l)=>{o[l]=this.createSegmentGroup(t,a,r,s)}),new gt(i,o)}createSegments(t,e,r,s){return e.map(i=>i.path.startsWith(":")?this.findPosParam(t,i,s):this.findOrReturn(i,r))}findPosParam(t,e,r){const s=r[e.path.substring(1)];if(!s)throw new te(4001,Ay);return s}findOrReturn(t,e){let r=0;for(const s of e){if(s.path===t.path)return e.splice(r),s;r++}return t}}class Cee{}class Iee{constructor(t,e,r,s,i,o,a){this.injector=t,this.rootComponentType=e,this.config=r,this.urlTree=s,this.url=i,this.paramsInheritanceStrategy=o,this.urlSerializer=a}recognize(){const t=ky(this.urlTree.root,[],[],this.config.filter(e=>void 0===e.redirectTo)).segmentGroup;return this.processSegmentGroup(this.injector,this.config,t,ft).pipe(ze(e=>{if(null===e)return null;const r=new Ey([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},ft,this.rootComponentType,null,this.urlTree.root,-1,{}),s=new da(r,e),i=new A$(this.url,s);return this.inheritParamsAndData(i._root),i}))}inheritParamsAndData(t){const e=t.value,r=N$(e,this.paramsInheritanceStrategy);e.params=Object.freeze(r.params),e.data=Object.freeze(r.data),t.children.forEach(s=>this.inheritParamsAndData(s))}processSegmentGroup(t,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.processChildren(t,e,r):this.processSegment(t,e,r,r.segments,s)}processChildren(t,e,r){return $n(Object.keys(r.children)).pipe(Ha(s=>{const i=r.children[s],o=V$(e,s);return this.processSegmentGroup(t,o,i,s)}),s$((s,i)=>s&&i?(s.push(...i),s):null),o$(s=>null!==s),my(null),i$(),ze(s=>{if(null===s)return null;const i=K$(s);return function Dee(n){n.sort((t,e)=>t.value.outlet===ft?-1:e.value.outlet===ft?1:t.value.outlet.localeCompare(e.value.outlet))}(i),i}))}processSegment(t,e,r,s,i){return $n(e).pipe(Ha(o=>this.processSegmentAgainstRoute(o._injector??t,o,r,s,i)),Ua(o=>!!o),ca(o=>{if(lS(o))return W$(r,s,i)?Oe([]):Oe(null);throw o}))}processSegmentAgainstRoute(t,e,r,s,i){if(e.redirectTo||!H$(e,r,s,i))return Oe(null);let o;if("**"===e.path){const a=s.length>0?c$(s).parameters:{},l=Y$(r)+s.length;o=Oe({snapshot:new Ey(s,a,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,Z$(e),Ci(e),e.component??e._loadedComponent??null,e,X$(r),l,Q$(e)),consumedSegments:[],remainingSegments:[]})}else o=U$(r,e,s,t).pipe(ze(({matched:a,consumedSegments:l,remainingSegments:c,parameters:u})=>{if(!a)return null;const d=Y$(r)+l.length;return{snapshot:new Ey(l,u,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,Z$(e),Ci(e),e.component??e._loadedComponent??null,e,X$(r),d,Q$(e)),consumedSegments:l,remainingSegments:c}}));return o.pipe(Xs(a=>{if(null===a)return Oe(null);const{snapshot:l,consumedSegments:c,remainingSegments:u}=a;t=e._injector??t;const d=e._loadedInjector??t,h=function Tee(n){return n.children?n.children:n.loadChildren?n._loadedRoutes:[]}(e),{segmentGroup:f,slicedSegments:p}=ky(r,c,u,h.filter(g=>void 0===g.redirectTo));if(0===p.length&&f.hasChildren())return this.processChildren(d,h,f).pipe(ze(g=>null===g?null:[new da(l,g)]));if(0===h.length&&0===p.length)return Oe([new da(l,[])]);const m=Ci(e)===i;return this.processSegment(d,h,f,p,m?ft:i).pipe(ze(g=>null===g?null:[new da(l,g)]))}))}}function kee(n){const t=n.value.routeConfig;return t&&""===t.path&&void 0===t.redirectTo}function K$(n){const t=[],e=new Set;for(const r of n){if(!kee(r)){t.push(r);continue}const s=t.find(i=>r.value.routeConfig===i.value.routeConfig);void 0!==s?(s.children.push(...r.children),e.add(s)):t.push(r)}for(const r of e){const s=K$(r.children);t.push(new da(r.value,s))}return t.filter(r=>!e.has(r))}function X$(n){let t=n;for(;t._sourceSegment;)t=t._sourceSegment;return t}function Y$(n){let t=n,e=t._segmentIndexShift??0;for(;t._sourceSegment;)t=t._sourceSegment,e+=t._segmentIndexShift??0;return e-1}function Z$(n){return n.data||{}}function Q$(n){return n.resolve||{}}function J$(n){return"string"==typeof n.title||null===n.title}function dS(n){return Xs(t=>{const e=n(t);return e?$n(e).pipe(ze(()=>t)):Oe(t)})}class Pee{constructor(t){this.router=t,this.currentNavigation=null}setupNavigations(t){const e=this.router.events;return t.pipe(Ss(r=>0!==r.id),ze(r=>({...r,extractedUrl:this.router.urlHandlingStrategy.extract(r.rawUrl)})),Xs(r=>{let s=!1,i=!1;return Oe(r).pipe(tr(o=>{this.currentNavigation={id:o.id,initialUrl:o.rawUrl,extractedUrl:o.extractedUrl,trigger:o.source,extras:o.extras,previousNavigation:this.router.lastSuccessfulNavigation?{...this.router.lastSuccessfulNavigation,previousNavigation:null}:null}}),Xs(o=>{const a=this.router.browserUrlTree.toString(),l=!this.router.navigated||o.extractedUrl.toString()!==a||a!==this.router.currentUrlTree.toString();if(("reload"===this.router.onSameUrlNavigation||l)&&this.router.urlHandlingStrategy.shouldProcessUrl(o.rawUrl))return tP(o.source)&&(this.router.browserUrlTree=o.extractedUrl),Oe(o).pipe(Xs(u=>{const d=this.router.transitions.getValue();return e.next(new QC(u.id,this.router.serializeUrl(u.extractedUrl),u.source,u.restoredState)),d!==this.router.transitions.getValue()?Go:Promise.resolve(u)}),function wee(n,t,e,r){return Xs(s=>function vee(n,t,e,r,s){return new xee(n,t,e,r,s).apply()}(n,t,e,s.extractedUrl,r).pipe(ze(i=>({...s,urlAfterRedirects:i}))))}(this.router.ngModule.injector,this.router.configLoader,this.router.urlSerializer,this.router.config),tr(u=>{this.currentNavigation={...this.currentNavigation,finalUrl:u.urlAfterRedirects},r.urlAfterRedirects=u.urlAfterRedirects}),function Aee(n,t,e,r,s){return Er(i=>function Eee(n,t,e,r,s,i,o="emptyOnly"){return new Iee(n,t,e,r,s,o,i).recognize().pipe(Xs(a=>null===a?function See(n){return new xn(t=>t.error(n))}(new Cee):Oe(a)))}(n,t,e,i.urlAfterRedirects,r.serialize(i.urlAfterRedirects),r,s).pipe(ze(o=>({...i,targetSnapshot:o}))))}(this.router.ngModule.injector,this.router.rootComponentType,this.router.config,this.router.urlSerializer,this.router.paramsInheritanceStrategy),tr(u=>{if(r.targetSnapshot=u.targetSnapshot,"eager"===this.router.urlUpdateStrategy){if(!u.extras.skipLocationChange){const h=this.router.urlHandlingStrategy.merge(u.urlAfterRedirects,u.rawUrl);this.router.setBrowserUrl(h,u)}this.router.browserUrlTree=u.urlAfterRedirects}const d=new wJ(u.id,this.router.serializeUrl(u.extractedUrl),this.router.serializeUrl(u.urlAfterRedirects),u.targetSnapshot);e.next(d)}));if(l&&this.router.rawUrlTree&&this.router.urlHandlingStrategy.shouldProcessUrl(this.router.rawUrlTree)){const{id:d,extractedUrl:h,source:f,restoredState:p,extras:m}=o,g=new QC(d,this.router.serializeUrl(h),f,p);e.next(g);const y=k$(h,this.router.rootComponentType).snapshot;return Oe(r={...o,targetSnapshot:y,urlAfterRedirects:h,extras:{...m,skipLocationChange:!1,replaceUrl:!1}})}return this.router.rawUrlTree=o.rawUrl,o.resolve(null),Go}),tr(o=>{const a=new CJ(o.id,this.router.serializeUrl(o.extractedUrl),this.router.serializeUrl(o.urlAfterRedirects),o.targetSnapshot);this.router.triggerEvent(a)}),ze(o=>r={...o,guards:qJ(o.targetSnapshot,o.currentSnapshot,this.router.rootContexts)}),function see(n,t){return Er(e=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:i,canDeactivateChecks:o}}=e;return 0===o.length&&0===i.length?Oe({...e,guardsResult:!0}):function iee(n,t,e,r){return $n(n).pipe(Er(s=>function dee(n,t,e,r,s){const i=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return i&&0!==i.length?Oe(i.map(a=>{const l=hf(t)??s,c=Vu(a,l);return Wa(function tee(n){return n&&mf(n.canDeactivate)}(c)?c.canDeactivate(n,t,e,r):l.runInContext(()=>c(n,t,e,r))).pipe(Ua())})).pipe(Bu()):Oe(!0)}(s.component,s.route,e,t,r)),Ua(s=>!0!==s,!0))}(o,r,s,n).pipe(Er(a=>a&&function ZJ(n){return"boolean"==typeof n}(a)?function oee(n,t,e,r){return $n(t).pipe(Ha(s=>hy(function lee(n,t){return null!==n&&t&&t(new kJ(n)),Oe(!0)}(s.route.parent,r),function aee(n,t){return null!==n&&t&&t(new AJ(n)),Oe(!0)}(s.route,r),function uee(n,t,e){const r=t[t.length-1],i=t.slice(0,t.length-1).reverse().map(o=>function KJ(n){const t=n.routeConfig?n.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:n,guards:t}:null}(o)).filter(o=>null!==o).map(o=>fy(()=>Oe(o.guards.map(l=>{const c=hf(o.node)??e,u=Vu(l,c);return Wa(function eee(n){return n&&mf(n.canActivateChild)}(u)?u.canActivateChild(r,n):c.runInContext(()=>u(r,n))).pipe(Ua())})).pipe(Bu())));return Oe(i).pipe(Bu())}(n,s.path,e),function cee(n,t,e){const r=t.routeConfig?t.routeConfig.canActivate:null;if(!r||0===r.length)return Oe(!0);const s=r.map(i=>fy(()=>{const o=hf(t)??e,a=Vu(i,o);return Wa(function JJ(n){return n&&mf(n.canActivate)}(a)?a.canActivate(t,n):o.runInContext(()=>a(t,n))).pipe(Ua())}));return Oe(s).pipe(Bu())}(n,s.route,e))),Ua(s=>!0!==s,!0))}(r,i,n,t):Oe(a)),ze(a=>({...e,guardsResult:a})))})}(this.router.ngModule.injector,o=>this.router.triggerEvent(o)),tr(o=>{if(r.guardsResult=o.guardsResult,nc(o.guardsResult))throw M$(0,o.guardsResult);const a=new SJ(o.id,this.router.serializeUrl(o.extractedUrl),this.router.serializeUrl(o.urlAfterRedirects),o.targetSnapshot,!!o.guardsResult);this.router.triggerEvent(a)}),Ss(o=>!!o.guardsResult||(this.router.restoreHistory(o),this.router.cancelNavigationTransition(o,"",3),!1)),dS(o=>{if(o.guards.canActivateChecks.length)return Oe(o).pipe(tr(a=>{const l=new EJ(a.id,this.router.serializeUrl(a.extractedUrl),this.router.serializeUrl(a.urlAfterRedirects),a.targetSnapshot);this.router.triggerEvent(l)}),Xs(a=>{let l=!1;return Oe(a).pipe(function Ree(n,t){return Er(e=>{const{targetSnapshot:r,guards:{canActivateChecks:s}}=e;if(!s.length)return Oe(e);let i=0;return $n(s).pipe(Ha(o=>function Mee(n,t,e,r){const s=n.routeConfig,i=n._resolve;return void 0!==s?.title&&!J$(s)&&(i[nf]=s.title),function Fee(n,t,e,r){const s=function Oee(n){return[...Object.keys(n),...Object.getOwnPropertySymbols(n)]}(n);if(0===s.length)return Oe({});const i={};return $n(s).pipe(Er(o=>function $ee(n,t,e,r){const s=hf(t)??r,i=Vu(n,s);return Wa(i.resolve?i.resolve(t,e):s.runInContext(()=>i(t,e)))}(n[o],t,e,r).pipe(Ua(),tr(a=>{i[o]=a}))),jC(1),function KQ(n){return ze(()=>n)}(i),ca(o=>lS(o)?Go:Mu(o)))}(i,n,t,r).pipe(ze(o=>(n._resolvedData=o,n.data=N$(n,e).resolve,s&&J$(s)&&(n.data[nf]=s.title),null)))}(o.route,r,n,t)),tr(()=>i++),jC(1),Er(o=>i===s.length?Oe(e):Go))})}(this.router.paramsInheritanceStrategy,this.router.ngModule.injector),tr({next:()=>l=!0,complete:()=>{l||(this.router.restoreHistory(a),this.router.cancelNavigationTransition(a,"",2))}}))}),tr(a=>{const l=new IJ(a.id,this.router.serializeUrl(a.extractedUrl),this.router.serializeUrl(a.urlAfterRedirects),a.targetSnapshot);this.router.triggerEvent(l)}))}),dS(o=>{const a=l=>{const c=[];l.routeConfig?.loadComponent&&!l.routeConfig._loadedComponent&&c.push(this.router.configLoader.loadComponent(l.routeConfig).pipe(tr(u=>{l.component=u}),ze(()=>{})));for(const u of l.children)c.push(...a(u));return c};return HC(a(o.targetSnapshot.root)).pipe(my(),no(1))}),dS(()=>this.router.afterPreactivation()),ze(o=>{const a=function $J(n,t,e){const r=uf(n,t._root,e?e._root:void 0);return new T$(r,t)}(this.router.routeReuseStrategy,o.targetSnapshot,o.currentRouterState);return r={...o,targetRouterState:a}}),tr(o=>{this.router.currentUrlTree=o.urlAfterRedirects,this.router.rawUrlTree=this.router.urlHandlingStrategy.merge(o.urlAfterRedirects,o.rawUrl),this.router.routerState=o.targetRouterState,"deferred"===this.router.urlUpdateStrategy&&(o.extras.skipLocationChange||this.router.setBrowserUrl(this.router.rawUrlTree,o),this.router.browserUrlTree=o.urlAfterRedirects)}),((n,t,e)=>ze(r=>(new GJ(t,r.targetRouterState,r.currentRouterState,e).activate(n),r)))(this.router.rootContexts,this.router.routeReuseStrategy,o=>this.router.triggerEvent(o)),tr({next(){s=!0},complete(){s=!0}}),gy(()=>{s||i||this.router.cancelNavigationTransition(r,"",1),this.currentNavigation?.id===r.id&&(this.currentNavigation=null)}),ca(o=>{if(i=!0,$$(o)){O$(o)||(this.router.navigated=!0,this.router.restoreHistory(r,!0));const a=new Sy(r.id,this.router.serializeUrl(r.extractedUrl),o.message,o.cancellationCode);if(e.next(a),O$(o)){const l=this.router.urlHandlingStrategy.merge(o.url,this.router.rawUrlTree),c={skipLocationChange:r.extras.skipLocationChange,replaceUrl:"eager"===this.router.urlUpdateStrategy||tP(r.source)};this.router.scheduleNavigation(l,"imperative",null,c,{resolve:r.resolve,reject:r.reject,promise:r.promise})}else r.resolve(!1)}else{this.router.restoreHistory(r,!0);const a=new E$(r.id,this.router.serializeUrl(r.extractedUrl),o,r.targetSnapshot??void 0);e.next(a);try{r.resolve(this.router.errorHandler(o))}catch(l){r.reject(l)}}return Go}))}))}}function tP(n){return"imperative"!==n}let nP=(()=>{class n{buildTitle(e){let r,s=e.root;for(;void 0!==s;)r=this.getResolvedTitleForRoute(s)??r,s=s.children.find(i=>i.outlet===ft);return r}getResolvedTitleForRoute(e){return e.data[nf]}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:function(){return Mt(Lee)},providedIn:"root"}),n})(),Lee=(()=>{class n extends nP{constructor(e){super(),this.title=e}updateTitle(e){const r=this.buildTitle(e);void 0!==r&&this.title.setTitle(r)}}return n.\u0275fac=function(e){return new(e||n)(J(X2))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Vee=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:function(){return Mt(zee)},providedIn:"root"}),n})();class Bee{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}let zee=(()=>{class n extends Bee{}return n.\u0275fac=function(){let t;return function(r){return(t||(t=Dr(n)))(r||n)}}(),n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const My=new me("",{providedIn:"root",factory:()=>({})}),zu=new me("ROUTES");let hS=(()=>{class n{constructor(e,r){this.injector=e,this.compiler=r,this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap}loadComponent(e){if(this.componentLoaders.get(e))return this.componentLoaders.get(e);if(e._loadedComponent)return Oe(e._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(e);const r=Wa(e.loadComponent()).pipe(ze(sP),tr(i=>{this.onLoadEndListener&&this.onLoadEndListener(e),e._loadedComponent=i}),gy(()=>{this.componentLoaders.delete(e)})),s=new n$(r,()=>new Wt).pipe(WC());return this.componentLoaders.set(e,s),s}loadChildren(e,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return Oe({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);const i=this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(ze(a=>{this.onLoadEndListener&&this.onLoadEndListener(r);let l,c,u=!1;Array.isArray(a)?c=a:(l=a.create(e).injector,c=l$(l.get(zu,[],qe.Self|qe.Optional)));return{routes:c.map(aS),injector:l}}),gy(()=>{this.childrenLoaders.delete(r)})),o=new n$(i,()=>new Wt).pipe(WC());return this.childrenLoaders.set(r,o),o}loadModuleFactoryOrRoutes(e){return Wa(e()).pipe(ze(sP),Er(s=>s instanceof FF||Array.isArray(s)?Oe(s):$n(this.compiler.compileModuleAsync(s))))}}return n.\u0275fac=function(e){return new(e||n)(J(os),J(iC))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function sP(n){return function Wee(n){return n&&"object"==typeof n&&"default"in n}(n)?n.default:n}let jee=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:function(){return Mt(Gee)},providedIn:"root"}),n})(),Gee=(()=>{class n{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,r){return e}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function qee(n){throw n}function Kee(n,t,e){return t.parse("/")}const Xee={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},Yee={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};function oP(){const n=Mt(m$),t=Mt(df),e=Mt(Kg),r=Mt(os),s=Mt(iC),i=Mt(zu,{optional:!0})??[],o=Mt(My,{optional:!0})??{},a=new jr(null,n,t,e,r,s,l$(i));return function Zee(n,t){n.errorHandler&&(t.errorHandler=n.errorHandler),n.malformedUriErrorHandler&&(t.malformedUriErrorHandler=n.malformedUriErrorHandler),n.onSameUrlNavigation&&(t.onSameUrlNavigation=n.onSameUrlNavigation),n.paramsInheritanceStrategy&&(t.paramsInheritanceStrategy=n.paramsInheritanceStrategy),n.urlUpdateStrategy&&(t.urlUpdateStrategy=n.urlUpdateStrategy),n.canceledNavigationResolution&&(t.canceledNavigationResolution=n.canceledNavigationResolution)}(o,a),a}let jr=(()=>{class n{constructor(e,r,s,i,o,a,l){this.rootComponentType=e,this.urlSerializer=r,this.rootContexts=s,this.location=i,this.config=l,this.lastSuccessfulNavigation=null,this.disposed=!1,this.navigationId=0,this.currentPageId=0,this.isNgZoneEnabled=!1,this.events=new Wt,this.errorHandler=qee,this.malformedUriErrorHandler=Kee,this.navigated=!1,this.lastSuccessfulId=-1,this.afterPreactivation=()=>Oe(void 0),this.urlHandlingStrategy=Mt(jee),this.routeReuseStrategy=Mt(Vee),this.titleStrategy=Mt(nP),this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.canceledNavigationResolution="replace",this.navigationTransitions=new Pee(this),this.configLoader=o.get(hS),this.configLoader.onLoadEndListener=h=>this.triggerEvent(new TJ(h)),this.configLoader.onLoadStartListener=h=>this.triggerEvent(new DJ(h)),this.ngModule=o.get(Zl),this.console=o.get(I7);const d=o.get(St);this.isNgZoneEnabled=d instanceof St&&St.isInAngularZone(),this.resetConfig(l),this.currentUrlTree=new ec,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=k$(this.currentUrlTree,this.rootComponentType),this.transitions=new wi({id:0,targetPageId:0,currentUrlTree:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.navigationTransitions.setupNavigations(this.transitions),this.processNavigations()}get browserPageId(){return this.location.getState()?.\u0275routerPageId}resetRootComponentType(e){this.rootComponentType=e,this.routerState.root.component=this.rootComponentType}setTransition(e){this.transitions.next({...this.transitions.value,...e})}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const r="popstate"===e.type?"popstate":"hashchange";"popstate"===r&&setTimeout(()=>{const s={replaceUrl:!0},i=e.state?.navigationId?e.state:null;if(e.state){const a={...e.state};delete a.navigationId,delete a.\u0275routerPageId,0!==Object.keys(a).length&&(s.state=a)}const o=this.parseUrl(e.url);this.scheduleNavigation(o,r,i,s)},0)}))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}triggerEvent(e){this.events.next(e)}resetConfig(e){this.config=e.map(aS),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,r={}){const{relativeTo:s,queryParams:i,fragment:o,queryParamsHandling:a,preserveFragment:l}=r,c=s||this.routerState.root,u=l?this.currentUrlTree.fragment:o;let d=null;switch(a){case"merge":d={...this.currentUrlTree.queryParams,...i};break;case"preserve":d=this.currentUrlTree.queryParams;break;default:d=i||null}return null!==d&&(d=this.removeEmptyProps(d)),gJ(c,this.currentUrlTree,e,d,u??null)}navigateByUrl(e,r={skipLocationChange:!1}){const s=nc(e)?e:this.parseUrl(e),i=this.urlHandlingStrategy.merge(s,this.rawUrlTree);return this.scheduleNavigation(i,"imperative",null,r)}navigate(e,r={skipLocationChange:!1}){return function Qee(n){for(let t=0;t<n.length;t++){if(null==n[t])throw new te(4008,!1)}}(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let r;try{r=this.urlSerializer.parse(e)}catch(s){r=this.malformedUriErrorHandler(s,this.urlSerializer,e)}return r}isActive(e,r){let s;if(s=!0===r?{...Xee}:!1===r?{...Yee}:r,nc(e))return d$(this.currentUrlTree,e,s);const i=this.parseUrl(e);return d$(this.currentUrlTree,i,s)}removeEmptyProps(e){return Object.keys(e).reduce((r,s)=>{const i=e[s];return null!=i&&(r[s]=i),r},{})}processNavigations(){this.navigations.subscribe(e=>{this.navigated=!0,this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId,this.events.next(new rc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.getCurrentNavigation(),this.titleStrategy?.updateTitle(this.routerState.snapshot),e.resolve(!0)},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)})}scheduleNavigation(e,r,s,i,o){if(this.disposed)return Promise.resolve(!1);let a,l,c;o?(a=o.resolve,l=o.reject,c=o.promise):c=new Promise((h,f)=>{a=h,l=f});const u=++this.navigationId;let d;return"computed"===this.canceledNavigationResolution?(0===this.currentPageId&&(s=this.location.getState()),d=s&&s.\u0275routerPageId?s.\u0275routerPageId:i.replaceUrl||i.skipLocationChange?this.browserPageId??0:(this.browserPageId??0)+1):d=0,this.setTransition({id:u,targetPageId:d,source:r,restoredState:s,currentUrlTree:this.currentUrlTree,rawUrl:e,extras:i,resolve:a,reject:l,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(h=>Promise.reject(h))}setBrowserUrl(e,r){const s=this.urlSerializer.serialize(e),i={...r.extras.state,...this.generateNgRouterState(r.id,r.targetPageId)};this.location.isCurrentPathEqualTo(s)||r.extras.replaceUrl?this.location.replaceState(s,"",i):this.location.go(s,"",i)}restoreHistory(e,r=!1){if("computed"===this.canceledNavigationResolution){const s=this.currentPageId-e.targetPageId;"popstate"!==e.source&&"eager"!==this.urlUpdateStrategy&&this.currentUrlTree!==this.getCurrentNavigation()?.finalUrl||0===s?this.currentUrlTree===this.getCurrentNavigation()?.finalUrl&&0===s&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree()):this.location.historyGo(s)}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}cancelNavigationTransition(e,r,s){const i=new Sy(e.id,this.serializeUrl(e.extractedUrl),r,s);this.triggerEvent(i),e.resolve(!1)}generateNgRouterState(e,r){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}}return n.\u0275fac=function(e){Ih()},n.\u0275prov=Ce({token:n,factory:function(){return oP()},providedIn:"root"}),n})();class aP{}let tte=(()=>{class n{constructor(e,r,s,i,o){this.router=e,this.injector=s,this.preloadingStrategy=i,this.loader=o}setUpPreloading(){this.subscription=this.router.events.pipe(Ss(e=>e instanceof rc),Ha(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,r){const s=[];for(const i of r){i.providers&&!i._injector&&(i._injector=$g(i.providers,e,`Route: ${i.path}`));const o=i._injector??e,a=i._loadedInjector??o;i.loadChildren&&!i._loadedRoutes&&void 0===i.canLoad||i.loadComponent&&!i._loadedComponent?s.push(this.preloadConfig(o,i)):(i.children||i._loadedRoutes)&&s.push(this.processRoutes(a,i.children??i._loadedRoutes))}return $n(s).pipe(zc())}preloadConfig(e,r){return this.preloadingStrategy.preload(r,()=>{let s;s=r.loadChildren&&void 0===r.canLoad?this.loader.loadChildren(e,r):Oe(null);const i=s.pipe(Er(o=>null===o?Oe(void 0):(r._loadedRoutes=o.routes,r._loadedInjector=o.injector,this.processRoutes(o.injector??e,o.routes))));return r.loadComponent&&!r._loadedComponent?$n([i,this.loader.loadComponent(r)]).pipe(zc()):i})}}return n.\u0275fac=function(e){return new(e||n)(J(jr),J(iC),J($a),J(aP),J(hS))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const pS=new me("");let lP=(()=>{class n{constructor(e,r,s,i={}){this.router=e,this.viewportScroller=r,this.zone=s,this.options=i,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},i.scrollPositionRestoration=i.scrollPositionRestoration||"disabled",i.anchorScrolling=i.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(e=>{e instanceof QC?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof rc&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.router.parseUrl(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(e=>{e instanceof I$&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,r){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.router.triggerEvent(new I$(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))})},0)})}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return n.\u0275fac=function(e){Ih()},n.\u0275prov=Ce({token:n,factory:n.\u0275fac}),n})();function Hu(n,t){return{\u0275kind:n,\u0275providers:t}}function uP(){const n=Mt(os);return t=>{const e=n.get(ku);if(t!==e.components[0])return;const r=n.get(jr),s=n.get(dP);1===n.get(gS)&&r.initialNavigation(),n.get(hP,null,qe.Optional)?.setUpPreloading(),n.get(pS,null,qe.Optional)?.init(),r.resetRootComponentType(e.componentTypes[0]),s.closed||(s.next(),s.unsubscribe())}}const dP=new me("",{factory:()=>new Wt}),gS=new me("",{providedIn:"root",factory:()=>1});const hP=new me("");function ote(n){return Hu(0,[{provide:hP,useExisting:tte},{provide:aP,useExisting:n}])}const fP=new me("ROUTER_FORROOT_GUARD"),ate=[Kg,{provide:m$,useClass:GC},{provide:jr,useFactory:oP},df,{provide:Lu,useFactory:function cP(n){return n.routerState.root},deps:[jr]},hS,[]];function lte(){return new MO("Router",jr)}let pP=(()=>{class n{constructor(e){}static forRoot(e,r){return{ngModule:n,providers:[ate,[],{provide:zu,multi:!0,useValue:e},{provide:fP,useFactory:hte,deps:[[jr,new Oa,new iu]]},{provide:My,useValue:r||{}},r?.useHash?{provide:Jl,useClass:f9}:{provide:Jl,useClass:n2},{provide:pS,useFactory:()=>{const n=Mt(jr),t=Mt(NZ),e=Mt(St),r=Mt(My);return r.scrollOffset&&t.setOffset(r.scrollOffset),new lP(n,t,e,r)}},r?.preloadingStrategy?ote(r.preloadingStrategy).\u0275providers:[],{provide:MO,multi:!0,useFactory:lte},r?.initialNavigation?fte(r):[],[{provide:mP,useFactory:uP},{provide:IO,multi:!0,useExisting:mP}]]}}static forChild(e){return{ngModule:n,providers:[{provide:zu,multi:!0,useValue:e}]}}}return n.\u0275fac=function(e){return new(e||n)(J(fP,8))},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({imports:[iS]}),n})();function hte(n){return"guarded"}function fte(n){return["disabled"===n.initialNavigation?Hu(3,[{provide:Bg,multi:!0,useFactory:()=>{const t=Mt(jr);return()=>{t.setUpLocationChangeListener()}}},{provide:gS,useValue:2}]).\u0275providers:[],"enabledBlocking"===n.initialNavigation?Hu(2,[{provide:gS,useValue:0},{provide:Bg,multi:!0,deps:[os],useFactory:t=>{const e=t.get(d9,Promise.resolve());return()=>e.then(()=>new Promise(s=>{const i=t.get(jr),o=t.get(dP);(function r(s){t.get(jr).events.pipe(Ss(o=>o instanceof rc||o instanceof Sy||o instanceof E$),ze(o=>o instanceof rc||o instanceof Sy&&(0===o.code||1===o.code)&&null),Ss(o=>null!==o),no(1)).subscribe(()=>{s()})})(()=>{s(!0)}),i.afterPreactivation=()=>(s(!0),o.closed?Oe(void 0):o),i.initialNavigation()}))}}]).\u0275providers:[]]}const mP=new me(""),mte=[];class Fy{static#e=this.\u0275fac=function(e){return new(e||Fy)};static#t=this.\u0275mod=Kt({type:Fy});static#n=this.\u0275inj=jt({imports:[pP.forRoot(mte),pP]})}class gte extends He{constructor(t,e){super()}schedule(t,e=0){return this}}const Oy={setInterval(n,t,...e){const{delegate:r}=Oy;return r?.setInterval?r.setInterval(n,t,...e):setInterval(n,t,...e)},clearInterval(n){const{delegate:t}=Oy;return(t?.clearInterval||clearInterval)(n)},delegate:void 0};class yS extends gte{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){var r;if(this.closed)return this;this.state=t;const s=this.id,i=this.scheduler;return null!=s&&(this.id=this.recycleAsyncId(i,s,e)),this.pending=!0,this.delay=e,this.id=null!==(r=this.id)&&void 0!==r?r:this.requestAsyncId(i,this.id,e),this}requestAsyncId(t,e,r=0){return Oy.setInterval(t.flush.bind(t,this),r)}recycleAsyncId(t,e,r=0){if(null!=r&&this.delay===r&&!1===this.pending)return e;null!=e&&Oy.clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const r=this._execute(t,e);if(r)return r;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let s,r=!1;try{this.work(t)}catch(i){r=!0,s=i||new Error("Scheduled action threw falsy error")}if(r)return this.unsubscribe(),s}unsubscribe(){if(!this.closed){const{id:t,scheduler:e}=this,{actions:r}=e;this.work=this.state=this.scheduler=null,this.pending=!1,ct(r,this),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null,super.unsubscribe()}}}const gP={now:()=>(gP.delegate||Date).now(),delegate:void 0};class bf{constructor(t,e=bf.now){this.schedulerActionCtor=t,this.now=e}schedule(t,e=0,r){return new this.schedulerActionCtor(this,t).schedule(r,e)}}bf.now=gP.now;class bS extends bf{constructor(t,e=bf.now){super(t,e),this.actions=[],this._active=!1}flush(t){const{actions:e}=this;if(this._active)return void e.push(t);let r;this._active=!0;do{if(r=t.execute(t.state,t.delay))break}while(t=e.shift());if(this._active=!1,r){for(;t=e.shift();)t.unsubscribe();throw r}}}const $y=new bS(yS),yte=$y;function yP(n=0,t,e=yte){let r=-1;return null!=t&&(oN(t)?e=t:r=t),new xn(s=>{let i=function bte(n){return n instanceof Date&&!isNaN(n)}(n)?+n-e.now():n;i<0&&(i=0);let o=0;return e.schedule(function(){s.closed||(s.next(o++),0<=r?this.schedule(void 0,r):s.complete())},i)})}function bP(n,t){return t?e=>e.pipe(bP((r,s)=>Vr(n(r,s)).pipe(ze((i,o)=>t(r,i,s,o))))):Dn((e,r)=>{let s=0,i=null,o=!1;e.subscribe(ln(r,a=>{i||(i=ln(r,void 0,()=>{i=null,o&&r.complete()}),Vr(n(a,s++)).subscribe(i))},()=>{o=!0,!i&&r.complete()}))})}function _P(n,t,e,r,s,i,o){try{var a=n[i](o),l=a.value}catch(c){return void e(c)}a.done?t(l):Promise.resolve(l).then(r,s)}function ee(n){return function(){var t=this,e=arguments;return new Promise(function(r,s){var i=n.apply(t,e);function o(l){_P(i,r,s,o,a,"next",l)}function a(l){_P(i,r,s,o,a,"throw",l)}o(void 0)})}}class vP{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class _S{refCount(t){return Es("refCount")}incRef(t){return Es("incRef")}timerAvailable(){return!0}time(t){return Es("time")}read(t){return Es("read")}readSync(t){return Es("readSync")}readToGPU(t,e){return Es("readToGPU")}numDataIds(){return Es("numDataIds")}disposeData(t,e){return Es("disposeData")}write(t,e,r){return Es("write")}move(t,e,r,s,i){return Es("move")}createTensorFromTexture(t,e,r){return Es("createTensorFromTexture")}memory(){return Es("memory")}floatPrecision(){return Es("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Es("dispose")}}function Es(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function xP(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,ja(n,t,e)}function sc(n,t,e){return Math.max(n,Math.min(t,e))}function vS(n){return n%2==0?n:n+1}function ja(n,t,e){const r=n[t];n[t]=n[e],n[e]=r}function S(n,t){if(!n)throw new Error("string"==typeof t?t:t())}function Is(n,t,e=""){S(It(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function Wu(n){S(null!=n,()=>"The input to the tensor constructor must be a non-null value.")}function ju(n,t=[],e=!1){if(null==t&&(t=[]),Array.isArray(n)||Do(n)&&!e)for(let r=0;r<n.length;++r)ju(n[r],t,e);else t.push(n);return t}function X(n){if(0===n.length)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function It(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function Gu(n){return n%1==0}function xS(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function qu(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function wP(n,t=(s=>0),e,r){return new Promise((s,i)=>{let o=0;const a=()=>{if(n())return void s();o++;const l=t(o);null!=e&&o>=e?i():null!=r?r(a,l):setTimeout(a,l)};a()})}function CP(n,t){let e=1,r=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)e*=n[i];else if(-1===n[i]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(-1===r){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(0===e)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const s=n.slice();return s[r]=t/e,s}function ht(n,t){const e=t.length;return S((n=null==n?t.map((r,s)=>s):[].concat(n)).every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),S(n.every(r=>Gu(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?e+r:r)}function Ga(n,t){const e=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||s?null:ht(t,n).sort();let o=0;for(let a=0;a<n.length;++a){if(null!=i){if(i[o]===a&&1!==n[a])throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(null==i[o]||i[o]>a)&&1===n[a]&&(e.push(n[a]),r.push(a)),i[o]<=a&&o++}1!==n[a]&&(e.push(n[a]),r.push(a))}return{newShape:e,keptDims:r}}function gr(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);e=new Uint8Array(t)}return e}function Kn(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else if("bool"===n)e=new Uint8Array(t);else{if("string"!==n)throw new Error(`Unknown data type ${n}`);e=new Array(t)}return e}function SP(n,t){return!("complex64"===t||"float32"===t&&"complex64"!==n||"int32"===t&&"float32"!==n&&"complex64"!==n||"bool"===t&&"bool"===n)}function Do(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function wS(n){if("float32"===n||"int32"===n)return 4;if("complex64"===n)return 8;if("bool"===n)return 1;throw new Error(`Unknown dtype ${n}`)}function _f(n){return"string"==typeof n||n instanceof String}function CS(n){return"number"==typeof n}function vf(n){return Array.isArray(n)?vf(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":CS(n)?"float32":_f(n)?"string":function Ite(n){return"boolean"==typeof n}(n)?"bool":"float32"}function SS(n){return!!(n&&n.constructor&&n.call&&n.apply)}function ES(n,t){for(let e=t;e<n;++e)if(n%e==0)return e;return n}function Pe(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let r=t-3;r>=0;--r)e[r]=e[r+1]*n[r+1];return e}function EP(n,t,e,r=!1){const s=new Array;if(1===t.length){const i=t[0]*(r?2:1);for(let o=0;o<i;o++)s[o]=e[n+o]}else{const i=t[0],o=t.slice(1),a=o.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<i;l++)s[l]=EP(n+l*a,o,e,r)}return s}function Si(n,t,e=!1){if(0===n.length)return t[0];const r=n.reduce((s,i)=>s*i)*(e?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return EP(0,n,t,e)}function IS(n,t){const e=$r(n,t);for(let r=0;r<e.length;r++)e[r]=1;return e}function $r(n,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t)return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function IP(n,t){const e=n.reduce((r,s)=>r*s,1);if(null==t||"float32"===t)return Si(n,new Float32Array(e));if("int32"===t)return Si(n,new Int32Array(e));if("bool"===t)return Si(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Ys(n){n.forEach(t=>{S(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function To(n,t,e){if(0===t)return 0;if(1===t)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=e[s]*n[s];return r}function Ku(n,t,e){if(0===t)return[];if(1===t)return[n];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/e[s]),n-=r[s]*e[s];return r[r.length-1]=n,r}function Xu(n){return n&&n.then&&"function"==typeof n.then}const DP="tfjsflags";class Dte{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Tte,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(j().getBool("IS_TEST")||j().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},null!=this.urlFlags[t]){const s=this.urlFlags[t];j().getBool("IS_TEST")||j().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}getAsync(t){var e=this;return ee(function*(){return t in e.flags||(e.flags[t]=yield e.evaluateFlag(t)),e.flags[t]})()}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Xu(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);DP in t&&t[DP].split(",").forEach(r=>{const[s,i]=r.split(":");this.urlFlags[s]=function Nte(n,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${n}.`)}(s,i)})}}function Tte(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(function kte(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}(t,r[0],r[1]),r.join("="))),t}function j(){return TP}let DS,TP=null;function kP(){if(null==DS){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");n=self}DS=n}return DS}function TS(n,t){const e=function Rte(){const n=kP();return null==n._tfGlobals&&(n._tfGlobals=new Map),n._tfGlobals}();if(e.has(n))return e.get(n);{const r=t();return e.set(n,r),e.get(n)}}const Py="Abs",xf="Acos",wf="Acosh",Yu="Add",Ly="AddN",Vy="ArgMax",By="ArgMin",Cf="Asin",Sf="Asinh",Ef="Atan",If="Atanh",Df="Atan2",zy="AvgPool",AS="AvgPoolGrad",Uy="AvgPool3D",RS="AvgPool3DGrad",Hy="BatchMatMul",Wy="BatchToSpaceND",MS="Bincount",FS="BroadcastArgs",Tf="Cast",kf="Ceil",Nf="ClipByValue",OS="Complex",jy="ComplexAbs",Gy="Concat",qy="Conv2D",$S="Conv2DBackpropFilter",Ky="Conv2DBackpropInput",Xy="Conv3D",PS="Conv3DBackpropFilterV2",LS="Conv3DBackpropInputV2",Af="Cos",Rf="Cosh",VS="Cumprod",Yy="Cumsum",BS="CropAndResize",zS="DenseBincount",US="DepthToSpace",Zy="DepthwiseConv2dNative",HS="DepthwiseConv2dNativeBackpropFilter",WS="DepthwiseConv2dNativeBackpropInput",jS="Diag",Qy="Dilation2D",GS="Dilation2DBackpropInput",qS="Dilation2DBackpropFilter",Mf="RealDiv",KS="Einsum",Ff="Elu",XS="EluGrad",Of="Erf",Jy="Equal",$f="Exp",eb="ExpandDims",Pf="Expm1",ZS="Fill",QS="FlipLeftRight",Lf="Floor",Vf="FloorDiv",tb="FusedBatchNorm",nb="GatherV2",JS="GatherNd",rb="Greater",Bf="GreaterEqual",zf="Identity",eE="IFFT",tE="Imag",Uf="IsFinite",Hf="IsInf",Wf="IsNan",sb="LeakyRelu",ib="Less",ob="LessEqual",nE="LinSpace",jf="Log",Gf="Log1p",ab="LogicalAnd",lb="LogicalNot",cb="LogicalOr",ub="LRN",rE="LRNGrad",db="Max",qf="Maximum",hb="MaxPool",sE="MaxPoolGrad",fb="MaxPool3D",iE="MaxPool3DGrad",oE="MaxPoolWithArgmax",pb="Mean",mb="Min",Kf="Minimum",gb="MirrorPad",Xf="Mod",aE="Multinomial",Yf="Multiply",yb="Neg",bb="NotEqual",lE="NonMaxSuppressionV3",cE="NonMaxSuppressionV4",uE="NonMaxSuppressionV5",_b="OnesLike",vb="OneHot",xb="Pack",wb="PadV2",Zf="Pow",Cb="Prelu",Sb="Prod",dE="RaggedGather",hE="RaggedRange",fE="RaggedTensorToTensor",pE="Range",mE="Real",Qf="Reciprocal",Jf="Relu",Eb="Reshape",Ib="ResizeNearestNeighbor",gE="ResizeNearestNeighborGrad",Db="ResizeBilinear",yE="ResizeBilinearGrad",ep="Relu6",Tb="Reverse",tp="Round",np="Rsqrt",bE="ScatterNd",_E="SearchSorted",kb="Select",rp="Selu",Nb="Slice",sp="Sin",ip="Sinh",op="Sign",ap="Sigmoid",lp="Softplus",cp="Sqrt",Ab="Sum",Rb="SpaceToBatchND",Mb="SplitV",Fb="Softmax",vE="SparseFillEmptyRows",xE="SparseReshape",wE="SparseSegmentMean",CE="SparseSegmentSum",SE="SparseToDense",up="SquaredDifference",EE="Square",IE="StridedSlice",DE="StringNGrams",TE="StringSplit",kE="StringToHashBucketFast",dp="Sub",hp="Tan",fp="Tanh",pp="Tile",NE="TopK",AE="Transform",Zu="Transpose",RE="Unique",Ob="Unpack",$b="UnsortedSegmentSum",Pb="ZerosLike",mp="Step",ME="FromPixels",FE="RotateWithOffset",Lb="_FusedMatMul",Vb="FusedConv2D",Bb="FusedDepthwiseConv2D";function Zs(...n){j().getBool("IS_TEST")||j().getBool("PROD")||console.warn(...n)}function Ote(...n){j().getBool("IS_TEST")||j().getBool("PROD")||console.log(...n)}const Qu=TS("kernelRegistry",()=>new Map),gp=TS("gradRegistry",()=>new Map);function OE(n,t){const e=LE(n,t);return Qu.get(e)}function NP(n){return gp.get(n)}function $E(n){const t=Qu.entries(),e=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[i,o]=s,[a]=i.split("_");a===n&&e.push(o)}return e}function PE(n){const{kernelName:t,backendName:e}=n,r=LE(t,e);Qu.has(r)&&Zs(`The kernel '${t}' for backend '${e}' is already registered`),Qu.set(r,n)}function $te(n){const{kernelName:t}=n;gp.has(t)&&j().getBool("DEBUG")&&Zs(`Overriding the gradient for '${t}'`),gp.set(t,n)}function LE(n,t){return`${t}_${n}`}var AP=Z(658);const ic=Z.n(AP)()||AP;function zb(n){return ic.fromString(n,!0,16)}const RP=zb("c3a5c85c97cb3127"),oc=zb("b492b66fbe98f273"),Gr=zb("9ae16a3b2f90404f");function VE(n){return n.xor(n.shru(47))}function MP(n,t,e){const r=n.slice(t,t+e);return ic.fromBytes(Array.from(r),!0,!0)}function nn(n,t){return MP(n,t,8)}function FP(n,t){return MP(n,t,4)}function yr(n,t){return 0===t?n:n.shru(t).or(n.shl(64-t))}function qa(n,t,e=zb("9ddfea08eb382d69")){let r=n.xor(t).mul(e);r=r.xor(r.shru(47));let s=t.xor(r).mul(e);return s=s.xor(s.shru(47)),s=s.mul(e),s}function Ub(n,t,e,r){return function Lte(n,t,e,r,s,i){s=s.add(n),i=yr(i.add(s).add(r),21);const o=s;return s=(s=s.add(t)).add(e),i=i.add(yr(s,44)),[s.add(r),i.add(o)]}(nn(n,t),nn(n,t+8),nn(n,t+16),nn(n,t+24),e,r)}function Ute(n,t=n.length){const e=ic.fromNumber(81,!0);if(t<=32)return t<=16?function Vte(n,t=n.length){if(t>=8){const e=Gr.add(2*t),r=nn(n,0).add(Gr),s=nn(n,t-8);return qa(yr(s,37).mul(e).add(r),yr(r,25).add(s).mul(e),e)}if(t>=4){const e=Gr.add(2*t);return qa(FP(n,0).shl(3).add(t),FP(n,t-4),e)}if(t>0){const o=t+(n[t-1]<<2);return VE(Gr.mul(n[0]+(n[t>>1]<<8)).xor(RP.mul(o))).mul(Gr)}return Gr}(n,t):function Bte(n,t=n.length){const e=Gr.add(2*t),r=nn(n,0).mul(oc),s=nn(n,8),i=nn(n,t-8).mul(e),o=nn(n,t-16).mul(Gr);return qa(yr(r.add(s),43).add(yr(i,30)).add(o),r.add(yr(s.add(Gr),18)).add(i),e)}(n,t);if(t<=64)return function zte(n,t=n.length){const e=Gr.add(2*t),r=nn(n,0).mul(Gr),s=nn(n,8),i=nn(n,t-8).mul(e),o=nn(n,t-16).mul(Gr),a=yr(r.add(s),43).add(yr(i,30)).add(o),l=qa(a,r.add(yr(s.add(Gr),18)).add(i),e),c=nn(n,16).mul(e),u=nn(n,24),d=a.add(nn(n,t-32)).mul(e),h=l.add(nn(n,t-24)).mul(e);return qa(yr(c.add(u),43).add(yr(d,30)).add(h),c.add(yr(u.add(r),18)).add(d),e)}(n,t);let r=e,s=e.mul(oc).add(113),i=VE(s.mul(Gr).add(113)).mul(Gr),o=[ic.UZERO,ic.UZERO],a=[ic.UZERO,ic.UZERO];r=r.mul(Gr).add(nn(n,0));let l=0;const c=64*(t-1>>6),u=c+(t-1&63)-63;do{r=yr(r.add(s).add(o[0]).add(nn(n,l+8)),37).mul(oc),s=yr(s.add(o[1]).add(nn(n,l+48)),42).mul(oc),r=r.xor(a[1]),s=s.add(o[0]).add(nn(n,l+40)),i=yr(i.add(a[0]),33).mul(oc),o=Ub(n,l,o[1].mul(oc),r.add(a[0])),a=Ub(n,l+32,i.add(a[1]),s.add(nn(n,l+16))),[i,r]=[r,i],l+=64}while(l!==c);const d=oc.add(i.and(255).shl(1));return l=u,a[0]=a[0].add(t-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),r=yr(r.add(s).add(o[0]).add(nn(n,l+8)),37).mul(d),s=yr(s.add(o[1]).add(nn(n,l+48)),42).mul(d),r=r.xor(a[1].mul(9)),s=s.add(o[0].mul(9).add(nn(n,l+40))),i=yr(i.add(a[0]),33).mul(d),o=Ub(n,l,o[1].mul(d),r.add(a[0])),a=Ub(n,l+32,i.add(a[1]),s.add(nn(n,l+16))),[i,r]=[r,i],qa(qa(o[0],a[0],d).add(VE(s).mul(RP)).add(i),qa(o[1],a[1],d).add(r),d)}function Ka(n,t){return"string"===t?Xa(n):ac([n],t)}function ac(n,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=ju(n)),j().getBool("DEBUG")&&function Cte(n,t){for(let e=0;e<n.length;e++){const r=n[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(n,t),function Hte(n,t){return n instanceof Float32Array&&"float32"===t||n instanceof Int32Array&&"int32"===t||n instanceof Uint8Array&&"bool"===t}(n,t))return n;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t){const e=new Uint8Array(n.length);for(let r=0;r<e.length;++r)0!==Math.round(n[r])&&(e[r]=1);return e}throw new Error(`Unknown data type ${t}`)}function us(){return j().platform.now()}function Xa(n,t="utf-8"){return t=t||"utf-8",j().platform.encode(n,t)}function Ya(n,t="utf-8"){return t=t||"utf-8",j().platform.decode(n,t)}class Wte{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new Gte)}profileKernel(t,e,r){let s;const i=()=>{s=r()};let o;const a=us();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of s)c.dataSync();o=Promise.resolve({kernelMs:us()-a})}if(j().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const u=s[c];u.data().then(d=>{jte(d,u.dtype,t)})}return{kernelName:t,outputs:s,inputs:e,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>null!=c.getExtraProfileInfo?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:r,timeMs:s,inputs:i,extraInfo:o}=t;r.forEach(a=>{Promise.all([a.data(),s,o]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],i,l[2])})})}}function jte(n,t,e){if("float32"!==t)return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${e}'`),!0}return!1}class Gte{logKernelProfile(t,e,r,s,i,o){const a="number"==typeof s?qu(`${s}ms`,9):s.error,l=qu(t,25),c=e.rank,u=e.size,d=qu(e.shape.toString(),14);let h="";for(const f in i){const p=i[f];if(null!=p){const m=p.shape||e.shape,g=m.length;h+=`${f}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}\t%c${a}\t%c${c}D ${d}\t%c${u}\t%c${h}\t%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Xte(n,t,e,r){const s=Pe(t),i=function Yte(n,t,e,r){const s=X(t),i=r[r.length-1],o=new Array(i).fill(0),a=t.length,l="complex64"===e?_p(n):n;if(a>1)for(let c=0;c<s/i;c++){const u=c*i;for(let d=0;d<i;d++)o[d]=Math.max(o[d],bp(l[u+d],0,e).length)}return o}(n,t,e,s),o=t.length,a=Hb(n,t,e,s,i),l=["Tensor"];return r&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join("\n")),l.join("\n")}function bp(n,t,e){let r;return r=Array.isArray(n)?`${parseFloat(n[0].toFixed(7))} + ${parseFloat(n[1].toFixed(7))}j`:_f(n)?`'${n}'`:"bool"===e?$P(n):parseFloat(n.toFixed(7)).toString(),qu(r,t)}function $P(n){return 0===n?"false":"true"}function Hb(n,t,e,r,s,i=!0){const o="complex64"===e?2:1,a=t[0],l=t.length;if(0===l)return"complex64"===e?[bp(_p(n)[0],0,e)]:"bool"===e?[$P(n[0])]:[n[0].toString()];if(1===l){if(a>20){let y=Array.from(n.slice(0,3*o)),b=Array.from(n.slice((a-3)*o,a*o));return"complex64"===e&&(y=_p(y),b=_p(b)),["["+y.map((_,v)=>bp(_,s[v],e)).join(", ")+", ..., "+b.map((_,v)=>bp(_,s[a-3+v],e)).join(", ")+"]"]}return["["+("complex64"===e?_p(n):Array.from(n)).map((g,y)=>bp(g,s[y],e)).join(", ")+"]"]}const c=t.slice(1),u=r.slice(1),d=r[0]*o,h=[];if(a>20){for(let m=0;m<3;m++){const g=m*d;h.push(...Hb(n.slice(g,g+d),c,e,u,s,!1))}h.push("...");for(let m=a-3;m<a;m++){const g=m*d;h.push(...Hb(n.slice(g,g+d),c,e,u,s,m===a-1))}}else for(let m=0;m<a;m++){const g=m*d;h.push(...Hb(n.slice(g,g+d),c,e,u,s,m===a-1))}const f=2===l?",":"";h[0]="["+h[0]+f;for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+f;let p=",\n";for(let m=2;m<l;m++)p+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(i?"":p),h}function _p(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class br{constructor(t,e,r){if(this.dtype=e,this.shape=t.slice(),this.size=X(t),null!=r){const s=r.length;S(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Kn(e,this.size),this.strides=Pe(t)}set(t,...e){0===e.length&&(e=[0]),S(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const r=this.locToIndex(e);this.values[r]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const s of t){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return ro().makeTensor(this.values,this.shape,this.dtype)}}let ro=null,Ju=null,PP=null;class fn{constructor(t,e,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=X(t),this.strides=Pe(t),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var t=this;return ee(function*(){const e=yield t.data();return Ju.buffer(t.shape,t.dtype,e)})()}bufferSync(){return Ju.buffer(this.shape,this.dtype,this.dataSync())}array(){var t=this;return ee(function*(){const e=yield t.data();return Si(t.shape,e,"complex64"===t.dtype)})()}arraySync(){return Si(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var t=this;return ee(function*(){t.throwIfDisposed();const e=ro().read(t.dataId);if("string"===t.dtype){const r=yield e;try{return r.map(s=>Ya(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataToGPU(t){return this.throwIfDisposed(),ro().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=ro().readSync(this.dataId);if("string"===this.dtype)try{return t.map(e=>Ya(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){var t=this;return ee(function*(){t.throwIfDisposed();const e=yield ro().read(t.dataId);return"string"===t.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(ro().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Ju.print(this,t)}clone(){return this.throwIfDisposed(),Ju.clone(this)}toString(t=!1){return Xte(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Ju.cast(this,t)}variable(t=!0,e,r){return this.throwIfDisposed(),ro().makeVariable(this,t,e,r)}}function Y(){return TS("Tensor",()=>fn)}Object.defineProperty(fn,Symbol.hasInstance,{value:n=>!!n&&null!=n.data&&null!=n.dataSync&&null!=n.throwIfDisposed}),Y();class Wb extends fn{constructor(t,e,r,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=e,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!It(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);ro().disposeTensor(this),this.dataId=t.dataId,ro().incRef(this,null)}dispose(){ro().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Wb,Symbol.hasInstance,{value:n=>n instanceof fn&&null!=n.assign&&n.assign instanceof Function});var jb=(()=>{return(n=jb||(jb={})).float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64",jb;var n})(),Gb=(()=>{return(n=Gb||(Gb={})).float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64",Gb;var n})(),qb=(()=>{return(n=qb||(qb={})).float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64",qb;var n})(),Kb=(()=>{return(n=Kb||(Kb={})).float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64",Kb;var n})();const ene={float32:qb,int32:jb,bool:Gb,complex64:Kb};function Ds(n,t){if("string"===n||"string"===t){if("string"===n&&"string"===t)return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return ene[n][t]}function zE(n){return Ds(n,"int32")}function Rn(n,t){if(n.dtype===t.dtype)return[n,t];const e=Ds(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function LP(n){const t=[];return VP(n,t,new Set),t}function VP(n,t,e){if(null==n)return;if(n instanceof fn)return void t.push(n);if(!function nne(n){return Array.isArray(n)||"object"==typeof n}(n))return;const r=n;for(const s in r){const i=r[s];e.has(i)||(e.add(i),VP(i,t,e))}}function UE(n){return null!=n.kernelName}class BP{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}let rne=(()=>{class n{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new BP}ready(){var e=this;return ee(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const r=e.getSortedBackends();for(let s=0;s<r.length;s++){const i=r[s];if(yield e.initializeBackend(i).success)return void(yield e.setBackend(i))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:r}=this.initializeBackend(e);if(r)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,s=1){return e in this.registryFactory?(Zs(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:s},!0)}setBackend(e){var r=this;return ee(function*(){if(null==r.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(r.backendName=e,null==r.registry[e]){r.backendInstance=null;const{success:s,asyncInit:i}=r.initializeBackend(e);if(!(i?yield s:s))return!1}return r.backendInstance=r.registry[e],r.setupRegisteredKernels(),r.profiler=new Wte(r.backendInstance),!0})()}setupRegisteredKernels(){$E(this.backendName).forEach(r=>{null!=r.setupFunc&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){$E(e).forEach(s=>{null!=s.disposeFunc&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const r=this.registryFactory[e];if(null==r)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=r.factory();if(!s||s instanceof _S||"function"!=typeof s.then)return this.registry[e]=s,{success:!0,asyncInit:!1};{const i=++this.pendingBackendInitId,o=s.then(a=>!(i<this.pendingBackendInitId||(this.registry[e]=a,this.pendingBackendInit=null,0))).catch(a=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,Zs(`Initialization of backend ${e} failed`),Zs(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}}catch(s){return Zs(`Initialization of backend ${e} failed`),Zs(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let r=0;r<e.length;r++){const s=e[r],{success:i,asyncInit:o}=this.initializeBackend(s);if(o||i)return{name:s,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){const s=this.state.tensorInfo.get(r),i=s.backend,o=this.readSync(r),a=i.refCount(r);i.disposeData(r,!0),s.backend=e,e.move(r,o,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let i,s=null;if(null==r){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");r=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof r)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(i),()=>(i=r(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,r,s){e();try{const i=s();return r(),i}catch(i){throw r(),i}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(e){const r=R.runKernel(zf,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[r],a=>({x:()=>R.runKernel(Tf,{x:a},{dtype:"float32"})}),[],{}),r}runKernel(e,r,s){if(null==OE(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,s){const i=this.backend.numDataIds();let o=0;s.forEach(c=>{o+="complex64"===c.dtype?3:1});const l=i-r-o-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let r,s=[];const i=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;let l,c;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const u=UE(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(UE(e)){const{kernelName:m,inputs:g,attrs:y}=e,b=OE(m,this.backendName);S(null!=b,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),l=()=>{const _=this.backend.numDataIds();c=b.kernelFunc({inputs:g,attrs:y,backend:this.backend});const v=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,_,v);const w=v.map(C=>null!=C.rank?C:this.makeTensorFromTensorInfo(C));if(i){const C=this.getTensorsForGradient(m,g,w);s=this.saveTensorsForBackwardMode(C)}return w}}else{const{forwardFunc:m}=e,g=y=>{!i||(s=y.map(b=>this.keep(this.clone(b))))};l=()=>{const y=this.backend.numDataIds();c=this.tidy(()=>m(this.backend,g));const b=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,y,b),b}}const{inputs:d,attrs:h}=e,f=UE(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(u,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),r=p.outputs):r=l()}),i&&this.addTapeNode(u,d,r,f,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(m=>null!=d[m]?d[m].shape:null),outputShapes:r.map(m=>m.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(c)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,r,s){const i=NP(e);if(null!=i){const o=i.inputsToSave||[],a=i.outputsToSave||[];let l;i.saveAllInputs?(S(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(r).map(u=>r[u])):l=o.map(u=>r[u]);const c=s.filter((u,d)=>a[d]);return l.concat(c)}return[]}makeTensor(e,r,s,i){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");i=i||this.backend;let o=e;"string"===(s=s||"float32")&&_f(e[0])&&(o=e.map(c=>Xa(c)));const a=i.write(o,r,s),l=new fn(r,s,a,this.nextTensorId());if(this.trackTensor(l,i),"string"===s){const c=this.state.tensorInfo.get(a),u=function Ete(n){if(null==n)return 0;let t=0;return n.forEach(e=>t+=e.length),t}(o);this.state.numBytes+=u-c.bytes,c.bytes=u}return l}makeTensorFromDataId(e,r,s,i){return this.makeTensorFromTensorInfo({dataId:e,shape:r,dtype:s=s||"float32"},i)}makeTensorFromTensorInfo(e,r){const{dataId:s,shape:i,dtype:o}=e,a=new fn(i,o,s,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(e,r=!0,s,i){s=s||this.nextVariableId().toString(),null!=i&&i!==e.dtype&&(e=e.cast(i));const o=new Wb(e,r,s,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,r){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let s=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(s=e.size*wS(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof Wb||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const s=e.size*wS(e.dtype);this.state.numBytes-=s}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var r=this;return ee(function*(){r.state.profiling=!0;const s=r.state.numBytes,i=r.state.numTensors;r.state.activeProfile.kernels=[],r.state.activeProfile.result=yield e(),r.state.profiling=!1,r.state.activeProfile.peakBytes=Math.max(...r.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),r.state.activeProfile.newBytes=r.state.numBytes-s,r.state.activeProfile.newTensors=r.state.numTensors-i;for(const o of r.state.activeProfile.kernels)o.kernelTimeMs=yield o.kernelTimeMs,o.extraInfo=yield o.extraInfo;return r.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,r,s,i,o,a){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:s,saved:o},c=NP(e);null!=c&&(i=c.gradFunc),null!=i&&(l.gradient=u=>(u=u.map((d,h)=>{if(null==d){const f=s[h],p=$r(f.size,f.dtype);return this.makeTensor(p,f.shape,f.dtype)}return d}),i(u.length>1?u:u[0],o,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){const r=LP(e),s=new Set(r.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const a=this.state.activeScope.track[o];!a.kept&&!s.has(a.id)&&a.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(o=>{!o.kept&&o.scopeId===i.id&&this.track(o)})}gradients(e,r,s,i=!1){if(S(r.length>0,()=>"gradients() received an empty list of xs."),null!=s&&"float32"!==s.dtype)throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));S(o instanceof fn,()=>"The result y returned by f() must be a tensor.");const a=function qte(n,t,e){const r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const d in u){const h=u[d];let f=!1;for(let p=0;p<t.length;p++)if(r[h.id]){c.outputs.forEach(m=>r[m.id]=!0),f=!0,s[c.id]=!0;break}if(f)break}}const i={};i[e.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let d=0;d<c.outputs.length;d++)if(i[c.outputs[d].id]){for(const h in u)i[u[h].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(s[c.id]&&o[c.id]){const u={};for(const h in c.inputs){const f=c.inputs[h];r[f.id]&&(u[h]=f)}const d=Object.assign({},c);d.inputs=u,d.outputs=c.outputs,a.push(d)}}return a}(this.state.activeTape,r,o);if(!i&&0===a.length&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[o.id]=s??function sne(n){const t=IS(X(n),"float32");return R.makeTensor(t,n,"float32")}(o.shape),function Kte(n,t,e,r){for(let s=t.length-1;s>=0;s--){const i=t[s],o=[];if(i.outputs.forEach(l=>{const c=n[l.id];o.push(null!=c?c:null)}),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=e(()=>a[l]());if("float32"!==c.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=i.inputs[l];if(!It(c.shape,u.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(null==n[u.id])n[u.id]=c;else{const d=n[u.id];n[u.id]=r(d,c),d.dispose()}}}}(l,a,u=>this.tidy(u),ine);const c=r.map(u=>l[u.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(u=>{for(const d of u.saved)d.dispose()}),this.state.activeTape=null),{value:o,grads:c}})}customGrad(e){return S(SS(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{let s;S(r.every(l=>l instanceof fn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const i={};return r.forEach((l,c)=>{i[c]=l}),this.runKernelFunc({forwardFunc:(l,c)=>(s=e(...r,c),S(s.value instanceof fn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),S(SS(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),backwardsFunc:(l,c)=>{const u=s.gradFunc(l,c),d=Array.isArray(u)?u:[u];S(d.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),S(d.every(f=>f instanceof fn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return d.forEach((f,p)=>{h[p]=()=>f}),h},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,r){return this.state.tensorInfo.get(e).backend.readToGPU(e,r)}time(e){var r=this;return ee(function*(){const s=us(),i=yield r.backend.time(e);return i.wallMs=us()-s,i})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new BP;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();function zP(){const n=kP();if(null==n._tfengine){const t=new Dte(n);n._tfengine=new rne(t)}return function Ate(n){TP=n}(n._tfengine.ENV),function Zte(n){ro=n}(()=>n._tfengine),n._tfengine}const R=zP();function ine(n,t){return R.runKernel(Yu,{a:n,b:t})}function UP(n){if(n||function one(){return typeof navigator<"u"&&null!=navigator}()){if(n||(n=navigator),"ReactNative"===n.product)return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function HP(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}const Qs=j();function Za(n,t){let e=n;if(Do(n))return"string"===t?[]:[n.length];if("object"==typeof n&&"texture"in n)return[n.height,n.width*(n.channels||"RGBA").length];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(e)||Do(e)&&"string"!==t;)r.push(e.length),e=e[0];return Array.isArray(n)&&j().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&WP(n,r,[]),r}function WP(n,t,e){if(e=e||[],!Array.isArray(n)&&!Do(n))return void S(0===t.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);S(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),S(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const r=t.slice(1);for(let s=0;s<n.length;++s)WP(n[s],r,e.concat(s))}function jP(n,t,e,r){if("string_or_numeric"!==n){if(null==n)throw new Error("Expected dtype cannot be null.");if("numeric"!==n&&n!==t||"numeric"===n&&"string"===t)throw new Error(`Argument '${e}' passed to '${r}' must be ${n} tensor, but got ${t} tensor`)}}function E(n,t,e,r="numeric"){if(n instanceof fn)return jP(r,n.dtype,t,e),n;let s=vf(n);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),jP(r,s,t,e),null==n||!Do(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==n?"null":n.constructor.name}'`);const i=Za(n,s);!Do(n)&&!Array.isArray(n)&&(n=[n]);const a="string"!==s?ac(n,s):ju(n,[],!0);return R.makeTensor(a,i,s)}function Xb(n,t,e,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>E(i,`${t}[${o}]`,e,r))}Qs.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Qs.registerFlag("IS_BROWSER",()=>HP()),Qs.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),Qs.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Qs.registerFlag("PROD",()=>!1),Qs.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Qs.getBool("DEBUG")),Qs.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Qs.registerFlag("IS_TEST",()=>!1),Qs.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),Qs.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),Qs.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),Qs.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const GP="__op";function A(n){const t=Object.keys(n);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const r=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+=GP;const s=(...i)=>{R.startScope(e);try{const o=r(...i);return Xu(o)&&console.error("Cannot return a Promise inside of tidy."),R.endScope(o),o}catch(o){throw R.endScope(null),o}};return Object.defineProperty(s,"name",{value:e,configurable:!0}),s}const Qa=A({complex_:function ane(n,t){const e=E(n,"real","complex"),r=E(t,"imag","complex");return Is(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`),R.runKernel(OS,{real:e,imag:r})}});function Ja(n,t,e,r){if(null==r&&(r=vf(n)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if("object"==typeof n&&"texture"in n){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from texture only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return n.channels=n.channels||"RGBA",R.backend.createTensorFromTexture(n,t||e,r)}if(!Do(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Ys(t);const s=X(t),i=X(e);S(s===i,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${i}`);for(let o=0;o<e.length;++o){const a=e[o],l=o!==e.length-1||a!==X(t.slice(o));S(e[o]===t[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!Do(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n="string"!==r?ac(n,r):ju(n,[],!0),R.makeTensor(n,t,r)}function so(n,t,e){return Ja(n,t,Za(n,e),e)}const WE={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};function jE(n,t){return GE.apply(this,arguments)}function GE(){return GE=ee(function*(n,t){const e=[],r=[],s=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<s.length;++o){const a=s[o],l=Array.isArray(n)?n[o].tensor:n[a];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const u=new Promise(function(){var d=ee(function*(h){const f=yield l.bytes(),p=f.reduce((y,b)=>y+b.length,0)+4*f.length,m=new Uint8Array(p);let g=0;for(let y=0;y<f.length;y++){const b=f[y],_=new Uint8Array(new Uint32Array([b.length]).buffer);m.set(_,g),g+=4,m.set(b,g),g+=b.length}h(m)});return function(h){return d.apply(this,arguments)}}());r.push(u)}else r.push(l.data());null!=t&&(c.group=t),e.push(c)}return{data:lne(yield Promise.all(r)),specs:e}}),GE.apply(this,arguments)}function qP(n,t){const e={};let r,s=0;for(const i of t){const o=i.name,a=i.dtype,l=i.shape,c=X(l);let u;if("quantization"in i){const d=i.quantization;if("uint8"===d.dtype||"uint16"===d.dtype){if(!("min"in d)||!("scale"in d))throw new Error(`Weight ${i.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==d.dtype)throw new Error(`Weight ${i.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${i.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${a}.`)}const h=WE[d.dtype],f=n.slice(s,s+c*h),p="uint8"===d.dtype?new Uint8Array(f):new Uint16Array(f);if("float32"===a)if("uint8"===d.dtype||"uint16"===d.dtype){u=new Float32Array(p.length);for(let m=0;m<p.length;m++)u[m]=p[m]*d.scale+d.min}else{if("float16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);void 0===r&&(r=pne()),u=r(p)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${o}': ${a}`);if("uint8"!==d.dtype&&"uint16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);u=new Int32Array(p.length);for(let m=0;m<p.length;m++)u[m]=Math.round(p[m]*d.scale+d.min)}s+=c*h}else if("string"===a){const d=X(i.shape);u=[];for(let h=0;h<d;h++){const f=new Uint32Array(n.slice(s,s+4))[0];s+=4;const p=new Uint8Array(n.slice(s,s+f));u.push(p),s+=f}}else{const d=WE[a],h=n.slice(s,s+c*d);if("float32"===a)u=new Float32Array(h);else if("int32"===a)u=new Int32Array(h);else if("bool"===a)u=new Uint8Array(h);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${o}': ${a}`);{u=new Float32Array(h);const f=new Float32Array(u.length/2),p=new Float32Array(u.length/2);for(let y=0;y<f.length;y++)f[y]=u[2*y],p[y]=u[2*y+1];const m=so(f,l,"float32"),g=so(p,l,"float32");e[o]=Qa(m,g),m.dispose(),g.dispose()}}s+=c*d}"complex64"!==a&&(e[o]=so(u,l,a))}return e}function lne(n){if(null===n)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(i=>{if(t+=i.byteLength,e.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const r=new Uint8Array(t);let s=0;return e.forEach(i=>{r.set(new Uint8Array(i.buffer),s),s+=i.byteLength}),r.buffer}const qE=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function KP(n){return qE?Buffer.byteLength(n):new Blob([n]).size}function Zb(n){if(1===n.length)return n[0];let t=0;n.forEach(s=>{t+=s.byteLength});const e=new Uint8Array(t);let r=0;return n.forEach(s=>{e.set(new Uint8Array(s),r),r+=s.byteLength}),e.buffer}function XP(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const e=n.split("/");return e[e.length-1]}function YP(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return null!=n.signature&&(e.signature=n.signature),null!=n.userDefinedMetadata&&(e.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(e.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(e.initializerSignature=n.initializerSignature),null!=n.trainingConfig&&(e.trainingConfig=n.trainingConfig),e}function ZP(n,t,e){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(null!=n.trainingConfig&&(r.trainingConfig=n.trainingConfig),null!=n.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=e}return null!=n.signature&&(r.signature=n.signature),null!=n.userDefinedMetadata&&(r.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(r.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(r.initializerSignature=n.initializerSignature),r}function KE(n,t){return XE.apply(this,arguments)}function XE(){return(XE=ee(function*(n,t){let e,r;return null!=n.weightsManifest&&([e,r]=yield t(n.weightsManifest)),ZP(n,e,r)})).apply(this,arguments)}function vp(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==n.modelTopology?0:KP(JSON.stringify(n.modelTopology)),weightSpecsBytes:null==n.weightSpecs?0:KP(JSON.stringify(n.weightSpecs)),weightDataBytes:null==n.weightData?0:n.weightData.byteLength}}function QP(n){const t=[];for(const e of n)t.push(...e.weights);return t}function pne(){const n=function dne(){const n=e=>{let r=e<<13,s=0;for(;0==(8388608&r);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function hne(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}(),e=function fne(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}();return r=>{const s=new ArrayBuffer(4*r.length),i=new Uint32Array(s);for(let o=0;o<r.length;o++){const a=r[o];i[o]=n[e[a>>10]+(1023&a)]+t[a>>10]}return new Float32Array(s)}}class Sn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Sn.instance&&(Sn.instance=new Sn),Sn.instance}static registerSaveRouter(t){Sn.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Sn.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Sn.getHandlers(t,"save")}static getLoadHandlers(t,e){return Sn.getHandlers(t,"load",e)}static getHandlers(t,e,r){const s=[];return("load"===e?Sn.getInstance().loadRouters:Sn.getInstance().saveRouters).forEach(o=>{const a=o(t,r);null!==a&&s.push(a)}),s}}const mne=n=>Sn.registerSaveRouter(n),gne=n=>Sn.registerLoadRouter(n),JP=n=>Sn.getSaveHandlers(n),yne=(n,t)=>Sn.getLoadHandlers(n,t),Qb="tensorflowjs",lc="models_store",el="model_info_store";function QE(){if(!j().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function JE(n){const t=n.result;t.createObjectStore(lc,{keyPath:"modelPath"}),t.createObjectStore(el,{keyPath:"modelPath"})}let ed=(()=>{class n{constructor(e){if(this.indexedDB=QE(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var r=this;return ee(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return r.databaseAction(r.modelPath,e)})()}load(){var e=this;return ee(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,r){return new Promise((s,i)=>{const o=this.indexedDB.open(Qb,1);o.onupgradeneeded=()=>JE(o),o.onsuccess=()=>{const a=o.result;if(null==r){const l=a.transaction(lc,"readonly"),u=l.objectStore(lc).get(this.modelPath);u.onsuccess=()=>{if(null==u.result)return a.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(u.result.modelArtifacts)},u.onerror=d=>(a.close(),i(u.error)),l.oncomplete=()=>a.close()}else{const l=vp(r),c=a.transaction(el,"readwrite");let u=c.objectStore(el);const d=u.put({modelPath:this.modelPath,modelArtifactsInfo:l});let h;d.onsuccess=()=>{h=a.transaction(lc,"readwrite");const p=h.objectStore(lc).put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l});p.onsuccess=()=>s({modelArtifactsInfo:l}),p.onerror=m=>{u=c.objectStore(el);const g=u.delete(this.modelPath);g.onsuccess=()=>(a.close(),i(p.error)),g.onerror=y=>(a.close(),i(p.error))}},d.onerror=f=>(a.close(),i(d.error)),c.oncomplete=()=>{null==h?a.close():h.oncomplete=()=>a.close()}}},o.onerror=a=>i(o.error)})}}return n.URL_SCHEME="indexeddb://",n})();const eL=n=>j().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ed.URL_SCHEME)?function bne(n){return new ed(n)}(n.slice(ed.URL_SCHEME.length)):null;Sn.registerSaveRouter(eL),Sn.registerLoadRouter(eL);class vne{constructor(){this.indexedDB=QE()}listModels(){var t=this;return ee(function*(){return new Promise((e,r)=>{const s=t.indexedDB.open(Qb,1);s.onupgradeneeded=()=>JE(s),s.onsuccess=()=>{const i=s.result,o=i.transaction(el,"readonly"),l=o.objectStore(el).getAll();l.onsuccess=()=>{const c={};for(const u of l.result)c[u.modelPath]=u.modelArtifactsInfo;e(c)},l.onerror=c=>(i.close(),r(l.error)),o.oncomplete=()=>i.close()},s.onerror=i=>r(s.error)})})()}removeModel(t){var e=this;return ee(function*(){return t=function _ne(n){return n.startsWith(ed.URL_SCHEME)?n.slice(ed.URL_SCHEME.length):n}(t),new Promise((r,s)=>{const i=e.indexedDB.open(Qb,1);i.onupgradeneeded=()=>JE(i),i.onsuccess=()=>{const o=i.result,a=o.transaction(el,"readwrite"),l=a.objectStore(el),c=l.get(t);let u;c.onsuccess=()=>{if(null==c.result)return o.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const d=l.delete(t),h=()=>{u=o.transaction(lc,"readwrite");const p=u.objectStore(lc).delete(t);p.onsuccess=()=>r(c.result.modelArtifactsInfo),p.onerror=m=>s(c.error)};d.onsuccess=h,d.onerror=f=>(h(),o.close(),s(c.error))}},c.onerror=d=>(o.close(),s(c.error)),a.oncomplete=()=>{null==u?o.close():u.oncomplete=()=>o.close()}},i.onerror=o=>s(i.error)})})()}}const ko="/",cc="tensorflowjs_models",tL="info",xne="model_topology",wne="weight_specs",Cne="weight_data",Sne="model_metadata";function nL(n){return{info:[cc,n,tL].join(ko),topology:[cc,n,xne].join(ko),weightSpecs:[cc,n,wne].join(ko),weightData:[cc,n,Cne].join(ko),modelMetadata:[cc,n,Sne].join(ko)}}function rL(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function sL(n){const t=n.split(ko);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(ko)}let td=(()=>{class n{constructor(e){if(!j().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=nL(this.modelPath)}save(e){var r=this;return ee(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(e.modelTopology),i=JSON.stringify(e.weightSpecs),o=vp(e);try{return r.LS.setItem(r.keys.info,JSON.stringify(o)),r.LS.setItem(r.keys.topology,s),r.LS.setItem(r.keys.weightSpecs,i),r.LS.setItem(r.keys.weightData,function cne(n){if(qE)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let r=0,s=t.length;r<s;r++)e+=String.fromCharCode(t[r]);return btoa(e)}(e.weightData)),r.LS.setItem(r.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0})),{modelArtifactsInfo:o}}catch{throw rL(r.keys),new Error(`Failed to save model '${r.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}})()}load(){var e=this;return ee(function*(){const r=JSON.parse(e.LS.getItem(e.keys.info));if(null==r)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==r.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const s={},i=JSON.parse(e.LS.getItem(e.keys.topology));if(null==i)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);s.modelTopology=i;const o=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==o)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);s.weightSpecs=o;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const c=JSON.parse(a);s.format=c.format,s.generatedBy=c.generatedBy,s.convertedBy=c.convertedBy,null!=c.signature&&(s.signature=c.signature),null!=c.userDefinedMetadata&&(s.userDefinedMetadata=c.userDefinedMetadata),null!=c.modelInitializer&&(s.modelInitializer=c.modelInitializer),null!=c.initializerSignature&&(s.initializerSignature=c.initializerSignature),null!=c.trainingConfig&&(s.trainingConfig=c.trainingConfig)}const l=e.LS.getItem(e.keys.weightData);if(null==l)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return s.weightData=function une(n){if(qE){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let r=0;r<t.length;++r)e.set([t.charCodeAt(r)],r);return e.buffer}(l),s})()}}return n.URL_SCHEME="localstorage://",n})();const iL=n=>j().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(td.URL_SCHEME)?function Ine(n){return new td(n)}(n.slice(td.URL_SCHEME.length)):null;Sn.registerSaveRouter(iL),Sn.registerLoadRouter(iL);class Dne{constructor(){S(j().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),S(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var t=this;return ee(function*(){const e={},r=cc+ko,s=ko+tL;for(let i=0;i<t.LS.length;++i){const o=t.LS.key(i);o.startsWith(r)&&o.endsWith(s)&&(e[sL(o)]=JSON.parse(t.LS.getItem(o)))}return e})()}removeModel(t){var e=this;return ee(function*(){const r=nL(t=function Ene(n){return n.startsWith(td.URL_SCHEME)?n.slice(td.URL_SCHEME.length):n}(t));if(null==e.LS.getItem(r.info))throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(e.LS.getItem(r.info));return rL(r),s})()}}const nd="://";class qr{constructor(){this.managers={}}static getInstance(){return null==qr.instance&&(qr.instance=new qr),qr.instance}static registerManager(t,e){S(null!=t,()=>"scheme must not be undefined or null."),t.endsWith(nd)&&(t=t.slice(0,t.indexOf(nd))),S(t.length>0,()=>"scheme must not be an empty string.");const r=qr.getInstance();S(null==r.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=e}static getManager(t){const e=qr.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(qr.getInstance().managers)}}function Jb(n){if(-1===n.indexOf(nd))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${qr.getSchemes().join(",")}`);return{scheme:n.split(nd)[0],path:n.split(nd)[1]}}function oL(n,t){return eI.apply(this,arguments)}function eI(){return(eI=ee(function*(n,t,e=!1){S(n!==t,()=>`Old path and new path are the same: '${n}'`);const r=Sn.getLoadHandlers(n);S(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),S(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const s=r[0],i=Sn.getSaveHandlers(t);S(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),S(i.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);const o=i[0],a=Jb(n).scheme,l=Jb(n).path,c=a===Jb(n).scheme,u=yield s.load();e&&c&&(yield qr.getManager(a).removeModel(l));const d=yield o.save(u);return e&&!c&&(yield qr.getManager(a).removeModel(l)),d.modelArtifactsInfo})).apply(this,arguments)}function Tne(){return tI.apply(this,arguments)}function tI(){return(tI=ee(function*(){const n=qr.getSchemes(),t={};for(const e of n){const r=yield qr.getManager(e).listModels();for(const s in r)t[e+nd+s]=r[s]}return t})).apply(this,arguments)}function kne(n){return nI.apply(this,arguments)}function nI(){return(nI=ee(function*(n){const t=Jb(n);return qr.getManager(t.scheme).removeModel(t.path)})).apply(this,arguments)}function Nne(n,t){return rI.apply(this,arguments)}function rI(){return(rI=ee(function*(n,t){return oL(n,t,!1)})).apply(this,arguments)}function Ane(n,t){return sI.apply(this,arguments)}function sI(){return(sI=ee(function*(n,t){return oL(n,t,!0)})).apply(this,arguments)}class Rne{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){typeof window>"u"||!j().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(t,e):(this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{r.source===window&&r.data.name===this.messageName&&(r.stopPropagation(),(0,this.functionRefs[r.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}}if(j().get("IS_BROWSER")){j().setPlatform("browser",new Rne);try{qr.registerManager(td.URL_SCHEME,new Dne)}catch{}try{qr.registerManager(ed.URL_SCHEME,new vne)}catch{}}let rd;function it(n,t="float32",e){return t=t||"float32",Ys(n),new br(n,t,e)}j().get("IS_NODE")&&!j().get("IS_BROWSER")&&j().setPlatform("node",new class Fne{constructor(){this.util=Z(628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=j().global.fetch?j().global.fetch(t,e):(null==rd&&(rd=Z(410)),rd(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const ve=A({cast_:function One(n,t){const e=E(n,"x","cast");if(!function Ste(n){return"bool"===n||"complex64"===n||"float32"===n||"int32"===n||"string"===n}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==e.dtype||"string"!==t&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return R.runKernel(Tf,{x:e},{dtype:t})}}),ha=A({clone_:function $ne(n){const e={x:E(n,"x","clone","string_or_numeric")};return R.runKernel(zf,e)}});function aL(n,t=!1){console.log(n.toString(t))}function lL(n){return new Promise(t=>setTimeout(t)).then(n)}zP(),function Qte(n){Ju=n}({buffer:it,cast:ve,clone:ha,print:aL});let iI=(()=>{class n{constructor(e){if(!j().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(n.URL_SCHEME)&&(e=e.slice(n.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var r=this;return ee(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const s=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const o=YP(e,[{paths:["./"+r.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),l=r.modelJsonAnchor??document.createElement("a");if(l.download=r.modelJsonFileName,l.href=a,yield lL(()=>l.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const c=r.weightDataAnchor??document.createElement("a");c.download=r.weightDataFileName,c.href=s,yield lL(()=>c.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:vp(e)}}})()}}return n.URL_SCHEME="downloads://",n})();class Bne{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}load(){var t=this;return ee(function*(){return new Promise((e,r)=>{const s=new FileReader;s.onload=i=>{const o=JSON.parse(i.target.result),a=o.modelTopology;if(null==a)return void r(new Error(`modelTopology field is missing from file ${t.jsonFile.name}`));if(null==o.weightsManifest)return void r(new Error(`weightManifest field is missing from file ${t.jsonFile.name}`));if(0===t.weightsFiles.length)return void e({modelTopology:a});const c=KE(o,u=>t.loadWeights(u));e(c)},s.onerror=i=>r(`Failed to read model topology and weights manifest JSON from file '${t.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(t.jsonFile)})})()}loadWeights(t){const e=[],r=[];for(const o of t)e.push(...o.weights),r.push(...o.paths);const s=this.checkManifestAndWeightFiles(t),i=r.map(o=>this.loadWeightsFile(o,s[o]));return Promise.all(i).then(o=>[e,Zb(o)])}loadWeightsFile(t,e){return new Promise((r,s)=>{const i=new FileReader;i.onload=o=>{r(o.target.result)},i.onerror=o=>s(`Failed to weights data from file of path '${t}'.`),i.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],r=this.weightsFiles.map(i=>XP(i.name)),s={};for(const i of t)i.paths.forEach(o=>{const a=XP(o);if(-1!==e.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),-1===r.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);s[o]=this.weightsFiles[r.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}function Hne(n){return new Bne(n)}function cL(n,t,e,r){(function o(l){S(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(n),function a(l,c){S(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),S(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),S(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}(e=e??0,r=r??1);let s=0;return Promise.all(n.map(l=>(l.then(c=>{const u=e+ ++s/n.length*(r-e);return t(u),c}),l)))}function uL(n,t){return oI.apply(this,arguments)}function oI(){return(oI=ee(function*(n,t){null==t&&(t={});const e=t.fetchFunc??j().platform.fetch,r=n.map(d=>e(d,t.requestInit,{isBinary:!0})),a=(null==t.onProgress?yield Promise.all(r):yield cL(r,t.onProgress,0,.5)).map(d=>d.arrayBuffer());return null==t.onProgress?yield Promise.all(a):yield cL(a,t.onProgress,.5,1)})).apply(this,arguments)}function Wne(n){return aI.apply(this,arguments)}function aI(){return(aI=ee(function*(n,t="",e,r){return dL(o=>uL(o,{requestInit:r}))(n,t,e)})).apply(this,arguments)}function dL(n){return function(){var t=ee(function*(e,r="",s){const i=e.map(()=>!1),o={},a=null!=s?s.map(()=>!1):[],l=[];if(e.forEach((p,m)=>{let g=0;p.weights.forEach(y=>{const _=WE["quantization"in y?y.quantization.dtype:y.dtype]*X(y.shape),v=()=>{i[m]=!0,null==o[m]&&(o[m]=[]),o[m].push({manifestEntry:y,groupOffset:g,sizeBytes:_})};null!=s?s.forEach((w,C)=>{w===y.name&&(v(),a[C]=!0)}):v(),l.push(y.name),g+=_})}),!a.every(p=>p)){const p=s.filter((m,g)=>!a[g]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. \nManifest JSON has weights with names: ${l.join(", ")}.`)}const c=i.reduce((p,m,g)=>(m&&p.push(g),p),[]),u=[];c.forEach(p=>{e[p].paths.forEach(m=>{const g=r+(r.endsWith("/")?"":"/")+m;u.push(g)})});const d=yield n(u),h={};let f=0;return c.forEach(p=>{const m=e[p].paths.length;let g=0;for(let w=0;w<m;w++)g+=d[f+w].byteLength;const y=new ArrayBuffer(g),b=new Uint8Array(y);let _=0;for(let w=0;w<m;w++){const C=new Uint8Array(d[f+w]);b.set(C,_),_+=C.byteLength}o[p].forEach(w=>{const I=qP(y.slice(w.groupOffset,w.groupOffset+w.sizeBytes),[w.manifestEntry]);for(const D in I)h[D]=I[D]}),f+=m}),h});return function(e){return t.apply(this,arguments)}}()}Sn.registerSaveRouter(n=>j().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(iI.URL_SCHEME)?function Une(n="model"){return new iI(n)}(n.slice(iI.URL_SCHEME.length)):null);let hL=(()=>{class n{constructor(e,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.onProgress=r.onProgress,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?(S("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=j().platform.fetch,S(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&S(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{}}save(e){var r=this;return ee(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const s=Object.assign({method:r.DEFAULT_METHOD},r.requestInit);s.body=new FormData;const o=YP(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);s.body.append("model.json",new Blob([JSON.stringify(o)],{type:"application/json"}),"model.json"),null!=e.weightData&&s.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=yield r.fetch(r.path,s);if(a.ok)return{modelArtifactsInfo:vp(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})()}load(){var e=this;return ee(function*(){const r=yield e.fetch(e.path,e.requestInit);if(!r.ok)throw new Error(`Request to ${e.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let s;try{s=yield r.json()}catch{let l=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?l+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":l+=" Please make sure the server is serving valid JSON for this request.",new Error(l)}if(null==s.modelTopology&&null==s.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return KE(s,a=>e.loadWeights(a))})()}loadWeights(e){var r=this;return ee(function*(){const s=Array.isArray(r.path)?r.path[1]:r.path,[i,o]=function qne(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?");return[n.substring(0,t)+"/",e>t?n.substring(e):""]}(s),a=r.weightPathPrefix||i,l=QP(e),c=[],u=[];for(const h of e)for(const f of h.paths)null!=r.weightUrlConverter?u.push(r.weightUrlConverter(f)):c.push(a+f+o);return r.weightUrlConverter&&c.push(...yield Promise.all(u)),[l,Zb(yield uL(c,{requestInit:r.requestInit,fetchFunc:r.fetch,onProgress:r.onProgress}))]})()}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();function lI(n){return null!=n.match(hL.URL_SCHEME_REGEX)}const fL=(n,t)=>{if(typeof fetch>"u"&&(null==t||null==t.fetchFunc))return null;{let e=!0;if(e=Array.isArray(n)?n.every(r=>lI(r)):lI(n),e)return cI(n,t)}return null};function cI(n,t){return new hL(n,t)}function Kne(n,t){return cI(n,t)}Sn.registerSaveRouter(fL),Sn.registerLoadRouter(fL);class uI{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class pL{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class Xne{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function Yne(n,t,e,r){const s=arguments;return new Xne(mL(...s))}function mL(n,t,e,r){return 1===arguments.length?null!=n.modelTopology||null!=n.weightSpecs?new uI(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new uI({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new uI({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:r}))}function Zne(n){return new pL(n)}function Qne(n){return new pL(n)}function sd(n,t){const e=n.length,r=[];for(let s=0;s<e;s++){const i=e-1-s,o=n[i]||1;(t[t.length-1-s]||1)>1&&1===o&&r.unshift(i)}return r}function nr(n,t){const e=[];for(let r=0;r<t.length;r++){const s=n[n.length-r-1],i=t.length-r-1,o=t[i];(null==s||1===s&&o>1)&&e.unshift(i)}return e}function Je(n,t){const e=[],r=Math.max(n.length,t.length);for(let s=0;s<r;s++){let i=n[n.length-s-1];null==i&&(i=1);let o=t[t.length-s-1];if(null==o&&(o=1),1===i)e.unshift(o);else if(1===o)e.unshift(i);else{if(i!==o)throw Error(`Operands could not be broadcast together with shapes ${n} and ${t}.`);e.unshift(i)}}return e}function gL(n,t,e){if(Wu(n),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Za(n,e);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Ja(n,t,r,e)}let uc;const rre=A({fromPixels_:function yL(n,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==n)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,r=!1,s=!1,i=!1,o=!1,a=!1;if(n.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)i=!0;else if(null!=n.getContext)o=!0;else{if(!(typeof ImageBitmap<"u"&&n instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);a=!0}if(null!=OE(ME,R.backendName))return R.runKernel(ME,{pixels:n},{numChannels:t});const[c,u]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let d,h;if(o)d=n.getContext("2d").getImageData(0,0,c,u).data;else if(r||e)d=n.data;else if(i||s||a){if(null==uc)if(typeof document>"u"){if(!(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u"))throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");uc=new OffscreenCanvas(1,1).getContext("2d")}else uc=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});uc.canvas.width=c,uc.canvas.height=u,uc.drawImage(n,0,0,c,u),d=uc.getImageData(0,0,c,u).data}if(4===t)h=new Int32Array(d);else{const p=c*u;h=new Int32Array(p*t);for(let m=0;m<p;m++)for(let g=0;g<t;++g)h[m*t+g]=d[4*m+g]}return gL(h,[u,c,t],"int32")}});function pI(n,t,e){const r=n.shape.length;S(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),S(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)S(t[s]+e[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+e[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function ire(n){const t=[];let e=0;for(;n>0;)1&n&&t.push(e),n/=2,e++;return t}function mI(n,t,e){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((t[s]-n[s])/e[s]);return r}function bL(n,t,e,r){const s=[...n];for(let i=s.length;i<r.length;i++)s.push(1);for(let i=0;i<e;i++)0===i?s[t]=1:(s.splice(t,0,1),s.pop());return s}function _L(n,t,e){return e<=n?e:e-(t-1)}function vL(n,t){const e=[];for(let r=0;r<n;r++)e.push(t+r);return e}function ore(n,t,e,r,s,i,o,a,l){const c=n.length;let u=new Array(c),d=new Array(c),h=new Array(c);if(t.length&&e>0){const f=t[0],p=e+1;u=xL(o,f,p,r,n),d=wL(a,f,p,s,n),h=bL(i,f,p,n)}else for(let f=0;f<c;f++)u[f]=SL(o,r,i,n,f,l),d[f]=EL(a,s,i,n,f,l),h[f]=CL(i,f,l);return{begin:u,end:d,strides:h}}function xL(n,t,e,r,s){const i=[...s],o=vL(e,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=_L(t,e,a);let c=r[l];n&1<<l&&(c=0),i[a]=c}return i}function wL(n,t,e,r,s){const i=[...s],o=vL(e,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=_L(t,e,a);let c=r[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),i[a]=c}for(let a=0;a<i.length;a++){const l=s[a];i[a]<0&&(i[a]+=l),i[a]=sc(0,i[a],s[a])}return i}function CL(n,t,e){let r=n[t];return(e&1<<t||null==r)&&(r=1),r}function SL(n,t,e,r,s,i){let o=t[s];(n&1<<s||i&1<<s||null==o)&&(o=(e[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=sc(0,o,l-1),o}function EL(n,t,e,r,s,i){let o=t[s];const a=e[s]||1;(n&1<<s||i&1<<s||null==o)&&(o=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=a>0?sc(0,o,l):sc(-1,o,l-1),o}function gI(n,t,e){let r=e.length;for(let s=0;s<e.length;s++)if(e[s]>1){r=s;break}for(let s=r+1;s<e.length;s++)if(t[s]>0||e[s]!==n[s])return!1;return!0}function yI(n,t){let e=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)e+=n[r]*t[r];return e}function e_(n,t,e){let r;const s=n.shape.length;let i;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach(o=>{S(-1!==o,()=>"slice() does not support negative begin indexing.")}),i=null==e?new Array(s).fill(-1):"number"==typeof e?[e,...new Array(s-1).fill(-1)]:e.length<s?e.concat(new Array(s-e.length).fill(-1)):e,i=i.map((o,a)=>o>=0?o:(S(-1===o,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,i]}function bI(n,t,e,r,s,i,o,a,l){let c;if(null==r?(c=new Array(t.length),c.fill(1)):c=r,null!=o&&0!=(o&o-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const d={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:c.slice(),beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let _=0;_<d.dims;_++)u&&0!=(1<<_&a)&&d.numAddAxisAfterEllipsis++,1<<_&o&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function are(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=null!=n.begin,t.endValid=null!=n.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(t.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<s;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&n.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=n.begin&&(t.begin[e]=n.begin[r]),null!=n.end&&(t.end[e]=n.end[r]),t.strides[e]=n.strides[r],n.beginMask&1<<r&&(t.beginMask|=1<<e),n.endMask&1<<r&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[e]=r,e++}}(d,h);let f=!0,p=!0,m=!0;const g=[],y=[];for(let _=0;_<n.length;++_){if(0===h.strides[_])throw Error(`strides[${_}] must be non-zero`);const v=!!(h.shrinkAxisMask&1<<_),w=n[_];if(-1===w){g.push(v?1:-1);continue}const C=[h.beginMask&1<<_,h.endMask&1<<_],I=[h.strides[_]>0?0:-1,h.strides[_]>0?w:w-1];if(v&&h.strides[_]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[_];const D=!!(h.beginMask&1<<_&&h.endMask&1<<_);if(h.beginValid&&h.endValid){if(v){const z=h.begin[_]<0?w+h.begin[_]:h.begin[_];if(h.begin[_]=z,h.end[_]=h.begin[_]+1,z<0||z>=w)throw Error(`slice index ${h.begin[_]} of dimension ${_} out of bounds.`)}else h.begin[_]=IL(h.begin[_],0,h.strides[_],w,C,I),h.end[_]=IL(h.end[_],1,h.strides[_],w,C,I);const P=1===h.strides[_]&&0===h.begin[_]&&h.end[_]===w;f=f&&P,p=p&&(0===_&&1===h.strides[_]||P)}else f=f&&1===h.strides[_]&&D,p=p&&(0===_&&1===h.strides[_]||D);let T,N=!1;if(h.beginValid&&h.endValid?(T=h.end[_]-h.begin[_],N=!0):v?(T=1,N=!0):D&&w>=0&&(T=h.strides[_]<0?-w:w,N=!0),N){let P;P=0===T||T<0!=h.strides[_]<0?0:Math.trunc(T/h.strides[_])+(T%h.strides[_]!=0?1:0),g.push(P)}else g.push(-1)}for(let _=0;_<h.finalShapeGatherIndices.length;++_){const v=h.finalShapeGatherIndices[_];v>=0?y.push(g[v]):-2===v&&y.push(1)}return{finalShapeSparse:y.filter((_,v)=>-2!==h.finalShapeGatherIndices[v]),finalShape:y,isIdentity:f,sliceDim0:p,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function IL(n,t,e,r,s,i){if(s[t])return e>0?i[t]:i[t+1&1];{const o=n<0?r+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}class id{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class Ei{constructor(){this.classNameMap={}}static getMap(){return null==Ei.instance&&(Ei.instance=new Ei),Ei.instance}static register(t){Ei.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function se(n){S(null!=n.className,()=>"Class being registered does not have the static className property defined."),S("string"==typeof n.className,()=>"className is required to be a string, but got type "+typeof n.className),S(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Ei.register(n)}function No(){return R}function _I(){return R.memory()}function B(n,t){return R.tidy(n,t)}function ot(n){LP(n).forEach(e=>e.dispose())}function _r(n){return R.keep(n)}function DL(n,t,e=1){return R.registerBackend(n,t,e)}function fa(n){return R.customGrad(n)}function Le(n,t){if((Do(n)&&"string"!==t||Array.isArray(n))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Do(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Ja(n,[],[],t)}!function Jte(n){PP=n}(function cre(n){j().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});class tl extends id{minimize(t,e=!1,r){const{value:s,grads:i}=this.computeGradients(t,r);if(null!=r){const o=r.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return ot(i),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function dre(n,t){S(SS(n),()=>"The f passed in variableGrads(f) must be a function"),S(null==t||Array.isArray(t)&&t.every(c=>c instanceof Wb),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=t;if(!e){t=[];for(const c in R.registeredVariables)t.push(R.registeredVariables[c])}const r=e?t.filter(c=>!c.trainable):null,s=t.length;S((t=t.filter(c=>c.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:o,grads:a}=R.gradients(n,t,null,!0);S(a.some(c=>null!=c),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),S(0===o.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return t.forEach((c,u)=>{null!=a[u]&&(l[c.name]=a[u])}),r?.forEach(c=>l[c.name]=null),{value:o,grads:l}}(t,e)}dispose(){null!=this.iterations_&&ot(this.iterations_)}saveIterations(){var t=this;return ee(function*(){return null==t.iterations_&&(t.iterations_=0),{name:"iter",tensor:Le(t.iterations_,"int32")}})()}getWeights(){return ee(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(t){var e=this;return ee(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(t){var e=this;return ee(function*(){return e.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})()}}Object.defineProperty(tl,Symbol.hasInstance,{value:n=>null!=n.minimize&&null!=n.computeGradients&&null!=n.applyGradients});const rr=A({abs_:function hre(n){const t=E(n,"x","abs");return R.runKernel("complex64"===t.dtype?jy:Py,{x:t})}}),TL=A({acos_:function fre(n){const e={x:E(n,"x","acos")};return R.runKernel(xf,e)}}),kL=A({acosh_:function pre(n){const e={x:E(n,"x","acosh")};return R.runKernel(wf,e)}}),le=A({add_:function mre(n,t){let e=E(n,"a","add"),r=E(t,"b","add");return[e,r]=Rn(e,r),R.runKernel(Yu,{a:e,b:r})}}),yre=A({addN_:function gre(n){S(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),S(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const t=n.map((s,i)=>E(s,`tensors${i}`,"addN")),e=t[0];return t.forEach(s=>{if(s.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(s=>{if(!It(s.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),R.runKernel(Ly,t)}}),vI=A({all_:function bre(n,t=null,e=!1){const s={x:E(n,"x","all","bool")};return R.runKernel("All",s,{axis:t,keepDims:e})}}),n_=A({any_:function _re(n,t=null,e=!1){const s={x:E(n,"x","any","bool")};return R.runKernel("Any",s,{axis:t,keepDims:e})}}),od=A({argMax_:function vre(n,t=0){const r={x:E(n,"x","argMax")};return R.runKernel(Vy,r,{axis:t})}}),NL=A({argMin_:function xre(n,t=0){const r={x:E(n,"x","argMin")};return R.runKernel(By,r,{axis:t})}}),AL=A({asin_:function wre(n){const e={x:E(n,"x","asin")};return R.runKernel(Cf,e)}}),RL=A({asinh_:function Cre(n){const e={x:E(n,"x","asinh")};return R.runKernel(Sf,e)}}),ML=A({atan_:function Sre(n){const e={x:E(n,"x","atan")};return R.runKernel(Ef,e)}}),FL=A({atan2_:function Ere(n,t){let e=E(n,"a","atan2"),r=E(t,"b","atan2");return[e,r]=Rn(e,r),R.runKernel(Df,{a:e,b:r})}}),OL=A({atanh_:function Ire(n){const e={x:E(n,"x","atanh")};return R.runKernel(If,e)}});function xp(n,t,e,r,s="NHWC",i){return vr(n,[...t,n[3]],e,i,r,null,null,ma(s))}function Ii(n,t,e,r,s,i,o="channelsLast"){const[a,l]=r_(t);let c;if("channelsLast"===o)c=[a,l,n[3],n[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);c=[a,l,n[1],n[1]]}return vr(n,c,e,r,s,i,!1,o)}function pa(n,t,e,r,s,i,o="NDHWC"){const[a,l,c]=wI(t);let u,d;if("NDHWC"===o)d="channelsLast",u=[a,l,c,n[4],n[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);d="channelsFirst",u=[a,l,c,n[1],n[1]]}return nl(n,u,e,r,s,!1,d,i)}function vr(n,t,e,r,s,i,o=!1,a="channelsLast"){let[l,c,u,d]=[-1,-1,-1,-1];if("channelsLast"===a)[l,c,u,d]=n;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,c,u]=n}const[h,f,,p]=t,[m,g]=r_(e),[y,b]=r_(r),_=ad(h,y),v=ad(f,b),{padInfo:w,outHeight:C,outWidth:I}=function kre(n,t,e,r,s,i,o,a,l){let c,u,d;if("number"==typeof n){c={top:n,bottom:n,left:n,right:n,type:0===n?"VALID":"NUMBER"};const f=function Dre(n,t,e,r,s){null==r&&(r=xI(n,t,e));const o=n[1];return[dc((n[0]-t+2*r)/e+1,s),dc((o-t+2*r)/e+1,s)]}([t,e],i,r,n,a);u=f[0],d=f[1]}else if("same"===n){u=Math.ceil(t/r),d=Math.ceil(e/s);const h=Math.max(0,(u-1)*r+i-t),f=Math.max(0,(d-1)*s+o-e),p=Math.floor(h/2),m=h-p,g=Math.floor(f/2);c={top:p,bottom:m,left:g,right:f-g,type:"SAME"}}else if("valid"===n)c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-i+1)/r),d=Math.ceil((e-o+1)/s);else{if("object"!=typeof n)throw Error(`Unknown padding parameter: ${n}`);{const h="channelsLast"===l?n[1][0]:n[2][0],f="channelsLast"===l?n[1][1]:n[2][1],p="channelsLast"===l?n[2][0]:n[3][0],m="channelsLast"===l?n[2][1]:n[3][1];c={top:h,bottom:f,left:p,right:m,type:0===h&&0===f&&0===p&&0===m?"VALID":"EXPLICIT"},u=dc((t-i+h+f)/r+1,a),d=dc((e-o+p+m)/s+1,a)}}return{padInfo:c,outHeight:u,outWidth:d}}(s,c,u,m,g,_,v,i,a),D=o?p*d:p;let T;return"channelsFirst"===a?T=[l,D,C,I]:"channelsLast"===a&&(T=[l,C,I,D]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:d,outHeight:C,outWidth:I,outChannels:D,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:f,effectiveFilterHeight:_,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:n,outShape:T,filterShape:t}}function nl(n,t,e,r,s,i=!1,o="channelsLast",a){let[l,c,u,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,c,u,d,h]=n;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,c,u,d]=n}const[f,p,m,,g]=t,[y,b,_]=wI(e),[v,w,C]=wI(r),I=ad(f,v),D=ad(p,w),T=ad(m,C),{padInfo:N,outDepth:P,outHeight:z,outWidth:W}=function Nre(n,t,e,r,s,i,o,a,l,c,u){let d,h,f,p;if("number"==typeof n){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:0===n?"VALID":"NUMBER"};const g=function Tre(n,t,e,r,s,i){null==s&&(s=xI(n,t,r));const a=n[1],l=n[2];return[dc((n[0]-t+2*s)/r+1,i),dc((a-t+2*s)/r+1,i),dc((l-t+2*s)/r+1,i),e]}([t,e,r,1],a,1,s,n,u);h=g[0],f=g[1],p=g[2]}else if("same"===n){h=Math.ceil(t/s),f=Math.ceil(e/i),p=Math.ceil(r/o);const m=(h-1)*s+a-t,g=(f-1)*i+l-e,y=(p-1)*o+c-r,b=Math.floor(m/2),_=m-b,v=Math.floor(g/2),w=g-v,C=Math.floor(y/2);d={top:v,bottom:w,left:C,right:y-C,front:b,back:_,type:"SAME"}}else{if("valid"!==n)throw Error(`Unknown padding parameter: ${n}`);d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},h=Math.ceil((t-a+1)/s),f=Math.ceil((e-l+1)/i),p=Math.ceil((r-c+1)/o)}return{padInfo:d,outDepth:h,outHeight:f,outWidth:p}}(s,c,u,d,y,b,_,I,D,T,a),G=i?g*h:g;let q;return"channelsFirst"===o?q=[l,G,P,z,W]:"channelsLast"===o&&(q=[l,P,z,W,G]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:d,inChannels:h,outDepth:P,outHeight:z,outWidth:W,outChannels:G,padInfo:N,strideDepth:y,strideHeight:b,strideWidth:_,filterDepth:f,filterHeight:p,filterWidth:m,effectiveFilterDepth:I,effectiveFilterHeight:D,effectiveFilterWidth:T,dilationDepth:v,dilationHeight:w,dilationWidth:C,inShape:n,outShape:q,filterShape:t}}function xI(n,t,e,r=1){const s=ad(t,r);return Math.floor((n[0]*(e-1)-e+s)/2)}function r_(n){return"number"==typeof n?[n,n,n]:2===n.length?[n[0],n[1],1]:n}function wI(n){return"number"==typeof n?[n,n,n]:n}function ad(n,t){return t<=1?n:n+(n-1)*(t-1)}function dc(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function rl(n){const[t,e,r]=r_(n);return 1===t&&1===e&&1===r}function Tr(n,t){return rl(n)||rl(t)}function ma(n){if("NHWC"===n)return"channelsLast";if("NCHW"===n)return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Kr(n,t,e){if(null!=e){if("string"==typeof t)throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if("number"==typeof t)S(Gu(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);t.forEach(r=>{r.forEach(s=>{S(Gu(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${s}.`)})})}}}const F=A({reshape_:function Are(n,t){const r={x:E(n,"x","reshape","string_or_numeric")};return R.runKernel(Eb,r,{shape:t})}}),s_=A({avgPool_:function Rre(n,t,e,r,s){const i=E(n,"x","avgPool","float32");S(Tr(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let a=i,l=!1;3===i.rank&&(l=!0,a=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Kr("avgPool",r,s);let d=R.runKernel(zy,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return d=ve(d,i.dtype),l?F(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),$L=A({avgPool3d_:function Mre(n,t,e,r,s,i="NDHWC"){const o=E(n,"x","avgPool3d","float32");let a=o,l=!1;4===o.rank&&(l=!0,a=F(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===i,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Kr("avgPool3d",r,s);let d=R.runKernel(Uy,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:i});return d=ve(d,a.dtype),l?F(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Xn=A({concat_:function Fre(n,t=0){S(n.length>=1,()=>"Pass at least one tensor to concat");const e=Xb(n,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(i=>{if("complex64"!==i.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${i.dtype}. `)}),1===e.length?ha(e[0]):R.runKernel(Gy,e,{axis:t})}}),pt=A({matMul_:function Ore(n,t,e=!1,r=!1){let s=E(n,"a","matMul"),i=E(t,"b","matMul");return[s,i]=Rn(s,i),R.runKernel(Hy,{a:s,b:i},{transposeA:e,transposeB:r})}}),M=A({mul_:function $re(n,t){let e=E(n,"a","mul"),r=E(t,"b","mul");return[e,r]=Rn(e,r),R.runKernel(Yf,{a:e,b:r})}}),Ao=A({sigmoid_:function Pre(n){const e={x:E(n,"x","sigmoid","float32")};return R.runKernel(ap,e)}}),Dt=A({slice_:function Lre(n,t,e){const r=E(n,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return R.runKernel(Nb,{x:r},{begin:t,size:e})}}),ld=A({tanh_:function Vre(n){const e={x:E(n,"x","tanh","float32")};return R.runKernel(fp,e)}}),zre=A({basicLSTMCell_:function Bre(n,t,e,r,s,i){const o=E(n,"forgetBias","basicLSTMCell"),a=E(t,"lstmKernel","basicLSTMCell"),l=E(e,"lstmBias","basicLSTMCell"),c=E(r,"data","basicLSTMCell"),u=E(s,"c","basicLSTMCell"),d=E(i,"h","basicLSTMCell"),h=Xn([c,d],1),f=pt(h,a),p=le(f,l),g=p.shape[1]/4,y=[p.shape[0],g],b=Dt(p,[0,0],y),_=Dt(p,[0,g],y),v=Dt(p,[0,2*g],y),w=Dt(p,[0,3*g],y),C=le(M(Ao(b),ld(_)),M(u,Ao(le(o,v))));return[C,M(ld(C),Ao(w))]}}),i_=A({batchToSpaceND_:function Ure(n,t,e){const r=E(n,"x","batchToSpaceND"),s=t.reduce((a,l)=>a*l);return S(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),S(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),S(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`),R.runKernel(Wy,{x:r},{blockShape:t,crops:e})}});function Hre(n){let t;return t=0===n.rank||1===n.rank?F(n,[1,1,1,n.size]):2===n.rank?F(n,[1,1,n.shape[0],n.shape[1]]):3===n.rank?F(n,[1,n.shape[0],n.shape[1],n.shape[2]]):n,t}const wp=A({batchNorm_:function Wre(n,t,e,r,s,i){null==i&&(i=.001);const o=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let c,u;null!=s&&(c=E(s,"scale","batchNorm")),null!=r&&(u=E(r,"offset","batchNorm")),S(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:Hre(o),scale:c,offset:u,mean:a,variance:l},p=R.runKernel(tb,h,{varianceEpsilon:i});return F(p,o.shape)}}),PL=A({batchNorm2d_:function jre(n,t,e,r,s,i){const o=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let c,u;return null!=s&&(c=E(s,"scale","batchNorm")),null!=r&&(u=E(r,"offset","batchNorm")),S(2===o.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),S(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),S(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=c&&S(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),null!=u&&S(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),wp(o,a,l,u,c,i)}}),LL=A({batchNorm3d_:function Gre(n,t,e,r,s,i){const o=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let c,u;return null!=s&&(c=E(s,"scale","batchNorm")),null!=r&&(u=E(r,"offset","batchNorm")),S(3===o.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),S(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),S(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=c&&S(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),null!=u&&S(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),wp(o,a,l,u,c,i)}}),VL=A({batchNorm4d_:function qre(n,t,e,r,s,i){const o=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let c,u;return null!=s&&(c=E(s,"scale","batchNorm")),null!=r&&(u=E(r,"offset","batchNorm")),S(4===o.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),S(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),S(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=c&&S(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),null!=u&&S(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),wp(o,a,l,u,c,i)}}),BL=A({bincount_:function Kre(n,t,e){const r=E(n,"x","bincount"),s=E(t,"weights","bincount");return S("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),S(e>=0,()=>`size must be non-negative, but got ${e}.`),S(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),R.runKernel(MS,{x:r,weights:s},{size:e})}}),Yre=A({broadcastArgs_:function Xre(n,t){const e=E(n,"s0","broadcastArgs","int32"),r=E(t,"s1","broadcastArgs","int32");if(1!==e.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);return R.runKernel(FS,{s0:e,s1:r})}}),cd=A({broadcastTo_:function Zre(n,t){let e=E(n,"broadcastTo","x");const r=e.shape;if(Ys(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const c=e.shape.slice();for(;c.length<t.length;)c.unshift(1);e=F(e,c)}const s=e.shape,i=Array.from(t);for(let c=t.length-1;c>=0;c--)if(s[c]===t[c])i[c]=1;else if(1!==e.shape[c])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);return 0===i.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length?ha(e):R.runKernel(pp,{x:e},{reps:i})}}),zL=A({ceil_:function Qre(n){const e={x:E(n,"x","ceil","float32")};return R.runKernel(kf,e)}});function ud(n,t,e){return Ys(n),R.runKernel(ZS,{},{shape:n,value:t,dtype:e})}const Ts=A({clipByValue_:function Jre(n,t,e){const r=E(n,"x","clipByValue");return S(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e?ud(r.shape,t,r.dtype):R.runKernel(Nf,{x:r},{clipValueMin:t,clipValueMax:e})}}),UL=A({concat1d_:function ese(n){return Xn(n,0)}}),HL=A({concat2d_:function tse(n,t){return Xn(n,t)}}),WL=A({concat3d_:function nse(n,t){return Xn(n,t)}}),jL=A({concat4d_:function rse(n,t){return Xn(n,t)}}),sl=A({conv2d_:function sse(n,t,e,r,s="NHWC",i=[1,1],o){const a=E(n,"x","conv2d","float32"),l=E(t,"filter","conv2d","float32");let c=a,u=!1;3===a.rank&&(u=!0,c=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===c.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),S(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Kr("conv2d",r,o);const d="NHWC"===s?c.shape[3]:c.shape[1];S(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),S(Tr(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const p=R.runKernel(qy,{x:c,filter:l},{strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o});return u?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),CI=A({conv1d_:function ise(n,t,e,r,s="NWC",i=1,o){const a=E(n,"x","conv1d"),l=E(t,"filter","conv1d");let c=a,u=!1;2===a.rank&&(u=!0,c=F(a,[1,a.shape[0],a.shape[1]])),S(3===c.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),S(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Kr("conv1d",r,o),S(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),S(Tr(e,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${i}'`),S("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=F(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=F(c,[c.shape[0],1,c.shape[1],c.shape[2]]),g=sl(h,d,[1,e],r,"NHWC",[1,i],o);return F(g,u?[g.shape[2],g.shape[3]]:[g.shape[0],g.shape[2],g.shape[3]])}}),SI=A({conv2DBackpropInput_:function ose(n,t,e,r,s,i="NHWC",o){S(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let a=n,l=t,c=!1;3===t.rank&&(c=!0,l=F(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,n[0],n[1],n[2]]),S(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),S(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),S(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const u="NHWC"===i?a[3]:a[1],d="NHWC"===i?l.shape[3]:l.shape[1];S(u===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[2]}.`),S(d===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`),Kr("conv2dDerInput",s,o);const p=R.runKernel(Ky,{dy:l,filter:e},{strides:r,pad:s,dataFormat:i,dimRoundingMode:o,inputShape:a});return c?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),EI=A({conv2dTranspose_:function ase(n,t,e,r,s,i){const o=E(n,"x","conv2dTranspose"),a=E(t,"filter","conv2dTranspose");return SI(e,o,a,r,s,"NHWC",i)}}),GL=A({conv3d_:function lse(n,t,e,r,s="NDHWC",i=[1,1,1]){const o=E(n,"x","conv3d"),a=E(t,"filter","conv3d");let l=o,c=!1;4===o.rank&&(c=!0,l=F(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),S(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),S(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),S(Tr(e,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),S("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const h=R.runKernel(Xy,{x:l,filter:a},{strides:e,pad:r,dataFormat:s,dilations:i});return c?F(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),qL=A({conv3DBackpropInput_:function cse(n,t,e,r,s){S(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let i=n,o=t,a=!1;4===t.rank&&(a=!0,o=F(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const l=i[4],c=o.shape[4];S(5===i.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),S(5===o.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),S(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),S(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),S(c===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${e.shape[4]}.`);const h=R.runKernel(LS,{dy:o,filter:e},{pad:s,strides:r,inputShape:i});return a?F(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),KL=A({conv3dTranspose_:function use(n,t,e,r,s){const i=E(n,"x","conv3dTranspose"),o=E(t,"filter","conv3dTranspose");return qL(e,i,o,r,s)}}),o_=A({cos_:function dse(n){const e={x:E(n,"x","cos","float32")};return R.runKernel(Af,e)}}),II=A({cosh_:function hse(n){const e={x:E(n,"x","cosh","float32")};return R.runKernel(Rf,e)}}),a_=A({cumprod_:function fse(n,t=0,e=!1,r=!1){const i={x:E(n,"x","cumprod")};return R.runKernel(VS,i,{axis:t,exclusive:e,reverse:r})}}),DI=A({cumsum_:function pse(n,t=0,e=!1,r=!1){const i={x:E(n,"x","cumsum")};return R.runKernel(Yy,i,{axis:t,exclusive:e,reverse:r})}}),TI=A({denseBincount_:function mse(n,t,e,r=!1){const s=E(n,"x","denseBincount"),i=E(t,"weights","denseBincount");return S("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),S(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),S(e>=0,()=>`size must be non-negative, but got ${e}.`),S(i.size===s.size||0===i.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${i.shape}.`),R.runKernel(zS,{x:s,weights:i},{size:e,binaryOutput:r})}}),XL=A({depthToSpace_:function gse(n,t,e="NHWC"){const r=E(n,"x","depthToSpace","float32"),s="NHWC"===e?r.shape[1]:r.shape[2],i="NHWC"===e?r.shape[2]:r.shape[3],o="NHWC"===e?r.shape[3]:r.shape[1];return S(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),S(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),S(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${t} for depthToSpace with input shape\n        ${r.shape}`),S(o%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${r.shape}`),R.runKernel(US,{x:r},{blockSize:t,dataFormat:e})}}),Cp=A({depthwiseConv2d_:function yse(n,t,e,r,s="NHWC",i=[1,1],o){const a=E(n,"x","depthwiseConv2d","float32"),l=E(t,"filter","depthwiseConv2d","float32");let c=a,u=!1;3===a.rank&&(u=!0,c=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===c.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),S(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d="NHWC"===s?c.shape[3]:c.shape[1];S(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),Kr("depthwiseConv2d",r,o);const p=R.runKernel(Zy,{x:c,filter:l},{strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o});return u?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),_se=A({diag_:function bse(n){const e={x:E(n,"x","diag")};return R.runKernel(jS,e)}}),YL=A({dilation2d_:function vse(n,t,e,r,s=[1,1],i="NHWC"){const o=E(n,"x","dilation2d"),a=E(t,"filter","dilation2d");S(3===o.rank||4===o.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),S(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),S("NHWC"===i,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,c=!1;3===o.rank&&(l=F(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0);const h=R.runKernel(Qy,{x:l,filter:a},{strides:e,pad:r,dilations:s});return c?F(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),kI=A({floorDiv_:function xse(n,t){let e=E(n,"a","floorDiv"),r=E(t,"b","floorDiv");return[e,r]=Rn(e,r),R.runKernel(Vf,{a:e,b:r})}}),$e=A({div_:function wse(n,t){let e=E(n,"a","div"),r=E(t,"b","div");return[e,r]=Rn(e,r),"int32"===e.dtype&&"int32"===r.dtype?kI(e,r):R.runKernel(Mf,{a:e,b:r},{})}}),oo=A({equal_:function Cse(n,t){let e=E(n,"a","equal","string_or_numeric"),r=E(t,"b","equal","string_or_numeric");return[e,r]=Rn(e,r),Je(e.shape,r.shape),R.runKernel(Jy,{a:e,b:r})}}),ds=A({where_:function Sse(n,t,e){const r=E(t,"a","where"),s=E(e,"b","where"),i=E(n,"condition","where","bool"),o=Je(Je(i.shape,r.shape),s.shape),a=cd(i,o),l=cd(r,o),c=cd(s,o);return R.runKernel(kb,{condition:a,t:l,e:c})}}),Tt=A({zerosLike_:function Ese(n){const e={x:E(n,"x","zerosLike")};return R.runKernel(Pb,e)}}),ZL=A({divNoNan_:function Ise(n,t){let e=E(n,"a","div"),r=E(t,"b","div");[e,r]=Rn(e,r);const s=$e(e,r),i=Tt(s),o=oo(r,i);return ds(o,i,s)}}),QL=A({dot_:function Dse(n,t){const e=E(n,"t1","dot"),r=E(t,"t2","dot");S(!(1!==e.rank&&2!==e.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);const s=1===e.rank?e.size:e.shape[1],i=1===r.rank?r.size:r.shape[0];if(S(s===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${i}.`),1===e.rank&&1===r.rank){const o=F(e,[1,-1]),a=F(r,[-1,1]),l=pt(o,a);return F(l,[])}if(1===e.rank&&2===r.rank){const o=F(e,[1,-1]),a=F(r,[r.shape[0],r.shape[1]]),l=pt(o,a);return F(l,[l.size])}if(2===e.rank&&1===r.rank){const o=F(r,[-1,1]),a=pt(e,o);return F(a,[a.size])}{const o=F(r,[r.shape[0],r.shape[1]]);return pt(e,o)}}}),kse=A({einsum_:function Tse(n,...t){const e=t.map((s,i)=>E(s,`tensors${i}`,"einsum"));return R.runKernel(KS,e,{equation:n})}}),Sp=A({elu_:function Nse(n){const e={x:E(n,"x","elu","float32")};return R.runKernel(Ff,e)}}),JL=A({erf_:function Ase(n){let t=E(n,"x","erf");return S("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=ve(t,"float32")),R.runKernel(Of,{x:t})}});function NI(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function eV(n,t,e){const r=n.length+t.length,s=[];let i=0,o=0;for(let a=0;a<r;a++)-1===e.indexOf(a)?s.push(n[i++]):s.push(t[o++]);return s}function xr(n,t){const e=[],r=n.length;for(let i=0;i<r;i++)-1===t.indexOf(i)&&e.push(n[i]);return[e,t.map(i=>n[i])]}function Vn(n,t){return eV(n,t.map(r=>1),t)}function kr(n,t,e){S(NI(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function En(n,t){if(NI(n,t))return null;const e=[];for(let r=0;r<t;++r)-1===n.indexOf(r)&&e.push(r);return n.forEach(r=>e.push(r)),e}function il(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function Bn(n,t){const e=[];for(let r=t-n;r<t;++r)e.push(r);return e}const Di=A({max_:function Rse(n,t=null,e=!1){const s={x:E(n,"x","max")};return R.runKernel(db,s,{reductionIndices:t,keepDims:e})}}),Ep=A({min_:function Mse(n,t=null,e=!1){const s={x:E(n,"x","min")};return R.runKernel(mb,s,{axis:t,keepDims:e})}}),ol=A({pow_:function Fse(n,t){let e=E(n,"base","pow"),r=E(t,"exp","pow");return[e,r]=Rn(e,r),R.runKernel(Zf,{a:e,b:r})}}),Pr=A({sqrt_:function Ose(n){const e={x:E(n,"x","sqrt","float32")};return R.runKernel(cp,e)}}),Yt=A({square_:function $se(n){const t=E(n,"x","square");return R.runKernel("Square",{x:t},{})}}),Ae=A({sum_:function Pse(n,t=null,e=!1){let r=E(n,"x","sum");return"bool"===r.dtype&&(r=ve(r,"int32")),R.runKernel(Ab,{x:r},{axis:t,keepDims:e})}});function tV(n,t,e=null){if(0===n.rank)return rr(n);if(1!==n.rank&&null===e)return tV(F(n,[-1]),t,e);if(1===n.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===t)return Ae(rr(n),e);if(t===1/0)return Di(rr(n),e);if(t===-1/0)return Ep(rr(n),e);if("euclidean"===t||2===t)return Pr(Ae(ol(rr(n),Le(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&2===e.length){if(1===t)return Di(Ae(rr(n),e[0]),e[1]-1);if(t===1/0)return Di(Ae(rr(n),e[1]),e[0]);if(t===-1/0)return Ep(Ae(rr(n),e[1]),e[0]);if("fro"===t||"euclidean"===t)return Pr(Ae(Yt(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const Ip=A({norm_:function Lse(n,t="euclidean",e=null,r=!1){const s=tV(n=E(n,"x","norm"),t,e);let i=s.shape;if(r){const o=ht(e,n.shape);i=Vn(s.shape,o)}return F(s,i)}}),nV=A({euclideanNorm_:function Vse(n,t=null,e=!1){return Ip(n,"euclidean",t,e)}}),Js=A({exp_:function Bse(n){const e={x:E(n,"x","exp")};return R.runKernel($f,e)}}),hs=A({expandDims_:function zse(n,t=0){const e=E(n,"x","expandDims","string_or_numeric");return S(t<=e.rank,()=>"Axis must be <= rank of the tensor"),R.runKernel(eb,{input:e},{dim:t})}}),rV=A({expm1_:function Use(n){const e={x:E(n,"x","expm1")};return R.runKernel(Pf,e)}}),Ti=A({tile_:function Hse(n,t){const e=E(n,"x","tile","string_or_numeric");return S(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`),R.runKernel(pp,{x:e},{reps:t})}}),AI=A({eye_:function Wse(n,t,e,r="float32"){null==t&&(t=n);const s=it([n,t],r),i=n<=t?n:t;for(let a=0;a<i;++a)s.set(1,a,a);const o=F(s.toTensor(),[n,t]);if(null==e)return o;if(1===e.length)return Ti(hs(o,0),[e[0],1,1]);if(2===e.length)return Ti(hs(hs(o,0),0),[e[0],e[1],1,1]);if(3===e.length)return Ti(hs(hs(hs(o,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}}),Dp=A({floor_:function jse(n){const e={x:E(n,"x","floor","float32")};return R.runKernel(Lf,e)}}),Tp=A({gather_:function Gse(n,t,e=0,r=0){const s=E(n,"x","gather"),i=E(t,"indices","gather","int32");return R.runKernel(nb,{x:s,indices:i},{axis:e,batchDims:r})}}),ks=A({greater_:function qse(n,t){let e=E(n,"a","greater","string_or_numeric"),r=E(t,"b","greater","string_or_numeric");return[e,r]=Rn(e,r),Je(e.shape,r.shape),R.runKernel(rb,{a:e,b:r})}}),al=A({greaterEqual_:function Kse(n,t){let e=E(n,"a","greaterEqual","string_or_numeric"),r=E(t,"b","greaterEqual","string_or_numeric");return[e,r]=Rn(e,r),Je(e.shape,r.shape),R.runKernel(Bf,{a:e,b:r})}}),l_=A({imag_:function Xse(n){const e={input:E(n,"input","imag")};return R.runKernel(tE,e)}}),sV=A({isFinite_:function Yse(n){const e={x:E(n,"x","isFinite")};return R.runKernel(Uf,e)}}),iV=A({isInf_:function Zse(n){const e={x:E(n,"x","isInf")};return R.runKernel(Hf,e)}}),oV=A({isNaN_:function Qse(n){const e={x:E(n,"x","isNaN")};return R.runKernel(Wf,e)}}),c_=A({leakyRelu_:function Jse(n,t=.2){const r={x:E(n,"x","leakyRelu")};return R.runKernel(sb,r,{alpha:t})}}),RI=A({less_:function eie(n,t){let e=E(n,"a","less","string_or_numeric"),r=E(t,"b","less","string_or_numeric");return[e,r]=Rn(e,r),Je(e.shape,r.shape),R.runKernel(ib,{a:e,b:r})}}),hc=A({lessEqual_:function tie(n,t){let e=E(n,"a","lessEqual","string_or_numeric"),r=E(t,"b","lessEqual","string_or_numeric");return[e,r]=Rn(e,r),Je(e.shape,r.shape),R.runKernel(ob,{a:e,b:r})}});function nie(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");return R.runKernel(nE,{},{start:n,stop:t,num:e})}const aV=A({localResponseNormalization_:function rie(n,t=5,e=1,r=1,s=.5){const i=E(n,"x","localResponseNormalization");S(4===i.rank||3===i.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`),S(Gu(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=i,a=!1;3===i.rank&&(a=!0,o=F(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const u=R.runKernel(ub,{x:o},{depthRadius:t,bias:e,alpha:r,beta:s});return a?F(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),ei=A({log_:function sie(n){const e={x:E(n,"x","log","float32")};return R.runKernel(jf,e)}}),u_=A({log1p_:function iie(n){const e={x:E(n,"x","log1p")};return R.runKernel(Gf,e)}}),yn=A({neg_:function oie(n){const e={x:E(n,"x","neg")};return R.runKernel(yb,e)}}),dd=A({softplus_:function aie(n){const e={x:E(n,"x","softplus")};return R.runKernel(lp,e)}}),lV=A({logSigmoid_:function lie(n){const t=E(n,"x","logSigmoid");return fa(r=>({value:yn(dd(yn(r))),gradFunc:o=>M(o,Ao(yn(r)))}))(t)}}),De=A({sub_:function cie(n,t){let e=E(n,"a","sub"),r=E(t,"b","sub");return[e,r]=Rn(e,r),R.runKernel(dp,{a:e,b:r})}}),MI=A({logSoftmax_:function uie(n,t=-1){const e=E(n,"logits","logSoftmax");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return fa((s,i)=>{const a=Di(s,t,!0),l=De(s,a),c=De(ve(l,"float32"),ei(Ae(Js(l),t,!0)));return i([c]),{value:c,gradFunc:(d,h)=>{const[f]=h,m=Js(f);return De(d,M(Ae(d,t,!0),m))}}})(e)}}),FI=A({logSumExp_:function die(n,t=null,e=!1){const r=E(n,"x","logSumExp"),s=ht(t,r.shape),i=Di(r,s,!0),o=De(r,i),a=Js(o),l=Ae(a,s),c=ei(l),u=le(F(i,c.shape),c);if(e){const d=Vn(u.shape,s);return F(u,d)}return u}}),Ro=A({logicalAnd_:function hie(n,t){const e=E(n,"a","logicalAnd","bool"),r=E(t,"b","logicalAnd","bool");return Je(e.shape,r.shape),R.runKernel(ab,{a:e,b:r})}}),d_=A({logicalNot_:function fie(n){const e={x:E(n,"x","logicalNot","bool")};return R.runKernel(lb,e)}}),OI=A({logicalOr_:function pie(n,t){const e=E(n,"a","logicalOr","bool"),r=E(t,"b","logicalOr","bool");return Je(e.shape,r.shape),R.runKernel(cb,{a:e,b:r})}}),cV=A({logicalXor_:function mie(n,t){const e=E(n,"a","logicalXor","bool"),r=E(t,"b","logicalXor","bool");return Je(e.shape,r.shape),Ro(OI(n,t),d_(Ro(n,t)))}}),h_=2147483648,$I=A({searchSorted_:function gie(n,t,e="left"){const r=E(n,"sortedSequence","searchSorted"),s=E(t,"values","searchSorted"),o=s.shape[s.shape.length-1],a=F(r,[-1,r.shape[r.shape.length-1]]),l=F(s,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(X(l.shape)>=h_)throw new Error(`values tensor size must less than ${h_}`);if(a.shape[1]>=h_)throw new Error(`trailing dim_size must less than ${h_} for int32 output type, was ${a.shape[1]}`);return R.runKernel(_E,{sortedSequence:a,values:l},{side:e})}});function yie(n,t){return $I(n,t,"left")}const f_=A({maxPool_:function bie(n,t,e,r,s){const i=E(n,"x","maxPool");let a=i,l=!1;3===i.rank&&(l=!0,a=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),S(Tr(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),Kr("maxPool",r,s);const d=R.runKernel(hb,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return l?F(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),uV=A({maxPool3d_:function _ie(n,t=[1,1,1],e,r,s,i="NDHWC"){const o=E(n,"x","maxPool3d");let a=o,l=!1;4===o.rank&&(l=!0,a=F(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===i,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Kr("maxPool3d",r,s);const d=R.runKernel(fb,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:i});return l?F(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),xie=A({maxPoolWithArgmax_:function vie(n,t,e,r,s=!1){const o={x:E(n,"x","maxPoolWithArgmax")},l=R.runKernel(oE,o,{filterSize:t,strides:e,pad:r,includeBatchInIndex:s});return{result:l[0],indexes:l[1]}}}),ga=A({maximum_:function wie(n,t){let e=E(n,"a","maximum"),r=E(t,"b","maximum");return[e,r]=Rn(e,r),"bool"===e.dtype&&(e=ve(e,"int32"),r=ve(r,"int32")),Je(e.shape,r.shape),R.runKernel(qf,{a:e,b:r})}}),Mn=A({mean_:function Cie(n,t=null,e=!1){const s={x:E(n,"x","mean")};return R.runKernel(pb,s,{axis:t,keepDims:e})}});function sr(n,t="float32"){if(Ys(n),"complex64"===t){const r=sr(n,"float32"),s=sr(n,"float32");return Qa(r,s)}const e=$r(X(n),t);return R.makeTensor(e,n,t)}function ti(n,t="float32"){if(Ys(n),"complex64"===t){const r=ti(n,"float32"),s=sr(n,"float32");return Qa(r,s)}const e=IS(X(n),t);return R.makeTensor(e,n,t)}function Sie(n,t,{indexing:e="xy"}={}){if("xy"!==e&&"ij"!==e)throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(void 0===n)return[];let r=E(n,"x","meshgrid",n instanceof fn?n.dtype:"float32");if(void 0===t)return[r];let s=E(t,"y","meshgrid",t instanceof fn?t.dtype:"float32");const i=X(r.shape),o=X(s.shape);return"xy"===e?(r=F(r,[1,-1]),s=F(s,[-1,1]),[pt(ti([o,1],r.dtype),r),pt(s,ti([1,i],s.dtype))]):(r=F(r,[-1,1]),s=F(s,[1,-1]),[pt(r,ti([1,o],r.dtype)),pt(ti([i,1],s.dtype),s)])}const kp=A({minimum_:function Eie(n,t){let e=E(n,"a","minimum"),r=E(t,"b","minimum");return[e,r]=Rn(e,r),"bool"===e.dtype&&(e=ve(e,"int32"),r=ve(r,"int32")),Je(e.shape,r.shape),R.runKernel(Kf,{a:e,b:r})}}),dV=A({mirrorPad_:function Iie(n,t,e){S("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const r=E(n,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");S(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s="reflect"===e?1:0;for(let a=0;a<r.rank;a++)S(2===t[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),S(t[a][0]>=0&&t[a][0]<=r.shape[a]-s&&t[a][1]>=0&&t[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);return R.runKernel(gb,{x:r},{paddings:t,mode:e})}}),hV=A({mod_:function Die(n,t){let e=E(n,"a","mod"),r=E(t,"b","mod");return[e,r]=Rn(e,r),R.runKernel(Xf,{a:e,b:r})}}),p_=A({moments_:function Tie(n,t=null,e=!1){const r=ht(t,(n=E(n,"x","moments")).shape),s=Mn(n,r,e);let i=s.shape;e||(i=Vn(s.shape,r));const o=Yt(De(ve(n,"float32"),F(s,i)));return{mean:s,variance:Mn(o,r,e)}}}),Nie=A({multiRNNCell_:function kie(n,t,e,r){const s=E(t,"data","multiRNNCell"),i=Xb(e,"c","multiRNNCell"),o=Xb(r,"h","multiRNNCell");let a=s;const l=[];for(let d=0;d<n.length;d++){const h=n[d](a,i[d],o[d]);l.push(h[0]),l.push(h[1]),a=h[1]}const c=[],u=[];for(let d=0;d<l.length;d+=2)c.push(l[d]),u.push(l[d+1]);return[c,u]}}),Rie=A({multinomial_:function Aie(n,t,e,r=!1){const s=E(n,"logits","multinomial"),i=s.size,o=s.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);e=e||Math.random();const l={logits:1===o?F(s,[1,-1]):s},u=R.runKernel(aE,l,{numSamples:t,seed:e,normalized:r});return 1===o?F(u,[u.size]):u}}),hd=A({notEqual_:function Mie(n,t){let e=E(n,"a","notEqual","string_or_numeric"),r=E(t,"b","notEqual","string_or_numeric");return[e,r]=Rn(e,r),Je(e.shape,r.shape),R.runKernel(bb,{a:e,b:r})}}),PI=A({oneHot_:function Fie(n,t,e=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:E(n,"indices","oneHot","int32")};return R.runKernel(vb,o,{dtype:s,depth:t,onValue:e,offValue:r})}}),ni=A({onesLike_:function Oie(n){const e={x:E(n,"x","onesLike")};return R.runKernel(_b,e)}}),Pie=A({outerProduct_:function $ie(n,t){const e=E(n,"v1","outerProduct"),r=E(t,"v2","outerProduct");S(1===e.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${r.rank}.`);const s=F(e,[-1,1]),i=F(r,[1,-1]);return pt(s,i)}}),ll=A({pad_:function Lie(n,t,e=0){const r=E(n,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return R.runKernel(wb,{x:r},{paddings:t,constantValue:e})}}),Bie=A({pad1d_:function Vie(n,t,e=0){return S(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),ll(n,[t],e)}}),Uie=A({pad2d_:function zie(n,t,e=0){return S(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),ll(n,t,e)}}),Wie=A({pad3d_:function Hie(n,t,e=0){return S(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),ll(n,t,e)}}),Gie=A({pad4d_:function jie(n,t,e=0){return S(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),ll(n,t,e)}}),m_=A({spaceToBatchND_:function qie(n,t,e){const r=E(n,"x","spaceToBatchND");return S(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),S(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),S(r.shape.reduce((o,a,l)=>l>0&&l<=t.length?o&&(a+e[l-1][0]+e[l-1][1])%t[l-1]==0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`),R.runKernel(Rb,{x:r},{blockShape:t,paddings:e})}}),fV=A({pool_:function Kie(n,t,e,r,s,i,o){null==s&&(s=[1,1]),null==i&&(i=1),0===r&&(r="valid");const a=E(n,"x","maxPool");let l=a,c=!1;3===a.rank&&(c=!0,l=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(Tr(i,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${s}'`);const u=Ii(l.shape,t,i,s,r),d=[u.dilationHeight,u.dilationWidth];let h;h="same"===r?function Yie(n,t){const r=n.map((o,a)=>o+(o-1)*(t[a]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),i=r.map((o,a)=>o-s[a]);return r.map((o,a)=>[s[a],i[a]])}([u.filterHeight,u.filterWidth],d):[[0,0],[0,0]];const f=1===d[0]&&1===d[1],[p,m]=function Xie(n,t,e){const r=e.map(u=>u[0]),s=e.map(u=>u[1]),i=n.concat(r,s),o=t.map((u,d)=>(u-i[d]%u)%u),a=s.map((u,d)=>u+o[d]),l=t.map((u,d)=>[r[d],a[d]]),c=t.map((u,d)=>[0,o[d]]);return[l,c]}([u.inHeight,u.inWidth],d,h),g=f?r:"valid",y=f?l:m_(l,d,p),_=("avg"===e?()=>s_(y,t,i,g,o):()=>f_(y,t,i,g,o))(),v=f?_:i_(_,d,m);return c?F(v,[v.shape[1],v.shape[2],v.shape[3]]):v}}),g_=A({prelu_:function Zie(n,t){const e=E(n,"x","prelu"),r=E(t,"alpha","prelu");return R.runKernel(Cb,{x:e,alpha:r})}}),pV=A({prod_:function Qie(n,t=null,e=!1){let r=E(n,"x","prod");return"bool"===r.dtype&&(r=ve(r,"int32")),R.runKernel(Sb,{x:r},{axis:t,keepDims:e})}}),eoe=A({raggedGather_:function Jie(n,t,e,r){const s=n.map((u,d)=>E(u,`tensors${d}`,"raggedGather","int32")),i=E(t,"paramsDenseValues","raggedGather"),o=E(e,"indices","raggedGather","int32"),c=R.runKernel(dE,{paramsNestedSplits:s,paramsDenseValues:i,indices:o},{outputRaggedRank:r});return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}}),noe=A({raggedRange_:function toe(n,t,e){const r=E(n,"starts","raggedRange"),s=E(t,"limits","raggedRange",r.dtype),i=E(e,"deltas","raggedRange",r.dtype),a=R.runKernel(hE,{starts:r,limits:s,deltas:i});return{rtNestedSplits:a[0],rtDenseValues:a[1]}}}),soe=A({raggedTensorToTensor_:function roe(n,t,e,r,s){const i=E(n,"shape","raggedTensorToTensor","int32"),o=E(t,"values","raggedTensorToTensor"),a=E(e,"defaultValue","raggedTensorToTensor",o.dtype),l=r.map((d,h)=>E(d,`tensors${h}`,"raggedTensorToTensor","int32"));return R.runKernel(fE,{shape:i,values:o,defaultValue:a,rowPartitionTensors:l},{rowPartitionTypes:s})}}),ooe=A({rand_:function ioe(n,t,e){Ys(n);const r=X(n);let s=null;if(null==e||"float32"===e)s=new Float32Array(r);else if("int32"===e)s=new Int32Array(r);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);s=new Uint8Array(r)}for(let i=0;i<r;i++)s[i]=t();return R.makeTensor(s,n,e)}});var y_=Z(340);class LI{constructor(t,e,r,s,i){this.mean=t,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=i||Math.random();this.random=y_.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let t,e,r=!1;for(;!r;){let s,i,o;do{s=2*this.random()-1,i=2*this.random()-1,o=s*s+i*i}while(o>=1||0===o);const a=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*s*a,e=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class aoe{constructor(t,e,r,s){this.alpha=t,this.beta=1/e,this.dtype=r;const i=s||Math.random();this.randu=y_.alea(i.toString()),this.randn=new LI(0,1,r,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,r,s,i,o;for(;;){do{s=this.randn.nextValue(),o=1+this.c*s}while(o<=0);if(o*=o*o,t=s*s,e=1-.331*t*t,r=.5*t+this.d*(1-o+Math.log(o)),i=this.randu(),i<e||Math.log(i)<r)break}return o*=1/this.beta*this.d,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class loe{constructor(t=0,e=1,r,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=r,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=y_.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const foe=A({randomGamma_:function hoe(n,t,e=1,r="float32",s){if(Ys(n),null==e&&(e=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const i=new aoe(t,e,r,s),o=it(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),BI=A({randomNormal_:function poe(n,t=0,e=1,r,s){if(Ys(n),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const i=new LI(t,e,r,!1,s),o=it(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),goe=A({randomStandardNormal_:function moe(n,t,e){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return BI(n,0,1,t,e)}}),Np=A({randomUniform_:function yoe(n,t=0,e=1,r="float32",s){Ys(n);const i=it(n,r),o=new loe(t,e,null,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}});function fd(n,t,e=1,r="float32"){if(0===e)throw new Error("Cannot have a step of zero");return R.runKernel(pE,{},{start:n,stop:t,step:e,dtype:r})}const Ap=A({real_:function boe(n){const e={input:E(n,"input","real")};return R.runKernel(mE,e)}}),mV=A({reciprocal_:function _oe(n){const e={x:E(n,"x","reciprocal")};return R.runKernel(Qf,e)}}),Mo=A({relu_:function voe(n){const e={x:E(n,"x","relu")};return R.runKernel(Jf,e)}}),zI=A({relu6_:function xoe(n){const e={x:E(n,"x","relu6")};return R.runKernel(ep,e)}}),ki=A({reverse_:function woe(n,t){const r={x:E(n,"x","reverse")};return R.runKernel(Tb,r,{dims:t})}}),Soe=A({reverse1d_:function Coe(n){const t=E(n,"x","reverse");return S(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),ki(t,0)}}),Ioe=A({reverse2d_:function Eoe(n,t){const e=E(n,"x","reverse");return S(2===e.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),ki(e,t)}}),Toe=A({reverse3d_:function Doe(n,t){const e=E(n,"x","reverse");return S(3===e.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),ki(e,t)}}),Noe=A({reverse4d_:function koe(n,t){const e=E(n,"x","reverse");return S(4===e.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),ki(e,t)}}),UI=A({round_:function Aoe(n){const e={x:E(n,"x","round")};return R.runKernel(tp,e)}}),HI=A({rsqrt_:function Roe(n){const e={x:E(n,"x","rsqrt","float32")};return R.runKernel(np,e)}}),WI=A({selu_:function Moe(n){const e={x:E(n,"x","selu")};return R.runKernel(rp,e)}}),jI=A({separableConv2d_:function Foe(n,t,e,r,s,i=[1,1],o="NHWC"){const a=E(n,"x","separableConv2d"),l=E(t,"depthwiseFilter","separableConv2d"),c=E(e,"pointwiseFilter","separableConv2d");let u=a,d=!1;if(3===a.rank&&(d=!0,u=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");S(4===u.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),S(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),S(4===c.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),S(1===c.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),S(1===c.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const h=l.shape[2],f=l.shape[3];S(c.shape[2]===h*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*f}, but got ${c.shape[2]}.`);const p=Cp(u,l,r,s,o,i),g=sl(p,c,1,"valid",o);return d?F(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});function GI(){return(GI=ee(function*(n,t){const e=E(n,"x","setdiff1d"),r=E(t,"y","setdiff1d");S(e.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${r.dtype}).`),S(1===e.rank,()=>`x should be 1D tensor, but got x (${e.shape}).`),S(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=yield e.data(),i=yield r.data(),o=new Set(i);let a=0;for(let u=0;u<s.length;u++)o.has(s[u])||a++;const l=new br([a],e.dtype),c=new br([a],"int32");for(let u=0,d=0;u<s.length;u++)o.has(s[u])||(l.values[d]=s[u],c.values[d]=u,d++);return[l.toTensor(),c.toTensor()]})).apply(this,arguments)}const $oe=function Ooe(n,t){return GI.apply(this,arguments)},gV=A({sign_:function Poe(n){const e={x:E(n,"x","sign")};return R.runKernel(op,e)}}),qI=A({sin_:function Loe(n){const e={x:E(n,"x","sin","float32")};return R.runKernel(sp,e)}}),KI=A({sinh_:function Voe(n){const e={x:E(n,"x","sinh")};return R.runKernel(ip,e)}}),b_=A({slice1d_:function Boe(n,t,e){const r=E(n,"x","slice1d");return S(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Dt(r,[t],[e])}}),XI=A({slice2d_:function zoe(n,t,e){const r=E(n,"x","slice2d");return S(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Dt(r,t,e)}}),__=A({slice3d_:function Uoe(n,t,e){const r=E(n,"x","slice3d");return S(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Dt(r,t,e)}}),Rp=A({slice4d_:function Hoe(n,t,e){const r=E(n,"x","slice4d");return S(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Dt(r,t,e)}}),v_=A({softmax_:function Woe(n,t=-1){const e=E(n,"logits","softmax","float32");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);return R.runKernel(Fb,{logits:e},{dim:t})}}),x_=A({fft_:function joe(n){return S("complex64"===n.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`),R.runKernel("FFT",{input:n})}}),Mp=A({ifft_:function Goe(n){return S("complex64"===n.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`),R.runKernel(eE,{input:n})}}),YI=A({irfft_:function qoe(n){const t=n.shape[n.shape.length-1],e=n.size/t;let r;if(t<=2){const s=F(n,[e,t]);r=Mp(s)}else{const s=[e,2*(t-1)],i=F(Ap(n),[e,t]),o=F(l_(n),[e,t]),a=ki(Dt(i,[0,1],[e,t-2]),1),l=M(ki(Dt(o,[0,1],[e,t-2]),1),Le(-1)),c=Xn([i,a],1),u=Xn([o,l],1),d=F(Qa(c,u),[s[0],s[1]]);r=Mp(d)}if(r=Ap(r),3===n.rank&&0!==n.shape[0]){const s=r,i=n.shape[0];r=F(r,[i,r.shape[0]/i,r.shape[1]]),s.dispose()}return r}}),Ns=A({split_:function Koe(n,t,e=0){const s={x:E(n,"x","split")};return R.runKernel(Mb,s,{numOrSizeSplits:t,axis:e})}}),w_=A({rfft_:function Xoe(n,t){S("float32"===n.dtype,()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const r=n.size/e;let s;if(null!=t&&t<e){const p=n.shape.map(g=>0),m=n.shape.map(g=>g);m[n.shape.length-1]=t,s=Dt(n,p,m),e=t}else if(null!=t&&t>e){const p=n.shape.map(m=>m);p[n.shape.length-1]=t-e,s=Xn([n,sr(p)],n.shape.length-1),e=t}else s=n;const i=Tt(s),o=F(Qa(s,i),[r,e]),a=x_(o),l=Math.floor(e/2)+1,c=Ap(a),u=l_(a),d=Ns(c,[l,e-l],c.shape.length-1),h=Ns(u,[l,e-l],u.shape.length-1),f=s.shape.slice();return f[s.shape.length-1]=l,F(Qa(d[0],h[0]),f)}}),ZI=A({squaredDifference_:function Yoe(n,t){let e=E(n,"a","squaredDifference"),r=E(t,"b","squaredDifference");return[e,r]=Rn(e,r),Je(e.shape,r.shape),R.runKernel(up,{a:e,b:r},{})}}),fc=A({squeeze_:function Zoe(n,t){const e=E(n,"x","squeeze","string_or_numeric");return F(e,Ga(e.shape,t).newShape)}}),ri=A({stack_:function Qoe(n,t=0){const e=Xb(n,"tensors","stack","string_or_numeric");return S(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&S(t<=e[0].rank,()=>"Axis must be <= rank of the tensor"),R.runKernel(xb,e,{axis:t})}}),pd=A({step_:function Joe(n,t=0){const r={x:E(n,"x","step")};return R.runKernel(mp,r,{alpha:t})}}),yV=A({stridedSlice_:function eae(n,t,e,r,s=0,i=0,o=0,a=0,l=0){const u={x:E(n,"x","stridedSlice","string_or_numeric")};return R.runKernel(IE,u,{begin:t,end:e,strides:r,beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l})}}),bV=A({tan_:function tae(n){const e={x:E(n,"x","tan","float32")};return R.runKernel(hp,e)}});function fs(n,t){Wu(n);const e=Za(n,t);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Ja(n,null,e,t)}function Fp(n,t,e){if(Wu(n),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Za(n,e);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Ja(n,t,r,e)}function nae(n,t,e){if(Wu(n),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=Za(n,e);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Ja(n,t,r,e)}function rae(n,t,e){if(Wu(n),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=Za(n,e);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Ja(n,t,r,e)}function sae(n,t,e){if(Wu(n),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=Za(n,e);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Ja(n,t=t||r,r,e)}const _V=A({topk_:function iae(n,t=1,e=!0){const r=E(n,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const i={x:r},o={k:t,sorted:e},[a,l]=R.runKernel(NE,i,o);return{values:a,indices:l}}}),QI=A({truncatedNormal_:function oae(n,t=0,e=1,r,s){if(Ys(n),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const i=new LI(t,e,r,!0,s),o=it(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),vV=A({unique_:function aae(n,t=0){const e=E(n,"x","unique","string_or_numeric");S(e.rank>0,()=>"The input tensor must be at least 1D");const r={x:e},s={axis:t},[i,o]=R.runKernel(RE,r,s);return{values:i,indices:o}}}),JI=A({unsortedSegmentSum_:function lae(n,t,e){const r=E(n,"x","unsortedSegmentSum"),s=E(t,"segmentIds","unsortedSegmentSum","int32");return S(Gu(e),()=>"numSegments must be of dtype int"),R.runKernel($b,{x:r,segmentIds:s},{numSegments:e})}}),Ni=A({unstack_:function cae(n,t=0){const e=E(n,"x","unstack","string_or_numeric");return S(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`),R.runKernel(Ob,{value:e},{axis:t})}});function uae(n,t){return $I(n,t,"right")}function xV(n,t=!0,e,r){return R.makeVariable(n,t,e,r)}function eD(n,t){const e=[];for(let i=0;i<t.length;i++)t[i]&&e.push(i);const r=it(n,"int32"),s=it([e.length,n.length],"int32");for(let i=0;i<e.length;i++){const o=r.indexToLoc(e[i]);s.values.set(o,i*n.length)}return s.toTensor()}function tD(){return(tD=ee(function*(n){const t=E(n,"condition","whereAsync","bool"),e=yield t.data(),r=eD(t.shape,e);return n!==t&&t.dispose(),r})).apply(this,arguments)}const wV=function dae(n){return tD.apply(this,arguments)};function nD(){return(nD=ee(function*(n,t,e){const r=E(n,"tensor","boolMask"),s=E(t,"mask","boolMask","bool"),i=e??0,o=s.rank,a=r.shape;S(o>0,()=>"mask cannot be scalar"),Is(a.slice(i,i+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=i;m<i+o;m++)l*=a[m];const c=a.slice(0,i).concat([l],a.slice(i+o)),u=F(r,c),d=F(s,[-1]),h=yield wV(d),f=fc(h,[1]),p=Tp(u,f,i);return n!==r&&r.dispose(),t!==s&&s.dispose(),f.dispose(),u.dispose(),d.dispose(),h.dispose(),p})).apply(this,arguments)}const fae=function hae(n,t,e){return nD.apply(this,arguments)},vt=A({transpose_:function pae(n,t,e){const r=E(n,"x","transpose");if(null==t&&(t=r.shape.map((o,a)=>a).reverse()),S(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(o=>{S(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();const s={x:r},i={perm:t};return"complex64"===r.dtype?B(()=>{let o=Ap(r),a=l_(r);return o=R.runKernel(Zu,{x:o},i),a=R.runKernel(Zu,{x:a},i),e&&(a=yn(a)),Qa(o,a)}):R.runKernel(Zu,s,i)}}),gae=A({movingAverage_:function mae(n,t,e,r,s=!0){const i=E(n,"v","movingAverage"),o=E(t,"x","movingAverage"),a=E(e,"decay","movingAverage");(function tne(n,t){S(n.dtype===t.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`)})(i,o),S(It(i.shape,o.shape),()=>"Shape mismatch in v and x");const l=Le(1),c=De(l,a);let u=M(De(o,i),c);if(s){S(null!=r,()=>"When using zeroDebias: true, step is required.");const d=E(r,"step","movingAverage");u=$e(u,De(l,ol(a,d)))}return le(i,u)}});function CV(n,t,e){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(e.rank<s)throw new Error(i+` update.rank < ${s}. `);if(n.length<r+(e.rank-s))throw new Error(i+` Output shape length < ${r+(e.rank-s)}`);if(e.rank!==s+n.length-r)throw new Error(i+" update.rank != "+(s+n.length-r));for(let o=0;o<s;++o)if(e.shape[o]!==t.shape[o])throw new Error(i+` updates.shape[${o}] (${e.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<e.rank-s;++o)if(e.shape[o+s]!==n[o+r])throw new Error(i+` updates.shape[${o+s}] (${e.shape[o+s]}) != shape[${o+s}] (${n[o+s]})`)}function SV(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===n.size)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}CV(e,t,n)}function Op(n,t,e){const r=t.shape.length,s=r>1?t.shape[r-1]:1,i=e.length;let o=1;for(let d=s;d<i;++d)o*=e[d];const a=s<1?1:s;return{sliceRank:s,numUpdates:X(t.shape)/a,sliceSize:o,strides:[...Pe(e.slice(0,s)),1],outputSize:X(e)}}const bae=A({scatterND_:function yae(n,t,e){Ys(e);const r=E(n,"indices","scatterND","int32"),s=E(t,"updates","scatterND");return SV(s,r,e),R.runKernel(bE,{indices:r,updates:s},{shape:e})}}),xae=A({sparseToDense_:function vae(n,t,e,r=0){Ys(e);const s=E(n,"sparseIndices","sparseToDense","int32"),i=E(t,"sparseValues","sparseToDense","string_or_numeric"),o=E(r,"defaultValue","sparseToDense",i.dtype);return function _ae(n,t,e,r){if("int32"!==n.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(e.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${i}.`);if(0!==t.rank&&(1!==t.rank||t.size!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,i,e,o),R.runKernel(SE,{sparseIndices:s,sparseValues:i,defaultValue:o},{outputShape:e})}}),Cae=A({gatherND_:function wae(n,t){const e=E(t,"indices","gatherND","int32"),s={params:E(n,"x","gatherND","string_or_numeric"),indices:e};return R.runKernel(JS,s)}}),EV=A({dropout_:function Eae(n,t,e,r){const s=E(n,"x","dropout");if(S("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),S(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return n instanceof fn?s.clone():s;const i=function Sae(n,t){if(null==t)return n.shape.slice();if(It(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let r=0;r<n.shape.length;r++)e.push(null==t[r]&&null!=n.shape[r]?n.shape[r]:t[r]);return e}return t}(s,e),o=1-t,a=$e(Dp(le(Np(i,0,1,"float32",r),o)),o);return M(s,a)}});function IV(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function rD(n,t,e){const r=1-n%2,s=new Float32Array(n);for(let i=0;i<n;++i){const o=2*Math.PI*i/(n+r-1);s[i]=t-e*Math.cos(o)}return fs(s,"float32")}function sD(){return(sD=ee(function*(n,t,e=1){const r=E(n,"predictions","inTopK"),s=E(t,"targets","inTopK");S(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),S(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Is(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=r.shape[r.shape.length-1];S(e>0&&e<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${e}`);const o=yield r.data(),a=yield s.data(),[l,c]=[o.length/i,i],u=gr("bool",l);for(let d=0;d<l;d++){const h=d*c,f=o.subarray(h,h+c),p=[];for(let m=0;m<f.length;m++)p.push({value:f[m],index:m});p.sort((m,g)=>g.value-m.value),u[d]=0;for(let m=0;m<e;m++)if(p[m].index===a[d]){u[d]=1;break}}return n!==r&&r.dispose(),t!==s&&s.dispose(),so(u,s.shape,"bool")})).apply(this,arguments)}const Dae=function Iae(n,t){return sD.apply(this,arguments)},iD=A({conv2DBackpropFilter_:function Tae(n,t,e,r,s,i="NHWC",o){let a=n;3===n.rank&&(a=F(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;3===l.rank&&(l=F(t,[1,t.shape[0],t.shape[1],t.shape[2]])),S(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),S(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),S(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const c="NHWC"===i?a.shape[3]:a.shape[1],u="NHWC"===i?l.shape[3]:l.shape[1];return S(c===e[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${e[2]}.`),S(u===e[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${e[3]}).`),Kr("conv2dDerFilter",s,o),R.runKernel($S,{x:a,dy:l},{strides:r,pad:s,dataFormat:i,dimRoundingMode:o,filterShape:e})}});function C_(n,t,e){if(null==e||"linear"===e)return n;if("relu"===e)return M(n,pd(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function S_(n,t){let e=t;const r=nr(n.shape,t.shape);return r.length>0&&(e=Ae(e,r)),F(e,n.shape)}function E_(n,t,e,r){if("linear"===t)return n;if("relu"===t)return Mo(n);if("elu"===t)return Sp(n);if("relu6"===t)return zI(n);if("prelu"===t)return g_(n,e);if("leakyrelu"===t)return c_(n,r);if("sigmoid"===t)return Ao(n);throw new Error(`Unknown fused activation ${t}.`)}const I_=(n,t)=>!(n>0)||"linear"===t,DV=A({fusedConv2d_:function kae({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(!1===I_(R.state.gradientDepth,l=l||"linear")){S("NHWC"===s,()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let C=sl(n,t,e,r,s,i,o);return null!=a&&(C=le(C,a)),E_(C,l,c,u)}const d=E(n,"x","conv2d","float32"),h=E(t,"filter","conv2d","float32");let f=d,p=!1;3===d.rank&&(p=!0,f=F(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(4===f.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),S(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),Kr("fused conv2d",r,o);const m="NHWC"===s?f.shape[3]:f.shape[1];S(h.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`),S(Tr(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const g=vr(f.shape,h.shape,e,i,r,o);let y,b;if(null!=a&&(y=E(a,"bias","fused conv2d"),[y]=Rn(y,d),"NHWC"===s?Je(g.outShape,y.shape):(S(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),S(0===y.shape.length||y.shape[0]===g.outChannels||1===y.shape[0],()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`))),null!=c){const C=c.shape;if(S(C.length<=1||3===C.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${C.length}.`),1===C.length)S(1===C[0]||C[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the number of output channels (${g.outChannels}).`);else if(3===C.length)try{Je(C,g.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the output shape of the conv2d (${g.outShape}).`)}b=E(c,"prelu weights","fused conv2d")}const _=(C,I)=>{S("NHWC"===s,()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[D,T,N,P]=I,z=C_(C,N,l);S(rl(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const q=[SI(T.shape,z,D,e,r),iD(T,z,D.shape,e,r)];if(null!=P){const $=S_(P,z);q.push($)}return q},v={x:f,filter:h,bias:y,preluActivationWeights:b},w={strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return null==a?fa((I,D,T)=>{let N=R.runKernel(Vb,v,w);return T([D,I,N]),p&&(N=F(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:_}})(f,h):fa((I,D,T,N)=>{let P=R.runKernel(Vb,v,w);return N([D,I,P,T]),p&&(P=F(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:_}})(f,h,y)}}),TV=A({depthwiseConv2dNativeBackpropFilter_:function Nae(n,t,e,r,s,i=[1,1],o){let a=n;3===n.rank&&(a=F(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;return 3===l.rank&&(l=F(t,[1,t.shape[0],t.shape[1],t.shape[2]])),R.runKernel(HS,{x:a,dy:l},{strides:r,pad:s,dimRoundingMode:o,dilations:i,filterShape:e})}}),kV=A({depthwiseConv2dNativeBackpropInput_:function Aae(n,t,e,r,s,i=[1,1],o){let a=t,l=!1;3===t.rank&&(l=!0,a=F(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const d=R.runKernel(WS,{dy:a,filter:e},{strides:r,pad:s,dimRoundingMode:o,dilations:i,inputShape:n});return l?F(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Mae=A({fusedDepthwiseConv2d_:function Rae({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(!1===I_(R.state.gradientDepth,l)){let w=Cp(n,t,e,r,s,i,o);return null!=a&&(w=le(w,a)),E_(w,l,c,u)}const d=E(n,"x","depthwiseConv2d","float32"),h=E(t,"filter","depthwiseConv2d","float32");let f=d,p=!1;3===d.rank&&(p=!0,f=F(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(4===f.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),S(4===h.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),S(f.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),null==i&&(i=[1,1]),S(Tr(e,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),Kr("fused depthwiseConv2d",r,o);const m=vr(f.shape,h.shape,e,i,r,o,!0);let g,y;null!=a&&(g=E(a,"bias","fused conv2d"),[g]=Rn(g,d),Je(m.outShape,g.shape)),null!=c&&(y=E(c,"prelu weights","fused depthwiseConv2d"));const b=(w,C)=>{S(rl(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[I,D,T,N]=C,P=C_(w,T,l),z=kV(D.shape,P,I,e,r,i,o),W=TV(D,P,I.shape,e,r,i,o);return null!=N?[z,W,S_(g,P)]:[z,W]},_={x:f,filter:h,bias:g,preluActivationWeights:y},v={strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return null==a?fa((C,I,D)=>{let T=R.runKernel(Bb,_,v);return D([I,C,T]),p&&(T=F(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:b}})(f,h):fa((C,I,D,T)=>{let N=R.runKernel(Bb,_,v);return T([I,C,N,D]),p&&(N=F(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:b}})(f,h,g)}}),oD=A({fusedMatMul_:function Fae({a:n,b:t,transposeA:e=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(!1===I_(R.state.gradientDepth,i)){let P=pt(n,t,e,r);return null!=s&&(P=le(P,s)),E_(P,i,o,a)}let l=E(n,"a","fused matMul"),c=E(t,"b","fused matMul");[l,c]=Rn(l,c);const u=e?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?c.shape[c.rank-1]:c.shape[c.rank-2],h=e?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?c.shape[c.rank-2]:c.shape[c.rank-1],p=l.shape.slice(0,-2),m=c.shape.slice(0,-2),g=X(p),y=X(m);S(u===d,()=>`Error in fused matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${e} and transposeB=${r} must match.`);const _=Je(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([h,f]),v=F(l,e?[g,u,h]:[g,h,u]),w=F(c,r?[y,f,d]:[y,d,f]);let C,I;null!=s&&(C=E(s,"bias","fused matMul"),[C]=Rn(C,l),Je(_,C.shape)),null!=o&&(I=E(o,"prelu weights","fused matMul"));const D=(P,z)=>{const[W,G,q,$]=z,V=C_(F(P,q.shape),q,i);let L,H;return e||r?!e&&r?(L=pt(V,G,!1,!1),H=pt(V,W,!0,!1)):e&&!r?(L=pt(G,V,!1,!0),H=pt(W,V,!1,!1)):(L=pt(G,V,!0,!0),H=pt(V,W,!0,!0)):(L=pt(V,G,!1,!0),H=pt(W,V,!0,!1)),null!=s?[L,H,S_($,V)]:[L,H]},T={a:v,b:w,bias:C,preluActivationWeights:I},N={transposeA:e,transposeB:r,activation:i,leakyreluAlpha:a};return null==s?fa((z,W,G)=>{const q=R.runKernel(Lb,T,N);return G([z,W,q]),{value:F(q,_),gradFunc:D}})(v,w):fa((z,W,G,q)=>{const $=R.runKernel(Lb,T,N);return q([z,W,$,G]),{value:F($,_),gradFunc:D}})(v,w,C)}}),$ae=A({hammingWindow_:function Oae(n){return rD(n,.54,.46)}}),NV=A({hannWindow_:function Pae(n){return rD(n,.5,.5)}}),AV=A({frame_:function Lae(n,t,e,r=!1,s=0){let i=0;const o=[];for(;i+t<=n.size;)o.push(Dt(n,i,t)),i+=e;if(r)for(;i<n.size;){const a=i+t-n.size,l=Xn([Dt(n,i,t-a),ud([a],s)]);o.push(l),i+=e}return 0===o.length?Fp([],[0,t]):F(Xn(o),[o.length,t])}}),Bae=A({stft_:function Vae(n,t,e,r,s=NV){null==r&&(r=IV(t));const i=AV(n,t,e),o=M(i,s(t));return w_(o,r)}}),Uae=A({cropAndResize_:function zae(n,t,e,r,s="bilinear",i=0){const o=E(n,"image","cropAndResize"),a=E(t,"boxes","cropAndResize","float32"),l=E(e,"boxInd","cropAndResize","int32"),c=a.shape[0];return S(4===o.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),S(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),S(1===l.rank&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),S(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),S(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),S("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),R.runKernel(BS,{image:o,boxes:a,boxInd:l},{method:s,extrapolationValue:i,cropSize:r})}}),Wae=A({flipLeftRight_:function Hae(n){const t=E(n,"image","flipLeftRight","float32");return S(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),R.runKernel(QS,{image:t},{})}}),Gae=A({grayscaleToRGB_:function jae(n){const t=E(n,"image","grayscaleToRGB"),e=t.rank-1,r=t.shape[e];S(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),S(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(t.rank);return s.fill(1,0,e),s[e]=3,Ti(t,s)}}),Kae=A({rotateWithOffset_:function qae(n,t,e=0,r=.5){const s=E(n,"image","rotateWithOffset","float32");return S(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),R.runKernel(FE,{image:s},{radians:t,fillValue:e,center:r})}});function md(n,t,e,r,s,i){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==i&&(i=0);const o=n.shape[0];return e=Math.min(e,o),S(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),S(2===n.rank,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),S(4===n.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),S(1===t.rank,()=>"scores must be a 1D tensor"),S(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),S(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:s,softNmsSigma:i}}const Yae=A({nonMaxSuppression_:function Xae(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const i=E(n,"boxes","nonMaxSuppression","float32"),o=E(t,"scores","nonMaxSuppression","float32"),a=md(i,o,e,r,s);return R.runKernel(lE,{boxes:i,scores:o},{maxOutputSize:e=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}});function Zae(n,t,e){const r=function Qae(n,t,e){return function ele(n,t,e){let r=0,s=n.length,i=0,o=!1;for(;r<s;){i=r+(s-r>>>1);const a=e(t,n[i]);a>0?r=i+1:(s=i,o=!a)}return o?r:-r-1}(n,t,e||Jae)}(n,t,e);n.splice(r<0?-(r+1):r,0,t)}function Jae(n,t){return n>t?1:n<t?-1:0}function aD(n,t,e,r,s){return uD(n,t,e,r,s,0)}function lD(n,t,e,r,s,i){return uD(n,t,e,r,s,0,!1,i,!0)}function cD(n,t,e,r,s,i){return uD(n,t,e,r,s,i,!0)}function uD(n,t,e,r,s,i,o=!1,a=!1,l=!1){const c=[];for(let g=0;g<t.length;g++)t[g]>s&&c.push({score:t[g],boxIndex:g,suppressBeginIndex:0});c.sort(RV);const u=i>0?-.5/i:0,d=[],h=[];for(;d.length<e&&c.length>0;){const g=c.pop(),{score:y,boxIndex:b,suppressBeginIndex:_}=g;if(y<s)break;let v=!1;for(let w=d.length-1;w>=_;--w){const C=tle(n,b,d[w]);if(C>=r){v=!0;break}if(g.score=g.score*nle(r,u,C),g.score<=s)break}g.suppressBeginIndex=d.length,v||(g.score===y?(d.push(b),h.push(g.score)):g.score>s&&Zae(c,g,RV))}const f=d.length,p=e-f;a&&p>0&&(d.push(...new Array(p).fill(0)),h.push(...new Array(p).fill(0)));const m={selectedIndices:d};return o&&(m.selectedScores=h),l&&(m.validOutputs=f),m}function tle(n,t,e){const r=n.subarray(4*t,4*t+4),s=n.subarray(4*e,4*e+4),i=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),u=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),f=(a-i)*(l-o),p=(d-c)*(h-u);if(f<=0||p<=0)return 0;const m=Math.max(i,c),g=Math.max(o,u),y=Math.min(a,d),b=Math.min(l,h),_=Math.max(y-m,0)*Math.max(b-g,0);return _/(f+p-_)}function nle(n,t,e){const r=Math.exp(t*e*e);return e<=n?r:0}function RV(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}function dD(){return(dD=ee(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const i=E(n,"boxes","nonMaxSuppressionAsync"),o=E(t,"scores","nonMaxSuppressionAsync"),a=md(i,o,e,r,s);e=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=yield Promise.all([i.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:d}=aD(c,u,e,r,s);return i!==n&&i.dispose(),o!==t&&o.dispose(),fs(d,"int32")})).apply(this,arguments)}const ole=A({nonMaxSuppressionWithScore_:function ile(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=E(n,"boxes","nonMaxSuppression"),a=E(t,"scores","nonMaxSuppression"),l=md(o,a,e,r,s,i),d=R.runKernel(uE,{boxes:o,scores:a},{maxOutputSize:e=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:i=l.softNmsSigma});return{selectedIndices:d[0],selectedScores:d[1]}}});function hD(){return(hD=ee(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=E(n,"boxes","nonMaxSuppressionAsync"),a=E(t,"scores","nonMaxSuppressionAsync"),l=md(o,a,e,r,s,i);e=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const c=yield Promise.all([o.data(),a.data()]),u=c[0],d=c[1],{selectedIndices:h,selectedScores:f}=cD(u,d,e,r,s,i);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:fs(h,"int32"),selectedScores:fs(f)}})).apply(this,arguments)}const ule=A({nonMaxSuppressionPadded_:function cle(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=E(n,"boxes","nonMaxSuppression"),a=E(t,"scores","nonMaxSuppression"),l=md(o,a,e,r,s,null),p=R.runKernel(cE,{boxes:o,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:i});return{selectedIndices:p[0],validOutputs:p[1]}}});function fD(){return(fD=ee(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=E(n,"boxes","nonMaxSuppressionAsync"),a=E(t,"scores","nonMaxSuppressionAsync"),l=md(o,a,e,r,s,null),c=l.maxOutputSize,u=l.iouThreshold,d=l.scoreThreshold,[h,f]=yield Promise.all([o.data(),a.data()]),{selectedIndices:p,validOutputs:m}=lD(h,f,c,u,d,i);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:fs(p,"int32"),validOutputs:Le(m,"int32")}})).apply(this,arguments)}const MV=A({resizeBilinear_:function fle(n,t,e=!1,r=!1){const s=E(n,"images","resizeBilinear");S(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),S(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),S(!1===r||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;3===s.rank&&(o=!0,i=F(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,c=R.runKernel(Db,{images:i},{alignCorners:e,halfPixelCenters:r,size:t});return o?F(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),FV=A({resizeNearestNeighbor_:function ple(n,t,e=!1,r=!1){const s=E(n,"images","resizeNearestNeighbor");S(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),S(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),S("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),S(!1===r||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;3===s.rank&&(o=!0,i=F(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,c=R.runKernel(Ib,{images:i},{alignCorners:e,halfPixelCenters:r,size:t});return o?F(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),yle=A({threshold_:function mle(n,t="binary",e=!1,r=.5){const s=E(n,"image","threshold"),l=s.shape[0]*s.shape[1];let u,d,h,f,c=M(fs([r]),255);if(S(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),S(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),S("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),S("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===s.shape[2]){[u,d,h]=Ns(s,[1,1,1],-1);const g=M(u,.2989),y=M(d,.587),b=M(h,.114);f=le(le(g,y),b)}else f=n;"otsu"===t&&(c=function gle(n,t){let i,o,a,l,c,u,e=fs([-1]),r=fs([0]),s=fs([0]);for(let d=0;d<n.size-1;d++){i=Dt(n,0,d+1),o=Dt(n,d+1),c=$e(Ae(i),t),u=$e(Ae(o),t);const h=Ae(M(i,fd(0,i.size)));a=$e(h,Ae(i));const f=ud(o.shape,i.size),p=le(fd(0,o.size),f),m=M(o,p);l=$e(Ae(m),Ae(o));const g=De(a,l),y=De(a,l),b=M(c,u);s=M(M(b,g),y);const _=ks(s,r);r=ds(_,s,r),e=ds(_,fs([d]),e)}return e}(BL(ve(UI(f),"int32"),so([]),256),l));const p=e?hc(f,c):ks(f,c);return ve(M(p,255),"int32")}}),_le=A({transform_:function ble(n,t,e="nearest",r="constant",s=0,i){const o=E(n,"image","transform","float32"),a=E(t,"transforms","transform","float32");return S(4===o.rank,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),S(2===a.rank&&(a.shape[0]===o.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),S(null==i||2===i.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`),R.runKernel(AE,{image:o,transforms:a},{interpolation:e,fillMode:r,fillValue:s,outputShape:i})}}),xle=A({bandPart_:function vle(n,t,e){S(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),S(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);const r=E(n,"a","bandPart");S(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[i,o]=r.shape.slice(-2);if(!(t<=i))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`);if(!(e<=o))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${o}).`);t<0&&(t=i),e<0&&(e=o);const a=F(fd(0,i,1,"int32"),[-1,1]),l=fd(0,o,1,"int32"),c=De(a,l),u=Ro(hc(c,Le(+t,"int32")),al(c,Le(-e,"int32"))),d=sr([i,o],r.dtype);return F(ri(Ni(F(r,[-1,i,o])).map(h=>ds(u,h,d))),s)}}),Cle=A({gramSchmidt_:function wle(n){let t;if(Array.isArray(n)){t=!1,S(null!=n&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let i=1;i<n.length;++i)S(n[i].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${s})`)}else t=!0,n=Ns(n,n.shape[0],0).map(s=>fc(s,[0]));S(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],r=n;for(let s=0;s<n.length;++s)e.push(R.tidy(()=>{let i=r[s];if(s>0)for(let o=0;o<s;++o){const a=M(Ae(M(e[o],i)),e[o]);i=De(i,a)}return $e(i,Ip(i,"euclidean"))}));return t?ri(e,0):e}});function OV(n,t=!1){return R.tidy(()=>{S(2===n.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],r=n.shape[1];let s=AI(e),i=ha(n);const o=Fp([[1]],[1,1]);let a=ha(o);const l=e>=r?r:e;for(let c=0;c<l;++c){const u=i,d=a,h=s;[a,i,s]=R.tidy(()=>{const f=Dt(i,[c,c],[e-c,1]),p=Ip(f),m=Dt(i,[c,c],[1,1]),g=ds(ks(m,0),Fp([[-1]]),Fp([[1]])),y=De(m,M(g,p)),b=$e(f,y);a=1===b.shape[0]?ha(o):Xn([o,Dt(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const _=yn($e(pt(g,y),p)),v=Dt(i,[c,0],[e-c,r]),w=M(_,a),C=vt(a);if(0===c)i=De(v,pt(w,pt(C,v)));else{const T=De(v,pt(w,pt(C,v)));i=Xn([Dt(i,[0,0],[c,r]),T],0)}const I=vt(w),D=Dt(s,[0,c],[e,s.shape[1]-c]);if(0===c)s=De(D,pt(pt(D,a),I));else{const T=De(D,pt(pt(D,a),I));s=Xn([Dt(s,[0,0],[e,c]),T],1)}return[a,i,s]}),ot([u,d,h])}return!t&&e>r&&(s=Dt(s,[0,0],[e,r]),i=Dt(i,[0,0],[r,r])),[s,i]})}const Ele=A({qr_:function Sle(n,t=!1){if(S(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),2===n.rank)return OV(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),r=Ni(F(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],i=[];return r.forEach(l=>{const[c,u]=OV(l,t);s.push(c),i.push(u)}),[F(ri(s,0),n.shape),F(ri(i,0),n.shape)]}}});var Xr=(()=>{return(n=Xr||(Xr={}))[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",Xr;var n})();const ya=A({computeWeightedLoss_:function Ile(n,t,e=Xr.SUM_BY_NONZERO_WEIGHTS){const r=E(n,"losses","computeWeightedLoss");let s=null;null!=t&&(s=E(t,"weights","computeWeightedLoss"));const i=null==s?r:M(r,s);if(e===Xr.NONE)return i;if(e===Xr.SUM)return Ae(i);if(e===Xr.MEAN){if(null==s)return Mn(i);{const o=r.size/s.size,a=$e(Ae(i),Ae(s));return o>1?$e(a,Le(o)):a}}if(e===Xr.SUM_BY_NONZERO_WEIGHTS){if(null==s)return $e(Ae(i),Le(r.size));{const o=M(s,ti(r.shape)),a=ve(Ae(hd(o,Le(0))),"float32");return $e(Ae(i),a)}}throw Error(`Unknown reduction: ${e}`)}}),Tle=A({absoluteDifference_:function Dle(n,t,e,r=Xr.SUM_BY_NONZERO_WEIGHTS){const s=E(n,"labels","absoluteDifference"),i=E(t,"predictions","absoluteDifference");let o=null;null!=e&&(o=E(e,"weights","absoluteDifference")),Is(s.shape,i.shape,"Error in absoluteDifference: ");const a=rr(De(s,i));return ya(a,o,r)}}),Nle=A({cosineDistance_:function kle(n,t,e,r,s=Xr.SUM_BY_NONZERO_WEIGHTS){const i=E(n,"labels","cosineDistance"),o=E(t,"predictions","cosineDistance");let a=null;null!=r&&(a=E(r,"weights","cosineDistance")),Is(i.shape,o.shape,"Error in cosineDistance: ");const l=Le(1),c=De(l,Ae(M(i,o),e,!0));return ya(c,a,s)}}),Rle=A({hingeLoss_:function Ale(n,t,e,r=Xr.SUM_BY_NONZERO_WEIGHTS){let s=E(n,"labels","hingeLoss");const i=E(t,"predictions","hingeLoss");let o=null;null!=e&&(o=E(e,"weights","hingeLoss")),Is(s.shape,i.shape,"Error in hingeLoss: ");const a=Le(1);s=De(M(Le(2),s),a);const l=Mo(De(a,M(s,i)));return ya(l,o,r)}}),Fle=A({huberLoss_:function Mle(n,t,e,r=1,s=Xr.SUM_BY_NONZERO_WEIGHTS){const i=E(n,"labels","huberLoss"),o=E(t,"predictions","huberLoss");let a=null;null!=e&&(a=E(e,"weights","huberLoss")),Is(i.shape,o.shape,"Error in huberLoss: ");const l=Le(r),c=rr(De(o,i)),u=kp(c,l),d=De(c,u),h=le(M(Le(.5),Yt(u)),M(l,d));return ya(h,a,s)}}),$le=A({logLoss_:function Ole(n,t,e,r=1e-7,s=Xr.SUM_BY_NONZERO_WEIGHTS){const i=E(n,"labels","logLoss"),o=E(t,"predictions","logLoss");let a=null;null!=e&&(a=E(e,"weights","logLoss")),Is(i.shape,o.shape,"Error in logLoss: ");const l=Le(1),c=Le(r),u=yn(M(i,ei(le(o,c)))),d=M(De(l,i),ei(le(De(l,o),c))),h=De(u,d);return ya(h,a,s)}}),Lle=A({meanSquaredError_:function Ple(n,t,e,r=Xr.SUM_BY_NONZERO_WEIGHTS){const s=E(n,"labels","meanSquaredError"),i=E(t,"predictions","meanSquaredError");let o=null;null!=e&&(o=E(e,"weights","meanSquaredError")),Is(s.shape,i.shape,"Error in meanSquaredError: ");const a=ZI(s,i);return ya(a,o,r)}}),zle=A({sigmoidCrossEntropy_:function Ble(n,t,e,r=0,s=Xr.SUM_BY_NONZERO_WEIGHTS){let i=E(n,"multiClassLabels","sigmoidCrossEntropy");const o=E(t,"logits","sigmoidCrossEntropy");let a=null;if(null!=e&&(a=E(e,"weights","sigmoidCrossEntropy")),Is(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const c=Le(r),u=Le(1),d=Le(.5);i=le(M(i,De(u,c)),M(d,c))}const l=function Vle(n,t){const e=E(n,"labels","sigmoidCrossEntropyWithLogits"),r=E(t,"logits","sigmoidCrossEntropyWithLogits");Is(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Mo(r),i=M(r,e),o=u_(Js(yn(rr(r))));return le(De(s,i),o)}(i,o);return ya(l,a,s)}}),Wle=A({softmaxCrossEntropy_:function Hle(n,t,e,r=0,s=Xr.SUM_BY_NONZERO_WEIGHTS){let i=E(n,"onehotLabels","softmaxCrossEntropy");const o=E(t,"logits","softmaxCrossEntropy");let a=null;if(null!=e&&(a=E(e,"weights","softmaxCrossEntropy")),Is(i.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const c=Le(r),u=Le(1),d=Le(i.shape[1]);i=le(M(i,De(u,c)),$e(c,d))}const l=function Ule(n,t,e=-1){if(-1===e&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return fa((s,i,o)=>{const l=FI(i,[e],!0),c=De(ve(i,"float32"),l);o([s,c]);const u=yn(M(c,s));return{value:Ae(u,[e]),gradFunc:(f,p)=>{const[m,g]=p,y=Vn(f.shape,[e]);return[M(F(f,y),De(ve(m,"float32"),Js(g))),M(F(f,y),De(Js(g),ve(m,"float32")))]}}})(n,t)}(i,o);return ya(l,a,s)}}),Gle=A({sparseFillEmptyRows_:function jle(n,t,e,r){const s=E(n,"indices","sparseFillEmptyRows","int32"),i=E(t,"values","sparseFillEmptyRows"),o=E(e,"denseShape","sparseFillEmptyRows","int32"),a=E(r,"defaultValue","sparseFillEmptyRows",i.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==i.rank)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(1!==o.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(0!==a.rank)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const c=R.runKernel(vE,{indices:s,values:i,denseShape:o,defaultValue:a});return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}}),Kle=A({sparseReshape_:function qle(n,t,e){const r=E(n,"inputIndices","sparseReshape","int32"),s=E(t,"inputShape","sparseReshape","int32"),i=E(e,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const a=R.runKernel(xE,{inputIndices:r,inputShape:s,newShape:i});return{outputIndices:a[0],outputShape:a[1]}}}),Yle=A({sparseSegmentMean_:function Xle(n,t,e){const r=E(n,"data","sparseSegmentMean"),s=E(t,"indices","sparseSegmentMean","int32"),i=E(e,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${i.shape}`);return R.runKernel(wE,{data:r,indices:s,segmentIds:i})}}),Qle=A({sparseSegmentSum_:function Zle(n,t,e){const r=E(n,"data","sparseSegmentSum"),s=E(t,"indices","sparseSegmentSum","int32"),i=E(e,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${i.shape}`);return R.runKernel(CE,{data:r,indices:s,segmentIds:i})}}),ece=A({stringNGrams_:function Jle(n,t,e,r,s,i,o,a){const l=E(n,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=E(t,"dataSplits","stringNGrams");if("int32"!==c.dtype)throw new Error("Data splits must be of datatype int32");const h=R.runKernel(DE,{data:l,dataSplits:c},{separator:e,nGramWidths:r,leftPad:s,rightPad:i,padWidth:o,preserveShortSequences:a});return{nGrams:h[0],nGramsSplits:h[1]}}}),nce=A({stringSplit_:function tce(n,t,e=!0){const r=E(n,"input","stringSplit","string"),s=E(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a=R.runKernel(TE,{input:r,delimiter:s},{skipEmpty:e});return{indices:a[0],values:a[1],shape:a[2]}}}),sce=A({stringToHashBucketFast_:function rce(n,t){const e=E(n,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");return R.runKernel(kE,{input:e},r)}}),ice={fft:x_,ifft:Mp,rfft:w_,irfft:YI},oce={hammingWindow:$ae,hannWindow:NV,frame:AV,stft:Bae},ba={flipLeftRight:Wae,grayscaleToRGB:Gae,resizeNearestNeighbor:FV,resizeBilinear:MV,rotateWithOffset:Kae,cropAndResize:Uae,nonMaxSuppression:Yae,nonMaxSuppressionAsync:function rle(n,t,e){return dD.apply(this,arguments)},nonMaxSuppressionWithScore:ole,nonMaxSuppressionWithScoreAsync:function ale(n,t,e){return hD.apply(this,arguments)},nonMaxSuppressionPadded:ule,nonMaxSuppressionPaddedAsync:function dle(n,t,e){return fD.apply(this,arguments)},threshold:yle,transform:_le},$V={bandPart:xle,gramSchmidt:Cle,qr:Ele},ace={absoluteDifference:Tle,computeWeightedLoss:ya,cosineDistance:Nle,hingeLoss:Rle,huberLoss:Fle,logLoss:$le,meanSquaredError:Lle,sigmoidCrossEntropy:zle,softmaxCrossEntropy:Wle},lce={sparseFillEmptyRows:Gle,sparseReshape:Kle,sparseSegmentMean:Yle,sparseSegmentSum:Qle},cce={stringNGrams:ece,stringSplit:nce,stringToHashBucketFast:sce};let pD=(()=>{class n extends tl{constructor(e,r,s=null){super(),this.learningRate=e,this.rho=r,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==s&&(this.epsilon=R.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=R.registeredVariables[s];null==this.accumulatedGrads[i]&&(this.accumulatedGrads[i]={originalName:`${s}/accum_grad`,variable:B(()=>Tt(o).variable(!1))}),null==this.accumulatedUpdates[i]&&(this.accumulatedUpdates[i]={originalName:`${s}/accum_var`,variable:B(()=>Tt(o).variable(!1))});const l=Array.isArray(e)?e[i].tensor:e[s];if(null==l)return;const c=this.accumulatedGrads[i].variable,u=this.accumulatedUpdates[i].variable;B(()=>{const d=le(M(c,this.rho),M(Yt(l),1-this.rho)),h=M($e(Pr(le(u,this.epsilon)),Pr(le(c,this.epsilon))),l),f=le(M(u,this.rho),M(Yt(h),1-this.rho));c.assign(d),u.assign(f);const p=le(M(h,-this.learningRate),o);o.assign(p)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(ot(this.accumulatedGrads.map(e=>e.variable)),ot(this.accumulatedUpdates.map(e=>e.variable)))}getWeights(){var e=this;return ee(function*(){const r=[...e.accumulatedGrads,...e.accumulatedUpdates];return[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return ee(function*(){const s=(e=yield r.extractIterations(e)).length/2;r.accumulatedGrads=e.slice(0,s).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),r.accumulatedUpdates=e.slice(s,2*s).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,r){return new e(r.learningRate,r.rho,r.epsilon)}}return n.className="Adadelta",n})();se(pD);let mD=(()=>{class n extends tl{constructor(e,r=.1){super(),this.learningRate=e,this.initialAccumulatorValue=r,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=R.registeredVariables[s];null==this.accumulatedGrads[i]&&(this.accumulatedGrads[i]={originalName:`${s}/accumulator`,variable:B(()=>ud(o.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[i].tensor:e[s];if(null==a)return;const l=this.accumulatedGrads[i].variable;B(()=>{const c=le(l,Yt(a));l.assign(c);const u=le(M($e(a,Pr(le(c,R.backend.epsilon()))),-this.learningRate),o);o.assign(u)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&ot(this.accumulatedGrads.map(e=>e.variable))}getWeights(){var e=this;return ee(function*(){return[yield e.saveIterations()].concat(e.accumulatedGrads.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(e){var r=this;return ee(function*(){e=yield r.extractIterations(e),r.accumulatedGrads=e.map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,r){return new e(r.learningRate,r.initialAccumulatorValue)}}return n.className="Adagrad",n})();se(mD);let gD=(()=>{class n extends tl{constructor(e,r,s,i=null){super(),this.learningRate=e,this.beta1=r,this.beta2=s,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],B(()=>{this.accBeta1=Le(r).variable(),this.accBeta2=Le(s).variable()}),null==i&&(this.epsilon=R.backend.epsilon())}applyGradients(e){const r=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);B(()=>{const s=De(1,this.accBeta1),i=De(1,this.accBeta2);r.forEach((o,a)=>{const l=R.registeredVariables[o];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:B(()=>Tt(l).variable(!1))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${o}/v`,variable:B(()=>Tt(l).variable(!1))});const u=Array.isArray(e)?e[a].tensor:e[o];if(null==u)return;const d=this.accumulatedFirstMoment[a].variable,h=this.accumulatedSecondMoment[a].variable,f=le(M(d,this.beta1),M(u,1-this.beta1)),p=le(M(h,this.beta2),M(Yt(u),1-this.beta2)),m=$e(f,s),g=$e(p,i);d.assign(f),h.assign(p);const y=le(M($e(m,le(Pr(g),this.epsilon)),-this.learningRate),l);l.assign(y)}),this.accBeta1.assign(M(this.accBeta1,this.beta1)),this.accBeta2.assign(M(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&ot(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&ot(this.accumulatedSecondMoment.map(e=>e.variable))}getWeights(){var e=this;return ee(function*(){const r=[...e.accumulatedFirstMoment,...e.accumulatedSecondMoment];return[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return ee(function*(){e=yield r.extractIterations(e),B(()=>{r.accBeta1.assign(ol(r.beta1,r.iterations_+1)),r.accBeta2.assign(ol(r.beta2,r.iterations_+1))});const s=e.length/2;r.accumulatedFirstMoment=e.slice(0,s).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),r.accumulatedSecondMoment=e.slice(s,2*s).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,r){return new e(r.learningRate,r.beta1,r.beta2,r.epsilon)}}return n.className="Adam",n})();se(gD);let yD=(()=>{class n extends tl{constructor(e,r,s,i=null,o=0){super(),this.learningRate=e,this.beta1=r,this.beta2=s,this.epsilon=i,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],B(()=>{this.iteration=Le(0).variable(),this.accBeta1=Le(r).variable()}),null==i&&(this.epsilon=R.backend.epsilon())}applyGradients(e){const r=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);B(()=>{const s=De(1,this.accBeta1),i=$e(-this.learningRate,le(M(this.iteration,this.decay),1));r.forEach((o,a)=>{const l=R.registeredVariables[o];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:Tt(l).variable(!1)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${o}/v`,variable:Tt(l).variable(!1)});const u=Array.isArray(e)?e[a].tensor:e[o];if(null==u)return;const d=this.accumulatedFirstMoment[a].variable,h=this.accumulatedWeightedInfNorm[a].variable,f=le(M(d,this.beta1),M(u,1-this.beta1)),p=M(h,this.beta2),m=rr(u),g=ga(p,m);d.assign(f),h.assign(g);const y=le(M($e(i,s),$e(f,le(g,this.epsilon))),l);l.assign(y)}),this.iteration.assign(le(this.iteration,1)),this.accBeta1.assign(M(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&ot(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&ot(this.accumulatedWeightedInfNorm.map(e=>e.variable))}getWeights(){return ee(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(e){return ee(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,r){return new e(r.learningRate,r.beta1,r.beta2,r.epsilon,r.decay)}}return n.className="Adamax",n})();se(yD);let D_=(()=>{class n extends tl{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=Array.isArray(e)?e[i].tensor:e[s];if(null==o)return;const a=R.registeredVariables[s];B(()=>{const l=le(M(this.c,o),a);a.assign(l)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=_r(Le(-e))}dispose(){this.c.dispose()}getWeights(){var e=this;return ee(function*(){return[yield e.saveIterations()]})()}setWeights(e){var r=this;return ee(function*(){if(0!==(e=yield r.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,r){return new e(r.learningRate)}}return n.className="SGD",n})();se(D_);let bD=(()=>{class n extends D_{constructor(e,r,s=!1){super(e),this.learningRate=e,this.momentum=r,this.useNesterov=s,this.accumulations=[],this.m=Le(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=R.registeredVariables[s];null==this.accumulations[i]&&(this.accumulations[i]={originalName:`${s}/momentum`,variable:B(()=>Tt(o).variable(!1))});const a=this.accumulations[i].variable,l=Array.isArray(e)?e[i].tensor:e[s];null!=l&&B(()=>{let c;const u=le(M(this.m,a),l);c=le(M(this.c,this.useNesterov?le(l,M(u,this.m)):u),o),a.assign(u),o.assign(c)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&ot(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}getWeights(){var e=this;return ee(function*(){return[yield e.saveIterations()].concat(e.accumulations.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(e){var r=this;return ee(function*(){e=yield r.extractIterations(e),r.accumulations=e.map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,r){return new e(r.learningRate,r.momentum,r.useNesterov)}}return n.className="Momentum",n})();se(bD);let _D=(()=>{class n extends tl{constructor(e,r=.9,s=0,i=null,o=!1){if(super(),this.learningRate=e,this.decay=r,this.momentum=s,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,null==i&&(this.epsilon=R.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=R.registeredVariables[s],a=!1;null==this.accumulatedMeanSquares[i]&&(this.accumulatedMeanSquares[i]={originalName:`${s}/rms`,variable:B(()=>Tt(o).variable(a))}),null==this.accumulatedMoments[i]&&(this.accumulatedMoments[i]={originalName:`${s}/momentum`,variable:B(()=>Tt(o).variable(a))}),null==this.accumulatedMeanGrads[i]&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${s}/mg`,variable:B(()=>Tt(o).variable(a))});const l=Array.isArray(e)?e[i].tensor:e[s];if(null==l)return;const c=this.accumulatedMeanSquares[i].variable,u=this.accumulatedMoments[i].variable;B(()=>{const d=le(M(c,this.decay),M(Yt(l),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[i].variable,f=le(M(h,this.decay),M(l,1-this.decay)),p=$e(M(l,this.learningRate),Pr(De(d,le(Yt(f),this.epsilon)))),m=le(M(u,this.momentum),p);c.assign(d),h.assign(f),u.assign(m);const g=De(o,m);o.assign(g)}else{const h=le(M(c,this.decay),M(Yt(l),1-this.decay)),f=le(M(u,this.momentum),$e(M(l,this.learningRate),Pr(le(h,this.epsilon))));c.assign(h),u.assign(f);const p=De(o,f);o.assign(p)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&ot(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&ot(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&ot(this.accumulatedMoments.map(e=>e.variable))}getWeights(){var e=this;return ee(function*(){const r=[...e.accumulatedMeanSquares,...e.accumulatedMoments];return e.centered&&r.push(...e.accumulatedMeanGrads),[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return ee(function*(){e=yield r.extractIterations(e);const s=r.centered?e.length/3:e.length/2,i=!1;r.accumulatedMeanSquares=e.slice(0,s).map(o=>({originalName:o.name,variable:o.tensor.variable(i)})),r.accumulatedMoments=e.slice(s,2*s).map(o=>({originalName:o.name,variable:o.tensor.variable(i)})),r.centered&&(r.accumulatedMeanGrads=e.slice(2*s,3*s).map(o=>({originalName:o.name,variable:o.tensor.variable(i)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,r){return new e(r.learningRate,r.decay,r.momentum,r.epsilon,r.centered)}}return n.className="RMSProp",n})();se(_D);class pc{static sgd(t){return new D_(t)}static momentum(t,e,r=!1){return new bD(t,e,r)}static rmsprop(t,e=.9,r=0,s=null,i=!1){return new _D(t,e,r,s,i)}static adam(t=.001,e=.9,r=.999,s=null){return new gD(t,e,r,s)}static adadelta(t=.001,e=.95,r=null){return new pD(t,e,r)}static adamax(t=.002,e=.9,r=.999,s=null,i=0){return new yD(t,e,r,s,i)}static adagrad(t,e=.1){return new mD(t,e)}}const gd={sgd:pc.sgd,momentum:pc.momentum,adadelta:pc.adadelta,adagrad:pc.adagrad,rmsprop:pc.rmsprop,adamax:pc.adamax,adam:pc.adam},uce=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function PV(){return new Promise(n=>uce(()=>n()))}function vD(n,t){const e=n[0].length;n.forEach((s,i)=>{S(s.length===e,()=>`Error in concat${e}D: rank of tensors[${i}] must be the same as the rank of the rest (${e})`)}),S(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const r=n[0];n.forEach((s,i)=>{for(let o=0;o<e;o++)S(o===t||s[o]===r[o],()=>`Error in concat${e}D: Shape of tensors[${i}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`)})}function Fo(n,t){const e=n[0].slice();for(let r=1;r<n.length;r++)e[t]+=n[r][t];return e}var Ai=(()=>{return(n=Ai||(Ai={}))[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS",Ai;var n})();function LV(n,t,e){let r=new Array;if(null==e&&null==t)return r;if(null==t)for(;r.length<n+e.length;)r.push(-1);else r=t.slice();if(null==e)return r;if(n+e.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${r.length}`);for(let s=1;s<e.length;++s){const i=e[s],o=r[r.length-e.length+s],a=r[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+n}] = ${i} but shape[${s+n}] = ${a}`)}else r[o]=i}return r}function VV(n){const t={FIRST_DIM_SIZE:Ai.FIRST_DIM_SIZE,VALUE_ROWIDS:Ai.VALUE_ROWIDS,ROW_LENGTHS:Ai.ROW_LENGTHS,ROW_SPLITS:Ai.ROW_SPLITS,ROW_LIMITS:Ai.ROW_LIMITS,ROW_STARTS:Ai.ROW_STARTS},e=[];for(const r of n){if(!(r in t))break;e.push(t[r])}return e}function BV(n){return 0===n.length?0:n[0]===Ai.FIRST_DIM_SIZE?n.length-1:n.length}function zV(n,t){if(null==n||null==t)return;const e=n.length,r=t.length;if(e>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(e,r-1);++s){const i=n[s],o=t[s+1];if(i>=0&&o>=0&&1!==i&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-n.length}] = ${i} but ragged tensor input.flatValues.shape[${s-n.length}] = ${o}`)}}const xD=30;function T_(n){return n<=xD?n:ES(n,Math.floor(Math.sqrt(n)))}function wD(n,t,e){return[e*("number"==typeof n?n:n[0]),t*("number"==typeof n?n:n[1])]}function $p(n,t,e,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(n[0]/e),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const i=t.length;for(let o=0;o<i;++o)s=s.concat([n[o+1]/t[o],t[o]]);s=s.concat(n.slice(i+1))}return s}function Pp(n,t,e=!0){const r=[];if(e){r.push(t);for(let s=t+1;s<n;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{const s=[],i=[];for(let o=1;o<n;++o)o>=2*t+1||o%2==1?i.push(o):s.push(o);r.push(...s),r.push(0),r.push(...i)}return r}function Lp(n,t,e,r=!0){const s=[];s.push(r?n[0]/e:n[0]*e);for(let i=1;i<n.length;++i)s.push(i<=t.length?r?t[i-1]*n[i]:n[i]/t[i-1]:n[i]);return s}function CD(n,t){const e=[0];for(let r=0;r<t;++r)e.push(n[r][0]);return e}function SD(n,t,e){const r=n.slice(0,1);for(let s=0;s<e;++s)r.push(n[s+1]-t[s][0]-t[s][1]);return r}function ED(n,t){const e=n.shape.length,r=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${e}`);if(0===X(n.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=t.shape,i=s[s.length-1];let o=1;for(let d=0;d<s.length-1;++d)o*=s[d];const a=n.shape,l=s.slice();l.pop();let c=1;for(let d=i;d<e;++d)c*=a[d],l.push(a[d]);const u=[...Pe(n.shape).map(d=>d/c),1].slice(0,i);return[l,o,c,u]}const k_=1.7580993408473768,N_=1.0507009873554805,ID=.3275911,DD=.254829592,TD=-.284496736,kD=1.421413741,ND=-1.453152027,AD=1.061405429;function _a(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(2*n.length);for(let r=0;r<e.length;r+=2)e[r]=n[r/2],e[r+1]=t[r/2];return e}function UV(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)t[r/2]=n[r],e[r/2]=n[r+1];return{real:t,imag:e}}function HV(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function WV(n){const t=Math.floor(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function RD(n,t){return{real:n[2*t],imag:n[2*t+1]}}function jV(n,t,e,r){n[2*r]=t,n[2*r+1]=e}function GV(n,t){const e=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const i=(t?2:-2)*Math.PI*(s/n);e[s]=Math.cos(i),r[s]=Math.sin(i)}return{real:e,imag:r}}function qV(n,t,e){const r=(e?2:-2)*Math.PI*(n/t);return{real:Math.cos(r),imag:Math.sin(r)}}const dce=/->/g;function FD(n,t){const e=((n=n.replace(/\s/g,"")).length-n.replace(dce,"").length)/"->".length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,s]=n.split("->");S(-1===r.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const i=r.split(","),o=i.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<s.length;++h){const f=s[h];if(!i.some(p=>-1!==p.indexOf(f)))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);-1===a.indexOf(f)&&a.push(f)}for(let h=0;h<r.length;++h){const f=r[h];-1===a.indexOf(f)&&","!==f&&a.push(f)}const l=new Array(i.length);for(let h=0;h<o;++h){if(new Set(i[h].split("")).size!==i[h].length)throw new Error(`Found duplicate axes in input component ${i[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let f=0;f<i[h].length;++f)l[h].push(a.indexOf(i[h][f]))}const c=a.length,d=[];for(let h=s.length;h<c;++h)d.push(h);return{allDims:a,summedDims:d,idDims:l}}function OD(n,t){let e=new Array(n);e.fill(-1);for(let s=0;s<t.length;++s)e[t[s]]=s;const r=[];for(let s=0;s<n;++s)-1===e[s]&&r.push(s);return e=e.filter(s=>-1!==s),{permutationIndices:e,expandDims:r}}function $D(n,t,e){const r=new Array(n);for(let s=0;s<e.length;++s){const i=e[s].shape;for(let o=0;o<t[s].length;++o)void 0===r[t[s][o]]?r[t[s][o]]=i[o]:S(r[t[s][o]]===i[o],()=>`Expected dimension ${r[t[s][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function PD(n,t){const e=n,r=[];let s=0;0===n.length&&e.push(-1),s=n.length+1;for(let o=0;o<s;++o)r.push([]);const i=[];for(let o=0;o<e.length;++o){const l=hce(t,e[o]);for(const c of l)-1===i.indexOf(c)&&(r[o].push(c),i.push(c))}return{path:e,steps:r}}function LD(n){return n.every((t,e)=>t===e)}function hce(n,t){const e=[];for(let r=0;r<n.length;++r)(0===n[r].length||-1!==n[r].indexOf(t)||-1===t)&&e.push(r);return e}function VD(n,t,e=0){let r=[];if("number"==typeof t)S(n.shape[e]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(n.shape[e]/t);else{S(t.reduce((o,a)=>(-1===a&&(o+=1),o),0)<=1,()=>"There should be only one negative value in split array.");const i=t.indexOf(-1);if(-1!==i){const o=t.reduce((a,l)=>l>0?a+l:a);t[i]=n.shape[e]-o}S(n.shape[e]===t.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function YV(n){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${n}`}function ZV(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function QV(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function JV(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function eB(n,t){return`size ${n} must be non-negative, not ${t}`}function tB(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function nB(n,t){return`Input to reshape is a SparseTensor with ${X(n)}\n  dense values, but the requested shape requires a multiple of ${X(t)}. inputShape=${n} outputShape= ${t}`}function rB(n,t){return`Input to reshape is a tensor with ${X(n)} dense values, but the requested shape has ${X(t)}. inputShape=${n} outputShape=${t}`}function BD(){return"segment ids must be >= 0"}function sB(){return"segment ids are not increasing"}function iB(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function oB(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function aB(n,t){let r,e=!1;for(n<=xD?(r=n,e=!0):r=ES(n,Math.floor(Math.sqrt(n)));!e;)r>t||r===n?e=!0:r=ES(n,r+1);return r}function lB(n,t,e){const r=[],s=n.length;for(let i=0;i<s;i++)r.push(i!==t?n[i]:e);return r}function zD(n,t,e,r){const s=t.shape.length,i=n.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>i)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${i}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let d=0;d<r;++d)if(n.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const o=n.shape[e],a=[];let l=1,c=1,u=1;for(let d=0;d<r;++d)a.push(n.shape[d]),l*=n.shape[d];for(let d=r;d<e;d++)a.push(n.shape[d]),c*=n.shape[d];for(let d=r;d<s;d++)a.push(t.shape[d]);for(let d=e+1;d<i;d++)a.push(n.shape[d]),u*=n.shape[d];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}function mc(n){try{return n.map(t=>Ya(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function cB(n){return n.map(t=>Xa(t))}const uB={kernelName:Py,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,pd(ve(e,"float32"),-1))}}},fce={kernelName:xf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=Yt(ve(e,"float32")),s=Pr(De(Le(1),r));return yn($e(n,s))}}}},pce={kernelName:wf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=Pr(De(Yt(ve(e,"float32")),1));return $e(n,r)}}}},mce={kernelName:Yu,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Je(e.shape,r.shape);return{a:()=>{let a=n;const l=nr(e.shape,s);return l.length>0&&(a=Ae(a,l)),F(a,e.shape)},b:()=>{let a=n;const l=nr(r.shape,s);return l.length>0&&(a=Ae(a,l)),F(a,r.shape)}}}},gce={kernelName:Ly,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((r,s)=>{e[s]=()=>n.clone()}),e}},yce={kernelName:Vy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Tt(e)}}},bce={kernelName:By,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Tt(e)}}},_ce={kernelName:Cf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$e(n,Pr(De(Le(1),Yt(ve(e,"float32")))))}}},vce={kernelName:Sf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=Pr(le(Le(1),Yt(ve(e,"float32"))));return $e(n,r)}}}},xce={kernelName:Df,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Je(e.shape,r.shape);return{a:()=>{const a=le(Yt(e),Yt(r));let l=M(n,$e(r,a));const c=nr(e.shape,s);return c.length>0&&(l=Ae(l,c)),F(l,e.shape)},b:()=>{const a=le(Yt(e),Yt(r));let l=yn(M(n,$e(e,a)));const c=nr(r.shape,s);return c.length>0&&(l=Ae(l,c)),F(l,r.shape)}}}},wce={kernelName:Ef,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$e(n,le(Yt(ve(e,"float32")),1))}}},Cce={kernelName:If,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$e(n,De(Le(1),Yt(ve(e,"float32"))))}}},Ece=A({avgPool3dGrad_:function Sce(n,t,e,r,s,i){const o=E(n,"dy","avgPool3dGrad"),a=E(t,"input","avgPool3dGrad");let l=o,c=a,u=!1;4===a.rank&&(u=!0,l=F(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),S(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),S(5===c.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),Kr("avgPool3dGrad",s,i);const f=R.runKernel(RS,{dy:l,input:c},{filterSize:e,strides:r,pad:s,dimRoundingMode:i});return u?F(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),Ice={kernelName:Uy,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:a}=e;return{x:()=>Ece(n,r,s,i,o,a)}}},Tce=A({avgPoolGrad_:function Dce(n,t,e,r,s){const i=E(n,"dy","avgPoolGrad"),o=E(t,"input","avgPoolGrad");S(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,c=!1;3===o.rank&&(c=!0,a=F(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),S(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const h=R.runKernel(AS,{dy:l,input:a},{filterSize:e,strides:r,pad:s});return c?F(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),kce={kernelName:zy,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:s,strides:i,pad:o}=e;return{x:()=>Tce(n,r,s,i,o)}}},Nce={kernelName:Hy,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[r,s]=t,{transposeA:i,transposeB:o}=e;return i||o?!i&&o?{a:()=>pt(n,s,!1,!1),b:()=>pt(n,r,!0,!1)}:i&&!o?{a:()=>pt(s,n,!1,!0),b:()=>pt(r,n,!1,!1)}:{a:()=>pt(s,n,!0,!0),b:()=>pt(n,r,!0,!0)}:{a:()=>pt(n,s,!1,!0),b:()=>pt(r,n,!0,!1)}}},Ace={kernelName:Wy,gradFunc:(n,t,e)=>{const{blockShape:r,crops:s}=e;return{x:()=>m_(n,r,s)}}},Rce={kernelName:"BroadcastTo",gradFunc:(n,t,e)=>{const s=e.inputShape,i=e.shape,o=Array.from(i);for(let l=s.length-1;l>=0;l--)if(s[l]===i[l])o[l]=1;else if(1!==s[l])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>Ae(n,a,!0)}}},Mce={kernelName:Tf,gradFunc:n=>({x:()=>n.clone()})},Fce={kernelName:kf,gradFunc:n=>({x:()=>Tt(n)})},Oce={kernelName:Nf,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{clipValueMin:s,clipValueMax:i}=e;return{x:()=>ds(Ro(al(r,s),hc(r,i)),n,Tt(n))}}},$ce={kernelName:jy,inputsToSave:["x"],gradFunc:uB.gradFunc},Pce={kernelName:Gy,saveAllInputs:!0,gradFunc:(n,t,e)=>{const r=t.map(l=>l.shape),{axis:s}=e,i=ht(s,t[0].shape)[0],o=r.map(l=>l[i]);return Ns(n,o,i).map(l=>()=>l)}},Lce={kernelName:qy,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,{dilations:i,strides:o,pad:a,dataFormat:l}=e;return S(rl(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>SI(r.shape,n,s,o,a,l),filter:()=>iD(r,n,s.shape,o,a,l)}}},Vce={kernelName:Ky,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>sl(n,s,i,o,a,1,l),filter:()=>iD(n,r,s.shape,i,o,a,l)}}},zce=A({conv3DBackpropFilter_:function Bce(n,t,e,r,s){let i=n;4===n.rank&&(i=F(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=t;return 4===o.rank&&(o=F(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),S(5===i.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),S(5===o.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),S(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),S(i.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${e[3]}.`),S(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`),R.runKernel(PS,{x:i,dy:o},{strides:r,pad:s,filterShape:e})}}),Uce={kernelName:Xy,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:s,pad:i}=e;S(rl(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,a]=t;return{x:()=>qL(o.shape,n,a,s,i),filter:()=>zce(o,n,a.shape,s,i)}}},Hce={kernelName:Af,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(yn(qI(ve(e,"float32"))),n)}}},Wce={kernelName:Rf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(KI(ve(e,"float32")),n)}}},jce={kernelName:Yy,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s,exclusive:i,reverse:o}=e;return{x:()=>{const a=En([s],r.rank);let l=DI(n,s,i,!o);return null!=a&&(l=vt(l,a)),l}}}},Gce={kernelName:Zy,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:s,pad:i,dimRoundingMode:o}=e,a=r??[1,1];S(rl(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=t;return S(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),S(4===c.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),S(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),S(Tr(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),Kr("depthwiseConv2d",i,o),{x:()=>kV(l.shape,n,c,s,i,a,o),filter:()=>TV(l,n,c.shape,s,i,a,o)}}},qce={kernelName:Qy,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,i={x:r,filter:s,dy:n},o={x:r,filter:s,dy:n};return{x:()=>R.runKernel(GS,i,e),filter:()=>R.runKernel(qS,o,e)}}},Kce={kernelName:Ff,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,r={dy:n,y:e};return{x:()=>R.runKernel(XS,r)}}},Xce={kernelName:Of,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=M(Js(yn(Yt(e))),2/Math.sqrt(Math.PI));return{x:()=>M(n,r)}}},Yce={kernelName:$f,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,e)}}},Zce={kernelName:eb,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>F(n,e.shape)}}},Qce={kernelName:Pf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,Js(e))}}},Jce={kernelName:Lf,gradFunc:n=>({x:()=>Tt(n)})},eue={kernelName:Vf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Je(e.shape,r.shape);return{a:()=>{const a=$e(n,ve(r,"float32")),l=nr(e.shape,s);return l.length>0?F(Ae(a,l),e.shape):a},b:()=>{let a=M(n,ve(e,"float32"));const l=nr(r.shape,s);l.length>0&&(a=F(Ae(a,l),r.shape));const c=Yt(r);return yn($e(a,ve(c,"float32")))}}}},tue={kernelName:tb,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:r}=e,[s,i,o,a]=t,l=a??Le(1),c=nr(i.shape,s.shape),u=[];if(1===i.rank){for(let v=0;v<s.shape.length-1;++v)u.push(s.shape[v]);u.push(1)}const d=De(s,i),h=M(n,l),f=HI(le(o,Le(r))),p=M(M(M(f,f),f),Le(-.5));return{x:()=>F(M(M(n,1===i.rank?Ti(F(f,[1,1,1,i.shape[0]]),u):f),l),s.shape),mean:()=>{let v=M(M(f,Le(-1)),h);return 1===i.rank&&(v=Ae(v,c)),F(v,i.shape)},variance:()=>{let v=M(M(p,d),h);return 1===i.rank&&(v=Ae(v,c)),F(v,i.shape)},scale:()=>{const v=M(d,f);let w=M(n,v);return 1===i.rank&&(w=Ae(w,c)),F(w,i.shape)},offset:()=>{let v=n;return 1===i.rank&&(v=Ae(v,c)),F(v,i.shape)}}}},nue={kernelName:nb,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[r,s]=t,{axis:i}=e,o=ht(i,r.shape)[0];return{x:()=>{const l=r.shape,c=s.size,u=l.slice(0,o),d=u.length,h=l.slice(i,l.length).slice(1),f=h.length,p=dB(0,d),m=dB(d+1,d+1+f),g=hB([u,[c],h]),y=F(n,g),b=F(s,[c]),_=hB([[d],p,m]),v=vt(y,_);let w=JI(v,b,r.shape[o]);const C=il(_);return w=vt(w,C),w},indices:()=>s}}};function dB(n,t){const e=[];for(let r=n;r<t;++r)e.push(r);return e}function hB(n){const t=[];for(let e=0;e<n.length;++e)for(let r=0;r<n[e].length;++r)t.push(n[e][r]);return t}const rue={kernelName:Bf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>Tt(e),b:()=>Tt(r)}}},sue={kernelName:zf,gradFunc:n=>({x:()=>ve(n,"float32")})},iue={kernelName:Uf,gradFunc:n=>({x:()=>Tt(n)})},oue={kernelName:Hf,gradFunc:n=>({x:()=>Tt(n)})},aue={kernelName:Wf,gradFunc:n=>({x:()=>Tt(n)})},lue={kernelName:sb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{alpha:s}=e,i=ks(r,0);return{x:()=>ds(i,n,M(n,s))}}},cue={kernelName:Gf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$e(n,le(e,1))}}},uue={kernelName:jf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$e(n,ve(e,"float32"))}}},due={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e;return{logits:()=>{const o=Js(r);return De(n,M(Ae(n,s,!0),o))}}}},fue=A({localResponseNormalizationBackprop_:function hue(n,t,e,r=5,s=1,i=1,o=.5){return R.runKernel(rE,{x:n,y:t,dy:e},{depthRadius:r,bias:s,alpha:i,beta:o})}}),pue={kernelName:ub,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{depthRadius:i,bias:o,alpha:a,beta:l}=e;return{x:()=>fue(r,s,n,i,o,a,l)}}};function fB(n,t,e,r){return t.rank<e.rank&&(t=F(t,Vn(t.shape,r))),n.rank<e.rank&&(n=F(n,Vn(n.shape,r))),{x:()=>M(n,ve(oo(e,t),n.dtype))}}const pB={kernelName:db,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{reductionIndices:s}=r,i=t[0],l=fB(n,t[1],i,ht(s,i.shape));return{x:()=>l.x()}}},mue={kernelName:qf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>M(n,ve(al(e,r),"float32")),b:()=>M(n,ve(RI(e,r),"float32"))}}},yue=A({maxPool3dGrad_:function gue(n,t,e,r,s,i,o){const a=E(n,"dy","maxPool3dGrad"),l=E(t,"input","maxPool3dGrad"),c=E(e,"output","maxPool3dGrad");let u=a,d=l,h=c,f=!1;4===l.rank&&(f=!0,u=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=F(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=F(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),S(5===u.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),S(5===d.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),S(5===h.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),Kr("maxPool3dGrad",i,o);const g=R.runKernel(iE,{dy:u,input:d,output:h},{filterSize:r,strides:s,pad:i,dimRoundingMode:o});return f?F(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),bue={kernelName:fb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=e;return{x:()=>yue(n,r,s,i,o,a,l)}}},vue=A({maxPoolGrad_:function _ue(n,t,e,r,s,i,o){const a=E(n,"dy","maxPoolGrad"),l=E(t,"input","maxPoolGrad"),c=E(e,"output","maxPoolGrad");return S(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),S(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),S(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Kr("maxPoolGrad",i,o),R.runKernel(sE,{dy:a,input:l,output:c},{filterSize:r,strides:s,pad:i,dimRoundingMode:o})}}),mB={kernelName:wb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:s}=e,i=s.map(o=>o[0]);return{x:()=>Dt(n,i,r.shape)}}};const gB={kernelName:Rb,gradFunc:(n,t,e)=>{const{blockShape:r,paddings:s}=e;return{x:()=>i_(n,r,s)}}},yB={kernelName:Mb,gradFunc:(n,t,e)=>{const{axis:r}=e;return{x:()=>Xn(n,r)}}},gde=[uB,fce,pce,mce,gce,yce,bce,_ce,vce,xce,wce,Cce,Ice,kce,Nce,Ace,Rce,Mce,Fce,Oce,$ce,Pce,Vce,Lce,Uce,Hce,Wce,jce,Gce,qce,{kernelName:Mf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Je(e.shape,r.shape);return{a:()=>{const a=$e(n,ve(r,"float32")),l=nr(e.shape,s);return l.length>0?F(Ae(a,l),e.shape):a},b:()=>{let a=M(n,ve(e,"float32"));const l=nr(r.shape,s);l.length>0&&(a=F(Ae(a,l),r.shape));const c=Yt(r);return yn($e(a,ve(c,"float32")))}}}},Kce,Xce,Yce,Zce,Qce,eue,Jce,tue,nue,rue,sue,iue,oue,aue,lue,cue,uue,due,pue,pB,pB,mue,bue,{kernelName:hb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{filterSize:i,strides:o,pad:a}=e;return{x:()=>vue(n,r,s,i,o,a)}}},{kernelName:pb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e,i=ht(s,r.shape),l=X(xr(r.shape,i)[1]);return{x:()=>{const u=r.shape.slice();i.forEach(f=>{u[f]=1});const d=F(n,u);return $e(M(d,ti(r.shape,"float32")),l)}}}},{kernelName:mb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{axis:s}=r,[i,o]=t,l=fB(n,o,i,ht(s,i.shape));return{x:()=>l.x()}}},{kernelName:Kf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>M(n,ve(hc(e,r),"float32")),b:()=>M(n,ve(ks(e,r),"float32"))}}},{kernelName:gb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:s}=e,i=s.map(o=>o[0]);return{x:()=>Dt(n,i,r.shape)}}},{kernelName:Xf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Je(e.shape,r.shape);return{a:()=>{const a=nr(e.shape,s);return a.length>0?F(Ae(n,a),e.shape):n},b:()=>{const a=M(n,yn(Dp($e(e,r)))),l=nr(r.shape,s);return l.length>0?F(Ae(a,l),r.shape):a}}}},{kernelName:Yf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Je(e.shape,r.shape);return{a:()=>{const a=M(n,ve(r,"float32")),l=nr(e.shape,s);return l.length>0?F(Ae(a,l),e.shape):a},b:()=>{const a=M(n,ve(e,"float32")),l=nr(r.shape,s);return l.length>0?F(Ae(a,l),r.shape):a}}}},{kernelName:yb,gradFunc:n=>({x:()=>yn(n)})},{kernelName:vb,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>sr(e.shape,"float32")}}},{kernelName:_b,gradFunc:n=>({x:()=>Tt(n)})},{kernelName:xb,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:r}=e;return Ni(n,r).map(i=>()=>i)}},mB,mB,{kernelName:Zf,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,r,s]=t,i=e,o=r,a=Je(i.shape,o.shape);return{a:()=>{const u=ve(o,"float32");let d=M(n,M(u,ol(i,De(u,Le(1)))));const h=nr(i.shape,a);return h.length>0&&(d=Ae(d,h)),F(d,i.shape)},b:()=>{const u=ks(i,0),d=ds(u,ei(i),Tt(i));let h=M(n,M(s,d));const f=nr(o.shape,a);return f.length>0&&(h=Ae(h,f)),F(h,o.shape)}}}},{kernelName:Cb,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,r]=t,s=ks(e,0);return{x:()=>ds(s,n,M(n,r)),alpha:()=>{let i=ds(s,Tt(n),M(n,e));const o=nr(r.shape,n.shape);return o.length>0&&(i=Ae(i,o)),F(i,r.shape)}}}},{kernelName:Sb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e;let i=[];return i=null==s?r.shape.map((o,a)=>a):"number"==typeof s?[s]:s,{x:()=>function Oue(n,t,e){const r=n.shape.length,s=r-e.length,i=En(e,r);let o=n;null!=i&&(o=vt(n,i));const a=o.shape.slice(),c=a.splice(r-e.length,e.length).reduce((h,f)=>h*f,1);a.push(c);let d=function Fue(n,t,e){const r=n.shape.slice();r[e]=1;const s=F(t,r),i=a_(n,e,!0,!1),o=a_(n,e,!0,!0),a=M(i,o);return M(s,a)}(o.reshape(a),t,s);if(d=d.reshape(o.shape),null!=i){const h=il(i);d=vt(d,h)}return d}(r,n,i)}}},{kernelName:Qf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$e(n,yn(Yt(e)))}}},{kernelName:ep,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=M(hc(e,6),pd(e));return{x:()=>M(n,ve(r,"float32"))}}},{kernelName:Jf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,ve(pd(e),"float32"))}}},{kernelName:Eb,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>F(n,e.shape)}}},{kernelName:Db,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,s={dy:n,images:r};return{images:()=>R.runKernel(yE,s,e)}}},{kernelName:Ib,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,s={dy:n,images:r};return{images:()=>R.runKernel(gE,s,e)}}},{kernelName:Tb,gradFunc:(n,t,e)=>{const{dims:r}=e,s=ht(r,n.shape);return{x:()=>ki(n,s)}}},{kernelName:tp,gradFunc:n=>({x:()=>Tt(n)})},{kernelName:np,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>yn($e(n,M(ol(e,1.5),2)))}}},{kernelName:kb,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>ve(Tt(e),"float32"),t:()=>M(n,ve(e,n.dtype)),e:()=>M(n,ve(d_(e),n.dtype))}}},{kernelName:rp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=ks(e,Le(0)),s=Le(k_),i=Le(N_),o=M(n,i),a=M(M(n,s),Js(ve(e,"float32")));return ds(r,o,a)}}}},{kernelName:ap,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,M(e,De(Le(1),e)))}}},{kernelName:op,gradFunc:n=>({x:()=>Tt(n)})},{kernelName:sp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(o_(ve(e,"float32")),n)}}},{kernelName:ip,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(II(ve(e,"float32")),n)}}},{kernelName:Nb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{begin:s,size:i}=e,o=r.shape,[a,l]=e_(r,s,i),c=[];for(let u=0;u<n.rank;u++)c.push([a[u],o[u]-a[u]-l[u]]);return{x:()=>ll(n,c)}}},{kernelName:Fb,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{dim:s}=e,o=M(n,r);return{logits:()=>De(o,M(Ae(o,[s],!0),r))}}},{kernelName:lp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,Ao(e))}}},gB,gB,yB,yB,{kernelName:cp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$e(n,M(Pr(ve(e,"float32")),2))}}},{kernelName:up,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Le(2);return{a:()=>M(n,M(s,De(e,r))),b:()=>M(n,M(s,De(r,e)))}}},{kernelName:EE,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,M(ve(e,"float32"),2))}}},{kernelName:mp,gradFunc:n=>({x:()=>Tt(n)})},{kernelName:dp,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Je(e.shape,r.shape);return{a:()=>{let a=n;const l=nr(e.shape,s);return l.length>0&&(a=Ae(a,l)),F(a,e.shape)},b:()=>{let a=n;const l=nr(r.shape,s);return l.length>0&&(a=Ae(a,l)),F(yn(a),r.shape)}}}},{kernelName:Ab,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,s=r.shape.slice(),{axis:i}=e;ht(i,r.shape).forEach(c=>{s[c]=1});const a=F(n,s),l=M(a,ti(r.shape,"float32"));return{x:()=>l}}},{kernelName:hp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>$e(n,Yt(o_(e)))}}},{kernelName:fp,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(De(Le(1),Yt(e)),n)}}},{kernelName:pp,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{reps:s}=e;return{x:()=>{let o=Tt(r);if(1===r.rank)for(let a=0;a<s[0];++a)o=le(o,Dt(n,[a*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)o=le(o,Dt(n,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let c=0;c<s[2];++c)o=le(o,Dt(n,[a*r.shape[0],l*r.shape[1],c*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let c=0;c<s[2];++c)for(let u=0;u<s[3];++u)o=le(o,Dt(n,[a*r.shape[0],l*r.shape[1],c*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return o}}}},{kernelName:Zu,gradFunc:(n,t,e)=>{const r=e,{perm:s}=r,i=il(s);return{x:()=>vt(n,i)}}},{kernelName:Ob,gradFunc:(n,t,e)=>{const r=e,{axis:s}=r;return{value:()=>ri(n,s)}}},{kernelName:$b,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>function pde(n,t){const e=ga(t,Tt(t)),r=Tp(n,e);let s=al(t,Le(0,"int32"));const i=r.rank-s.rank;for(let a=0;a<i;++a)s=hs(s,a+1);s=Ro(s,ti(r.shape,"bool"));const o=Tt(r);return ds(s,r,o)}(n,e)}}},{kernelName:Pb,gradFunc:n=>({x:()=>Tt(n)})}];for(const n of gde)$te(n);Y().prototype.abs=function(){return this.throwIfDisposed(),rr(this)},Y().prototype.acos=function(){return this.throwIfDisposed(),TL(this)},Y().prototype.acosh=function(){return this.throwIfDisposed(),kL(this)},Y().prototype.add=function(n){return this.throwIfDisposed(),le(this,n)},Y().prototype.all=function(n,t){return this.throwIfDisposed(),vI(this,n,t)},Y().prototype.any=function(n,t){return this.throwIfDisposed(),n_(this,n,t)},Y().prototype.argMax=function(n){return this.throwIfDisposed(),od(this,n)},Y().prototype.argMin=function(n){return this.throwIfDisposed(),NL(this,n)},Y().prototype.asScalar=function(){return this.throwIfDisposed(),S(1===this.size,()=>"The array must have only 1 element."),F(this,[])},Y().prototype.asType=function(n){return this.throwIfDisposed(),ve(this,n)},Y().prototype.as1D=function(){return this.throwIfDisposed(),F(this,[this.size])},Y().prototype.as2D=function(n,t){return this.throwIfDisposed(),F(this,[n,t])},Y().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),F(this,[n,t,e])},Y().prototype.as4D=function(n,t,e,r){return this.throwIfDisposed(),F(this,[n,t,e,r])},Y().prototype.as5D=function(n,t,e,r,s){return this.throwIfDisposed(),F(this,[n,t,e,r,s])},Y().prototype.asin=function(){return this.throwIfDisposed(),AL(this)},Y().prototype.asinh=function(){return this.throwIfDisposed(),RL(this)},Y().prototype.atan=function(){return this.throwIfDisposed(),ML(this)},Y().prototype.atan2=function(n){return this.throwIfDisposed(),FL(this,n)},Y().prototype.atanh=function(){return this.throwIfDisposed(),OL(this)},Y().prototype.avgPool=function(n,t,e,r){return this.throwIfDisposed(),s_(this,n,t,e,r)},Y().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),i_(this,n,t)},Y().prototype.batchNorm=function(n,t,e,r,s){return this.throwIfDisposed(),wp(this,n,t,e,r,s)},Y().prototype.broadcastTo=function(n){return this.throwIfDisposed(),cd(this,n)},Y().prototype.cast=function(n){return this.throwIfDisposed(),ve(this,n)},Y().prototype.ceil=function(){return this.throwIfDisposed(),zL(this)},Y().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Ts(this,n,t)},Y().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof fn&&(n=[n]),Xn([this,...n],t)},Y().prototype.conv1d=function(n,t,e,r,s,i){return this.throwIfDisposed(),CI(this,n,t,e,r,s,i)},Y().prototype.conv2dTranspose=function(n,t,e,r,s){return this.throwIfDisposed(),EI(this,n,t,e,r,s)},Y().prototype.conv2d=function(n,t,e,r,s,i){return this.throwIfDisposed(),sl(this,n,t,e,r,s,i)},Y().prototype.cos=function(){return this.throwIfDisposed(),o_(this)},Y().prototype.cosh=function(){return this.throwIfDisposed(),II(this)},Y().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),a_(this,n,t,e)},Y().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),DI(this,n,t,e)},Y().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),XL(this,n,t)},Y().prototype.depthwiseConv2d=function(n,t,e,r,s,i){return this.throwIfDisposed(),Cp(this,n,t,e,r,s,i)},Y().prototype.dilation2d=function(n,t,e,r,s){return this.throwIfDisposed(),YL(this,n,t,e,r,s)},Y().prototype.divNoNan=function(n){return this.throwIfDisposed(),ZL(this,n)},Y().prototype.div=function(n){return this.throwIfDisposed(),$e(this,n)},Y().prototype.dot=function(n){return this.throwIfDisposed(),QL(this,n)},Y().prototype.elu=function(){return this.throwIfDisposed(),Sp(this)},Y().prototype.equal=function(n){return this.throwIfDisposed(),oo(this,n)},Y().prototype.erf=function(){return this.throwIfDisposed(),JL(this)},Y().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),nV(this,n,t)},Y().prototype.exp=function(){return this.throwIfDisposed(),Js(this)},Y().prototype.expandDims=function(n){return this.throwIfDisposed(),hs(this,n)},Y().prototype.expm1=function(){return this.throwIfDisposed(),rV(this)},Y().prototype.fft=function(){return this.throwIfDisposed(),x_(this)},Y().prototype.flatten=function(){return this.throwIfDisposed(),F(this,[this.size])},Y().prototype.floor=function(){return this.throwIfDisposed(),Dp(this)},Y().prototype.floorDiv=function(n){return this.throwIfDisposed(),kI(this,n)},Y().prototype.gather=function(n,t){return this.throwIfDisposed(),Tp(this,n,t)},Y().prototype.greaterEqual=function(n){return this.throwIfDisposed(),al(this,n)},Y().prototype.greater=function(n){return this.throwIfDisposed(),ks(this,n)},Y().prototype.ifft=function(){return this.throwIfDisposed(),Mp(this)},Y().prototype.irfft=function(){return this.throwIfDisposed(),YI(this)},Y().prototype.isFinite=function(){return this.throwIfDisposed(),sV(this)},Y().prototype.isInf=function(){return this.throwIfDisposed(),iV(this)},Y().prototype.isNaN=function(){return this.throwIfDisposed(),oV(this)},Y().prototype.leakyRelu=function(n){return this.throwIfDisposed(),c_(this,n)},Y().prototype.lessEqual=function(n){return this.throwIfDisposed(),hc(this,n)},Y().prototype.less=function(n){return this.throwIfDisposed(),RI(this,n)},Y().prototype.localResponseNormalization=function(n,t,e,r){return this.throwIfDisposed(),aV(this,n,t,e,r)},Y().prototype.logSigmoid=function(){return this.throwIfDisposed(),lV(this)},Y().prototype.logSoftmax=function(n){return this.throwIfDisposed(),MI(this,n)},Y().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),FI(this,n,t)},Y().prototype.log=function(){return this.throwIfDisposed(),ei(this)},Y().prototype.log1p=function(){return this.throwIfDisposed(),u_(this)},Y().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Ro(this,n)},Y().prototype.logicalNot=function(){return this.throwIfDisposed(),d_(this)},Y().prototype.logicalOr=function(n){return this.throwIfDisposed(),OI(this,n)},Y().prototype.logicalXor=function(n){return this.throwIfDisposed(),cV(this,n)},Y().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),pt(this,n,t,e)},Y().prototype.maxPool=function(n,t,e,r){return this.throwIfDisposed(),f_(this,n,t,e,r)},Y().prototype.max=function(n,t){return this.throwIfDisposed(),Di(this,n,t)},Y().prototype.maximum=function(n){return this.throwIfDisposed(),ga(this,n)},Y().prototype.mean=function(n,t){return this.throwIfDisposed(),Mn(this,n,t)},Y().prototype.min=function(n,t){return this.throwIfDisposed(),Ep(this,n,t)},Y().prototype.minimum=function(n){return this.throwIfDisposed(),kp(this,n)},Y().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),dV(this,n,t)},Y().prototype.mod=function(n){return this.throwIfDisposed(),hV(this,n)},Y().prototype.mul=function(n){return this.throwIfDisposed(),M(this,n)},Y().prototype.neg=function(){return this.throwIfDisposed(),yn(this)},Y().prototype.norm=function(n,t,e){return this.throwIfDisposed(),Ip(this,n,t,e)},Y().prototype.notEqual=function(n){return this.throwIfDisposed(),hd(this,n)},Y().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),PI(this,n,t,e)},Y().prototype.onesLike=function(){return this.throwIfDisposed(),ni(this)},Y().prototype.pad=function(n,t){return this.throwIfDisposed(),ll(this,n,t)},Y().prototype.pool=function(n,t,e,r,s,i){return this.throwIfDisposed(),fV(this,n,t,e,r,s,i)},Y().prototype.pow=function(n){return this.throwIfDisposed(),ol(this,n)},Y().prototype.prelu=function(n){return this.throwIfDisposed(),g_(this,n)},Y().prototype.prod=function(n,t){return this.throwIfDisposed(),pV(this,n,t)},Y().prototype.reciprocal=function(){return this.throwIfDisposed(),mV(this)},Y().prototype.relu=function(){return this.throwIfDisposed(),Mo(this)},Y().prototype.relu6=function(){return this.throwIfDisposed(),zI(this)},Y().prototype.reshapeAs=function(n){return this.throwIfDisposed(),F(this,n.shape)},Y().prototype.reshape=function(n){return this.throwIfDisposed(),F(this,n)},Y().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),MV(this,n,t,e)},Y().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),FV(this,n,t,e)},Y().prototype.reverse=function(n){return this.throwIfDisposed(),ki(this,n)},Y().prototype.rfft=function(){return this.throwIfDisposed(),w_(this)},Y().prototype.round=function(){return this.throwIfDisposed(),UI(this)},Y().prototype.rsqrt=function(){return this.throwIfDisposed(),HI(this)},Y().prototype.selu=function(){return this.throwIfDisposed(),WI(this)},Y().prototype.separableConv2d=function(n,t,e,r,s,i){return this.throwIfDisposed(),jI(this,n,t,e,r,s,i)},Y().prototype.sigmoid=function(){return this.throwIfDisposed(),Ao(this)},Y().prototype.sign=function(){return this.throwIfDisposed(),gV(this)},Y().prototype.sin=function(){return this.throwIfDisposed(),qI(this)},Y().prototype.sinh=function(){return this.throwIfDisposed(),KI(this)},Y().prototype.slice=function(n,t){return this.throwIfDisposed(),Dt(this,n,t)},Y().prototype.softmax=function(n){return this.throwIfDisposed(),v_(this,n)},Y().prototype.softplus=function(){return this.throwIfDisposed(),dd(this)},Y().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),m_(this,n,t)},Y().prototype.split=function(n,t){return this.throwIfDisposed(),Ns(this,n,t)},Y().prototype.sqrt=function(){return this.throwIfDisposed(),Pr(this)},Y().prototype.square=function(){return this.throwIfDisposed(),Yt(this)},Y().prototype.squaredDifference=function(n){return this.throwIfDisposed(),ZI(this,n)},Y().prototype.squeeze=function(n){return this.throwIfDisposed(),fc(this,n)},Y().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof fn?[this,n]:[this,...n];return ri(e,t)},Y().prototype.step=function(n){return this.throwIfDisposed(),pd(this,n)},Y().prototype.stridedSlice=function(n,t,e,r,s,i,o,a){return this.throwIfDisposed(),yV(this,n,t,e,r,s,i,o,a)},Y().prototype.sub=function(n){return this.throwIfDisposed(),De(this,n)},Y().prototype.sum=function(n,t){return this.throwIfDisposed(),Ae(this,n,t)},Y().prototype.tan=function(){return this.throwIfDisposed(),bV(this)},Y().prototype.tanh=function(){return this.throwIfDisposed(),ld(this)},Y().prototype.tile=function(n){return this.throwIfDisposed(),Ti(this,n)},Y().prototype.toBool=function(){return this.throwIfDisposed(),ve(this,"bool")},Y().prototype.toFloat=function(){return this.throwIfDisposed(),ve(this,"float32")},Y().prototype.toInt=function(){return this.throwIfDisposed(),ve(this,"int32")},Y().prototype.topk=function(n,t){return this.throwIfDisposed(),_V(this,n,t)},Y().prototype.transpose=function(n){return this.throwIfDisposed(),vt(this,n)},Y().prototype.unique=function(n){return this.throwIfDisposed(),vV(this,n)},Y().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),JI(this,n,t)},Y().prototype.unstack=function(n){return this.throwIfDisposed(),Ni(this,n)},Y().prototype.where=function(n,t){return this.throwIfDisposed(),ds(n,this,t)},Y().prototype.zerosLike=function(){return this.throwIfDisposed(),Tt(this)};class Oo extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Oo.prototype)}}class Ri extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Ri.prototype)}}class O extends Error{constructor(t){super(t),Object.setPrototypeOf(this,O.prototype)}}class et extends Error{constructor(t){super(t),Object.setPrototypeOf(this,et.prototype)}}class UD extends Error{constructor(t){super(t),Object.setPrototypeOf(this,UD.prototype)}}class bB extends Error{constructor(t){super(t),Object.setPrototypeOf(this,bB.prototype)}}class _B{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=t}}function gc(n,t){if(Array.isArray(n)){let e=[];for(let r=0;r<t;r++)e=e.concat(n);return e}{const e=new Array(t);return e.fill(n),e}}function si(n,t){if(!n)throw new UD(t)}function vB(n,t){let e=0;for(const r of n)r===t&&e++;return e}function ps(n){return 1===n.length?n[0]:n}function rn(n){return Array.isArray(n)?n:[n]}function va(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function yc(n){return n.length<=1||-1===n.indexOf("_")?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let Mi={};function HD(n){if(null==n)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function WD(n){if(null!=n&&"object"==typeof n)if(Array.isArray(n))n.forEach(t=>WD(t));else{const t=Object.keys(n);for(const e of t){const r=n[e];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?WD(r):n[e]=r.value)}}}function Vp(n,t={},e={},r="object",s=!1){if("string"==typeof n){const i=n;let o;if(i in e)o=e[i];else if(i in Mi)o=Mi[i];else if(o=t[i],null==o)throw new O(`Unknown ${r}: ${n}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}{const i=n;if(null==i.className||null==i.config)throw new O(`${r}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);const o=i.className;let a,l;if(o in e?[a,l]=e[o]:o in Mi?[a,l]=Mi.className:o in t&&([a,l]=t[o]),null==a)throw new O(`Unknown ${r}: ${o}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const c={};for(const f of Object.keys(Mi))c[f]=Mi[f];for(const f of Object.keys(e))c[f]=e[f];i.config.customObjects=c;const d=Object.assign({},Mi);for(const f of Object.keys(e))Mi[f]=e[f];WD(i.config);const h=l(a,i.config,e,s);return Mi=Object.assign({},d),h}{const c=Object.assign({},Mi);for(const d of Object.keys(e))Mi[d]=e[d];const u=new a(i.config);return Mi=Object.assign({},c),u}}}function A_(n,t){return-1*function yde(n,t){return n<t?-1:n>t?1:0}(n,t)}function cl(n){if(null==n)return n;const t=[];for(const e of n)-1===t.indexOf(e)&&t.push(e);return t}function bde(n){if(null==n)throw new O(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function bc(n,t,e){if(null!=e&&n.indexOf(e)<0)throw new O(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function jD(n,t,e=0,r=1/0){return si(e>=0),si(r>=e),Array.isArray(n)&&n.length>=e&&n.length<=r&&n.every(s=>typeof s===t)}function wr(n,t){Array.isArray(n)?(S(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,r)=>wr(e,`element ${r+1} of ${t}`))):S(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${xB(n)}.`)}function xB(n){return null===n?"null":Array.isArray(n)?"["+n.map(t=>xB(t)).join(",")+"]":"string"==typeof n?`"${n}"`:`${n}`}function wB(n){return"relu"===n?"relu":"linear"===n?"linear":"elu"===n?"elu":null}let vde=0;function CB(){return vde++}const R_={};function M_(n=""){return n in R_||(R_[n]=0),R_[n]+=1,n+R_[n].toString()}const xde=["channelsFirst","channelsLast"],wde=["nearest","bilinear"],Cde=["valid","same","causal"],Sde=["max","avg"],Ede=["sum","mul","concat","ave"],yd=new Map;function zn(n){bc(xde,"DataFormat",n)}function ii(n){bc(Cde,"PaddingMode",n)}function SB(n){bc(Sde,"PoolMode",n)}const Bp=[];function _c(n,t){Bp.push(n);try{const e=t();return Bp.pop(),e}catch(e){throw Bp.pop(),e}}function IB(n){if(!TB(n))throw new Error("Not a valid tensor name: '"+n+"'");return function Dde(){return 0===Bp.length?"":Bp.join("/")+"/"}()+n}function DB(n){if(!TB(n))throw new Error("Not a valid tensor name: '"+n+"'");yd.has(n)||yd.set(n,0);const t=yd.get(n);if(yd.set(n,yd.get(n)+1),t>0){const e=`${n}_${t}`;return yd.set(e,1),e}return n}const Tde=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function TB(n){return!!n.match(Tde)}function kde(n){return n===parseInt(n.toString(),10)}function ul(n,t,e){null==t&&(t=0),null==e&&(e=n.length);let r=1;for(let s=t;s<e;++s)r*=n[s];return r}function bd(n){if(0===n.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r<t&&(t=r)}return t}function dl(n){if(0===n.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r>t&&(t=r)}return t}function ao(n,t){if(t<n)throw new O(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let r=n;r<t;++r)e.push(r);return e}let F_;function ir(){return null==F_&&(F_=function ure(){return R.backend}().epsilon()),F_}function $o(n,t){return ve(n,t)}function zp(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),F(n,e)}function vc(n,t,e){return B(()=>{switch(n.rank){case 1:return b_(n,t,e);case 2:return XI(n,[t,0],[e,n.shape[1]]);case 3:return __(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return Rp(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Dt(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Dt(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new O(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function GD(n,t,e){return B(()=>{switch(n.rank){case 1:return b_(n,t,e);case 2:return XI(n,[0,t],[n.shape[0],e]);case 3:return __(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return Rp(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new O(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function O_(n,t,e,r){return B(()=>{switch(n.rank){case 1:return b_(n,t,e);case 2:switch(r){case 1:return vc(n,t,e);case 2:return GD(n,t,e);default:throw new O(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return vc(n,t,e);case 2:return __(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return GD(n,t,e);default:throw new O(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return vc(n,t,e);case 2:return Rp(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return Rp(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return GD(n,t,e);default:throw new O(`The axis is not within the rank of the tensor ${r}`)}default:throw new O(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function qD(n,t=-1){let e;return t<0&&(e=n[0].rank,t=0!==e?e:0),t===n[0].rank&&(t=-1),Xn(n,t)}function NB(n,t){switch(n.rank){case 1:return UL([n,t]);case 2:return HL([n,t],0);case 3:return WL([n,t],0);case 4:return jL([n,t],0);default:throw new O(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function KD(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new O(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return Ti(n,t)}function $_(n,t=0,e=1,r,s){return BI(n,t,e,r,s)}function Po(n,t,e,r){if(n.rank<2||t.rank<2)throw new et(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3&&n.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new et(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`);if(2===n.rank&&2===t.rank)return oD({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?XD(n.rank,r,"channelsLast"):null,activation:e});{const s=n.shape.slice(),i=s.pop();n=F(n,[-1,i]);const o=t.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],u=Array.from({length:t.rank},(p,m)=>0===m?t.rank-2:m<=t.rank-2?m-1:m);t=F(vt(t,u),[l,-1]);const d=[...s,...c];return F(oD({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?XD(n.rank,r,"channelsLast"):null,activation:e}),d)}}function AB(n,t,e){return B(()=>(t=Array.isArray(t)?fs(t,"int32"):ve(t,"int32"),Tp(n,t,e)))}function Up(n){return M(n,n)}function XD(n,t,e){const r=t.shape;if(1!==t.rank&&t.rank!==n)throw new O(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(5===n){if("channelsFirst"===e)return F(t,1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===e)return F(t,1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===n){if("channelsFirst"===e)return F(t,1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===e)return F(t,1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===n){if("channelsFirst"===e)return F(t,1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===e)return F(t,1===r.length?[1,1,r[0]]:[1].concat(r))}else if(n<3)return t;throw new O(`Unsupported input rank by biasAdd: ${t.rank}`)}function co(n,t,e){return B(()=>(null==e&&(e="channelsLast"),zn(e),le(n,XD(n.rank,t,e))))}function RB(n,t,e,r){return B(()=>EV(n,t,e,r))}function Hp(n,t,e=!1){return e?n():t()}const Lde=["fanIn","fanOut","fanAvg"],Vde=["normal","uniform","truncatedNormal"];class Fi extends id{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}se((()=>{class n extends Fi{apply(e,r){return sr(e,r)}}return n.className="Zeros",n})());let MB=(()=>{class n extends Fi{apply(e,r){return ti(e,r)}}return n.className="Ones",n})();se(MB),se((()=>{class n extends Fi{constructor(e){if(super(),"object"!=typeof e)throw new O(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new O(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return B(()=>M(Le(this.value),ti(e,r)))}getConfig(){return{value:this.value}}}return n.className="Constant",n})()),se((()=>{class n extends Fi{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return Np(e,this.minval,this.maxval,r)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return n.className="RandomUniform",n})()),se((()=>{class n extends Fi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new et(`randomNormal does not support dType ${r}.`);return $_(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="RandomNormal",n})()),se((()=>{class n extends Fi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new et(`truncatedNormal does not support dType ${r}.`);return QI(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="TruncatedNormal",n})()),se((()=>{class n extends Fi{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,r){return B(()=>{if(2!==e.length||e[0]!==e[1])throw new O("Identity matrix initializer can only be used for 2D square matrices.");return M(this.gain,AI(e[0]))})}getConfig(){return{gain:this.gain}}}return n.className="Identity",n})());let oi=(()=>{class n extends Fi{constructor(e){if(super(),e.scale<0)throw new O(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale??1,this.mode=e.mode??"fanIn",function Bde(n){bc(Lde,"FanMode",n)}(this.mode),this.distribution=e.distribution??"normal",function zde(n){bc(Vde,"Distribution",n)}(this.distribution),this.seed=e.seed}apply(e,r){const s=function Ude(n,t="channelsLast"){let e,r;if(zn(t),2===n.length)e=n[0],r=n[1];else if(-1!==[3,4,5].indexOf(n.length)){if("channelsFirst"===t){const s=ul(n,2);e=n[1]*s,r=n[0]*s}else if("channelsLast"===t){const s=ul(n,0,n.length-2);e=n[n.length-2]*s,r=n[n.length-1]*s}}else{const s=ul(n);e=Math.sqrt(s),r=Math.sqrt(s)}return[e,r]}(e),i=s[0],o=s[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,i):"fanOut"===this.mode?Math.max(1,o):Math.max(1,(i+o)/2),"normal"===this.distribution){const l=Math.sqrt(a);if("float32"!==(r=r||"float32")&&"int32"!==r)throw new et(`${this.getClassName()} does not support dType ${r}.`);return QI(e,0,l,r,this.seed)}{const l=Math.sqrt(3*a);return Np(e,-l,l,r)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return n.className="VarianceScaling",n})();se(oi);let FB=(()=>{class n extends oi{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return oi.className}}return n.className="GlorotUniform",n})();se(FB);let OB=(()=>{class n extends oi{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return oi.className}}return n.className="GlorotNormal",n})();se(OB);let $B=(()=>{class n extends oi{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return oi.className}}return n.className="HeNormal",n})();se($B);let PB=(()=>{class n extends oi{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return oi.className}}return n.className="HeUniform",n})();se(PB);let LB=(()=>{class n extends oi{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return oi.className}}return n.className="LeCunNormal",n})();se(LB);let VB=(()=>{class n extends oi{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return oi.className}}return n.className="LeCunNormal",n})();se(VB),se((()=>{class n extends Fi{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=e.gain??this.DEFAULT_GAIN,this.seed=e.seed,null!=this.seed)throw new et("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,r){return B(()=>{if(e.length<2)throw new et("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const i=$_(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let o=$V.gramSchmidt(i);return e[0]>e[1]&&(o=vt(o)),M(this.gain,o)})}getConfig(){return{gain:this.gain,seed:this.seed}}}return n.className="Orthogonal",n})());const BB={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function zB(n,t={}){return Vp(n,Ei.getMap().classNameMap,t,"initializer")}function In(n){return HD(n)}function bn(n){if("string"==typeof n){const t=n in BB?BB[n]:n;if("GlorotNormal"===t)return new OB;if("GlorotUniform"===t)return new FB;if("HeNormal"===t)return new $B;if("HeUniform"===t)return new PB;if("LeCunNormal"===t)return new LB;if("LeCunUniform"===t)return new VB;{const e={};return e.className=t,e.config={},zB(e)}}return n instanceof Fi?n:zB(n)}function YD(n){return Array.isArray(n)&&Array.isArray(n[0])}function P_(n){return 0===n.length?[]:Array.isArray(n[0])?n:[n]}function Ye(n){let t;if(Array.isArray(n)){if(1!==n.length)throw new O(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function Ot(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(1===n.length)return n[0];throw new O(`Expected exactly 1 Shape; got ${n.length}`)}return n}function L_(n){let t=0;for(const e of n)t+=0===e.shape.length?1:e.shape.reduce((r,s)=>r*s);return t}const UB="Variable";class Lo{constructor(t,e="float32",r=UB,s=!0,i=null){this.dtype=e??"float32",this.shape=t.shape,this.id=CB(),this.originalName=IB(r=r??UB),this.name=DB(this.originalName),this.trainable_=s,this.constraint=i,this.val=xV(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function Hde(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function ZD(n){return n.map(t=>t.read())}function QD(n){n.forEach(t=>{t[0].write(t[1])})}class or{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class Vo{constructor(t,e,r,s,i,o,a){this.dtype=t,this.shape=e,this.sourceLayer=r,this.inputs=s,this.callArgs=i,this.outputTensorIndex=a,this.id=CB(),null!=o&&(this.originalName=IB(o),this.name=DB(this.originalName)),this.rank=e.length}}let Wde=0;class V_{constructor(t,e){this.callArgs=e,this.id=Wde++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const r of t.inboundLayers)r?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let jde=0;class mt extends id{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=jde++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const r=this.getClassName();e=va(r)+"_"+M_(r)}if(this.name=e,this.trainable_=t.trainable??!0,null!=t.inputShape||null!=t.batchInputShape){let r;if(null!=t.batchInputShape)r=t.batchInputShape;else if(null!=t.inputShape){let i=null;null!=t.batchSize&&(i=t.batchSize),r=[i].concat(t.inputShape)}this.batchInputShape=r;let s=t.dtype;null==s&&(s=t.inputDType),null==s&&(s="float32"),this.dtype=s}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new Ri(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new O(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return ps(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return ps(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Oo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Oo(`Layer ${this.name} is not connected, no input to return.`);return ps(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Oo(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Oo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ps(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=rn(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=rn(this.inputSpec);if(t.length!==e.length)throw new O(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let r=0;r<t.length;r++){const s=t[r],i=e[r];if(null==i)continue;const o=s.rank;if(null!=i.ndim&&o!==i.ndim)throw new O(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);if(null!=i.maxNDim&&o>i.maxNDim)throw new O(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);if(null!=i.minNDim&&o<i.minNDim)throw new O(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);if(null!=i.dtype&&s.dtype!==i.dtype)throw new O(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${s.dtype}.`);if(i.axes){const a=s.shape;for(const l in i.axes){const c=Number(l),u=i.axes[l],d=c>=0?a[c]:a[a.length+c];if(null!=u&&-1===[u,null].indexOf(d))throw new O(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${u} but got shape ${a}.`)}}if(null!=i.shape)for(let a=0;a<i.shape.length;++a){const l=i.shape[a],c=s.shape[a];if(null!=l&&null!=c&&l!==c)throw new O(`Input ${r} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${s.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const r=rn(t);let s=!0;for(const o of r)if(!(o instanceof Vo)){s=!1;break}let i=!0;for(const o of r)if(o instanceof Vo){i=!1;break}if(s===i)throw new O("Arguments to apply() must be all SymbolicTensors or all Tensors");return _c(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const o=[];for(const a of rn(t))o.push(a.shape);this.build(ps(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&i&&(this._refCount=1)}if(this.assertInputCompatibility(t),i){let o=this.call(t,e);const a=rn(o),l=[];for(let c of a)-1!==r.indexOf(c)&&(c=c.clone()),l.push(c);if(o=ps(l),null!=this.activityRegularizer)throw new et("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}{const o=function Gde(n){n=rn(n);const t=[];for(const e of n)t.push(e.shape);return ps(t)}(t),a=this.computeOutputShape(o);let l;const c="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?o[0]:o),l=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((u,d)=>new Vo(c,u,this,rn(t),e,this.name,d)):new Vo(c,a,this,rn(t),e,this.name),this.addInboundNode(t,l,null,null,o,a,e),this._refCount++,null!=this.activityRegularizer)throw new et("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,s)=>{null!=r&&null!=t[s]&&t[s]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Oo(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const r=JSON.stringify(e.outputShapes);-1===t.indexOf(r)&&t.push(r)}if(1===t.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Oo(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Ri(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return L_(this.weights)}build(t){this.built=!0}getWeights(t=!1){return ZD(t?this.trainableWeights:this.weights)}setWeights(t){B(()=>{const e=this.weights;if(e.length!==t.length)throw new O(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const r=[],s=ZD(e);for(let i=0;i<s.length;++i){const o=s[i],a=e[i],l=t[i];if(!It(o.shape,l.shape))throw new O(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}QD(r)})}addWeight(t,e,r,s,i,o,a,l){if(-1!==this._addedWeightNames.indexOf(t))throw new O(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(s=null!=l?l():bn("zeros"));const c=s.apply(e,r),u=new Lo(c,r,t,o,a);return c.dispose(),null!=i&&this.addLoss(()=>i.apply(u.read())),null==o&&(o=!0),o?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=rn(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(r=>{if(null!=r)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,r,s,i,o,a=null){const l=rn(t);e=rn(e),r=rn(r),s=rn(s),i=P_(i),o=P_(o);const c=[],u=[],d=[];for(const h of l)c.push(h.sourceLayer),u.push(h.nodeIndex),d.push(h.tensorIndex);new V_({outboundLayer:this,inboundLayers:c,nodeIndices:u,tensorIndices:d,inputTensors:l,outputTensors:e,inputMasks:r,outputMasks:s,inputShapes:i,outputShapes:o},a);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function HB(n,t,e){if((null==t||null!=e&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),0===t.inboundNodes.length)return[n];{const r=t.inboundNodes[e];if(0===r.inboundLayers.length)return r.inputTensors;{const s=[];for(let i=0;i<r.inboundLayers.length;i++){const c=HB(r.inputTensors[i],r.inboundLayers[i],r.nodeIndices[i]);for(const u of c)-1===s.indexOf(u)&&s.push(u)}return s}}}let B_=(()=>{class n extends mt{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:M_("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new O("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new O("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new O("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=r,this.dtype=s,this.inputSpec=[{shape:r}];const i=new Vo(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new V_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new O(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return n.className="InputLayer",n})();se(B_);class hl{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof hl)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,r){if(null!=this.id2Value[t.id])throw new O(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function Xde(n,t){if(null==n.dtype||n.dtype===t.dtype)return t;try{return ve(t,n.dtype)}catch{throw new O(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=r&&(this.id2Mask[t.id]=r),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Vo){if(null==this.id2Value[t.id])throw new O(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new O(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof Vo){if(null==this.id2Value[t.id])throw new O(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new O(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&ot(this.id2Mask)}}const z_=new _B,U_=new _B;function Wp(n,t,e,r){const s=null!=e&&e.training,i=Array.isArray(n),o=i?n:[n],a=o.map(p=>p.name),l=[],c=t.names();for(const p of a)-1!==c.indexOf(p)?l.push(t.getValue(p)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const u=a.join(",")+"|"+t.names().sort().join(",");let h,d=z_.get(u);if(null==d){const p=function Zde(n,t){S(null!=n&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(1===n.length){const s=WB(n[0],t);e=s.sorted,r=s.recipientMap}else{const s=new Set;for(const i of n){const{sorted:o,recipientMap:a}=WB(i,t);for(const l of o)s.has(l.name)||(e.push(l),s.add(l.name));for(const l in a)null==r[l]&&(r[l]=new Set),a[l].forEach(c=>r[l].add(c))}}return{sorted:e,recipientCounts:Qde(r)}}(o,t);d=p.sorted,h=p.recipientCounts,z_.put(u,d),U_.put(u,h)}h={},s||Object.assign(h,U_.get(u));const f=new hl(t);for(let p=0;p<d.length;++p){if(null!=r){const T=_I().numTensors;T>r.maxNumTensors&&(r.maxNumTensors=T),T<r.minNumTensors&&(r.minNumTensors=T)}const m=d[p],g=m.sourceLayer;if(g instanceof B_)continue;const y=[],b=[],_=[];let v=!1;for(const T of m.inputs){const N=f.getValue(T),P=f.getMask(T);y.push(N),b.push(P),null!=P&&(v=!0),s||(h[T.name]--,0===h[T.name]&&!t.hasKey(T)&&-1===a.indexOf(T.name)&&!N.isDisposed&&!0!==T.sourceLayer.stateful&&_.push(N))}v&&((e=e||{}).mask=b[0]);const w=rn(g.apply(y,e));let C=null;g.supportsMasking&&(C=g.computeMask(y,b));const I=Jde(m),D=Array.isArray(I)?I:[I];for(let T=0;T<D.length;++T){f.hasKey(D[T])||f.add(D[T],w[T],Array.isArray(C)?C[0]:C);const N=a.indexOf(D[T].name);-1!==N&&(l[N]=w[T])}s||ot(_)}return f.disposeMasks(),i?l:l[0]}function Qde(n){const t={};for(const e in n)t[e]=n[e].size;return t}function WB(n,t){const e=new Set,r=[],s={};for(const a of t.names())e.add(a);const i=[],o=[];for(i.push(n);i.length>0;){const a=i[i.length-1];if(e.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(0===a.inputs.length||l)i.pop(),r.push(a),e.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const c of a.inputs)null==s[c.name]&&(s[c.name]=new Set),s[c.name].add(a.name),!e.has(c.name)&&i.push(c)}}return{sorted:r,recipientMap:s}}function Jde(n){let t;if(1===n.sourceLayer.inboundNodes.length)t=n.sourceLayer.output;else{let e=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const s of n.sourceLayer.inboundNodes[r].outputTensors)if(s.id===n.id){e=r;break}t=n.sourceLayer.getOutputAt(e)}return t}function JD(n,t){return B(()=>Pr(Ae(M(n,n),t,!0)))}j().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function Yde(n){z_?.setMaxEntries(n),U_?.setMaxEntries(n)});class jp extends id{getConfig(){return{}}}se((()=>{class n extends jp{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return B(()=>{const r=JD(e,this.axis),s=Ts(r,0,this.maxValue);return M(e,$e(s,le(ir(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return n.className="MaxNorm",n})()),se((()=>{class n extends jp{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return B(()=>$e(e,le(ir(),JD(e,this.axis))))}getConfig(){return{axis:this.axis}}}return n.className="UnitNorm",n})()),se((()=>{class n extends jp{apply(e){return Mo(e)}}return n.className="NonNeg",n})()),se((()=>{class n extends jp{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return B(()=>{const r=JD(e,this.axis),s=le(M(this.rate,Ts(r,this.minValue,this.maxValue)),M(1-this.rate,r));return M(e,$e(s,le(ir(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return n.className="MinMaxNorm",n})());const jB={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ar(n){return HD(n)}function GB(n,t={}){return Vp(n,Ei.getMap().classNameMap,t,"constraint")}function lr(n){return null==n?null:"string"==typeof n?GB({className:n in jB?jB[n]:n,config:{}}):n instanceof jp?n:GB(n)}function fl(n){return eT.apply(this,arguments)}function eT(){return(eT=ee(function*(n){if(null==n)return;const t=[],e=[],r=[];for(const s in n){const i=n[s];if("number"!=typeof i){const o=i;t.push(o.data()),e.push(s),r.push(o)}}if(t.length>0){const s=yield Promise.all(t);for(let i=0;i<s.length;++i)n[e[i]]=s[i][0];ot(r)}})).apply(this,arguments)}function qB(n){if(null!=n)for(const t in n){const e=n[t];"number"!=typeof e&&e.dispose()}}class _d{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return ee(function*(){})()}onEpochEnd(t,e){return ee(function*(){})()}onBatchBegin(t,e){return ee(function*(){})()}onBatchEnd(t,e){return ee(function*(){})()}onTrainBegin(t){return ee(function*(){})()}onTrainEnd(t){return ee(function*(){})()}setModel(t){}}class the{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){var r=this;return ee(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochBegin(t,e)})()}onEpochEnd(t,e){var r=this;return ee(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochEnd(t,e)})()}onBatchBegin(t,e){var r=this;return ee(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchBegin(t,e)})()}onBatchEnd(t,e){var r=this;return ee(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchEnd(t,e)})()}onTrainBegin(t){var e=this;return ee(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainBegin(t)})()}onTrainEnd(t){var e=this;return ee(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainEnd(t)})()}}class nhe extends _d{constructor(){super()}onEpochBegin(t){var e=this;return ee(function*(){e.seen=0,e.totals={}})()}onBatchEnd(t,e){var r=this;return ee(function*(){null==e&&(e={});const s=e.size??0;r.seen+=s;for(const i in e){const o=e[i];if("number"==typeof o)r.totals.hasOwnProperty(i)||(r.totals[i]=0),r.totals[i]=r.totals[i]+o*s;else{let a;i in r.totals?a=r.totals[i]:r.totals[i]=0;const l=B(()=>le(r.totals[i],M(o,s)));r.totals[i]=l,a?.dispose()}}})()}onEpochEnd(t,e){var r=this;return ee(function*(){if(null!=e)for(const s of r.params.metrics)null!=r.totals[s]&&("number"==typeof r.totals[s]?e[s]=r.totals[s]/r.seen:B(()=>{const i=M($e(1,r.seen),r.totals[s]);e[s]=i,r.totals[s].dispose(),_r(e[s])}))})()}}class rhe extends _d{onTrainBegin(t){var e=this;return ee(function*(){e.epoch=[],e.history={}})()}onEpochEnd(t,e){var r=this;return ee(function*(){null==e&&(e={}),r.epoch.push(t);for(const s in e)null==r.history[s]&&(r.history[s]=[]),r.history[s].push(e[s])})()}syncData(){var t=this;return ee(function*(){const e=[],r=[],s=[];for(const o in t.history){const a=t.history[o];for(let l=0;l<a.length;++l)"number"!=typeof a[l]&&(e.push(a[l].data()),r.push(o),s.push(l))}const i=yield Promise.all(e);for(let o=0;o<i.length;++o)t.history[r[o]][s[o]].dispose(),t.history[r[o]][s[o]]=i[o][0]})()}}class she extends _d{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||PV,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");CS(this.yieldEvery)&&(this.maybeWait=function _de(n,t,e){let s,r=null!=e?e():us();return(...o)=>{const a=null!=e?e():us();return a-r<t||(r=a,s=n(...o)),s}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,r){var s=this;return ee(function*(){const i=[];null!=s.yield&&(yield fl(r),i.push(s.yield(t,e,r))),i.push(s.nextFrameFunc()),yield Promise.all(i)})()}onEpochBegin(t,e){var r=this;return ee(function*(){r.currentEpoch=t,null!=r.epochBegin&&(yield fl(e),yield r.epochBegin(t,e))})()}onEpochEnd(t,e){var r=this;return ee(function*(){const s=[];null!=r.epochEnd&&(yield fl(e),s.push(r.epochEnd(t,e))),"epoch"===r.yieldEvery&&s.push(r.nextFrameFunc()),yield Promise.all(s)})()}onBatchBegin(t,e){var r=this;return ee(function*(){null!=r.batchBegin&&(yield fl(e),yield r.batchBegin(t,e))})()}onBatchEnd(t,e){var r=this;return ee(function*(){const s=[];null!=r.batchEnd&&(yield fl(e),s.push(r.batchEnd(t,e))),"batch"===r.yieldEvery?s.push(r.nextFrameFunc()):CS(r.yieldEvery)&&s.push(r.maybeWait(r.currentEpoch,t,e)),yield Promise.all(s)})()}onTrainBegin(t){var e=this;return ee(function*(){null!=e.trainBegin&&(yield fl(t),yield e.trainBegin(t))})()}onTrainEnd(t){var e=this;return ee(function*(){null!=e.trainEnd&&(yield fl(t),yield e.trainEnd(t))})()}}function KB(n,t){return null==n&&(n={}),n instanceof _d?[n]:Array.isArray(n)&&n[0]instanceof _d?n:rn(n).map(r=>new she(r,t))}let ihe=(()=>{class n{constructor(){}static registerCallbackConstructor(e,r){S(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),n.checkForDuplicate(r),null==n.constructors[e]&&(n.constructors[e]=[]),n.constructors[e].push(r)}static checkForDuplicate(e){for(const r in n.constructors)n.constructors[+r].forEach(i=>{if(i===e)throw new O("Duplicate callback constructor.")})}static clear(){n.constructors={}}static createCallbacks(e){const r=[];for(const s in n.constructors){const i=+s;e>=i&&r.push(...n.constructors[i])}return r.map(s=>new s)}}return n.constructors={},n})();function XB(n,t,e,r,s,i,o,a,l){const c=new rhe,u=[new nhe,...ihe.createCallbacks(t)];null!=n&&u.push(...n),u.push(c);const d=new the(u);return d.setParams({epochs:e,initialEpoch:r,samples:s,steps:i,batchSize:o,verbose:t,doValidation:a,metrics:l}),{callbackList:d,history:c}}function xa(n,t={},e=!1){return Vp(n,Ei.getMap().classNameMap,t,"layer",e)}function H_(n,t){return B(()=>{"float32"!==n.dtype&&(n=ve(n,"float32"));const e=Ae(Up(n),t,!0),r=ud(e.shape,ir()),s=Pr(ga(e,r));return $e(n,s)})}function W_(n,t){return B(()=>Mn(Up(De(t,n)),-1))}function tT(n,t){return B(()=>Mn(rr(De(t,n)),-1))}function nT(n,t){return B(()=>{const e=De(n,t),r=Ts(rr(n),ir(),Number.MAX_VALUE),s=rr($e(e,r));return M(100,Mn(s,-1))})}function Gp(n,t,e=!1){return B(()=>{if(e)t=v_(t);else{const r=Ae(t,t.shape.length-1,!0);t=$e(t,r)}return t=Ts(t,ir(),1-ir()),yn(Ae(M(ve(n,"float32"),ei(t)),t.shape.length-1))})}function j_(n,t,e=!1){return B(()=>{const r=ve(Dp(function Mde(n){const t=[ul(n.shape)];return F(n,t)}(n)),"int32"),s=(t=Ts(t,ir(),1-ir())).shape;return Gp(F(PI(r,s[s.length-1]),s),t,e)})}function G_(n,t){return B(()=>{let e;return e=Ts(t,ir(),1-ir()),e=ei($e(e,De(1,e))),Mn(function dhe(n,t){if(!It(n.shape,t.shape))throw new O(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return B(()=>{const e=Mo(t),r=yn(rr(t));return le(De(e,M(t,n)),u_(Js(r)))})}(n,e),-1)})}function YB(n,t){return B(()=>{const e=H_(n,-1),r=H_(t,-1),s=M(e,r);return yn(Ae(s,-1))})}const q_={meanSquaredError:W_,meanAbsoluteError:tT,meanAbsolutePercentageError:nT,meanSquaredLogarithmicError:function ohe(n,t){return B(()=>{const e=Ts(t,ir(),Number.MAX_VALUE),r=ei(le(1,e)),s=Ts(n,ir(),Number.MAX_VALUE),i=ei(le(1,s));return Mn(Up(De(r,i)),-1)})},squaredHinge:function ahe(n,t){return B(()=>{const e=ga(0,De(1,M(n,t)));return Mn(Up(e),-1)})},hinge:function lhe(n,t){return B(()=>{const e=ga(0,De(1,M(n,t)));return Mn(e,-1)})},categoricalHinge:function che(n,t){return B(()=>{const e=Ae(M(n,t),-1),r=Di(M(De(1,n),t),-1);return ga(0,le(1,De(r,e)))})},logcosh:function uhe(n,t){return B(()=>{const e=Math.log(2),r=De(t,n),s=De(le(r,dd(M(-2,r))),e);return Mn(s,-1)})},categoricalCrossentropy:Gp,sparseCategoricalCrossentropy:j_,binaryCrossentropy:G_,kullbackLeiblerDivergence:function hhe(n,t){return B(()=>{const e=Ts(n,ir(),1),r=Ts(t,ir(),1);return Ae(M(n,ei($e(e,r))),-1)})},poisson:function fhe(n,t){return B(()=>{const e=ei(le(ir(),t));return Mn(De(t,M(n,e)),-1)})},cosineProximity:YB};function rT(n){if("string"==typeof n){if(n in q_)return q_[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new O(t)}return n}function ZB(n,t){return B(()=>{const e=M(.5,ni(t)),r=$o(ks(t,e),n.dtype);return Mn(oo(n,r),-1)})}function QB(n,t){return B(()=>$o(oo(od(n,-1),od(t,-1)),"float32"))}function yhe(n,t){return G_(n,t)}function bhe(n,t){return n.rank===t.rank&&(n=fc(n,[n.rank-1])),(t=od(t,-1)).dtype!==n.dtype&&(t=ve(t,n.dtype)),ve(oo(n,t),"float32")}const ez=Gp,tz=j_,K_={binaryAccuracy:ZB,categoricalAccuracy:QB,precision:function ghe(n,t){return B(()=>{const e=function JB(n,t){return B(()=>ve(Ae(Ro(oo(n,1),oo(t,1))),"float32"))}(n,t),r=function mhe(n,t){return B(()=>ve(Ae(Ro(oo(n,0),oo(t,1))),"float32"))}(n,t),s=le(e,r);return ve(ds(ks(s,0),$e(e,s),0),"float32")})},categoricalCrossentropy:ez,sparseCategoricalCrossentropy:tz,mse:W_,MSE:W_,mae:tT,MAE:tT,mape:nT,MAPE:nT,cosine:YB};function Ihe(n){if("string"==typeof n&&n in K_)return K_[n];if("string"!=typeof n&&null!=n)return n;throw new O(`Unknown metric ${n}`)}function X_(n){if(si(null!==n,`Unknown LossOrMetricFn ${n}`),"string"==typeof n)return n;{let t;for(const e of Object.keys(q_))if(q_[e]===n){t=e;break}if(void 0!==t)return t;for(const e of Object.keys(K_))if(K_[e]===n){t=e;break}return void 0!==t?t:n.name}}function rz(n,t,e=!1){if(null==n||"object"!=typeof n||Object.getPrototypeOf(n)!==Object.prototype||!sT(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const r=JSON.stringify(n);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function sT(n){if(null===n)return!0;if("object"==typeof n){if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if("string"!=typeof e||!sT(n[e]))return!1;return!0}if(Array.isArray(n)){for(const t of n)if(!sT(t))return!1;return!0}return!1}{const t=typeof n;return"string"===t||"number"===t||"boolean"===t}}function Y_(n,t,e=console.log){let r="";for(let s=0;s<n.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=n[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);e(r)}function Ahe(n,t,e){let r,s;try{s=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}Y_([`${n.name} (${n.getClassName()})`,s,r,n.countParams().toString()],t,e)}function Rhe(n,t,e,r){let s,i;try{i=n.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const o=[];for(const d of n.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(d)))for(let h=0;h<d.inboundLayers.length;++h)o.push(`${d.inboundLayers[h].name}[${d.nodeIndices[h]}][${d.tensorIndices[h]}]`);const a=n.name,l=n.getClassName(),c=0===o.length?"":o[0];Y_([`${a} (${l})`,i,s,n.countParams().toString(),c],t,r);for(let d=1;d<o.length;++d)Y_(["","","","",o[d]],t,r)}function sz(n,t,e){return("inboundNodes"===n||"outputLayers"===n||"inputLayers"===n)&&0===t&&"string"==typeof e}function iT(n,t){if(null===n)return null;if("string"==typeof n)return yc(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];sz(t,s,i)?e.push(i):e.push(iT(i,t))}return e}{const e={};for(const r of Object.keys(n)){const s=n[r];if("name"===r&&"string"==typeof s)e[r]=s;else{const i=yc(r);e[i]=iT(s,i)}}return e}}function oT(n,t){if(null==n)return null;if("string"==typeof n)return va(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];sz(t,s,i)?e.push(i):e.push(oT(i,t))}return e}{const e={};for(const r of Object.keys(n)){const s=n[r];e[va(r)]="name"!==r&&"className"!==r||"string"!=typeof s?oT(s,r):s}return e}}class uo extends mt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const b=this.getClassName().toLowerCase();this.name=M_(b)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],cl(this.inputs).length!==this.inputs.length)throw new O(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);cl(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const v=b.nodeIndex,w=b.tensorIndex;this.outputLayers.push(b.sourceLayer),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(w)}for(const b of this.inputs){const _=b.sourceLayer,v=b.nodeIndex,w=b.tensorIndex;si(0===v,"input layer has >1 nodes"),si(0===w,"input layer has >1 tensors"),this.inputLayers.push(_),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const _=this.inputLayers[b];if(!(_ instanceof B_))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${_.getClassName()}.`);this.inputNames.push(_.name),this.feedInputShapes.push(_.batchInputShape),this.feedInputNames.push(_.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const e={},r={},s={},i={},o={},a=[],l=(b,_,v,w,C,I)=>{(null==w||null==C||null==I)&&(w=b.sourceLayer,C=b.nodeIndex,I=b.tensorIndex);const D=w.inboundNodes[C];if(-1!==v.indexOf(D))throw new Ri(`The tensor ${b.name} at layer "${w.name}" is part of a cycle.`);if(-1!==_.indexOf(D))return;this.containerNodes.add(uo.nodeKey(w,C)),w.id in o||(o[w.id]=Object.keys(o).length),-1===v.indexOf(D)&&v.push(D);const T=D.inboundLayers.length;for(let N=0;N<T;N++)l(D.inputTensors[N],_,v,D.inboundLayers[N],D.nodeIndices[N],D.tensorIndices[N]);for(_.push(D);v.indexOf(D)>=0;)v.splice(v.indexOf(D),1);a.push(D)},c=[],u=[];for(const b of this.outputs)l(b,c,u);const d=a.slice().reverse();for(const b of d){r[b.id]=b,b.id in e||(e[b.id]=0);let _=e[b.id];_=Math.max(_,s[b.outboundLayer.id]??0),s[b.outboundLayer.id]=_,i[b.outboundLayer.id]=b.outboundLayer,e[b.id]=_;for(let w=0;w<b.inboundLayers.length;w++){const D=b.inboundLayers[w].inboundNodes[b.nodeIndices[w]];e[D.id]=Math.max(_+1,e[D.id]??0),r[D.id]=D}}const h={};for(const b in e){const _=e[b];_ in h||(h[_]=[]),h[_].push(r[b])}const f={};for(const b in s){const _=s[b];_ in f||(f[_]=[]),f[_].push(i[b])}let p=Object.keys(f).map(b=>parseInt(b,10)).sort(A_);this.layers=[];for(const b of p){const _=f[b];_.sort((v,w)=>{const C=o[v.id],I=o[w.id];return C<I?-1:C>I?1:0});for(const v of _)v instanceof uo&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=f,p=Object.keys(h).map(b=>parseInt(b,10)).sort(A_);const m=this.inputs.slice(),g=[];for(const b of p)for(const _ of h[b]){const v=_.outboundLayer;if(null!=v){for(const w of _.inputTensors)if(-1===m.indexOf(w))throw new Ri(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${v.name}". The following previous layers were accessed without issue: ${g}`);for(const w of _.outputTensors)m.push(w);g.push(v.name)}}this.nodesByDepth=h;const y=this.layers.map(b=>b.name);for(const b of y){const _=y.filter(v=>v===b).length;if(1!==_)throw new Ri(`The name "${b}" is used ${_} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new V_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new O("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.layers)e.push(...r.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const r={};let s=0;for(const o of this.layers)for(const a of o.weights){if(null!=r[a.originalName])throw new O(`Duplicate weight name: ${a.originalName}`);r[a.originalName]=a,s++}const i=[];for(const o in t){let a=o;if(null==r[o]){const l=o.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(null!=r[a])i.push([r[a],t[o]]);else if(e)throw new O(`Provided weight data has no target variable: ${o}`);delete r[a]}if(e){const o=[];for(const a in r)o.push(a);if(o.length>0)throw new O(`${o.length} of ${s} weights are not set: ${o}`)}QD(i)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 4.1.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const r=oT(this.updatedConfig());return e?JSON.stringify(r):r}call(t,e){return B(()=>{t=rn(t);const r=new hl;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],t[s]);return Wp(this.outputs,r,e)})}computeMask(t,e){return B(()=>{let r;return t=rn(t),r=null==e?gc(null,t.length):rn(e),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){const e=P_(t);if(e.length!==this.inputLayers.length)throw new O(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<e.length;a++)r[this.inputLayers[a].name+"_0_0"]=e[a];const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(A_);if(s.length>1)for(const a of s){const l=this.nodesByDepth[a];for(const c of l){const u=c.outboundLayer;if(-1!==this.inputLayers.map(m=>m.id).indexOf(u.id))continue;const d=[];for(let m=0;m<c.inboundLayers.length;m++)d.push(r[`${c.inboundLayers[m].name}_${c.nodeIndices[m]}_${c.tensorIndices[m]}`]);const f=P_(u.computeOutputShape(ps(d))),p=u.inboundNodes.indexOf(c);for(let m=0;m<f.length;m++)r[`${u.name}_${p}_${m}`]=f[m]}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++)o.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<o.length;a++){const l=o[a];si(l in r),i.push(r[l])}return ps(i)}runInternalGraph(t,e){null==e&&(e=gc(null,t.length));const r={};for(let l=0;l<this.inputs.length;++l)r[this.inputs[l].id]=[t[l],e[l]];const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(A_);for(const l of s){const c=this.nodesByDepth[l];for(const u of c){const d=u.outboundLayer,h=u.inputTensors,f=u.outputTensors,p=new Array;for(const m of h)m.id in r&&p.push(r[m.id]);if(p.length===h.length){let g,y,b,_,m={};if(null!=u.callArgs&&(m=u.callArgs),1===p.length){const[v,w]=p[0];null==m.mask&&(m.mask=w),b=rn(d.call(v,m)),_=rn(d.computeMask(v,w)),g=[v],y=[w]}else g=p.map(v=>v[0]),y=p.map(v=>v[1]),null==m.mask&&(m.mask=y),b=rn(d.call(g,m)),_=rn(d.computeMask(g,y));if(d.activityRegularizer)throw new et("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<f.length;++v)r[f[v].id]=[b[v],_[v]]}}}const i=[],o=[],a=[];for(const l of this.outputs){si(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[c,u]=r[l.id];a.push(c.shape),i.push(c),o.push(u)}return[i,o,a]}buildNodeConversionMap(t){const e={};let r;for(const s of this.layers){r=s instanceof uo?1:0;for(let i=0;i<s.inboundNodes.length;i++){const o=uo.nodeKey(s,i);this.containerNodes.has(o)&&(e[o]=r,r+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new O(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new O("Provide either a layer name or layer index");for(const r of this.layers)if(r.name===t)return r;throw new O(`No such layer: ${t}`)}calculateLosses(){return B(()=>{const t=[];for(const e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){const s=uo.nodeKey(e,r);this.containerNodes.has(s)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let d=0;d<o.inboundNodes.length;d++){const h=o.inboundNodes[d],f=uo.nodeKey(o,d);let p={};if(this.containerNodes.has(f)){if(h.callArgs)try{JSON.stringify(h.callArgs),p=h.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(h.inboundLayers.length>0){const m=[];for(let g=0;g<h.inboundLayers.length;g++){const y=h.inboundLayers[g],_=h.tensorIndices[g];let w=e[uo.nodeKey(y,h.nodeIndices[g])];null==w&&(w=0),m.push([y.name,w,_,p])}c.push(m)}}}const u={};u.name=o.name,u.className=a,u.config=l,u.inboundNodes=c,r.push(u)}t.layers=r;const s=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],c=uo.nodeKey(a,this.inputLayersNodeIndices[o]);if(!this.containerNodes.has(c))continue;let u=e[c];null==u&&(u=0),s.push([a.name,u,this.inputLayersTensorIndices[o]])}t.inputLayers=s;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],c=uo.nodeKey(a,this.outputLayersNodeIndices[o]);if(!this.containerNodes.has(c))continue;let u=e[c];null==u&&(u=0),i.push([a.name,u,this.outputLayersTensorIndices[o]])}return t.outputLayers=i,t}static fromConfig(t,e,r={},s=!1){const i={},o={};function a(g,y){g.name in o?o[g.name].push(y):o[g.name]=[y]}function l(g,y){const b=[];let _;for(const v of y){const w=v[0],C=v[1],I=v[2];if(_=v[3]??{},!(w in i))return void a(g,y);const D=i[w];if(D.inboundNodes.length<=C)return void a(g,y);b.push(D.inboundNodes[C].outputTensors[I])}b.length>0&&g.apply(ps(b),_)}function c(g){const y=g.name,b=xa(g,null!=e.customObjects?e.customObjects:{});b.setFastWeightInitDuringBuild(s),i[y]=b,g.inboundNodes.forEach(v=>{if(!(v instanceof Array))throw new O(`Corrupted configuration, expected array for nodeData: ${v}`);a(b,v)})}const u=e.name,d=e.layers;for(const g of d)c(g);for(;!bde(o);)for(const g of d){const y=i[g.name];if(y.name in o){const b=o[y.name];delete o[y.name];for(const _ of b)l(y,_)}}const h=[],f=[],p=e.inputLayers;for(const g of p){const y=g[0],b=g[1],_=g[2];si(y in i),h.push(i[y].inboundNodes[b].outputTensors[_])}const m=e.outputLayers;for(const g of m){const y=g[0],b=g[1],_=g[2];si(y in i),f.push(i[y].inboundNodes[b].outputTensors[_])}return new t({inputs:h,outputs:f,name:u})}get stateful(){if(this._stateful)throw new O("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){B(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function oz(n,t){return function iz(n,t,e){const r=t.length;if(null==n||Array.isArray(n)&&0===n.length)return t.map(s=>null);if(1===r)return Array.isArray(n)&&1===n.length?n:"object"==typeof n&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}if("object"==typeof n&&Object.keys(n).length>0&&"object"==typeof n[Object.keys(n)[0]]){const s=[];return t.forEach(i=>{s.push(i in n?n[i]:null)}),s}throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}(n,t,"classWeight")}function az(n,t,e,r){return lT.apply(this,arguments)}function lT(){return(lT=ee(function*(n,t,e,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const s=B(()=>{if(1===n.shape.length)return ha(n);if(2===n.shape.length){if(n.shape[1]>1)return od(n,1);if(1===n.shape[1])return F(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(yield s.data());ot(s);const o=[];return i.forEach(a=>{if(null==e[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(e[a])}),fs(o,"float32")}return null})).apply(this,arguments)}function Mhe(n,t){return M(n,t)}function lz(n,t){let e,r;e=t.xs,r=t.ys,S(null!=e&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const i=cz("input",n.inputNames,e),o=cz("output",n.outputNames,r),a=i[0].shape[0];S(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),S(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<i.length;l++)S(i[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)S(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function cz(n,t,e){if(e instanceof fn)return[e];if(Array.isArray(e))return S(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const r=[];for(const s of t){if(null==e[s])throw new O(`The feature data generated by the dataset lacks the required ${n} key '${s}'.`);r.push(e[s])}return r}}function Ohe(n){if(3===n.length)throw new et("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}function cT(){return(cT=ee(function*(n,t,e){const r=null!=e.batchesPerEpoch;if(S(null!=n.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),S(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),S(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),S(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),S(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const s=null!=e.validationData;let i,o;if(s)if(uz(e.validationData))S(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const g=Ohe(e.validationData);i=g.xs,o=g.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;c=s?l.slice().concat(l.map(g=>"val_"+g)):l.slice();const u=KB(e.callbacks,e.yieldEvery),d=e.verbose??1,{callbackList:h,history:f}=XB(u,d,e.epochs,null,null,Phe(t,e),null,s,c);h.setModel(n),n.history=f,yield h.onTrainBegin(),n.stopTraining_=!1;let p=e.initialEpoch??0,m=yield t.iterator();for(;p<e.epochs;){const g={};yield h.onEpochBegin(p);let y=0,b=0;for(r||(m=yield t.iterator());!r||y<e.batchesPerEpoch;){const _=yield m.next();if(r&&_.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=_.value){const{xs:v,ys:w}=lz(n,_.value),C={};C.batch=b,C.size=v[0].shape[0],yield h.onBatchBegin(b,C);const I=[];if(null!=e.classWeight){const N=oz(e.classWeight,n.outputNames);for(let P=0;P<N.length;++P)I.push(yield az(w[P],null,N[P]))}const D=v.concat(w).concat(I),T=a(D);ot(D);for(let N=0;N<l.length;++N){const z=T[N];C[l[N]]=z,_r(z)}yield h.onBatchEnd(b,C),qB(C),b++,y++}if(r?y>=e.batchesPerEpoch:_.done){if(s){let v;v=uz(e.validationData)?rn(yield n.evaluateDataset(e.validationData,{batches:e.validationBatches})):rn(n.evaluate(i,o,{batchSize:e.validationBatchSize??32,verbose:0}));for(let w=0;w<n.metricsNames.length;++w)g[`val_${n.metricsNames[w]}`]=v[w]}break}if(n.stopTraining_)break}if(yield h.onEpochEnd(p,g),p++,n.stopTraining_)break}return yield h.onTrainEnd(),yield n.history.syncData(),n.history}finally{n.isTraining=!1}})).apply(this,arguments)}function Phe(n,t){let e=null;return null!=t.batchesPerEpoch?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function uz(n){return"function"==typeof n.iterator}function Lhe(n){return"function"==typeof n.next}function uT(){return(uT=ee(function*(n,t,e){const r=null!=(e=e||{}).batches,s=n.testFunction;let i=[];if(e.verbose>0)throw new et("Verbose mode is not implemented yet.");S(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=Lhe(t)?t:yield t.iterator();let a=0,l=0;for(;!r||l<e.batches;){const c=yield o.next();if(i=B(()=>{if(c.value){const{xs:u,ys:d}=lz(n,c.value),h=u.concat(d),f=B(()=>s(h));if(ot(h),0===l)for(let m=0;m<f.length;++m)i.push(Le(0));const p=h[0].shape[0];for(let m=0;m<f.length;++m){const g=f[m],y=i[m];i[m]=B(()=>le(i[m],M(p,g))),l>0&&ot(y)}ot(f),a+=p,++l}return i}),c.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<i.length;++c){const u=i[c];i[c]=$e(i[c],a),ot(u)}return ps(i)})).apply(this,arguments)}function dT(n){S(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function qp(n,t,e){return null==n?[null]:Array.isArray(n)?n.map(r=>vc(r,t,e-t)):vc(n,t,e-t)}function hT(n,t){return B(()=>null==n?null:Array.isArray(n)?n.map(e=>hT(e,t)):AB(n,"int32"===t.dtype?t:ve(t,"int32")))}function fT(n,t){const e=[];let r=0,s=null;for(;r<n;)s=r+t,s>=n&&(s=n),e.push([r,s]),r=s;return e}function dz(n){const t=[];n instanceof fn&&(n=[n]);for(let e=0;e<n.length;++e){const r=n[e];if(1===r.rank)t.push(zp(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function ho(n,t){if(null==n)return;const e=[];if(t instanceof fn)e.push(t.id);else if(Array.isArray(t))t.forEach(s=>e.push(s.id));else if(null!=t)for(const s in t)e.push(t[s].id);const r=[];if(n instanceof fn)-1===e.indexOf(n.id)&&r.push(n);else if(Array.isArray(n))n.forEach(s=>{-1===e.indexOf(s.id)&&r.push(s)});else if(null!=n)for(const s in n){const i=n[s];-1===e.indexOf(i.id)&&r.push(i)}r.forEach(s=>{s.isDisposed||s.dispose()})}function pT(n){return Array.isArray(n)}function hz(n){return!function Bhe(n){return n instanceof fn}(n)&&!pT(n)}function fz(n,t,e,r=!0,s=""){if(null==t||0===t.length){if(null!=n){let o=!1;if(pT(n)&&n.length>0)o=!0;else if(hz(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new O(`Error when checking model ${s} expected no data, but got ${n}`)}return[]}if(null==n)return t.map(o=>null);let i;if(hz(n)){i=[];for(const o of t){if(null==n[o])throw new O(`No data provided for "${o}". Need data for each key in: ${t}`);i.push(n[o])}}else if(pT(n)){if(n.length!==t.length)throw new O(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(t.length>1)throw new O(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=dz(i),null!=e)for(let o=0;o<t.length;++o){if(null==e[o])continue;const a=i[o];if(a.shape.length!==e[o].length)throw new O(`Error when checking ${s}: expected ${t[o]} to have ${e[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[o].length;++l){if(0===l&&!r)continue;const c=a.shape[l],u=e[o][l];if(null!=u&&u>=0&&c!==u)throw new O(`${s} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${s} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function pz(n,t,e,r=!0,s=""){let i;if(Array.isArray(n)){if(n.length!==t.length)throw new O(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(t.length>1)throw new O(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(null!=e)for(let o=0;o<t.length;++o){if(null==e[o])continue;const a=i[o];if(a.shape.length!==e[o].length)throw new O(`Error when checking ${s}: expected ${t[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[o].length;++l){if(0===l&&!r)continue;const c=a.shape[l],u=e[o][l];if(null!=u&&u!==c)throw new O(`Error when checking ${s}: expected ${t[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let vd=(()=>{class n extends uo{constructor(e){super(e),this.isTraining=!1}summary(e,r,s=console.log){if(!this.built)throw new O("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function The(n,t,e,r=console.log){const s=function Nhe(n){let t=!0;const e=[],r=[];for(const s in n.nodesByDepth)e.push(n.nodesByDepth[s]);for(const s of e){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of n.layers){let i=!1;for(const o of s.inboundNodes)if(-1!==r.indexOf(o)){if(i){t=!1;break}i=!0}if(!t)break}return t}(n),i=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(s?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(u=>Math.floor(t*u))),!s){i.push("Receives inputs"),o=[];for(const u in n.nodesByDepth)o.push(...n.nodesByDepth[u])}r("_".repeat(t)),Y_(i,e,r),r("=".repeat(t));const a=n.layers;for(let u=0;u<a.length;++u)s?Ahe(a[u],e,r):Rhe(a[u],e,o,r),r((u===a.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const l=function khe(n){let t;return t=L_(null!=n.collectedTrainableWeights?n.collectedTrainableWeights:n.trainableWeights),t}(n),c=L_(n.nonTrainableWeights);r(`Total params: ${l+c}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${c}`),r("_".repeat(t))}(this,e,r,s)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function Dhe(n){const t={Adagrad:()=>gd.adagrad(.01),Adadelta:()=>gd.adadelta(1,.95,ir()),Adam:()=>gd.adam(.001,.9,.999,ir()),Adamax:()=>gd.adamax(.002,.9,.999,ir(),0),RMSProp:()=>gd.rmsprop(.001,.9,0,ir()),SGD:()=>gd.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new O(`Unknown Optimizer ${n}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof tl))throw new O("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new O(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(l=>rT(l))}else{const a=rT(e.loss);this.outputs.forEach(l=>{r.push(a)})}else{e.loss=e.loss;for(const a in e.loss)if(-1===this.outputNames.indexOf(a))throw new O(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==e.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(rT(e.loss[a]))}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const l=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],_c("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(-1!==s.indexOf(a))continue;const l=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([l,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const i=function Hhe(n,t){if(null==n||Array.isArray(n)&&0===n.length)return t.map(r=>[]);let e;if("string"==typeof n||"function"==typeof n)e=[n];else{if(!Array.isArray(n)&&"object"!=typeof n)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);e=n}if(Array.isArray(e))return t.map(r=>e);{const r=[];for(const s of t){let i=e.hasOwnProperty(s)?e[s]:[];Array.isArray(i)||(i=[i]),r.push(i)}return r}}(e.metrics,this.outputNames),o=(a,l,c)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([c,a])};_c("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===s.indexOf(a)&&(u=>{let h,f,p;for(const m of u){if("string"==typeof m&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(m)){const y=this.internalOutputShapes[a];let b;1===y[y.length-1]||this.lossFunctions[a]===G_?-1!==["accuracy","acc"].indexOf(m)?f=ZB:-1!==["crossentropy","ce"].indexOf(m)&&(f=yhe):this.lossFunctions[a]===j_?-1!==["accuracy","acc"].indexOf(m)?f=bhe:-1!==["crossentropy","ce"].indexOf(m)&&(f=tz):-1!==["accuracy","acc"].indexOf(m)?f=QB:-1!==["crossentropy","ce"].indexOf(m)&&(f=ez),-1!==["accuracy","acc"].indexOf(m)?b="acc":-1!==["crossentropy","ce"].indexOf(m)&&(b="ce"),p=f,h=""+b}else p=Ihe(m),h=""+X_(m);let g;_c(h,()=>{g=p}),o(a,h,g)}})(i[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,s={}){const i=s.batchSize??32;dT(i);const a=this.standardizeUserDataXY(e,r,!0,i);try{const l=a[0].concat(a[1]);return this.makeTestFunction(),ps(this.testLoop(this.testFunction,l,i,s.verbose,s.steps))}finally{ho(a[0],e),ho(a[1],r)}}evaluateDataset(e,r){var s=this;return ee(function*(){return s.makeTestFunction(),function Vhe(n,t,e){return uT.apply(this,arguments)}(s,e,r)})()}checkNumSamples(e,r,s,i="steps"){let o;if(null!=s){if(o=null,null!=r)throw new O(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else{if(null==e)throw new O(`Either the input data should have a defined shape, or ${i} shoud be specified.`);o=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return o}execute(e,r){if(Array.isArray(r)&&0===r.length)throw new O("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(r),o=this.retrieveSymbolicTensors(s?r:[r]),a=new hl;if(e instanceof fn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new O(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)a.add(this.inputs[c],e[c])}else for(const c of this.inputs){const u=e[c.name];if(null==u)throw new O(`No value is provided for the model's input ${c.name}`);a.add(c,u)}const l=Wp(o,a);return s?l:l[0]}retrieveSymbolicTensors(e){const r=gc(null,e.length);let s=e.length;for(const i of this.layers){const o=Array.isArray(i.output)?i.output:[i.output],a=o.map(l=>l.name);for(let l=0;l<e.length;++l){const c=a.indexOf(e[l]);if(-1!==c&&(r[l]=o[c],s--),0===s)break}if(0===s)break}if(s>0){const i=[];throw r.forEach((o,a)=>{null==o&&i.push(e[a])}),new O(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return r}predictLoop(e,r=32,s=!1){return B(()=>{const i=this.checkNumSamples(e);if(s)throw new et("Verbose predictLoop() is not implemented yet.");const o=fT(i,r),a=this.outputs.map(l=>[]);for(let l=0;l<o.length;++l)B(()=>{const h=qp(e,o[l][0],o[l][1]),f=[];if(Array.isArray(h))for(let m=0;m<h.length;++m)f.push({key:this.inputs[m],value:h[m]});else f.push({key:this.inputs[0],value:h});const p=new hl(f);return Wp(this.outputs,p)}).forEach((u,d)=>a[d].push(u));return ps(a.map(l=>Xn(l,0)))})}predict(e,r={}){const s=dz(e);pz(s,this.inputNames,this.feedInputShapes,!1);try{const i=r.batchSize??32;return dT(i),this.predictLoop(s,i)}finally{ho(s,e)}}predictOnBatch(e){pz(e,this.inputNames,this.feedInputShapes,!0);const r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,s=!0,i){if(null==this.optimizer_)throw new Ri("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let a=0;a<this.feedOutputShapes.length;++a){const l=this.feedOutputShapes[a];o.push(this.feedLossFns[a]===j_?l.slice(0,l.length-1).concat([1]):l)}if(function zhe(n,t,e){const r=cl(n.map(i=>i.shape[0]));r.sort();const s=cl(t.map(i=>i.shape[0]));if(s.sort(),r.length>1)throw new O(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(s.length>1)throw new O(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(r.length>0&&s.length>0&&!It(r,s))throw new O(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(e=fz(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=fz(r,this.feedOutputNames,o,!1,"target")),function Uhe(n,t,e){const r=[W_,G_,Gp];for(let s=0;s<n.length;++s){const i=n[s],o=t[s],a=e[s];if(null!=o){if(o===Gp&&1===i.shape[i.shape.length-1])throw new O(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(o)){const l=i.shape.slice(1),c=a.slice(1);for(let u=0;u<l.length;++u){const d=l[u],h=c[u];if(null!=h&&d!==h)throw new O(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=i&&i>0&&e[0].shape[0]%i!=0)throw new O(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,s,i,o=!0,a){var l=this;return ee(function*(){const[c,u]=l.standardizeUserDataXY(e,r,o,a);if(null!=s)throw new Error("sample weight is not supported yet.");let d=null;if(null!=i){const h=oz(i,l.outputNames);d=[];for(let f=0;f<h.length;++f)d.push(yield az(u[f],null,h[f]))}return[c,u,d]})()}testLoop(e,r,s,i=0,o){return B(()=>{const a=this.checkNumSamples(r,s,o,"steps"),l=[];if(i>0)throw new et("Verbose mode is not implemented yet.");if(null!=o)throw new et("steps mode in testLoop() is not implemented yet");{const c=fT(a,s),u=fs(ao(0,a));for(let d=0;d<c.length;++d){const h=c[d][0],f=c[d][1],p=vc(u,h,f-h),m=hT(r,p),g=e(m);if(0===d)for(let y=0;y<g.length;++y)l.push(Le(0));for(let y=0;y<g.length;++y)l[y]=le(l[y],M(f-h,g[y]))}for(let d=0;d<l.length;++d)l[d]=$e(l[d],a)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,r=[];for(let s=0;s<e.length;++s){const i=e[s];let o=i;vB(e,i)>1&&(o+=`_${vB(e.slice(0,s),i)}`),r.push(o)}return r}makeTrainFunction(){return e=>{const r=[],s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],c=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(()=>{const h=[];for(let g=0;g<this.inputs.length;++g)h.push({key:this.inputs[g],value:s[g]});const f=new hl(h),p=Wp(this.outputs,f,{training:!0});let m;for(let g=0;g<this.lossFunctions.length;++g){let b=(0,this.lossFunctions[g])(i[g],p[g]);null!=o[g]&&(b=Mhe(b,o[g]));const _=Mn(b);r.push(_),m=0===g?b:le(m,b)}for(let g=0;g<this.metricsTensors.length;++g){let y;if(this.outputs.length>1&&g<this.outputs.length)y=r[g];else{const _=this.metricsTensors[g][1];y=Mn((0,this.metricsTensors[g][0])(i[_],p[_]))}_r(y),a.push(y)}return m=Mn(m),this.calculateLosses().forEach(g=>{m=le(m,g)}),m},!0,c)].concat(a)}}makeTestFunction(){this.testFunction=e=>B(()=>{const r=[];let s;const i=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let u=0;u<this.inputs.length;++u)a.push({key:this.inputs[u],value:i[u]});const l=new hl(a),c=Wp(this.outputs,l);for(let u=0;u<this.lossFunctions.length;++u){const h=Mn((0,this.lossFunctions[u])(o[u],c[u]));s=0===u?h:le(s,h),r.push(s)}for(let u=0;u<this.metricsTensors.length;++u){const h=this.metricsTensors[u][1],f=Mn((0,this.metricsTensors[u][0])(o[h],c[h]));r.push(f)}return r})}fit(e,r,s={}){var i=this;return ee(function*(){if(i.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let o,a,l,c,u,d,h,f,p;i.isTraining=!0;try{const m=s.batchSize??32;dT(m);const g=!1,y=yield i.standardizeUserData(e,r,s.sampleWeight,s.classWeight,g,m);o=y[0],a=y[1],p=y[2];let _,b=!1;if(null!=s.validationData&&s.validationData.length>0){if(b=!0,2!==s.validationData.length)throw 3===s.validationData.length?new et("validationData including sample weights is not supported yet."):new O(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);u=s.validationData[0],d=s.validationData[1];const P=!0,z=yield i.standardizeUserData(u,d,null,null,P,m);h=z[0],f=z[1],_=h.concat(f)}else if(null!=s.validationSplit&&s.validationSplit>0&&s.validationSplit<1){b=!0;const P=Math.floor(o[0].shape[0]*(1-s.validationSplit)),z=o[0].shape[0];h=qp(o,P,z),l=o,o=qp(o,0,P),f=qp(a,P,z),c=a,a=qp(a,0,P),_=h.concat(f)}else null!=s.validationSteps&&(b=!0);const v=o.concat(a).concat(p);i.checkTrainableWeightsConsistency();const w=i.makeTrainFunction(),C=i.getDedupedMetricsNames();let I,D;b?(i.makeTestFunction(),I=i.testFunction,D=C.slice().concat(C.map(P=>"val_"+P))):(I=null,_=[],D=C.slice());const T=KB(s.callbacks,s.yieldEvery);return yield i.fitLoop(w,v,C,m,s.epochs,s.verbose,T,I,_,s.shuffle,D,s.initialEpoch,null,null)}finally{i.isTraining=!1,ho(o,e),ho(a,r),ho(l,e),ho(c,r),ho(h,u),ho(f,d),null!=p&&ot(p)}})()}fitLoop(e,r,s,i,o,a,l,c,u,d,h,f,p,m){var g=this;return ee(function*(){null==i&&(i=32),null==o&&(o=1),null==d&&(d=!0),null==f&&(f=0);let y=!1;if(null!=c&&null!=u&&(y=!0),null!=m&&(y=!0,null==p))throw new O("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const b=g.checkNumSamples(r,i,p,"steps_per_epoch");let _;null!=b&&(_=ao(0,b)),null==a&&(a=1);const{callbackList:v,history:w}=XB(l,a,o,f,b,p,i,y,h);v.setModel(g),g.history=w,yield v.onTrainBegin(),g.stopTraining_=!1;for(let C=f;C<o;++C){yield v.onEpochBegin(C);const I={};if(null!=p)throw new et("stepsPerEpoch mode is not implemented yet.");{if("batch"===d)throw new et("batch shuffling is not implemneted yet");d&&xP(_);const D=fs(_),T=fT(b,i);for(let N=0;N<T.length;++N){const P={};if(yield v.onBatchBegin(N,P),B(()=>{const z=T[N][0],W=T[N][1],G=vc(D,z,W-z);P.batch=N,P.size=W-z;const q=hT(r,G),$=e(q);for(let V=0;V<s.length;++V){const H=$[V];P[s[V]]=H,_r(H)}if(N===T.length-1&&y){const V=g.testLoop(c,u,i);for(let L=0;L<s.length;++L){const H=s[L],ne=V[L];_r(ne),I["val_"+H]=ne}}}),yield v.onBatchEnd(N,P),qB(P),g.stopTraining_)break}D.dispose()}if(yield v.onEpochEnd(C,I),g.stopTraining_)break}return yield v.onTrainEnd(),yield g.history.syncData(),g.history})()}fitDataset(e,r){var s=this;return ee(function*(){return function $he(n,t,e){return cT.apply(this,arguments)}(s,e,r)})()}trainOnBatch(e,r){var s=this;return ee(function*(){const i=yield s.standardizeUserData(e,r),o=i[0],a=i[1],c=s.makeTrainFunction()(o.concat(a)),u=[];for(const d of c){const h=yield d.data();u.push(h[0])}return ot(c),ho(i[0],e),ho(i[1],r),ps(u)})()}getNamedWeights(e){const r=[],s=null!=e&&e.trainableOnly,i=s?this.trainableWeights:this.weights,o=this.getWeights(s);for(let a=0;a<i.length;++a)s&&!i[a].trainable||r.push({name:i[a].originalName,tensor:o[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const r=_I().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-_I().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=va(this.loss);else if(Array.isArray(this.loss)){for(const r of this.loss)if("string"!=typeof r)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>va(r))}else{const r=Object.keys(this.loss);e={};const s=this.loss;for(const i of r){if("string"!=typeof s[i])throw new Error("Serialization of non-string loss is not supported.");e[i]=va(s[i])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[va(X_(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>va(X_(e)));{const e={};for(const r in this.metrics)e[r]=va(X_(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const s=xa(iT(e.optimizer_config));let i,o;if("string"==typeof e.loss)i=yc(e.loss);else if(Array.isArray(e.loss))i=e.loss.map(a=>yc(a));else if(null!=e.loss){i={};for(const a in e.loss)i[a]=yc(e.loss[a])}if(Array.isArray(e.metrics))o=e.metrics.map(a=>yc(a));else if(null!=e.metrics){o={};for(const a in e.metrics)o[a]=yc(e.metrics[a])}this.compile({loss:i,metrics:o,optimizer:s})}save(e,r){var s=this;return ee(function*(){if("string"==typeof e){const d=JP(e);if(0===d.length)throw new O(`Cannot find any save handlers for URL '${e}'`);if(d.length>1)throw new O(`Found more than one (${d.length}) save handlers for URL '${e}'`);e=d[0]}if(null==e.save)throw new O("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const i=yield jE(s.getNamedWeights(r)),c={modelTopology:s.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v4.1.0",convertedBy:null};if(null!=r&&r.includeOptimizer&&null!=s.optimizer){c.trainingConfig=s.getTrainingConfig();const d="optimizer",{data:h,specs:f}=yield jE(yield s.optimizer.getWeights(),d);i.specs.push(...f),i.data=Zb([i.data,h])}return null!=s.userDefinedMetadata&&(rz(s.userDefinedMetadata,s.name,!0),c.userDefinedMetadata=s.userDefinedMetadata),c.weightData=i.data,c.weightSpecs=i.specs,e.save(c)})()}setUserDefinedMetadata(e){rz(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return n.className="Model",n})();se(vd),se((()=>{class n extends vd{}return n.className="Functional",n})()),se((()=>{class n extends vd{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:M_("sequential_"),null!=e.layers)for(const r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new O(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const r=e instanceof n||e instanceof vd;let s;if(r){if(s=e,1!==s.outputs.length)throw new O("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==s.inputs.length)throw new O("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new O("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=function Kde(n){if(null==n.batchShape&&null==n.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=n.batchShape&&null!=n.shape)throw new O("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;null!=n.shape&&null==t&&(t=[null].concat(n.shape));let e=n.dtype;return null==e&&(e="float32"),new B_({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(r)this.outputs=s.outputs,this.inputs=s.inputs;else{if(1!==e.inboundNodes.length)throw new O(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new O("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=HB(this.outputs[0])}this.inboundNodes=[],new V_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:gc(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=e.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return null==this.model&&this.build(),this.model.call(e,r)}build(e){if(Ot(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new vd({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,s=console.log){this.built||this.build(),super.summary(e,r,s)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,r,s={}){if(!this.built)throw new Ri("The model needs to be compiled before being used.");return this.model.evaluate(e,r,s)}evaluateDataset(e,r){var s=this;return ee(function*(){if(!s.built)throw new Ri("The model needs to be compiled before being used.");return s.model.evaluateDataset(e,r)})()}predict(e,r={}){return null==this.model&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,r,s={}){var i=this;return ee(function*(){if(!i.built)throw new Ri("The model needs to be compiled before being used.");return i.model.fit(e,r,s)})()}fitDataset(e,r){var s=this;return ee(function*(){if(!s.built)throw new Ri("The model needs to be compiled before being used.");return s.model.fitDataset(e,r)})()}trainOnBatch(e,r){var s=this;return ee(function*(){return s.model.trainOnBatch(e,r)})()}static fromConfig(e,r,s={},i=!1){let o,a={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new O("Legacy serialization format not supported yet.");o=r}else S(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=r.layers,delete r.layers,a=r;const l=new e(a);if(!(l instanceof n))throw new et(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const c of o){const d=xa(c,void 0,i);i&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(e){if(null==this.model)throw new O("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new O("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const r of this.layers){const s={};s.className=r.getClassName(),s.config=r.getConfig(),e.push(s)}return{name:this.name,layers:e}}}return n.className="Sequential",n})());class ms extends id{getConfig(){return{}}}se((()=>{class n extends ms{apply(e,r=1){return function Ode(n,t=1){if(1!==t)throw new et(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Sp(n)}(e,r)}}return n.className="elu",n})()),se((()=>{class n extends ms{apply(e){return WI(e)}}return n.className="selu",n})()),se((()=>{class n extends ms{apply(e){return Mo(e)}}return n.className="relu",n})()),se((()=>{class n extends ms{apply(e){return B(()=>kp(6,Mo(e)))}}return n.className="relu6",n})()),se((()=>{class n extends ms{apply(e){return e}}return n.className="linear",n})()),se((()=>{class n extends ms{apply(e){return Ao(e)}}return n.className="sigmoid",n})()),se((()=>{class n extends ms{apply(e){return function Pde(n){return B(()=>{const t=le(.5,M(.2,n));return Ts(t,0,1)})}(e)}}return n.className="hardSigmoid",n})()),se((()=>{class n extends ms{apply(e){return dd(e)}}return n.className="softplus",n})()),se((()=>{class n extends ms{apply(e){return function $de(n){return B(()=>$e(n,le(rr(n),1)))}(e)}}return n.className="softsign",n})()),se((()=>{class n extends ms{apply(e){return ld(e)}}return n.className="tanh",n})());let mz=(()=>{class n extends ms{apply(e,r=-1){return v_(e,r)}}return n.className="softmax",n})();function pl(n){return n.getClassName()}function bT(n,t={}){return Vp(n,Ei.getMap().classNameMap,t,"activation")}function ml(n){if(null==n){return bT({className:"linear",config:{}})}if("string"==typeof n){const t={};return t.className=n,t.config={},bT(t)}return n instanceof ms?n:bT(n)}se(mz),se((()=>{class n extends ms{apply(e,r=-1){return MI(e,r)}}return n.className="logSoftmax",n})()),se((()=>{class n extends ms{apply(e,r=1){return B(()=>M(Ao(M(e,r)),e))}}return n.className="swish",n})()),se((()=>{class n extends ms{apply(e){return B(()=>M(e,ld(dd(e))))}}return n.className="mish",n})());class gz extends id{}se((()=>{class n extends gz{constructor(e){super(),function _T(n){if(null!=n&&"object"!=typeof n)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return B(()=>{let r=sr([1]);return this.hasL1&&(r=le(r,Ae(M(this.l1,rr(e))))),this.hasL2&&(r=le(r,Ae(M(this.l2,Up(e))))),F(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return n.className="L1L2",n})());const yz={l1l2:"L1L2"};function Zt(n){return HD(n)}function bz(n,t={}){return Vp(n,Ei.getMap().classNameMap,t,"regularizer")}function _n(n){return null==n?null:"string"==typeof n?bz({className:n in yz?yz[n]:n,config:{}}):n instanceof gz?n:bz(n)}function xd(n,t,e){if("number"==typeof n)return gc(n,t);if(n.length!==t)throw new O(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let r=0;r<t;++r){const s=n[r];if(!kde(s))throw new O(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${s}`)}return n}function fo(n,t,e,r,s=1){if(null==n)return n;let o;return o="same"===e?n:n-(t+(t-1)*(s-1))+1,Math.floor((o+r-1)/r)}function Bo(n,t,e,r){if(null==n)return null;if("valid"===r)n=n*t+dl([e-t,0]);else{if("same"!==r)throw new O(`Unsupport padding mode: ${r}.`);n*=t}return n}function xT(n,t){return B(()=>(zn(t),"channelsFirst"===t?vt(n,[0,2,3,1]):n))}function _z(n,t){return B(()=>(zn(t),"channelsFirst"===t?vt(n,[0,2,3,4,1]):n))}function wT(n,t,e,r=[1,1],s="valid",i,o,a=null){return B(()=>{if(null==i&&(i="channelsLast"),zn(i),3!==n.rank&&4!==n.rank)throw new O(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(3!==t.rank&&4!==t.rank)throw new O(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=xT(n,i);if("causal"===s)throw new et("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=DV({x:l,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:a}),"channelsFirst"===i&&(l=vt(l,[0,3,1,2])),l})}se((()=>{class n extends mt{constructor(e){super(e??{}),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,r){e=Ye(e);let s=Mo(e);return null!=this.maxValue&&(s=Ts(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ReLU",n})()),se((()=>{class n extends mt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=e.alpha??this.DEFAULT_ALPHA}call(e,r){const s=Ye(e);return c_(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LeakyReLU",n})()),se((()=>{class n extends mt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=bn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=_n(e.alphaRegularizer),this.alphaConstraint=lr(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new O(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const r=(e=Ot(e)).slice(1);if(null!=this.sharedAxes)for(const i of this.sharedAxes)r[i-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(null!=this.sharedAxes)for(let i=1;i<e.length;++i)s[i]=e[i];this.inputSpec=[new or({ndim:e.length,axes:s})],this.built=!0}call(e,r){return e=Ye(e),g_(e,this.alpha.read())}getConfig(){const e={alphaInitializer:In(this.alphaInitializer),alphaRegularizer:Zt(this.alphaRegularizer),alphaConstraint:ar(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return n.className="PReLU",n})()),se((()=>{class n extends mt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new et(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha??this.DEFAULT_ALPHA}call(e,r){const s=Ye(e);return Sp(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ELU",n})()),se((()=>{class n extends mt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=e.theta??this.DEFAULT_THETA}call(e,r){const s=Ye(e);return M(s,ve(ks(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ThresholdedReLU",n})()),se((()=>{class n extends mt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new mz).apply,this.axis=e.axis??this.DEFAULT_AXIS}call(e,r){const s=Ye(e);return this.softmax(s,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Softmax",n})());class Z_ extends mt{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Z_.verifyArgs(e),this.rank=t,wr(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new et(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=xd(e.kernelSize,t,"kernelSize"),this.strides=xd(e.strides??1,t,"strides"),this.padding=e.padding??"valid",ii(this.padding),this.dataFormat=e.dataFormat??"channelsLast",zn(this.dataFormat),this.activation=ml(e.activation),this.useBias=e.useBias??!0,this.biasInitializer=bn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=lr(e.biasConstraint),this.biasRegularizer=_n(e.biasRegularizer),this.activityRegularizer=_n(e.activityRegularizer),this.dilationRate=xd(e.dilationRate??1,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new O(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new O(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new O(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(si("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!jD(t.kernelSize,"number",1,3))throw new O(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:pl(this.activation),useBias:this.useBias,biasInitializer:In(this.biasInitializer),biasRegularizer:Zt(this.biasRegularizer),activityRegularizer:Zt(this.activityRegularizer),biasConstraint:ar(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class wd extends Z_{constructor(t,e){super(t,e),this.kernel=null,wd.verifyArgs(e),this.filters=e.filters,wr(this.filters,"filters"),this.kernelInitializer=bn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=lr(e.kernelConstraint),this.kernelRegularizer=_n(e.kernelRegularizer)}build(t){t=Ot(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new O(`The channel dimension of the input should be defined. Found ${t[e]}`);const r=t[e],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(t,e){return B(()=>{let r;t=Ye(t);const s=null==this.bias?null:this.bias.read(),i=wB(this.activation.getClassName());if(null!=i&&2===this.rank)r=wT(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(1===this.rank)r=function vz(n,t,e,r=1,s="valid",i,o=1){return B(()=>{if(null==i&&(i="channelsLast"),zn(i),3!==n.shape.length)throw new O(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(3!==t.shape.length)throw new O(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new O(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===i&&(n=vt(n,[0,2,1])),"causal"===s)throw new et("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=CI(n,t,r,"same"===s?"same":"valid","NWC",o);return null!=e&&(a=co(a,e)),a})}(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=wT(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new et("convolutions greater than 3D are not implemented yet.");r=function xz(n,t,e,r=[1,1,1],s="valid",i,o){return B(()=>{if(null==i&&(i="channelsLast"),zn(i),4!==n.rank&&5!==n.rank)throw new O(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(4!==t.rank&&5!==t.rank)throw new O(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=_z(n,i);if("causal"===s)throw new et("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=GL(a,t,r,"same"===s?"same":"valid","NDHWC",o),null!=e&&(a=co(a,e)),"channelsFirst"===i&&(a=vt(a,[0,4,1,2,3])),a})}(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=Ot(t);const e=[],r="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let i=0;i<r.length;++i){const o=fo(r[i],this.kernelSize[i],this.padding,this.strides[i],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[i]);e.push(o)}let s=[t[0]];return"channelsLast"===this.dataFormat?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){const t={filters:this.filters,kernelInitializer:In(this.kernelInitializer),kernelRegularizer:Zt(this.kernelRegularizer),kernelConstraint:ar(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new O(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}let wz=(()=>{class n extends wd{constructor(e){super(2,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!jD(e.kernelSize,"number",1,2))throw new O(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv2D",n})();se(wz);let Cz=(()=>{class n extends wd{constructor(e){super(3,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new O(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv3D",n})();se(Cz),se((()=>{class n extends wz{constructor(e){if(super(e),this.inputSpec=[new or({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new O(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Ot(e)).length)throw new O("Input should have rank 4; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new O("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new or({ndim:4,axes:{[r]:s}})],this.built=!0}call(e,r){return B(()=>{let s=Ye(e);if(4!==s.shape.length)throw new O(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape;let a,l;"channelsFirst"===this.dataFormat?(a=2,l=3):(a=1,l=2);const u=i[l],h=this.kernelSize[1],p=this.strides[1],y=[i[0],Bo(i[a],this.strides[0],this.kernelSize[0],this.padding),Bo(u,p,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=vt(s,[0,2,3,1]));let b=EI(s,this.kernel.read(),y,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=vt(b,[0,3,1,2])),null!=this.bias&&(b=co(b,this.bias.read(),this.dataFormat)),null!=this.activation&&(b=this.activation.apply(b)),b})}computeOutputShape(e){const r=(e=Ot(e)).slice();let s,i,o;"channelsFirst"===this.dataFormat?(s=1,i=2,o=3):(s=3,i=1,o=2);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.strides[0],u=this.strides[1];return r[s]=this.filters,r[i]=Bo(r[i],c,a,this.padding),r[o]=Bo(r[o],u,l,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv2DTranspose",n})()),se((()=>{class n extends Cz{constructor(e){if(super(e),this.inputSpec=[new or({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new O(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=Ot(e)).length)throw new O("Input should have rank 5; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new O("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new or({ndim:5,axes:{[r]:s}})],this.built=!0}call(e,r){return B(()=>{let s=Ye(e);if(5!==s.shape.length)throw new O(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape;let a,l,c;"channelsFirst"===this.dataFormat?(c=2,a=3,l=4):(c=1,a=2,l=3);const d=i[a],h=i[l],p=this.kernelSize[1],m=this.kernelSize[2],y=this.strides[1],b=this.strides[2],C=[i[0],Bo(i[c],this.strides[0],this.kernelSize[0],this.padding),Bo(d,y,p,this.padding),Bo(h,b,m,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=vt(s,[0,2,3,4,1]));let I=KL(s,this.kernel.read(),C,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(I=vt(I,[0,4,1,2,3])),null!==this.bias&&(I=co(I,this.bias.read(),this.dataFormat)),null!==this.activation&&(I=this.activation.apply(I)),I})}computeOutputShape(e){const r=(e=Ot(e)).slice();let s,i,o,a;"channelsFirst"===this.dataFormat?(s=1,i=2,o=3,a=4):(s=4,i=1,o=2,a=3);const l=this.kernelSize[0],c=this.kernelSize[1],u=this.kernelSize[2],d=this.strides[0],h=this.strides[1],f=this.strides[2];return r[s]=this.filters,r[i]=Bo(r[i],d,l,this.padding),r[o]=Bo(r[o],h,c,this.padding),r[a]=Bo(r[a],f,u,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv3DTranspose",n})());let qhe=(()=>{class n extends wd{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==r.filters)throw new O("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=r.kernelInitializer||null!=r.kernelRegularizer||null!=r.kernelConstraint)throw new O("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=r.padding&&"same"!==r.padding&&"valid"!==r.padding)throw new O(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=r.depthMultiplier??1,this.depthwiseInitializer=bn(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=_n(r.depthwiseRegularizer),this.depthwiseConstraint=lr(r.depthwiseConstraint),this.pointwiseInitializer=bn(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=_n(r.pointwiseRegularizer),this.pointwiseConstraint=lr(r.pointwiseConstraint)}build(e){if((e=Ot(e)).length<this.rank+2)throw new O(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r]||e[r]<0)throw new O(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);const s=e[r],i=this.kernelSize.concat([s,this.depthMultiplier]),o=[];for(let l=0;l<this.rank;++l)o.push(1);o.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new or({ndim:this.rank+2,axes:{[r]:s}})],this.built=!0}call(e,r){return B(()=>{let s;if(e=Ye(e),1===this.rank)throw new et("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=vt(e,[0,2,3,1])),s=jI(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=co(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),"channelsFirst"===this.dataFormat&&(s=vt(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=In(this.depthwiseInitializer),e.pointwiseInitializer=In(this.pointwiseInitializer),e.depthwiseRegularizer=Zt(this.depthwiseRegularizer),e.pointwiseRegularizer=Zt(this.pointwiseRegularizer),e.depthwiseConstraint=ar(this.depthwiseConstraint),e.pointwiseConstraint=ar(this.pointwiseConstraint),e}}return n.className="SeparableConv",n})();function Sz(n,t,e,r){if(Array.isArray(n)){if(null!=t||null!=e)throw new O("When inputs is an array, neither initialState or constants should be provided");null!=r&&(e=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function s(i){return null==i||Array.isArray(i)?i:[i]}return{inputs:n,initialState:t=s(t),constants:e=s(e)}}function Ez(n,t,e,r=!1,s,i,o=!1,a=!1){return B(()=>{const l=t.shape.length;if(l<3)throw new O(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(ao(2,l));if(t=vt(t,c),null!=i)throw new et("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=ve(ve(s,"bool"),"float32")).rank===l-1&&(s=hs(s,-1)),s=vt(s,c)),r&&(t=ki(t,0),null!=s&&(s=ki(s,0)));const u=[];let d,h=e;const f=t.shape[0],p=Ni(t);let m,g;null!=s&&(m=Ni(s));for(let y=0;y<f;++y){const b=p[y],_=B(()=>n(b,h));if(null==s)d=_[0],h=_[1];else{const v=B(()=>{const w=m[y],C=De(ni(w),w);return{output:le(M(_[0],w),M(h[0],C)),newStates:h.map((T,N)=>le(M(_[1][N],w),M(T,C)))}});d=v.output,h=v.newStates}a&&u.push(d)}return a&&(g=ri(u,1)),[d,g,h]})}se((()=>{class n extends qhe{constructor(e){super(2,e)}}return n.className="SeparableConv2D",n})()),se((()=>{class n extends wd{constructor(e){super(1,e),n.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!jD(e.kernelSize,"number",1,1))throw new O(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv1D",n})()),se((()=>{class n extends mt{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return B(()=>{if(e=Ye(e),"channelsLast"===this.dataFormat){const s=O_(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return O_(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const s=O_(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return O_(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Cropping2D",n})()),se((()=>{class n extends mt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size??this.DEFAULT_SIZE,this.dataFormat=e.dataFormat??"channelsLast",zn(this.dataFormat),this.interpolation=e.interpolation??"nearest",function Ide(n){bc(wde,"InterpolationFormat",n)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,r){return B(()=>{let s=Ye(e);const i=s.shape;if("channelsFirst"===this.dataFormat){s=vt(s,[0,2,3,1]);const o=this.size[0]*i[2],a=this.size[1]*i[3],l="nearest"===this.interpolation?ba.resizeNearestNeighbor(s,[o,a]):ba.resizeBilinear(s,[o,a]);return vt(l,[0,3,1,2])}{const o=this.size[0]*i[1],a=this.size[1]*i[2];return"nearest"===this.interpolation?ba.resizeNearestNeighbor(s,[o,a]):ba.resizeBilinear(s,[o,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}}return n.className="UpSampling2D",n})()),se((()=>{class n extends Z_{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier??1,this.depthwiseInitializer=bn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=lr(e.depthwiseConstraint),this.depthwiseRegularizer=_n(e.depthwiseRegularizer)}build(e){if((e=Ot(e)).length<4)throw new O(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const r="channelsFirst"===this.dataFormat?1:3;if(null==e[r]||e[r]<0)throw new O(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);const s=e[r];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return B(()=>{let s=function Khe(n,t,e=[1,1],r="valid",s,i){return B(()=>{null==s&&(s="channelsLast"),zn(s);let o=xT(n,s);if(4!==n.rank)throw new O(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(4!==t.rank)throw new O(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=Cp(o,t,e,"same"===r?"same":"valid","NHWC",i),"channelsFirst"===s&&(o=vt(o,[0,3,1,2])),o})}(e=Ye(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=co(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Ot(e);const s="channelsFirst"===this.dataFormat?e[3]:e[2],i="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,o=fo("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),a=fo(s,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],i,o,a]:[e[0],o,a,i]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=In(this.depthwiseInitializer),e.depthwiseRegularizer=Zt(this.depthwiseRegularizer),e.depthwiseConstraint=ar(this.depthwiseRegularizer),e}}return n.className="DepthwiseConv2D",n})());let Kp=(()=>{class n extends mt{constructor(e){let r;if(super(e),null==e.cell)throw new O("cell property is missing for the constructor of RNN.");if(r=Array.isArray(e.cell)?new Tz({cells:e.cell}):e.cell,null==r.stateSize)throw new O("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=e.returnSequences??!1,this.returnState=e.returnState??!1,this.goBackwards=e.goBackwards??!1,this._stateful=e.stateful??!1,this.unroll=e.unroll??!1,this.supportsMasking=!0,this.inputSpec=[new or({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return this.states_??ao(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null)}setStates(e){this.states_=e}computeOutputShape(e){YD(e)&&(e=e[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);const s=r[0];let i;if(i=this.returnSequences?[e[0],e[1],s]:[e[0],s],this.returnState){const o=[];for(const a of r)o.push([e[0],a]);return[i].concat(o)}return i}computeMask(e,r){return B(()=>{Array.isArray(r)&&(r=r[0]);const s=this.returnSequences?r:null;if(this.returnState){const i=this.states.map(o=>null);return[s].concat(i)}return s})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let s=0;s<e;++s)r.push(null);return r}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new et("Constants support is not implemented in RNN yet.");YD(e)&&(e=e[0]);const s=this.stateful?e[0]:null,i=e.slice(2);this.inputSpec[0]=new or({shape:[s,null,...i]});const o=[e[0]].concat(e.slice(2));let a;if(this.cell.build(o),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!It(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new O(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new or({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){B(()=>{if(!this.stateful)throw new Oo("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(null==s)throw new O("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(i=>sr([s,i])):[sr([s,this.cell.stateSize])];else if(null==e)ot(this.states_),null!=this.keptStates&&(ot(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>sr([s,i])):this.states_[0]=sr([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new O(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===r?this.keptStates.push(this.states_.slice()):ot(this.states_);for(let i=0;i<this.states_.length;++i){const o=e[i],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,l=[s,a];if(!It(o.shape,l))throw new O(`State ${i} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${o.shape}`);this.states_[i]=o}}this.states_=this.states_.map(i=>_r(i.clone()))})}apply(e,r){let s=null==r?null:r.initialState,i=null==r?null:r.constants;null==r&&(r={});const o=Sz(e,s,i,this.numConstants);e=o.inputs,s=o.initialState,i=o.constants;let a=[],l=[];if(null!=s){r.initialState=s,a=a.concat(s),this.stateSpec=[];for(const u of s)this.stateSpec.push(new or({shape:u.shape}));l=l.concat(this.stateSpec)}if(null!=i&&(r.constants=i,a=a.concat(i),this.numConstants=i.length),a[0]instanceof Vo){const u=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(u,r);return this.inputSpec=h,f}return super.apply(e,r)}call(e,r){return B(()=>{const s=null==r?null:r.mask,i=null==r?null:r.training;let o=null==r?null:r.initialState;e=Ye(e),null==o&&(o=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==a)throw new O(`RNN Layer has ${a} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:i},u=Ez((m,g)=>{const y=this.cell.call([m].concat(g),l);return[y[0],y.slice(1)]},e,o,this.goBackwards,s,null,this.unroll,this.returnSequences),d=u[0],h=u[1],f=u[2];this.stateful&&this.resetStates(f,i);const p=this.returnSequences?h:d;return this.returnState?[p].concat(f):p})}getInitialState(e){return B(()=>{let r=sr(e.shape);return r=Ae(r,[1,2]),r=zp(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?KD(r,[1,s]):r):this.cell.stateSize>1?[KD(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===n.className&&(r.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),r)}static fromConfig(e,r,s={}){const o=xa(r.cell,s);return new e(Object.assign(r,{cell:o}))}}return n.className="RNN",n})();se(Kp);class Q_ extends mt{}let Iz=(()=>{class n extends Q_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,wr(this.units,"units"),this.activation=ml(e.activation??this.DEFAULT_ACTIVATION),this.useBias=e.useBias??!0,this.kernelInitializer=bn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=bn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=bn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=_n(e.kernelRegularizer),this.recurrentRegularizer=_n(e.recurrentRegularizer),this.biasRegularizer=_n(e.biasRegularizer),this.kernelConstraint=lr(e.kernelConstraint),this.recurrentConstraint=lr(e.recurrentConstraint),this.biasConstraint=lr(e.biasConstraint),this.dropout=bd([1,dl([0,e.dropout??0])]),this.recurrentDropout=bd([1,dl([0,e.recurrentDropout??0])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ot(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return B(()=>{if(2!==e.length)throw new O(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const i=r.training??!1;let o;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=gl({ones:()=>ni(e),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=gl({ones:()=>ni(s),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,l=this.recurrentDropoutMask;o=Po(null!=a?M(e,a):e,this.kernel.read()),null!=this.bias&&(o=co(o,this.bias.read())),null!=l&&(s=M(s,l));let c=le(o,Po(s,this.recurrentKernel.read()));return null!=this.activation&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:pl(this.activation),useBias:this.useBias,kernelInitializer:In(this.kernelInitializer),recurrentInitializer:In(this.recurrentInitializer),biasInitializer:In(this.biasInitializer),kernelRegularizer:Zt(this.kernelRegularizer),recurrentRegularizer:Zt(this.recurrentRegularizer),biasRegularizer:Zt(this.biasRegularizer),activityRegularizer:Zt(this.activityRegularizer),kernelConstraint:ar(this.kernelConstraint),recurrentConstraint:ar(this.recurrentConstraint),biasConstraint:ar(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),r)}}return n.className="SimpleRNNCell",n})();se(Iz),se((()=>{class n extends Kp{constructor(e){e.cell=new Iz(e),super(e)}call(e,r){return B(()=>(null!=this.cell.dropoutMask&&(ot(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ot(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return new e(r)}}return n.className="SimpleRNN",n})());let Dz=(()=>{class n extends Q_{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new O("GRUCell does not support reset_after parameter set to true.");this.units=e.units,wr(this.units,"units"),this.activation=ml(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ml(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias??!0,this.kernelInitializer=bn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=bn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=bn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=_n(e.kernelRegularizer),this.recurrentRegularizer=_n(e.recurrentRegularizer),this.biasRegularizer=_n(e.biasRegularizer),this.kernelConstraint=lr(e.kernelConstraint),this.recurrentConstraint=lr(e.recurrentConstraint),this.biasConstraint=lr(e.biasConstraint),this.dropout=bd([1,dl([0,e.dropout??0])]),this.recurrentDropout=bd([1,dl([0,e.recurrentDropout??0])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ot(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return B(()=>{if(2!==e.length)throw new O(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training??!1;let i=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=gl({ones:()=>ni(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=gl({ones:()=>ni(i),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const a=this.recurrentDropoutMask;let l,c,u;0<this.dropout&&this.dropout<1&&(e=M(e,this.dropoutMask[0]));let d=Po(e,this.kernel.read());this.useBias&&(d=co(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=M(i,a[0]));const h=this.recurrentKernel.read(),[f,p]=Ns(h,[2*this.units,this.units],h.rank-1),m=Po(i,f),[g,y,b]=Ns(d,3,d.rank-1),[_,v]=Ns(m,2,m.rank-1);l=this.recurrentActivation.apply(le(g,_)),c=this.recurrentActivation.apply(le(y,v));const w=Po(M(c,i),p);u=this.activation.apply(le(b,w));const C=le(M(l,i),M(le(1,yn(l)),u));return[C,C]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:pl(this.activation),recurrentActivation:pl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:In(this.kernelInitializer),recurrentInitializer:In(this.recurrentInitializer),biasInitializer:In(this.biasInitializer),kernelRegularizer:Zt(this.kernelRegularizer),recurrentRegularizer:Zt(this.recurrentRegularizer),biasRegularizer:Zt(this.biasRegularizer),activityRegularizer:Zt(this.activityRegularizer),kernelConstraint:ar(this.kernelConstraint),recurrentConstraint:ar(this.recurrentConstraint),biasConstraint:ar(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),r)}}return n.className="GRUCell",n})();se(Dz),se((()=>{class n extends Kp{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Dz(e),super(e)}call(e,r){return B(()=>(null!=this.cell.dropoutMask&&(ot(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ot(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="GRU",n})());let CT=(()=>{class n extends Q_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,wr(this.units,"units"),this.activation=ml(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ml(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias??!0,this.kernelInitializer=bn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=bn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=bn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=_n(e.kernelRegularizer),this.recurrentRegularizer=_n(e.recurrentRegularizer),this.biasRegularizer=_n(e.biasRegularizer),this.kernelConstraint=lr(e.kernelConstraint),this.recurrentConstraint=lr(e.recurrentConstraint),this.biasConstraint=lr(e.biasConstraint),this.dropout=bd([1,dl([0,e.dropout??0])]),this.recurrentDropout=bd([1,dl([0,e.recurrentDropout??0])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;let i;if(e=Ot(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,a=this.units;i=new((r=class extends Fi{apply(c,u){const d=o.apply([a]),h=(new MB).apply([a]),f=o.apply([2*a]);return NB(NB(d,h),f)}}).className="CustomInit",r)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return B(()=>{const s=r.training??!1;if(3!==e.length)throw new O(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let i=e[1];const o=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=gl({ones:()=>ni(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=gl({ones:()=>ni(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const l=this.recurrentDropoutMask;let c,u,d,h;0<this.dropout&&this.dropout<1&&(e=M(e,this.dropoutMask[0]));let f=Po(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=M(i,l[0])),f=le(f,Po(i,this.recurrentKernel.read())),this.useBias&&(f=co(f,this.bias.read()));const[p,m,g,y]=Ns(f,4,f.rank-1);c=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(m),d=le(M(u,o),M(c,this.activation.apply(g))),h=this.recurrentActivation.apply(y);const b=M(h,this.activation.apply(d));return[b,b,d]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:pl(this.activation),recurrentActivation:pl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:In(this.kernelInitializer),recurrentInitializer:In(this.recurrentInitializer),biasInitializer:In(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Zt(this.kernelRegularizer),recurrentRegularizer:Zt(this.recurrentRegularizer),biasRegularizer:Zt(this.biasRegularizer),activityRegularizer:Zt(this.activityRegularizer),kernelConstraint:ar(this.kernelConstraint),recurrentConstraint:ar(this.recurrentConstraint),biasConstraint:ar(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),r)}}return n.className="LSTMCell",n})();se(CT),se((()=>{class n extends Kp{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new CT(e),super(e)}call(e,r){return B(()=>(null!=this.cell.dropoutMask&&(ot(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ot(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="LSTM",n})());let Tz=(()=>{class n extends Q_{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return B(()=>{let s=e.slice(1);const i=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?i.push(s.splice(0,l.stateSize.length)):i.push(s.splice(0,1));i.reverse();const o=[];let a;for(let l=0;l<this.cells.length;++l){const c=this.cells[l];s=i[l],a=0===l?[e[0]].concat(s):[a[0]].concat(s),a=c.call(a,r),o.push(a.slice(1))}s=[];for(const l of o.slice().reverse())s.push(...l);return[a[0]].concat(s)})}build(e){let r;YD(e)&&(e=e[0]),this.cells.forEach((s,i)=>{_c(`RNNCell_${i}`,()=>{s.build(e),r=Array.isArray(s.stateSize)?s.stateSize[0]:s.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){const e=super.getConfig(),i={cells:this.cells.map(o=>({className:o.getClassName(),config:o.getConfig()}))};return Object.assign(Object.assign({},e),i)}static fromConfig(e,r,s={}){const i=[];for(const o of r.cells)i.push(xa(o,s));return new e({cells:i})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){const r=[];for(const s of this.cells)r.push(...s.trainableWeights);return r.concat(e)}return e}getWeights(){const e=[];for(const r of this.cells)e.push(...r.weights);return ZD(e)}setWeights(e){const r=[];for(const s of this.cells){const o=e.splice(s.weights.length);for(let a=0;a<s.weights.length;++a)r.push([s.weights[a],o[a]])}QD(r)}}return n.className="StackedRNNCells",n})();function gl(n){const{ones:t,rate:e,training:r=!1,count:s=1,dropoutFunc:i}=n,o=()=>null!=i?i(t(),e):RB(t(),e),a=()=>Hp(o,t,r);return!s||s<=1?_r(a().clone()):Array(s).fill(void 0).map(a).map(c=>_r(c.clone()))}se(Tz);let Yhe=(()=>{class n extends Kp{constructor(e){if(e.unroll)throw new et("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new et("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new or({ndim:5})]}call(e,r){return B(()=>{if(null!=this.cell.dropoutMask&&(ot(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ot(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new O("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return B(()=>{const{stateSize:r}=this.cell,i=this.computeSingleOutputShape(e.shape),a=sr([i[0],...i.slice(2)]);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){B(()=>{if(!this.stateful)throw new Oo("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,i=this.computeSingleOutputShape(s),o=[i[0],...i.slice(2)];if(null==s[0])throw new O("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>sr(o)):[sr(o)];else if(null==e)ot(this.states_),null!=this.keptStates&&(ot(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>sr(o)):this.states_[0]=sr(o);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new O(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):ot(this.states_);for(let l=0;l<this.states_.length;++l){const c=e[l],u=o;if(!It(c.shape,u))throw new O(`State ${l} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${c.shape}`);this.states_[l]=c}}this.states_=this.states_.map(l=>_r(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:r,filters:s,kernelSize:i,padding:o,strides:a,dilationRate:l}=this.cell,c="channelsFirst"===r,d=e[c?4:3],h=fo(e[c?3:2],i[0],o,a[0],l[0]),f=fo(d,i[1],o,a[1],l[1]);return[...e.slice(0,2),...c?[s,h,f]:[h,f,s]]}}return n.className="ConvRNN2D",n})(),kz=(()=>{class n extends CT{constructor(e){const{filters:r,kernelSize:s,strides:i,padding:o,dataFormat:a,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:r})),this.filters=r,wr(this.filters,"filters"),this.kernelSize=xd(s,2,"kernelSize"),this.kernelSize.forEach(c=>wr(c,"kernelSize")),this.strides=xd(i||1,2,"strides"),this.strides.forEach(c=>wr(c,"strides")),this.padding=o||"valid",ii(this.padding),this.dataFormat=a||"channelsLast",zn(this.dataFormat),this.dilationRate=xd(l||1,2,"dilationRate"),this.dilationRate.forEach(c=>wr(c,"dilationRate"))}build(e){var r;e=Ot(e);const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new O(`The channel dimension of the input should be defined. Found ${e[s]}`);const a=this.kernelSize.concat([e[s],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){const u=this.biasInitializer,d=this.filters;c=new((r=class extends Fi{apply(f,p){return qD([u.apply([d]),ti([d]),u.apply([2*d])])}}).className="CustomInit",r)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return B(()=>{if(3!==e.length)throw new O(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training||!1,i=e[0],o=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=gl({ones:()=>ni(i),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const c=this.dropoutMask,u=(ie,de,ue)=>de&&de[ue]?M(de[ue],ie):ie;let d=u(i,c,0),h=u(i,c,1),f=u(i,c,2),p=u(i,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=gl({ones:()=>ni(o),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const m=this.recurrentDropoutMask;let g=u(o,m,0),y=u(o,m,1),b=u(o,m,2),_=u(o,m,3);const[w,C,I,D]=Ns(this.kernel.read(),4,3),[T,N,P,z]=this.useBias?Ns(this.bias.read(),4):[null,null,null,null];d=this.inputConv(d,w,T,this.padding),h=this.inputConv(h,C,N,this.padding),f=this.inputConv(f,I,P,this.padding),p=this.inputConv(p,D,z,this.padding);const[W,G,q,$]=Ns(this.recurrentKernel.read(),4,3);g=this.recurrentConv(g,W),y=this.recurrentConv(y,G),b=this.recurrentConv(b,q),_=this.recurrentConv(_,$);const V=this.recurrentActivation.apply(le(d,g)),L=this.recurrentActivation.apply(le(h,y)),H=le(M(L,a),M(V,this.activation.apply(le(f,b)))),ne=M(this.recurrentActivation.apply(le(p,_)),this.activation.apply(H));return[ne,ne,H]})}getConfig(){const s=function(n,t){var e={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&t.indexOf(r)<0&&(e[r]=n[r]);if(null!=n&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(n);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(n,r[s])&&(e[r[s]]=n[r[s]])}return e}(super.getConfig(),["units"]),i={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),i)}inputConv(e,r,s,i){const o=sl(e,r,this.strides,i||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return s?co(o,s,this.dataFormat):o}recurrentConv(e,r){return sl(e,r,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return n.className="ConvLSTM2DCell",n})();se(kz),se((()=>{class n extends Yhe{constructor(e){const r=new kz(e);super(Object.assign(Object.assign({},e),{cell:r}))}static fromConfig(e,r){return new e(r)}}return n.className="ConvLSTM2D",n})());let Nz=(()=>{class n extends mt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const r=e.shape,s=[];for(let i=0;i<this.noiseShape.length;++i)s.push(this.noiseShape[i]??r[i]);return s}call(e,r){return B(()=>{this.invokeCallHook(e,r);const s=Ye(e);if(0<this.rate&&this.rate<1){const i=r.training??!1,o=this.getNoiseShape(s);return Hp(()=>RB(s,this.rate,o,this.seed),()=>s,i)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return n.className="Dropout",n})();se(Nz),se((()=>{class n extends Nz{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const r=e.shape;return[r[0],1,r[2]]}}return n.className="SpatialDropout1D",n})()),se((()=>{class n extends mt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,wr(this.units,"units"),this.activation=ml(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=bn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=bn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=lr(e.kernelConstraint),this.biasConstraint=lr(e.biasConstraint),this.kernelRegularizer=_n(e.kernelRegularizer),this.biasRegularizer=_n(e.biasRegularizer),this.activityRegularizer=_n(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const r=(e=Ot(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){const r=(e=Ot(e)).slice();return r[r.length-1]=this.units,r}call(e,r){return B(()=>{this.invokeCallHook(e,r);const s=Ye(e),i=wB(this.activation.getClassName());let o;return null!=i?o=Po(s,this.kernel.read(),i,this.bias?this.bias.read():null):(o=Po(s,this.kernel.read()),null!=this.bias&&(o=co(o,this.bias.read())),null!=this.activation&&(o=this.activation.apply(o))),o})}getConfig(){const e={units:this.units,activation:pl(this.activation),useBias:this.useBias,kernelInitializer:In(this.kernelInitializer),biasInitializer:In(this.biasInitializer),kernelRegularizer:Zt(this.kernelRegularizer),biasRegularizer:Zt(this.biasRegularizer),activityRegularizer:Zt(this.activityRegularizer),kernelConstraint:ar(this.kernelConstraint),biasConstraint:ar(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dense",n})()),se((()=>{class n extends mt{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Ot(e);for(const r of e.slice(1))if(null==r)throw new O(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],ul(e,1)]}call(e,r){return B(()=>{this.invokeCallHook(e,r);let s=Ye(e);if("channelsFirst"===this.dataFormat&&s.rank>1){const i=[0];for(let o=2;o<s.rank;++o)i.push(o);i.push(1),s=vt(s,i)}return function Fde(n){if(n.rank<=1)throw new O(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],ul(n.shape,1)];return F(n,t)}(s)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const r=super.getConfig();return Object.assign(e,r),e}}return n.className="Flatten",n})()),se((()=>{class n extends mt{constructor(e){super(e),this.supportsMasking=!0,this.activation=ml(e.activation)}call(e,r){return B(()=>{this.invokeCallHook(e,r);const s=Ye(e);return this.activation.apply(s)})}getConfig(){const e={activation:pl(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Activation",n})()),se((()=>{class n extends mt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return B(()=>function Rde(n,t){return B(()=>{if(2!==n.shape.length)throw new O(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);return KD(zp(n,1),[1,t,1])})}(e=Ye(e),this.n))}getConfig(){const e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return n.className="RepeatVector",n})()),se((()=>{class n extends mt{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,r){const s="Total size of new array must be unchanged.",i=r.slice();let o=1,a=null;for(let c=0;c<i.length;++c){const u=i[c];if(this.isUnknown(u)){if(null!==a)throw new O("Can only specifiy one unknown dimension.");a=c}else o*=u}const l=ul(e);if(null!==a){if(0===o||l%o!=0)throw new O(s);i[a]=l/o}else if(l!==o)throw new O(s);return i}computeOutputShape(e){let r=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return B(()=>{this.invokeCallHook(e,r);const s=Ye(e),i=s.shape,o=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return F(s,o)})}getConfig(){const e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Reshape",n})()),se((()=>{class n extends mt{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const r=ao(1,e.dims.length+1);if(!It(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new or({ndim:this.dims.length+1})]}computeOutputShape(e){const r=(e=Ot(e)).slice();return this.dims.forEach((s,i)=>{r[i+1]=e[s]}),r}call(e,r){return vt(Ye(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Permute",n})()),se((()=>{class n extends mt{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=null!=e?e.maskValue??0:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){const s=Ye(e);return n_(hd(s,this.maskValue),-1)}call(e,r){return B(()=>{this.invokeCallHook(e,r);const s=Ye(e),a=n_(hd(s,this.maskValue),-1,!0);return M(s,ve(a,s.dtype))})}}return n.className="Masking",n})()),se((()=>{class n extends mt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=null==e.inputLength?[r,null]:[r].concat(rn(e.inputLength))}this.inputDim=e.inputDim,wr(this.inputDim,"inputDim"),this.outputDim=e.outputDim,wr(this.outputDim,"outputDim"),this.embeddingsInitializer=bn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=_n(e.embeddingsRegularizer),this.activityRegularizer=_n(e.activityRegularizer),this.embeddingsConstraint=lr(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return B(()=>this.maskZero?(e=Ye(e),hd(e,Tt(e))):null)}computeOutputShape(e){if(e=Ot(e),null==this.inputLength)return[...e,this.outputDim];const r=rn(this.inputLength);if(r.length!==e.length-1)throw new O(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let i=0;i<r.length;++i){const o=r[i],a=e[i+1];if(null!=o&&null!=a&&o!==a)throw new O(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==o&&(r[s]=a),s++}}return[e[0],...r,this.outputDim]}call(e,r){return B(()=>{this.invokeCallHook(e,r);let s=Ye(e);"int32"!==s.dtype&&(s=$o(s,"int32"));const i=AB(this.embeddings.read(),F(s,[s.size]));return F(i,Ot(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:In(this.embeddingsInitializer),embeddingsRegularizer:Zt(this.embeddingsRegularizer),activityRegularizer:Zt(this.activityRegularizer),embeddingsConstraint:ar(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Embedding",n})());class xc extends mt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new et}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const r=t.slice(0,t.length-e.length);for(let s=0;s<e.length;++s){const i=t[t.length-e.length+s],o=e[s];if(null==i||null==o||i<0||o<0)r.push(null);else if(1===i)r.push(o);else if(1===o)r.push(i);else{if(i!==o)throw new O("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));r.push(i)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Ot(t)]),t.length<2)throw new O(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const i of t)null!=i&&null!==i[0]&&e.push(i[0]);if(e=cl(e),e.length>1)throw new O(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=null==t[0]?null:t[0].slice(1);for(let i=1;i<t.length;++i){const o=null==t[i]?null:t[i].slice(1);r=this.computeElementwiseOpOutputShape(r,o)}const s=t.map(i=>i.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==cl(s).length}call(t,e){return B(()=>{if(this.reshapeRequired){const r=[],s=t.map(i=>i.rank);if(-1===s.indexOf(null)){const i=dl(s);for(let o of t){const a=o.rank;for(let l=0;l<i-a;++l)o=zp(o,1);r.push(o)}return this.mergeFunction(r)}{let i=!1;for(const l of t){const c=l.rank;if(null==c){const u=l.shape,d=u[0],h=u.slice(1).concat([d]);let f=F(l,[d].concat(ul(u.slice(1))));f=vt(f,[1,0]),f=F(f,h),r.push(f),i=!0}else if(c>1){const u=ao(1,c).concat([0]);r.push(vt(l,u)),i=!0}else r.push(l)}let o=this.mergeFunction(r);const a=o.rank;if(i)if(null==a){const l=o.shape,u=l[l.length-1],d=[u].concat(l.slice(0,l.length-1));o=F(vt(F(o,[-1,u]),[1,0]),d)}else if(a>1){const l=[a-1].concat(ao(0,a-1));o=vt(o,l)}return o}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let s=1;s<t.length;++s){const i=null==t[s]?null:t[s].slice(1);e=this.computeElementwiseOpOutputShape(e,i)}let r=[];for(const s of t)null!=s&&null!==s[0]&&r.push(s[0]);return r=cl(r),e=1===r.length?r.concat(e):[null].concat(e),e}computeMask(t,e){return B(()=>{if(null==e)return null;if(!Array.isArray(e))throw new O("`mask` should be an Array");if(!Array.isArray(t))throw new O("`inputs` should be an Array");if(e.length!==t.length)throw new O(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(s=>null==s))return null;let r=(e=e.map(s=>null==s?s:hs(s,0)))[0];for(let s=1;s<e.length-1;++s)r=Ro(r,e[s]);return r})}}function Xp(n,t){for(;n<0;)n+=t;return n}function Yp(n,t,e,r,s,i=.001){let o;if(2===n.rank)o=PL(n,t,e,r,s,i);else if(3===n.rank)o=LL(n,t,e,r,s,i);else{if(4!==n.rank)throw new et(`batchNormalization is not implemented for array of rank ${n.rank} yet`);o=VL(n,t,e,r,s,i)}return o}function J_(n,t,e,r,s,i){return B(()=>{let o;zn(s),SB(i),ii(r),null==e&&(e=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),n=xT(n,s);const a="same"===r?"same":"valid";return o="max"===i?f_(n,t,e,a):s_(n,t,e,a),"channelsFirst"===s&&(o=vt(o,[0,3,1,2])),o})}function Az(n,t,e,r,s,i){return B(()=>{let o;zn(s),SB(i),ii(r),null==e&&(e=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),n=_z(n,s);const a="same"===r?"same":"valid";return o="max"===i?uV(n,t,e,a):$L(n,t,e,a),"channelsFirst"===s&&(o=vt(o,[0,4,1,2,3])),o})}se((()=>{class n extends xc{constructor(e){super(e)}mergeFunction(e){return B(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=le(r,e[s]);return r})}}return n.className="Add",n})()),se((()=>{class n extends xc{constructor(e){super(e)}mergeFunction(e){return B(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=M(r,e[s]);return r})}}return n.className="Multiply",n})()),se((()=>{class n extends xc{constructor(e){super(e)}mergeFunction(e){return B(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=le(r,e[s]);return M(1/e.length,r)})}}return n.className="Average",n})()),se((()=>{class n extends xc{constructor(e){super(e)}mergeFunction(e){return B(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=ga(r,e[s]);return r})}}return n.className="Maximum",n})()),se((()=>{class n extends xc{constructor(e){super(e)}mergeFunction(e){return B(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=kp(r,e[s]);return r})}}return n.className="Minimum",n})()),se((()=>{class n extends xc{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=e.axis??this.DEFAULT_AXIS,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new O("A `Concatenate` layer should be called on a list of at least 2 inputs");let r=!0;for(const i of e)if(null!=i){r=!1;break}if(r)return;const s=[];for(let i=0;i<e.length;++i){const o=e[i].slice();o.splice(this.axis,1);let a=!1;for(const l of s)if(It(l,o)){a=!0;break}a||s.push(o)}if(s.length>1)throw new O("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return B(()=>qD(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new O("A `Concatenate` layer should be called on a list of inputs.");const r=e,s=r[0].slice(),i=this.axis<0?s.length+this.axis:this.axis;for(const o of r.slice(1)){if(null==s[i]||null==o[i]){s[i]=null;break}s[i]+=o[i]}return s}computeMask(e,r){if(null==r)return null;if(!Array.isArray(r))throw new O("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new O("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new O(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return B(()=>{let s=!0;if(r.forEach(a=>{null==a||(s=!1)}),s)return null;const i=[];for(let a=0;a<e.length;++a)i.push(null==r[a]?ve(ni(e[a]),"bool"):r[a].rank<e[a].rank?hs(r[a],-1):r[a]);const o=Xn(i,this.axis);return vI(o,-1,!1)})}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Concatenate",n})()),se((()=>{class n extends xc{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize??!1,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){S(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0],s=e[1];if(r.length>3||s.length>3)throw new et("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(r,s);if(r[i[0]]!==s[i[1]])throw new O(`Dimension incompatibility: ${r[i[0]]} !== ${s[i[1]]}`)}mergeFunction(e){if(2!==e.length)throw new O(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let i,r=e[0],s=e[1];return i=Array.isArray(this.axes)?this.axes.map((o,a)=>Xp(o,e[a].shape.length)):[Xp(this.axes,r.shape.length),Xp(this.axes,s.shape.length)],this.normalize&&(r=H_(r,i[0]),s=H_(s,i[1])),function Zhe(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new et("batchDot is not implemented for tensors of 4D or higher rank yet");if(S(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),S(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===n.dtype||"complex64"===t.dtype)throw new et("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,s=t.shape.length;null==e&&(e=[r-1,s-2]);const i=e;return B(()=>{let o,a;if(r>s){o=r-s;const l=[];for(let c=0;c<o;++c)l.push(1);t=F(t,t.shape.concat(l))}else if(s>r){o=s-r;const l=[];for(let c=0;c<o;++c)l.push(1);n=F(n,n.shape.concat(l))}else o=0;if(a=2===n.shape.length&&2===t.shape.length?i[0]===i[1]?Ae(M(n,t),i[0]):Ae(M(vt(n,[1,0]),t),i[1]):pt(n,t,i[0]!==n.shape.length-1,i[1]===t.shape.length-1),o>0){let l;l=r>s?r+s-3:r-1;const c=[];for(let u=l;u<l+o;++u)c.push(u);a=fc(a,c)}return 1===a.shape.length&&(a=hs(a,1)),a})}(r,s,i)}interpretAxes(e,r){let s;return s=Array.isArray(this.axes)?this.axes:[Xp(this.axes,e.length),Xp(this.axes,r.length)],s}computeOutputShape(e){S(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0].slice(),s=e[1].slice();if(r.length>3||s.length>3)throw new et("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(r,s);r.splice(i[0],1),s.splice(i[1],1),s.splice(0,1);const o=r.concat(s);return 1===o.length&&o.push(1),o}computeMask(e,r){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dot",n})()),se((()=>{class n extends mt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return B(()=>{this.invokeCallHook(e,r);const s=Ye(e);return Hp(()=>le($_(s.shape,0,this.stddev),s),()=>s,r.training||!1)})}}return n.className="GaussianNoise",n})()),se((()=>{class n extends mt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return B(()=>{this.invokeCallHook(e,r);const s=Ye(e);return this.rate>0&&this.rate<1?Hp(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return M(s,$_(s.shape,1,o))},()=>s,r.training||!1):s})}}return n.className="GaussianDropout",n})()),se((()=>{class n extends mt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ye(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return B(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return Hp(()=>{const o=Ye(e),c=-1.7580993408473766;let u=al(Np(s),this.rate);u=$o(u,"float32");const d=((1-this.rate)*(1+this.rate*c**2))**-.5,h=-d*c*this.rate,f=le(M(o,u),M(le(u,-1),c));return le(M(f,d),h)},()=>Ye(e),r.training||!1)}return e})}}return n.className="AlphaDropout",n})()),se((()=>{class n extends mt{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis??-1,this.momentum=e.momentum??.99,this.epsilon=e.epsilon??.001,this.center=e.center??!0,this.scale=e.scale??!0,this.betaInitializer=bn(e.betaInitializer||"zeros"),this.gammaInitializer=bn(e.gammaInitializer||"ones"),this.movingMeanInitializer=bn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=bn(e.movingVarianceInitializer||"ones"),this.betaConstraint=lr(e.betaConstraint),this.gammaConstraint=lr(e.gammaConstraint),this.betaRegularizer=_n(e.betaRegularizer),this.gammaRegularizer=_n(e.gammaRegularizer)}build(e){e=Ot(e);const r=this.axis>=0?this.axis:this.axis+e.length,s=e[r];if(null==s)throw new O(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new or({ndim:e.length,axes:{[r]:s}})];const i=[s];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return B(()=>{const s=r.training??!1,i=Ye(e),o=i.shape,a=o.length,l=ao(0,a),c=this.axis>=0?this.axis:this.axis+a;l.splice(c,1);const u=gc(1,a);u[c]=o[c];const d=l.slice();d.sort();const h=!It(d,ao(0,a).slice(0,a-1));if(!s)return(()=>{if(h){const _=F(this.movingMean.read(),u),v=F(this.movingVariance.read(),u),w=this.center?F(this.beta.read(),u):null,C=this.scale?F(this.gamma.read(),u):null;return Yp(i,_,v,w,C,this.epsilon)}return Yp(i,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[p,m,g]=function efe(n,t,e,r,s=.001){return It(r.slice().sort(),ao(0,n.rank-1))?function Qhe(n,t,e,r,s=.001){return B(()=>{const i=p_(n,r),o=i.mean,a=i.variance;return[Yp(n,o,a,e,t,s),o,a]})}(n,t,e,r,s):function Jhe(n,t,e,r,s=.001){return B(()=>{const i=p_(n,r),o=i.mean,a=i.variance,l=[];for(const p of ao(0,n.rank))-1!==r.indexOf(p)?l.push(1):l.push(n.shape[p]);const c=F(o,l),u=F(a,l),d=null==t?null:F(t,l),h=null==e?null:F(e,l);return[Yp(n,c,u,h,d,s),o,a]})}(n,t,e,r,s)}(i,this.gamma.read(),this.beta.read(),l,this.epsilon),y=(_,v,w)=>{B(()=>{const C=1-w,I=_.read(),D=M(De(I,v),C);_.write(De(I,D))})};return(()=>{y(this.movingMean,m,this.momentum),y(this.movingVariance,g,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:In(this.betaInitializer),gammaInitializer:In(this.gammaInitializer),movingMeanInitializer:In(this.movingMeanInitializer),movingVarianceInitializer:In(this.movingVarianceInitializer),betaRegularizer:Zt(this.betaRegularizer),gammaRegularizer:Zt(this.gammaRegularizer),betaConstraint:ar(this.betaConstraint),gammaConstraint:ar(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="BatchNormalization",n})()),se((()=>{class n extends mt{constructor(e){if(null==e&&(e={}),super(e),this.axis=e.axis??-1,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=e.epsilon??.001,this.center=e.center??!0,this.scale=e.scale??!0,this.betaInitializer=bn(e.betaInitializer||"zeros"),this.gammaInitializer=bn(e.gammaInitializer||"ones"),this.betaRegularizer=_n(e.betaRegularizer),this.gammaRegularizer=_n(e.gammaRegularizer),this.supportsMasking=!0}build(e){const r=(e=Ot(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=r);for(const o of this.axis)if(o<0||o>=r)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==cl(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(o=>e[o]);this.gamma=this.scale?this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,r){const s=Ye(e),i=s.shape,o=i.length;return B(()=>{let{mean:l,variance:c}=p_(s,this.axis,!0);const u=gc(1,o);for(const g of this.axis)u[g]=i[g];const d=g=>null!=g&&g.shape.length!==o?F(g,u):g;let h=this.scale?d(this.gamma.read()):null,f=this.center?d(this.beta.read()):null;const p=[],m=[];for(let g=0;g<o;++g)-1!==this.axis.indexOf(g)?(p.push(i[g]),m.push(1)):(p.push(1),m.push(i[g]));return l=Ti(l,p),c=Ti(c,p),null!=h&&(h=Ti(h,m)),null!=f&&(f=Ti(f,m)),Yp(s,l,c,f,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:In(this.betaInitializer),gammaInitializer:In(this.gammaInitializer),betaRegularizer:Zt(this.betaRegularizer),gammaRegularizer:Zt(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LayerNormalization",n})()),se((()=>{class n extends mt{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=e.dataFormat??"channelsLast",null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new O(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,s;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new O(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],2!==e.padding[1].length)throw new O(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[r,s]}this.inputSpec=[new or({ndim:4})]}computeOutputShape(e){let r,s;return e=Ot(e),"channelsFirst"===this.dataFormat?(r=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],r,s]):(r=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],r,s,e[3]])}call(e,r){return B(()=>function tfe(n,t,e){return B(()=>{if(4!==n.rank)throw new O(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new O("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new O(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===e?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],ll(n,r)})}(Ye(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ZeroPadding2D",n})());class Rz extends mt{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new O(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(wr(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new O(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}wr(this.strides,"strides"),this.padding=t.padding??"valid",ii(this.padding),this.inputSpec=[new or({ndim:3})]}computeOutputShape(t){const e=fo((t=Ot(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return B(()=>{this.invokeCallHook(t,e),t=zp(Ye(t),2);const r=this.poolingFunction(Ye(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return fc(r,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}se((()=>{class n extends Rz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return zn(o),ii(i),J_(e,r,s,i,o,"max")}}return n.className="MaxPooling1D",n})()),se((()=>{class n extends Rz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return zn(o),ii(i),J_(e,r,s,i,o,"avg")}}return n.className="AveragePooling1D",n})());class Mz extends mt{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new O(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];wr(this.poolSize,"poolSize"),wr(this.strides,"strides"),this.padding=t.padding??"valid",this.dataFormat=t.dataFormat??"channelsLast",zn(this.dataFormat),ii(this.padding),this.inputSpec=[new or({ndim:4})]}computeOutputShape(t){t=Ot(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2];return e=fo(e,this.poolSize[0],this.padding,this.strides[0]),r=fo(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r]:[t[0],e,r,t[3]]}call(t,e){return B(()=>(this.invokeCallHook(t,e),this.poolingFunction(Ye(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}se((()=>{class n extends Mz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return zn(o),ii(i),J_(e,r,s,i,o,"max")}}return n.className="MaxPooling2D",n})()),se((()=>{class n extends Mz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return zn(o),ii(i),J_(e,r,s,i,o,"avg")}}return n.className="AveragePooling2D",n})());class Fz extends mt{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new O(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];wr(this.poolSize,"poolSize"),wr(this.strides,"strides"),this.padding=t.padding??"valid",this.dataFormat=t.dataFormat??"channelsLast",zn(this.dataFormat),ii(this.padding),this.inputSpec=[new or({ndim:5})]}computeOutputShape(t){t=Ot(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2],s="channelsFirst"===this.dataFormat?t[4]:t[3];return e=fo(e,this.poolSize[0],this.padding,this.strides[0]),r=fo(r,this.poolSize[1],this.padding,this.strides[1]),s=fo(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r,s]:[t[0],e,r,s,t[4]]}call(t,e){return B(()=>(this.invokeCallHook(t,e),this.poolingFunction(Ye(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}se((()=>{class n extends Fz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return zn(o),ii(i),Az(e,r,s,i,o,"max")}}return n.className="MaxPooling3D",n})()),se((()=>{class n extends Fz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return zn(o),ii(i),Az(e,r,s,i,o,"avg")}}return n.className="AveragePooling3D",n})());class Oz extends mt{constructor(t){super(t),this.inputSpec=[new or({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new et}}se((()=>{class n extends Oz{constructor(e){super(e||{})}call(e,r){return B(()=>{const s=Ye(e);return Mn(s,1)})}}return n.className="GlobalAveragePooling1D",n})()),se((()=>{class n extends Oz{constructor(e){super(e||{})}call(e,r){return B(()=>{const s=Ye(e);return Di(s,1)})}}return n.className="GlobalMaxPooling1D",n})());class $z extends mt{constructor(t){super(t),this.dataFormat=t.dataFormat??"channelsLast",zn(this.dataFormat),this.inputSpec=[new or({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new et}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}se((()=>{class n extends $z{call(e,r){return B(()=>{const s=Ye(e);return Mn(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalAveragePooling2D",n})()),se((()=>{class n extends $z{call(e,r){return B(()=>{const s=Ye(e);return Di(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalMaxPooling2D",n})());class Pz extends mt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,r={}){const i=xa(e.layer,r);delete e.layer;const o={layer:i};return Object.assign(o,e),new t(o)}}se((()=>{class n extends Pz{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Ot(e)).length<3)throw new O(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){const r=[(e=Ot(e))[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(r);return[s[0],e[1]].concat(s.slice(1))}call(e,r){return B(()=>Ez((a,l)=>[Ye(this.layer.call(a,r)),[]],e=Ye(e),[],!1,null,null,!1,!0)[1])}}return n.className="TimeDistributed",n})()),se((()=>{class n extends Pz{constructor(e){super(e);const r=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=r,this.forwardLayer=xa(s),r.goBackwards=!0!==r.goBackwards;const i={};if(i.className=e.layer.getClassName(),i.config=r,this.backwardLayer=xa(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function nfe(n){bc(Ede,"BidirectionalMergeMode",n)}(this.mergeMode),e.weights)throw new et("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const s=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let s,i,o,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState&&(o=r.slice(1)),s=r[0],"concat"===this.mergeMode?(s[s.length-1]*=2,i=[s]):i=null==this.mergeMode?[s,s.slice()]:[s],this.returnState?null==this.mergeMode?i.concat(o).concat(o.slice()):[s].concat(o).concat(o.slice()):ps(i)}apply(e,r){let s=null==r?null:r.initialState,i=null==r?null:r.constants;null==r&&(r={});const o=Sz(e,s,i,this.numConstants);if(e=o.inputs,s=o.initialState,i=o.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(null==s||0===s.length)&&null==i)return super.apply(e,r);const a=[],l=[];if(null!=s){const u=s.length;if(u%2>0)throw new O("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=s,a.push(...s);const d=s.map(h=>new or({shape:h.shape}));this.forwardLayer.stateSpec=d.slice(0,u/2),this.backwardLayer.stateSpec=d.slice(u/2),l.push(...d)}if(null!=i)throw new et("Support for constants in Bidirectional layers is not implemented yet.");const c=a[0]instanceof Vo;for(const u of a)if(u instanceof Vo!==c)throw new O("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const u=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(u,r);return this.inputSpec=h,f}return super.apply(e,r)}call(e,r){return B(()=>{const s=r.initialState;let i,o,a,l;if(null==s)i=this.forwardLayer.call(e,r),o=this.backwardLayer.call(e,r);else{const c=s.slice(0,s.length/2),u=s.slice(s.length/2);i=this.forwardLayer.call(e,Object.assign(r,{initialState:c})),o=this.backwardLayer.call(e,Object.assign(r,{initialState:u}))}return this.returnState&&(Array.isArray(i)&&(a=i.slice(1).concat(o.slice(1))),i=i[0],o=o[0]),this.returnSequences&&(o=ki(o,1)),"concat"===this.mergeMode?l=qD([i,o]):"sum"===this.mergeMode?l=le(i,o):"ave"===this.mergeMode?l=M(.5,le(i,o)):"mul"===this.mergeMode?l=M(i,o):null==this.mergeMode&&(l=[i,o]),this.returnState?null==this.mergeMode?l.concat(a):[l].concat(a):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){_c(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),_c(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){let s;if(Array.isArray(r)&&(r=r[0]),s=this.returnSequences?null==this.mergeMode?[r,r]:r:null==this.mergeMode?[null,null]:null,this.returnState){const o=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(o).concat(o):[s].concat(o).concat(o)}return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){const s=xa(r.layer);if(delete r.layer,null!=r.numConstants)throw new et("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=r;return i.layer=s,new e(i)}}return n.className="Bidirectional",n})()),se((()=>{class n extends mt{constructor(e){super(e),this.scale=e.scale,this.offset=e.offset?e.offset:0}getConfig(){const e={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return B(()=>("float32"!==(e=Ye(e)).dtype&&(e=$o(e,"float32")),le(M(e,this.scale),this.offset)))}}return n.className="Rescaling",n})());const{resizeBilinear:sfe,cropAndResize:ife}=ba;se((()=>{class n extends mt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,r,s,i,o,a,l,c){return B(()=>{let u,d=!1;const g=[r/a,s/l,(i+r)/a,(o+s)/l],y=[];3===e.rank?(d=!0,u=ri([e])):u=e;for(let C=0;C<u.shape[0];C++)y.push(g);const b=so(y,[y.length,4]),_=fd(0,y.length,1,"int32"),w=ife(u,b,_,[i,o],"nearest");return $o(d?Ye(Ni(w)):w,c)})}upsize(e,r,s,i){return B(()=>$o(sfe(e,[r,s]),i))}call(e,r){return B(()=>{const s=Ye(e),i=s.dtype,o=s.shape,a=o[o.length-3],l=o[o.length-2];let c=0;a!==this.height&&(c=Math.floor((a-this.height)/2));let u=0;return l!==this.width&&(u=Math.floor((l-this.width)/2),0===u&&(u=1)),c>=0&&u>=0?this.centerCrop(s,c,u,this.height,this.width,a,l,i):this.upsize(e,this.height,this.width,i)})}getConfig(){const e={height:this.height,width:this.width},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){const s=(e=Ot(e)).length-2;return e[e.length-3]=this.height,e[s]=this.width,e}}return n.className="CenterCrop",n})()),se((()=>{class n extends mt{constructor(e){super(e),this.numTokens=e.numTokens,this.outputMode=e.outputMode?e.outputMode:"multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return null==(e=Ot(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,r){return B(()=>{let s;if("int32"!==(e=Ye(e)).dtype&&(e=$o(e,"int32")),typeof r.countWeights<"u"){if("count"!==this.outputMode)throw new O(`countWeights is not used when outputMode !== count.\n              Received countWeights=${r.countWeights}`);s=Ye(r.countWeights)}const i=Di(e),o=Ep(e),a=ks(this.numTokens,i).bufferSync().get(0),l=al(o,0).bufferSync().get(0);if(!a||!l)throw new O(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function ofe(n,t,e,r){let s=Ye(n);if("int32"!==s.dtype&&(s=$o(s,"int32")),"int"===t)return s;const i=s.shape;if(0===s.rank&&(s=hs(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=hs(s,-1)),s.rank>2)throw new O(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${s.rank}.`);const o=["multiHot","oneHot"].includes(t);let l;if(l=TI(s,typeof r<"u"&&"count"===t?r:[],e,o),"tfIdf"!==t)return l;if(r)return M(l,r);throw new O("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,s)})}}return n.className="CategoryEncoding",n})());const Lz=new Set(["bilinear","nearest"]);se((()=>{class n extends mt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!Lz.has(e.interpolation))throw new O(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){return e=Ot(e),[this.height,this.width,e[2]]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return B(()=>{const s=[this.height,this.width];if("bilinear"===this.interpolation)return ba.resizeBilinear(e,s,!this.cropToAspectRatio);if("nearest"===this.interpolation)return ba.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...Lz]} are supported`)})}}return n.className="Resizing",n})()),j().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Hz,ai=(()=>{return(n=ai||(ai={}))[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF",ai;var n})();!function(n){let t;var e;(e=t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(Hz||(Hz={}));const NT={};function Wz(n){return NT[n]}function x(n,t,e,r,s){const i=t.inputParams[n];if(i&&void 0!==i.inputIndexStart){const a=i.inputIndexStart,l=0===i.inputIndexEnd?void 0:void 0===i.inputIndexEnd?a+1:i.inputIndexEnd;if("tensor"===i.type)return Yr(t.inputNames[i.inputIndexStart],e,r,s);if("tensors"===i.type)return t.inputNames.slice(a,l).map(h=>Yr(h,e,r,s));const c=Yr(t.inputNames.slice(a)[0],e,r,s),u=c.dataSync();return"number"===i.type?u[0]:Si(c.shape,u)}const o=t.attrParams[n];return o&&o.value}function Yr(n,t,e,r){const[s,i]=As(n);if(null!=r){const a=r.getHashTableHandleByName(s);if(null!=a)return a}const o=e.currentContextIds.find(a=>!!t[tv(s,a)]);return void 0!==o?t[tv(s,o)][i]:void 0}function wa(n,t){const[e,r,s]=As(n);return[tv(e,t&&t.currentContextId),r,s]}function tv(n,t){return t?`${n}-${t}`:n}function As(n){const t=n.split(":");if(1===t.length)return[n,0,void 0];const r=3===t.length?t[1]:void 0;return[t[0],Number(t[t.length-1]),r]}function nv(n,t,e){let r=x("pad",n,t,e);if("explicit"===r){r=x("explicitPaddings",n,t,e);const s=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)s[i][0]=r[2*i],s[i][1]=r[2*i+1];return s}return r}function Ca(n){return n.kept?n:ha(n)}const hfe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ffe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],pfe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],mfe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],gfe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],yfe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],bfe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],_fe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],vfe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],xfe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],wfe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Cfe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],Sfe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],Efe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Ife=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],Dfe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Tfe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],kfe=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Nfe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class jz{constructor(){const e=[].concat(...[Be,rt,Ie,U,pe,be,re,fe,Ne,Fe,Lt,Qn,Hn,hi,Os,wt,At,Rt,ce].map(r=>r.json));this.opMappers=e.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}static get Instance(){return this._instance||(this._instance=new this)}transformGraph(t,e={}){const s=[],i=[],o=[],a=t.node.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?s.push(m[g.name]):"Const"===g.op?i.push(m[g.name]):(null==g.input||0===g.input.length)&&o.push(m[g.name]),m),{});let l=[];const c=[];let u={},d={};null!=e&&(u=this.mapSignatureEntries(e.inputs),d=this.mapSignatureEntries(e.outputs));const h=Object.keys(a);h.forEach(m=>{const g=a[m];g.inputNames.forEach((y,b)=>{const[_,,v]=wa(y),w=a[_];if(null!=w.outputs){const C=w.outputs.indexOf(v);-1!==C&&(g.inputNames[b]=`${_}:${C}`)}g.inputs.push(w),w.children.push(g)})}),0===Object.keys(d).length?h.forEach(m=>{const g=a[m];0===g.children.length&&c.push(g)}):Object.keys(d).forEach(m=>{const[g]=wa(m),y=a[g];null!=y&&(y.signatureKey=d[m],c.push(y))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{const[g]=wa(m),y=a[g];y&&(y.signatureKey=u[m],l.push(y))}):l=s;let f={};null!=t.library&&null!=t.library.function&&(f=t.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const p={nodes:a,inputs:l,outputs:c,weights:i,placeholders:s,signature:e,functions:f};return o.length>0&&(p.initNodes=o),p}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,r)=>(e[t[r].name]=r,e),{})}mapNode(t){const e=Wz(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const r={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return null!=e.inputs&&(r.inputParams=e.inputs.reduce((s,i)=>(s[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},s),{})),null!=e.attrs&&(r.attrParams=e.attrs.reduce((s,i)=>{const o=i.type;let a;switch(i.type){case"string":a=AT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=AT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":a=VT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=VT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":a=MT(t.attr,i.tfName,i.defaultValue||0),void 0===a&&i.tfDeprecatedName&&(a=MT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":a=LT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=LT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":a=RT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=RT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":a=zT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=zT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":a=PT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=PT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":a=BT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=BT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":a=OT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=OT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":a=$T(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=$T(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":a=qz(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=qz(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${t.op}`)}return s[i.name]={value:a,type:o},s},{})),r}mapFunction(t){const e=t.nodeDef,s=[];let i={};null!=e&&(i=e.reduce((d,h)=>(d[h.name]=this.mapNode(h),"Const"===h.op&&s.push(d[h.name]),d),{}));const o=[],a=[];t.signature.inputArg.forEach(d=>{const[h]=wa(d.name),f={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:FT(d.type),type:"dtype"}},children:[]};f.signatureKey=d.name,o.push(f),i[h]=f}),Object.keys(i).forEach(d=>{const h=i[d];h.inputNames.forEach((f,p)=>{const[m,,g]=wa(f),y=i[m];if(null!=y.outputs){const b=y.outputs.indexOf(g);-1!==b&&(h.inputNames[p]=`${m}:${b}`)}h.inputs.push(y),y.children.push(h)})});const c=t.ret;t.signature.outputArg.forEach(d=>{const[h,f]=wa(c[d.name]),p=i[h];null!=p&&(p.defaultOutput=f,a.push(p))});const u=this.mapArgsToSignature(t);return{nodes:i,inputs:o,outputs:a,weights:s,placeholders:[],signature:u}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r),e),{}),outputs:t.signature.outputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r,t.ret),e),{})}}mapArgToTensorInfo(t,e){let r=t.name;return null!=e&&(r=e[r]),{name:r,dtype:t.type}}}function Gz(n,t){const e=Array.isArray(n)?String.fromCharCode.apply(null,n):function Afe(n){const t=j().global;if(typeof t.atob<"u")return t.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(n);return t?e:e.toLowerCase()}function AT(n,t,e,r=!1){const s=n[t];return null!=s?Gz(s.s,r):e}function RT(n,t,e){const r=n[t];return r?r.b:e}function MT(n,t,e){const r=n[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:e;return"number"==typeof s?s:parseInt(s,10)}function FT(n){switch("string"==typeof n&&(n=ai[n]),n){case ai.DT_FLOAT:case ai.DT_HALF:return"float32";case ai.DT_INT32:case ai.DT_INT64:case ai.DT_INT8:case ai.DT_UINT8:return"int32";case ai.DT_BOOL:return"bool";case ai.DT_DOUBLE:return"float32";case ai.DT_STRING:return"string";default:return null}}function qz(n,t,e){const r=n[t];return r&&r.func?r.func.name:e}function OT(n,t,e){const r=n[t];return r&&r.type?FT(r.type):e}function $T(n,t,e){const r=n[t];return r&&r.list&&r.list.type?r.list.type.map(s=>FT(s)):e}function Kz(n){if(!n.unknownRank)return null!=n.dim?n.dim.map(t=>"number"==typeof t.size?t.size:parseInt(t.size,10)):[]}function PT(n,t,e){const r=n[t];return r&&r.shape?Kz(r.shape):e}function LT(n,t,e){const r=n[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>"number"==typeof s?s:parseInt(s,10)):e}function VT(n,t,e,r=!1){const s=n[t];return s&&s.list&&s.list.s?s.list.s.map(i=>Gz(i,r)):e}function BT(n,t,e){const r=n[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>Kz(s)):e}function zT(n,t,e){const r=n[t];return r&&r.list&&r.list.b?r.list.b:e}class Rfe{constructor(t,e,r){this.node=t,this.tensorMap=e,this.context=r,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(s=>this.getInput(s)),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce((s,i)=>(s[i]=this.getAttr(i),s),{}))}getInput(t){return Yr(t,this.tensorMap,this.context)}getAttr(t,e){const r=this.node.rawAttrs[t];if(null!=r.tensor)return Yr(t,this.tensorMap,this.context);if(null!=r.i||null!=r.f)return MT(this.node.rawAttrs,t,e);if(null!=r.s)return AT(this.node.rawAttrs,t,e);if(null!=r.b)return RT(this.node.rawAttrs,t,e);if(null!=r.shape)return PT(this.node.rawAttrs,t,e);if(null!=r.type)return OT(this.node.rawAttrs,t,e);if(null!=r.list){if(null!=r.list.i||null!=r.list.f)return LT(this.node.rawAttrs,t,e);if(null!=r.list.s)return VT(this.node.rawAttrs,t,e);if(null!=r.list.shape)return BT(this.node.rawAttrs,t,e);if(null!=r.list.b)return zT(this.node.rawAttrs,t,e);if(null!=r.list.type)return $T(this.node.rawAttrs,t,e)}return e}}function Oi(n,t,e=""){if("number"!=typeof n&&"number"!=typeof t){S(n.length===t.length,()=>e+` Shapes ${n} and ${t} must match`);for(let r=0;r<n.length;r++){const s=n[r],i=t[r];S(s<0||i<0||s===i,()=>e+` Shapes ${n} and ${t} must match`)}}}function Xz(n){return!("number"==typeof n||n.some(t=>t<0))}function Zp(n,t,e){let r=UT(n,e);const s=!Xz(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(i=>{r=UT(i.shape,r)}),!Xz(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function UT(n,t){if("number"==typeof n)return t;if("number"==typeof t)return n;if(n.length!==t.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${t}`);const e=[];for(let r=0;r<n.length;++r){const s=n[r],i=t[r];if(s>=0&&i>=0&&s!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${t}`);e[r]=s>=0?s:i}return e}class Ofe{constructor(t,e,r,s,i,o,a){this.name=t,this.dtype=e,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Le(0),_r(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=e.shape),Oi(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);r.tensor=e,_r(e),r.written=!0,this.tensors[t]=r}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((r,s)=>this.write(r,e[s]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let s=0;s<this.size();s++)t.push(s)}if(0===t.length)return so([],[0].concat(this.elementShape));const r=this.readMany(t);return Oi(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),ri(r,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return so([],[0].concat(this.elementShape));const e=[];for(let s=0;s<this.size();s++)e.push(s);const r=this.readMany(e);return Oi(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Xn(r,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const r=Math.max(...t);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(t,Ni(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let r=0;const s=t.map(l=>(r+=l,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const i=0===r?0:e.size/r,o=[];B(()=>{e=F(e,[1,r,i]);for(let l=0;l<t.length;++l)o[l]=F(Dt(e,[0,0===l?0:s[l-1],0],[1,t[l],i]),this.elementShape);return o});const a=[];for(let l=0;l<t.length;l++)a[l]=l;this.writeMany(a,o)}}class wc{constructor(t,e,r,s=-1){this.tensors=t,this.elementShape=e,this.elementDtype=r,t?.forEach(i=>{if(r!==i.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${i.dtype}`);Oi(e,i.shape,"TensorList shape mismatch: "),_r(i)}),this.idTensor=Le(0),this.maxNumElements=s,_r(this.idTensor)}get id(){return this.idTensor.id}copy(){return new wc([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,r=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==r&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Oi(t,this.elementShape,"TensorList shape mismatch: ");const s=Zp(this.elementShape,this.tensors,t);return B(()=>{const i=this.tensors.map(o=>F(o,s));return ri(i,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const r=Zp(this.elementShape,this.tensors,t),s=this.tensors.pop();return s.kept=!1,Oi(s.shape,t,"TensorList shape mismatch: "),F(s,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Oi(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");_r(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new wc([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)e.tensors[r]=this.tensors[r];return e}getItem(t,e,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);Oi(this.tensors[t].shape,e,"TensorList shape mismatch: ");const s=Zp(this.elementShape,this.tensors,e);return F(this.tensors[t],s)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Oi(this.elementShape,e.shape,"TensorList shape mismatch: "),_r(e),null!=this.tensors[t]&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,r){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);Oi(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());const s=Zp(this.elementShape,this.tensors,r);return 0===t.length?so([],[0].concat(s)):B(()=>{const i=t.map(o=>F(this.tensors[o],s));return ri(i,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Oi(this.elementShape,e,"TensorList shape mismatch: ");const r=Zp(this.elementShape,this.tensors,e);return 0===this.size()?so([],[0].concat(r)):B(()=>{const s=this.tensors.map(i=>F(i,r));return Xn(s,0)})}}const Bfe=function(){var n=ee(function*(t,e,r){switch(t.op){case"If":case"StatelessIf":{const s=x("thenBranch",t,e,r),i=x("elseBranch",t,e,r),o=x("cond",t,e,r),a=x("args",t,e,r);return(yield o.data())[0]?r.functionMap[s].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap):r.functionMap[i].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap)}case"While":case"StatelessWhile":{const s=x("body",t,e,r),i=x("cond",t,e,r),o=x("args",t,e,r),a=yield r.functionMap[i].executeFunctionAsync(o,r.tensorArrayMap,r.tensorListMap),l=o.map(d=>d.id);let c=yield a[0].data();a.forEach(d=>{!d.kept&&-1===l.indexOf(d.id)&&d.dispose()});let u=o;for(;c[0];){const d=u;u=yield r.functionMap[s].executeFunctionAsync(u,r.tensorArrayMap,r.tensorListMap);const h=u.map(p=>p.id);d.forEach(p=>{!p.kept&&-1===l.indexOf(p.id)&&-1===h.indexOf(p.id)&&p.dispose()});const f=yield r.functionMap[i].executeFunctionAsync(u,r.tensorArrayMap,r.tensorListMap);c=yield f[0].data(),f.forEach(p=>{!p.kept&&-1===l.indexOf(p.id)&&-1===h.indexOf(p.id)&&p.dispose()})}return u}case"LoopCond":return[Ca(x("pred",t,e,r))];case"Switch":{const s=x("pred",t,e,r);let i=x("data",t,e,r);return i.kept||(i=Ca(i)),(yield s.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const s=t.inputNames.find(i=>void 0!==Yr(i,e,r));return s?[Ca(Yr(s,e,r))]:void 0}case"Enter":{const s=x("frameName",t,e,r),i=x("tensor",t,e,r);return r.enterFrame(s),[Ca(i)]}case"Exit":{const s=x("tensor",t,e,r);return r.exitFrame(),[Ca(s)]}case"NextIteration":{const s=x("tensor",t,e,r);return r.nextIteration(),[Ca(s)]}case"TensorArrayV3":{const s=x("size",t,e,r),i=x("dtype",t,e,r),o=x("elementShape",t,e,r),a=x("dynamicSize",t,e,r),l=x("clearAfterRead",t,e,r),c=x("identicalElementShapes",t,e,r),u=x("name",t,e,r),d=new Ofe(u,i,s,o,c,a,l);return r.addTensorArray(d),[d.idTensor,Le(1)]}case"TensorArrayWriteV3":{const s=x("tensorArrayId",t,e,r),i=x("index",t,e,r),o=x("tensor",t,e,r),a=r.getTensorArray(s.id);return a.write(i,o),[a.idTensor]}case"TensorArrayReadV3":{const s=x("tensorArrayId",t,e,r),i=x("index",t,e,r);return[r.getTensorArray(s.id).read(i)]}case"TensorArrayGatherV3":{const s=x("tensorArrayId",t,e,r),i=x("indices",t,e,r),o=x("dtype",t,e,r);return[r.getTensorArray(s.id).gather(i,o)]}case"TensorArrayScatterV3":{const s=x("tensorArrayId",t,e,r),i=x("indices",t,e,r),o=x("tensor",t,e,r),a=r.getTensorArray(s.id);return a.scatter(i,o),[a.idTensor]}case"TensorArrayConcatV3":{const s=x("tensorArrayId",t,e,r),i=r.getTensorArray(s.id),o=x("dtype",t,e,r);return[i.concat(o)]}case"TensorArraySplitV3":{const s=x("tensorArrayId",t,e,r),i=x("tensor",t,e,r),o=x("lengths",t,e,r),a=r.getTensorArray(s.id);return a.split(o,i),[a.idTensor]}case"TensorArraySizeV3":{const s=x("tensorArrayId",t,e,r);return[Le(r.getTensorArray(s.id).size(),"int32")]}case"TensorArrayCloseV3":{const s=x("tensorArrayId",t,e,r),i=r.getTensorArray(s.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const s=x("tensorListId",t,e,r),i=x("index",t,e,r),o=x("tensor",t,e,r),a=r.getTensorList(s.id);return a.setItem(i,o),[a.idTensor]}case"TensorListGetItem":{const s=x("tensorListId",t,e,r),i=x("index",t,e,r),o=x("elementShape",t,e,r),a=x("elementDType",t,e,r);return[r.getTensorList(s.id).getItem(i,o,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=x("indices",t,e,r),l=function Lfe(n,t,e,r){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const i=new wc([],e,n.dtype,r),o=Ni(n,0);return t.forEach((a,l)=>{i.setItem(a,o[l])}),i}(x("tensor",t,e,r),s,x("elementShape",t,e,r),x("numElements",t,e,r));return r.addTensorList(l),[l.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=x("elementShape",t,e,r),i=x("elementDType",t,e,r);let o;o="TensorListReserve"===t.op?"numElements":"maxNumElements";const a=x(o,t,e,r),c=function Pfe(n,t,e,r){return new wc([],n,t,r)}(s,i,0,"TensorListReserve"===t.op?-1:a);return r.addTensorList(c),[c.idTensor]}case"TensorListGather":{const s=x("tensorListId",t,e,r),i=x("indices",t,e,r),o=x("elementShape",t,e,r),a=x("elementDType",t,e,r);return[r.getTensorList(s.id).gather(i,a,o)]}case"TensorListStack":{const s=x("tensorListId",t,e,r),i=x("elementShape",t,e,r),o=x("elementDType",t,e,r),a=x("numElements",t,e,r);return[r.getTensorList(s.id).stack(i,o,a)]}case"TensorListFromTensor":{const a=function $fe(n,t,e){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);Oi(n.shape.slice(1),t,"TensorList shape mismatch: ");const i=Ni(n);return new wc(i,t,r)}(x("tensor",t,e,r),x("elementShape",t,e,r),x("elementDType",t,e,r));return r.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=x("tensorListId",t,e,r),i=r.getTensorList(s.id),o=x("dtype",t,e,r),a=x("elementShape",t,e,r);return[i.concat(o,a)]}case"TensorListPushBack":{const s=x("tensorListId",t,e,r),i=x("tensor",t,e,r),o=r.getTensorList(s.id);return o.pushBack(i),[o.idTensor]}case"TensorListPopBack":{const s=x("tensorListId",t,e,r),i=x("elementShape",t,e,r),o=x("elementDType",t,e,r);return[r.getTensorList(s.id).popBack(i,o)]}case"TensorListSplit":{const s=x("tensor",t,e,r),i=x("elementShape",t,e,r),a=function Vfe(n,t,e){let r=0;const s=t.map(u=>(r+=u,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${n.shape}`);const o=UT(n.shape.slice(1),e),a=0===r?0:n.size/r,l=B(()=>{const u=[];n=F(n,[1,r,a]);for(let d=0;d<t.length;++d)u[d]=F(Dt(n,[0,0===d?0:s[d-1],0],[1,t[d],a]),o);return n.dispose(),u}),c=new wc([],e,n.dtype,t.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}(s,x("lengths",t,e,r),i);return r.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=x("tensorListId",t,e,r);return[Le(r.getTensorList(s.id).size(),"int32")]}case"TensorListResize":{const s=x("tensorListId",t,e,r),i=x("size",t,e,r),a=r.getTensorList(s.id).resize(i);return r.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s){return n.apply(this,arguments)}}();function Yz(n,t,e){const[r,s]=x("fusedOps",n,t,e),i="biasadd"===r,o=!i,a="prelu"===s,l="fusedbatchnorm"===r,c=x("numArgs",n,t,e);if(i){if(a&&2!==c)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i&&1!==c)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=x("strides",n,t,e),d=nv(n,t,e),h=x("dataFormat",n,t,e).toUpperCase(),f=x("dilations",n,t,e);let[p,m]=x("args",n,t,e);return o&&(m=p,p=void 0),{stride:u,pad:d,dataFormat:h,dilations:f,biasArg:p,preluArg:m,activationFunc:s,leakyreluAlpha:x("leakyreluAlpha",n,t,e)}}function HT(n,t,e){return{boxes:x("boxes",n,t,e),scores:x("scores",n,t,e),maxOutputSize:x("maxOutputSize",n,t,e),iouThreshold:x("iouThreshold",n,t,e),scoreThreshold:x("scoreThreshold",n,t,e),softNmsSigma:x("softNmsSigma",n,t,e)}}const Hfe=function(){var n=ee(function*(t,e,r,s,i=Q){switch(t.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:a,maxOutputSize:l,iouThreshold:c,scoreThreshold:u,softNmsSigma:d}=HT(t,e,r),h=yield i.image.nonMaxSuppressionWithScoreAsync(o,a,l,c,u,d);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:a,maxOutputSize:l,iouThreshold:c,scoreThreshold:u}=HT(t,e,r),d=x("padToMaxOutputSize",t,e,r),h=yield i.image.nonMaxSuppressionPaddedAsync(o,a,l,c,u,d);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:a,maxOutputSize:l,iouThreshold:c,scoreThreshold:u}=HT(t,e,r);return[yield i.image.nonMaxSuppressionAsync(o,a,l,c,u)]}case"Where":{const o=i.cast(x("condition",t,e,r),"bool"),a=[yield i.whereAsync(o)];return o.dispose(),a}case"ListDiff":return i.setdiff1dAsync(x("x",t,e,r),x("y",t,e,r));default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s,i){return n.apply(this,arguments)}}();class Gfe{constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=Le(0),this.tensorMap=new Map,_r(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Le(this.size(),"int32")}import(t,e){var r=this;return ee(function*(){r.checkKeyAndValueTensor(t,e);const s=yield t.data();return r.tensorMap.forEach(i=>i.dispose()),r.tensorMap.clear(),B(()=>{const i=Ni(e),o=s.length,a=i.length;S(o===a,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${a} elements.`);for(let l=0;l<o;l++){const c=s[l],u=i[l];_r(u),r.tensorMap.set(c,u)}return r.handle})})()}find(t,e){var r=this;return ee(function*(){r.checkKeyAndValueTensor(t,e);const s=yield t.data();return B(()=>{const i=[];for(let o=0;o<s.length;o++){const l=r.findWithDefault(s[o],e);i.push(l)}return ri(i)})})()}findWithDefault(t,e){return this.tensorMap.get(t)??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}const qfe=function(){var n=ee(function*(t,e,r,s){switch(t.op){case"HashTable":case"HashTableV2":{const i=s.getHashTableHandleByName(t.name);if(null!=i)return[i];{const o=x("keyDType",t,e,r),a=x("valueDType",t,e,r),l=new Gfe(o,a);return s.addHashTable(t.name,l),[l.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const i=x("tableHandle",t,e,r,s),o=x("keys",t,e,r),a=x("values",t,e,r);return[yield s.getHashTableById(i.id).import(o,a)]}case"LookupTableFind":case"LookupTableFindV2":{const i=x("tableHandle",t,e,r,s),o=x("keys",t,e,r),a=x("defaultValue",t,e,r);return[yield s.getHashTableById(i.id).find(o,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=x("tableHandle",t,e,r,s);return[s.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s,i){return n.apply(this,arguments)}}();function Zz(n,t,e,r,s=B){const i=((o,a,l)=>{switch(o.category){case"arithmetic":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(x("a",n,t,e),x("b",n,t,e))];case"AddN":return[r.addN(x("tensors",n,t,e))];case"FloorMod":case"Mod":return[r.mod(x("a",n,t,e),x("b",n,t,e))];case"Mul":return[r.mul(x("a",n,t,e),x("b",n,t,e))];case"RealDiv":case"Div":return[r.div(x("a",n,t,e),x("b",n,t,e))];case"DivNoNan":return[r.divNoNan(x("a",n,t,e),x("b",n,t,e))];case"FloorDiv":return[r.floorDiv(x("a",n,t,e),x("b",n,t,e))];case"Sub":return[r.sub(x("a",n,t,e),x("b",n,t,e))];case"Minimum":return[r.minimum(x("a",n,t,e),x("b",n,t,e))];case"Maximum":return[r.maximum(x("a",n,t,e),x("b",n,t,e))];case"Pow":return[r.pow(x("a",n,t,e),x("b",n,t,e))];case"SquaredDifference":return[r.squaredDifference(x("a",n,t,e),x("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"basic_math":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(x("x",n,t,e))];case"Acos":return[r.acos(x("x",n,t,e))];case"Acosh":return[r.acosh(x("x",n,t,e))];case"Asin":return[r.asin(x("x",n,t,e))];case"Asinh":return[r.asinh(x("x",n,t,e))];case"Atan":return[r.atan(x("x",n,t,e))];case"Atan2":return[r.atan2(x("x",n,t,e),x("y",n,t,e))];case"Atanh":return[r.atanh(x("x",n,t,e))];case"Ceil":return[r.ceil(x("x",n,t,e))];case"Complex":return[r.complex(x("real",n,t,e),x("imag",n,t,e))];case"Cos":return[r.cos(x("x",n,t,e))];case"Cosh":return[r.cosh(x("x",n,t,e))];case"Elu":return[r.elu(x("x",n,t,e))];case"Erf":return[r.erf(x("x",n,t,e))];case"Exp":return[r.exp(x("x",n,t,e))];case"Expm1":return[r.expm1(x("x",n,t,e))];case"Floor":return[r.floor(x("x",n,t,e))];case"Log":return[r.log(x("x",n,t,e))];case"Log1p":return[r.log1p(x("x",n,t,e))];case"Imag":return[r.imag(x("x",n,t,e))];case"Neg":return[r.neg(x("x",n,t,e))];case"Reciprocal":return[r.reciprocal(x("x",n,t,e))];case"Real":return[r.real(x("x",n,t,e))];case"Relu":return[r.relu(x("x",n,t,e))];case"Round":return[r.round(x("x",n,t,e))];case"Selu":return[r.selu(x("x",n,t,e))];case"Sigmoid":return[r.sigmoid(x("x",n,t,e))];case"Sin":return[r.sin(x("x",n,t,e))];case"Sign":return[r.sign(x("x",n,t,e))];case"Sinh":return[r.sinh(x("x",n,t,e))];case"Softplus":return[r.softplus(x("x",n,t,e))];case"Sqrt":return[r.sqrt(x("x",n,t,e))];case"Square":return[r.square(x("x",n,t,e))];case"Tanh":return[r.tanh(x("x",n,t,e))];case"Tan":return[r.tan(x("x",n,t,e))];case"ClipByValue":return[r.clipByValue(x("x",n,t,e),x("clipValueMin",n,t,e),x("clipValueMax",n,t,e))];case"Relu6":return[r.relu6(x("x",n,t,e))];case"Rsqrt":return[r.rsqrt(Yr(n.inputNames[0],t,e))];case"Prod":return[r.prod(x("x",n,t,e),x("axes",n,t,e))];case"LeakyRelu":return[r.leakyRelu(x("x",n,t,e),x("alpha",n,t,e))];case"Prelu":return[r.prelu(x("x",n,t,e),x("alpha",n,t,e))];case"IsNan":return[r.isNaN(Yr(n.inputNames[0],t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"control":return Bfe(o,a,l);case"convolution":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"Conv1D":{const s=x("stride",n,t,e),i=x("pad",n,t,e),o=x("dataFormat",n,t,e).toUpperCase(),a=x("dilation",n,t,e);return[r.conv1d(x("x",n,t,e),x("filter",n,t,e),s,i,o,a)]}case"Conv2D":{const s=x("strides",n,t,e),i=nv(n,t,e),o=x("dataFormat",n,t,e).toUpperCase(),a=x("dilations",n,t,e);return[r.conv2d(x("x",n,t,e),x("filter",n,t,e),[s[1],s[2]],i,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:d}=Yz(n,t,e);return[r.fused.conv2d({x:x("x",n,t,e),filter:x("filter",n,t,e),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:d}=Yz(n,t,e);return[r.fused.depthwiseConv2d({x:x("x",n,t,e),filter:x("filter",n,t,e),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=x("outputShape",n,t,e),i=x("strides",n,t,e),o=nv(n,t,e);return[r.conv2dTranspose(x("x",n,t,e),x("filter",n,t,e),s,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=x("strides",n,t,e),i=nv(n,t,e),o=x("dilations",n,t,e),a=x("dataFormat",n,t,e).toUpperCase();return[r.depthwiseConv2d(x("input",n,t,e),x("filter",n,t,e),[s[1],s[2]],i,a,[o[1],o[2]])]}case"Conv3D":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("dataFormat",n,t,e).toUpperCase(),a=x("dilations",n,t,e);return[r.conv3d(x("x",n,t,e),x("filter",n,t,e),[s[1],s[2],s[3]],i,o,[a[1],a[2],a[3]])]}case"AvgPool":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("kernelSize",n,t,e);return[r.avgPool(x("x",n,t,e),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPool":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("kernelSize",n,t,e);return[r.maxPool(x("x",n,t,e),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPoolWithArgmax":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("kernelSize",n,t,e),a=x("includeBatchInIndex",n,t,e),{result:l,indexes:c}=r.maxPoolWithArgmax(x("x",n,t,e),[o[1],o[2]],[s[1],s[2]],i,a);return[l,c]}case"AvgPool3D":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("kernelSize",n,t,e);return[r.avgPool3d(x("x",n,t,e),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"MaxPool3D":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("kernelSize",n,t,e);return[r.maxPool3d(x("x",n,t,e),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"Dilation2D":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("dilations",n,t,e),a=s[1],l=s[2],c=o[1],u=o[2];return[r.dilation2d(x("x",n,t,e),x("filter",n,t,e),[a,l],i,[c,u],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"creation":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"Fill":{const s=x("shape",n,t,e),i=x("dtype",n,t,e),o=x("value",n,t,e);return[r.fill(s,o,i)]}case"LinSpace":{const s=x("start",n,t,e),i=x("stop",n,t,e),o=x("num",n,t,e);return[r.linspace(s,i,o)]}case"Multinomial":{const s=x("logits",n,t,e),i=x("numSamples",n,t,e),o=x("seed",n,t,e);return[r.multinomial(s,i,o)]}case"OneHot":{const s=x("indices",n,t,e),i=x("depth",n,t,e),o=x("onValue",n,t,e),a=x("offValue",n,t,e),l=x("dtype",n,t,e);return[r.oneHot(s,i,o,a,l)]}case"Ones":return[r.ones(x("shape",n,t,e),x("dtype",n,t,e))];case"OnesLike":return[r.onesLike(x("x",n,t,e))];case"RandomStandardNormal":return[r.randomStandardNormal(x("shape",n,t,e),x("dtype",n,t,e),x("seed",n,t,e))];case"RandomUniform":return[r.randomUniform(x("shape",n,t,e),x("minval",n,t,e),x("maxval",n,t,e),x("dtype",n,t,e))];case"Range":{const s=x("start",n,t,e),i=x("stop",n,t,e),o=x("step",n,t,e);return[r.range(s,i,o,x("dtype",n,t,e))]}case"TruncatedNormal":{const s=x("shape",n,t,e),i=x("mean",n,t,e),o=x("stdDev",n,t,e),a=x("seed",n,t,e);return[r.truncatedNormal(s,i,o,x("dtype",n,t,e),a)]}case"Zeros":return[r.zeros(x("shape",n,t,e),x("dtype",n,t,e))];case"ZerosLike":return[r.zerosLike(x("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"dynamic":return Hfe(o,a,l);case"evaluation":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"LowerBound":{const s=x("sortedSequence",n,t,e),i=x("values",n,t,e);return[r.lowerBound(s,i)]}case"TopKV2":{const s=x("x",n,t,e),i=x("k",n,t,e),o=x("sorted",n,t,e),a=r.topk(s,i,o);return[a.values,a.indices]}case"UpperBound":{const s=x("sortedSequence",n,t,e),i=x("values",n,t,e);return[r.upperBound(s,i)]}case"Unique":{const s=x("x",n,t,e),i=r.unique(s);return[i.values,i.indices]}case"UniqueV2":{const s=x("x",n,t,e),i=x("axis",n,t,e),o=r.unique(s,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"image":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"ResizeBilinear":{const s=x("images",n,t,e),i=x("size",n,t,e),o=x("alignCorners",n,t,e),a=x("halfPixelCenters",n,t,e);return[r.image.resizeBilinear(s,[i[0],i[1]],o,a)]}case"ResizeNearestNeighbor":{const s=x("images",n,t,e),i=x("size",n,t,e),o=x("alignCorners",n,t,e),a=x("halfPixelCenters",n,t,e);return[r.image.resizeNearestNeighbor(s,[i[0],i[1]],o,a)]}case"CropAndResize":{const s=x("image",n,t,e),i=x("boxes",n,t,e),o=x("boxInd",n,t,e),a=x("cropSize",n,t,e),l=x("method",n,t,e),c=x("extrapolationValue",n,t,e);return[r.image.cropAndResize(s,i,o,a,l,c)]}case"ImageProjectiveTransformV3":{const s=x("images",n,t,e),i=x("transforms",n,t,e),o=x("outputShape",n,t,e),a=x("fillValue",n,t,e),l=x("interpolation",n,t,e),c=x("fillMode",n,t,e);return[r.image.transform(s,i,l.toLowerCase(),c.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"graph":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":const s=x("default",n,t,e);return[Yr(n.name,t,e)||s];case"Placeholder":return[Yr(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Ca(x("x",n,t,e))];case"IdentityN":return x("x",n,t,e).map(u=>Ca(u));case"Shape":return[r.tensor1d(x("x",n,t,e).shape,"int32")];case"ShapeN":return x("x",n,t,e).map(u=>r.tensor1d(u.shape));case"Size":return[r.scalar(x("x",n,t,e).size,"int32")];case"Rank":return[r.scalar(x("x",n,t,e).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=x("x",n,t,e),a=x("data",n,t,e),l=x("message",n,t,e),c=x("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<a.length;u++)console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"logical":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"Equal":return[r.equal(x("a",n,t,e),x("b",n,t,e))];case"NotEqual":return[r.notEqual(x("a",n,t,e),x("b",n,t,e))];case"Greater":return[r.greater(x("a",n,t,e),x("b",n,t,e))];case"GreaterEqual":return[r.greaterEqual(x("a",n,t,e),x("b",n,t,e))];case"Less":return[r.less(x("a",n,t,e),x("b",n,t,e))];case"LessEqual":return[r.lessEqual(x("a",n,t,e),x("b",n,t,e))];case"LogicalAnd":return[r.logicalAnd(x("a",n,t,e),x("b",n,t,e))];case"LogicalNot":return[r.logicalNot(x("a",n,t,e))];case"LogicalOr":return[r.logicalOr(x("a",n,t,e),x("b",n,t,e))];case"Select":case"SelectV2":return[r.where(x("condition",n,t,e),x("a",n,t,e),x("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"matrices":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(x("a",n,t,e),x("b",n,t,e),x("transposeA",n,t,e),x("transposeB",n,t,e))];case"Einsum":return[r.einsum(x("equation",n,t,e),...x("tensors",n,t,e))];case"Transpose":return[r.transpose(x("x",n,t,e),x("perm",n,t,e))];case"_FusedMatMul":const[s,i]=x("fusedOps",n,t,e),o="biasadd"===s,a="prelu"===i,l=x("numArgs",n,t,e),c=x("leakyreluAlpha",n,t,e);if(o){if(a&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,d]=x("args",n,t,e);return[r.fused.matMul({a:x("a",n,t,e),b:x("b",n,t,e),transposeA:x("transposeA",n,t,e),transposeB:x("transposeB",n,t,e),bias:u,activation:i,preluActivationWeights:d,leakyreluAlpha:c})];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"normalization":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(x("x",n,t,e),x("axis",n,t,e),x("keepDims",n,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(x("x",n,t,e),x("mean",n,t,e),x("variance",n,t,e),x("offset",n,t,e),x("scale",n,t,e),x("epsilon",n,t,e))];case"LRN":return[r.localResponseNormalization(x("x",n,t,e),x("radius",n,t,e),x("bias",n,t,e),x("alpha",n,t,e),x("beta",n,t,e))];case"Softmax":return[r.softmax(x("x",n,t,e))];case"LogSoftmax":return[r.logSoftmax(x("x",n,t,e))];case"SparseToDense":return[r.sparseToDense(x("sparseIndices",n,t,e),x("outputShape",n,t,e),x("sparseValues",n,t,e),x("defaultValue",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"ragged":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:i}=r.raggedGather(x("paramsNestedSplits",n,t,e),x("paramsDenseValues",n,t,e),x("indices",n,t,e),x("outputRaggedRank",n,t,e));return s.concat(i)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:i}=r.raggedRange(x("starts",n,t,e),x("limits",n,t,e),x("splits",n,t,e));return[s,i]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(x("shape",n,t,e),x("values",n,t,e),x("defaultValue",n,t,e),x("rowPartitionTensors",n,t,e),x("rowPartitionTypes",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"reduction":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"Max":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.max(x("x",n,t,e),a,l)]}case"Mean":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.mean(x("x",n,t,e),a,l)]}case"Min":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.min(x("x",n,t,e),a,l)]}case"Sum":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.sum(x("x",n,t,e),a,l)]}case"All":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.all(x("x",n,t,e),a,l)]}case"Any":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.any(x("x",n,t,e),a,l)]}case"ArgMax":{const a=x("axis",n,t,e);return[r.argMax(x("x",n,t,e),a)]}case"ArgMin":{const a=x("axis",n,t,e);return[r.argMin(x("x",n,t,e),a)]}case"Prod":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.prod(x("x",n,t,e),a,l)]}case"Cumprod":{const a=x("axis",n,t,e),l=x("exclusive",n,t,e),c=x("reverse",n,t,e);return[r.cumprod(x("x",n,t,e),a,l,c)]}case"Cumsum":{const a=x("axis",n,t,e),l=x("exclusive",n,t,e),c=x("reverse",n,t,e);return[r.cumsum(x("x",n,t,e),a,l,c)]}case"Bincount":const s=x("x",n,t,e),i=x("weights",n,t,e),o=x("size",n,t,e);return[r.bincount(s,i,o)];case"DenseBincount":{const a=x("x",n,t,e),l=x("weights",n,t,e),c=x("size",n,t,e),u=x("binaryOutput",n,t,e);return[r.denseBincount(a,l,c,u)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"slice_join":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=x("n",n,t,e),i=x("axis",n,t,e);let o=x("tensors",n,t,e);return o=o.slice(0,s),[r.concat(o,i)]}case"Gather":{const s=x("x",n,t,e),i=x("indices",n,t,e);return[r.gather(s,r.cast(i,"int32"),0)]}case"GatherV2":{const s=x("axis",n,t,e),i=x("batchDims",n,t,e),o=x("x",n,t,e),a=x("indices",n,t,e);return[r.gather(o,r.cast(a,"int32"),s,i)]}case"Reverse":{const s=x("dims",n,t,e),i=[];for(let a=0;a<s.length;a++)s[a]&&i.push(a);const o=x("x",n,t,e);return[r.reverse(o,i)]}case"ReverseV2":{const s=x("axis",n,t,e),i=x("x",n,t,e);return[r.reverse(i,s)]}case"Slice":{const s=x("begin",n,t,e),i=x("size",n,t,e);return[r.slice(x("x",n,t,e),s,i)]}case"StridedSlice":{const s=x("begin",n,t,e),i=x("end",n,t,e),o=x("strides",n,t,e),a=x("beginMask",n,t,e),l=x("endMask",n,t,e),c=x("ellipsisMask",n,t,e),u=x("newAxisMask",n,t,e),d=x("shrinkAxisMask",n,t,e),h=x("x",n,t,e);return[r.stridedSlice(h,s,i,o,a,l,c,u,d)]}case"Pack":return B(()=>{const s=x("axis",n,t,e),i=x("tensors",n,t,e),o=i[0].shape,a=r.squeeze(i[0]).shape,l=i.map(c=>{const u=It(c.shape,o);if(!u&&!It(r.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return u?c:r.reshape(c,o)});return[r.stack(l,s)]});case"Unpack":{const s=x("axis",n,t,e),i=x("tensor",n,t,e);return r.unstack(i,s)}case"Tile":{const s=x("reps",n,t,e);return[r.tile(x("x",n,t,e),s)]}case"Split":case"SplitV":{const s=x("axis",n,t,e),i=x("numOrSizeSplits",n,t,e),o=x("x",n,t,e);return r.split(o,i,s)}case"ScatterNd":{const s=x("indices",n,t,e),i=x("values",n,t,e),o=x("shape",n,t,e);return[r.scatterND(s,i,o)]}case"GatherNd":{const s=x("x",n,t,e),i=x("indices",n,t,e);return[r.gatherND(s,i)]}case"SparseToDense":{const s=x("sparseIndices",n,t,e),i=x("outputShape",n,t,e),o=x("sparseValues",n,t,e),a=x("defaultValue",n,t,e);return[r.sparseToDense(s,o,i,o.dtype===a.dtype?a:r.cast(a,o.dtype))]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"sparse":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:i,emptyRowIndicator:o,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(x("indices",n,t,e),x("values",n,t,e),x("denseShape",n,t,e),x("defaultValue",n,t,e));return[s,i,o,a]}case"SparseReshape":{const{outputIndices:s,outputShape:i}=r.sparse.sparseReshape(x("inputIndices",n,t,e),x("inputShape",n,t,e),x("newShape",n,t,e));return[s,i]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(x("data",n,t,e),x("indices",n,t,e),x("segmentIds",n,t,e))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(x("data",n,t,e),x("indices",n,t,e),x("segmentIds",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"spectral":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"FFT":return[r.fft(x("x",n,t,e))];case"IFFT":return[r.ifft(x("x",n,t,e))];case"RFFT":return[r.rfft(x("x",n,t,e))];case"IRFFT":return[r.irfft(x("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"string":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"StringNGrams":{const{nGrams:s,nGramsSplits:i}=r.string.stringNGrams(x("data",n,t,e),x("dataSplits",n,t,e),x("separator",n,t,e),x("nGramWidths",n,t,e),x("leftPad",n,t,e),x("rightPad",n,t,e),x("padWidth",n,t,e),x("preserveShortSequences",n,t,e));return[s,i]}case"StringSplit":{const{indices:s,values:i,shape:o}=r.string.stringSplit(x("input",n,t,e),x("delimiter",n,t,e),x("skipEmpty",n,t,e));return[s,i,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(x("input",n,t,e),x("numBuckets",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"transformation":return s(()=>((n,t,e,r=Q)=>{switch(n.op){case"Cast":return[r.cast(x("x",n,t,e),x("dtype",n,t,e))];case"ExpandDims":{const s=x("axis",n,t,e);return[r.expandDims(x("x",n,t,e),s)]}case"Squeeze":{const s=x("axis",n,t,e);return[r.squeeze(x("x",n,t,e),s)]}case"Reshape":return[r.reshape(x("x",n,t,e),x("shape",n,t,e))];case"MirrorPad":return[r.mirrorPad(x("x",n,t,e),x("padding",n,t,e),x("mode",n,t,e))];case"PadV2":case"Pad":return[r.pad(x("x",n,t,e),x("padding",n,t,e),x("constantValue",n,t,e))];case"SpaceToBatchND":{const s=x("blockShape",n,t,e),i=x("paddings",n,t,e);return[r.spaceToBatchND(x("x",n,t,e),s,i)]}case"BatchToSpaceND":{const s=x("blockShape",n,t,e),i=x("crops",n,t,e);return[r.batchToSpaceND(x("x",n,t,e),s,i)]}case"DepthToSpace":{const s=x("blockSize",n,t,e),i=x("dataFormat",n,t,e).toUpperCase();return[r.depthToSpace(x("x",n,t,e),s,i)]}case"BroadcastTo":return[r.broadcastTo(x("x",n,t,e),x("shape",n,t,e))];case"BroadcastArgs":return[r.broadcastArgs(x("s0",n,t,e),x("s1",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"hash_table":return qfe(o,a,l,r);case"custom":const c=Wz(o.op);if(c&&c.customExecutor)return c.customExecutor(new Rfe(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return Xu(i)?i.then(o=>[].concat(o)):[].concat(i)}class Qz{constructor(t={},e={},r={},s={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const r=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(r))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function Jz(n,t,e,r){const s=new Set,i=[];let o=null,a=null;const l=new Set,c=Object.keys(n).map(h=>As(h)[0]);let u=[];null!=r&&(u=r.map(h=>As(h.name)[0]));const d=[...t];for(;d.length>0;){const h=d.pop();if((e3(h)||cpe(h)||upe(h))&&null==o&&(o=h,a=o.children.map(f=>f.name).filter(f=>s.has(f))),s.add(h.name),null==e[h.name]&&-1===c.indexOf(h.name)&&-1===u.indexOf(h.name)){if(0===h.inputs.length){i.push(h.name);continue}h.inputs.forEach(f=>{l.has(f.name)||(l.add(f.name),d.push(f))})}}return{inputs:n,outputs:t,usedNodes:s,missingInputs:i,dynamicNode:o,syncInputs:a}}const ope=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],ape=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],lpe=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function e3(n){return ope.indexOf(n.op)>=0}function cpe(n){return ape.indexOf(n.op)>=0}function upe(n){return lpe.indexOf(n.op)>=0}class rv{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new rv(t.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(r=>t[r].map(s=>s.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}getCompilationKey(t,e){const r=t.map(i=>i.name).sort(),s=e.map(i=>i.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(t,e){const r=Jz(t,e,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:i,syncInputs:o}=r;if(null!=i)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(s.length>0){const a=e.map(c=>c.name),l=Object.keys(t);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${l}]. Missing the following inputs: [${s}]`)}return function ipe(n,t,e){const{usedNodes:r,inputs:s}=e,i=[],o=Object.keys(s).map(u=>As(u)[0]).map(u=>n.nodes[u]),a=n.initNodes;o.forEach(u=>{r.has(u.name)&&i.push(u)}),n.weights.forEach(u=>{r.has(u.name)&&i.push(u)}),a?.forEach(u=>{r.has(u.name)&&i.push(u)});const l=new Set,c=[];for(;i.length>0;){const u=i.pop();l.add(u.name),t[u.name]||c.push(u),u.children.forEach(d=>{!l.has(d.name)&&r.has(d.name)&&d.inputs.every(h=>l.has(h.name))&&i.push(d)})}return c}(this.graph,this.weightMap,r)}cloneAndKeepTensor(t){if(null==t)return null;const e=t.clone();return _r(e),e}cloneTensorList(t){return t?t.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,r])=>[e,this.cloneTensorList(r)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const s=r.map(d=>this.graph.nodes[As(d)[0]]),i=e.map(d=>As(d)[0]);let o=i.map(d=>this.graph.nodes[d]);0===o.length&&(o=this._outputs);const a=this.getCompilationKey(s,o);let l=this.compiledMap.get(a);null==l&&(l=this.compile(t,o),this.compiledMap.set(a,l));try{this.keepIntermediateTensors=j().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const c={},u={};return B(()=>{const d=new Qz(this.weightMap,c,u,this.functionExecutorMap),h=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(m=>{const[g,y]=As(m),b=[];b[y]=t[m],h[g]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[g]=this.cloneTensorList(b))});const f=this.getFrozenTensorIds(h),p={};for(let m=0;m<l.length;m++){const g=l[m];if(!h[g.name]){const y=Zz(g,h,d,this._resourceManager);if(Xu(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);h[g.name]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[g.name]=this.cloneTensorList(y)),this.checkTensorForDisposal(g.name,g,h,d,f,i,p)}}return null==this.parent&&d.dispose(f),e.map(m=>Yr(m,h,d))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(s=>s.id)));return new Set(e)}checkTensorForDisposal(t,e,r,s,i,o,a){"control"===e.category||-1!==o.indexOf(t)||(r[t].forEach(l=>{null!=l&&(a[l.id]=(a[l.id]||0)+e.children.length)}),e.inputs.forEach(l=>{if("control"!==l.category){const c=function dfe(n,t,e){return t[tv(n,e.currentContextId)]}(l.name,r,s);c?.forEach(u=>{if(u&&!u.kept&&!i.has(u.id)){const d=a[u.id];1===d?(u.dispose(),delete a[u.id]):null!=d&&a[u.id]--}})}}))}executeAsync(t,e){var r=this;return ee(function*(){return r._executeAsync(t,e)})()}disposeIntermediateTensors(){!this.clonedTensorsMap||(Object.values(this.clonedTensorsMap).forEach(t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(t,e,r=!1,s={},i={}){var o=this;return ee(function*(){o.disposeIntermediateTensors(),r||(t=o.mapInputs(t),o.checkInputs(t),o.checkInputShapeAndType(t),e=o.mapOutputs(e),o.checkOutputs(e));try{o.keepIntermediateTensors=j().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){o.keepIntermediateTensors=!1,console.warn(f.message)}const a=new Qz(o.weightMap,s,i,o.functionExecutorMap);o.keepIntermediateTensors&&(o.clonedTensorsMap=o.cloneTensorMap(o.weightMap));const l=yield o.executeWithControlFlow(t,a,e,r),c=e.map(f=>Yr(f,l,a)),u=c.map(f=>f.id),d=Object.keys(t).map(f=>t[f].id),h=new Set([...u,...d,...o.weightIds]);return Object.values(l).forEach(f=>{f.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),null==o.parent&&a.dispose(h),c})()}executeFunctionAsync(t,e,r){var s=this;return ee(function*(){const i=t.reduce((o,a,l)=>(o[s.inputs[l].name]=a,o),{});return s._executeAsync(i,s.outputNodes,!0,e,r)})()}executeWithControlFlow(t,e,r,s){var i=this;return ee(function*(){const o=Object.keys(t),a=o.map(v=>i.graph.nodes[As(v)[0]]),l=r.map(v=>As(v)[0]);let c=l.map(v=>i.graph.nodes[v]);0===c.length&&(c=i._outputs);const{usedNodes:u,missingInputs:d,dynamicNode:h,syncInputs:f}=Jz(t,c,i.weightMap,i._initNodes),p=[...a,...i.graph.weights,...i._initNodes||[]].map(v=>({node:v,contexts:e.currentContext})),m=Object.assign({},i.weightMap);Object.keys(t).forEach(v=>{const[w,C]=As(v),I=[];I[C]=t[v],m[w]=I});const g={},y=i.getFrozenTensorIds(m),b={};for(;p.length>0;){const v=i.processStack(a,p,e,m,b,y,l,g,u);yield Promise.all(v)}null==h&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const _=c.filter(v=>!e3(v)&&!Yr(v.name,m,e)).map(v=>v.name);if(_.length>0){let v="";throw null!=h&&(v=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${_}] from the provided inputs [${o}]. Consider providing the following inputs: [${d}]. ${v}`)}return m})()}processStack(t,e,r,s,i,o,a,l,c){const u=[];for(;e.length>0;){const d=e.pop();r.currentContext=d.contexts;let h="";if("Enter"===d.node.op&&x("isConstant",d.node,s,r)&&([h]=wa(d.node.name,r)),null==s[d.node.name]){const f=Zz(d.node,s,r,this._resourceManager);h||([h]=wa(d.node.name,r));const p=r.currentContext;Xu(f)?u.push(f.then(m=>(s[h]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(m)),r.currentContext=p,this.checkTensorForDisposal(h,d.node,s,r,o,a,l),this.processChildNodes(d.node,e,r,s,i,c),m))):(s[h]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(f)),this.checkTensorForDisposal(h,d.node,s,r,o,a,l),this.processChildNodes(d.node,e,r,s,i,c))}else this.processChildNodes(d.node,e,r,s,i,c)}return u}processChildNodes(t,e,r,s,i,o){t.children.forEach(a=>{const[l]=wa(a.name,r);i[l]||!o.has(a.name)||("Merge"===a.op?a.inputNames.some(c=>!!Yr(c,s,r))&&(i[l]=!0,e.push({contexts:r.currentContext,node:a})):a.inputNames.every(c=>!!Yr(c,s,r))&&(i[l]=!0,e.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const r=t[e],[s]=As(e),i=this.graph.nodes[s];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value;S(o.length===r.shape.length&&r.shape.every((l,c)=>-1===o[c]||o[c]===l),()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&S(r.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var e,r;const s={};for(const i in t){const o=null===(r=null===(e=this._signature)||void 0===e?void 0:e.inputs)||void 0===r?void 0:r[i];null!=o?s[o.name]=t[i]:s[i]=t[i]}return s}checkInputs(t){const e=Object.keys(t).filter(r=>{const[s]=As(r);return null==this.graph.nodes[s]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var r,s;const i=null===(s=null===(r=this._signature)||void 0===r?void 0:r.outputs)||void 0===s?void 0:s[e];return null!=i?i.name:e},{})}checkOutputs(t){t.forEach(e=>{const[r]=As(e);if(!this.graph.nodes[r])throw new Error(`The output '${e}' is not found in the graph`)})}}class dpe{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}class t3{constructor(t,e={},r=Ue){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=r,null==e&&(this.loadOptions={}),this.resourceManager=new dpe}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return Xu(t)?t.then(e=>this.loadSync(e)):this.loadSync(t)}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const i=this.artifacts.userDefinedMetadata;null!=i.signature&&(r=i.signature),null!=i.structuredOutputKeys&&(this.structuredOutputKeys=i.structuredOutputKeys)}this.signature=r,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const s=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new rv(jz.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const i=jz.Instance.transformGraph(t.modelInitializer);this.initializer=new rv(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}save(t,e){var r=this;return ee(function*(){if("string"==typeof t){const s=r.io.getSaveHandlers(t);if(0===s.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${t}'`);t=s[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(r.artifacts)})()}addStructuredOutputNames(t){if(this.structuredOutputKeys){const r={};return(t instanceof fn?[t]:t).forEach((s,i)=>r[this.structuredOutputKeys[i]]=s),r}return t}predict(t,e){const r=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(r)}predictAsync(t,e){var r=this;return ee(function*(){const s=yield r.executeAsync(t,r.outputNodes);return r.addStructuredOutputNames(s)})()}normalizeInputs(t){var e;if(!(t instanceof fn||Array.isArray(t))){const i=null===(e=this.signature)||void 0===e?void 0:e.inputs;if(null!=i)for(const o in i){const a=i[o];null!=a.resourceId&&(t[o]=this.resourceIdToCapturedInput[a.resourceId])}return t}t=Array.isArray(t)?t:[t];const r=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${t.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((i,o)=>{var a,l,c;const u=null===(c=null===(l=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===l?void 0:l[o])||void 0===c?void 0:c.resourceId;return i[o]=null!=u?this.resourceIdToCapturedInput[u]:t[s++],i},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return null==this.initializer?[]:this.initializer.execute({},null==this.initializerSignature?[]:Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){var t=this;return ee(function*(){return null==t.initializer?[]:t.initializer.executeAsync({},null==t.initializerSignature?[]:Object.keys(t.initializerSignature.outputs))})()}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,r=Object.keys(e);for(let s=0;s<r.length;s++)this.resourceIdToCapturedInput[e[r[s]].resourceId]=t[s]}}execute(t,e){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const r=this.executor.execute(t,e);return r.length>1?r:r[0]}executeAsync(t,e){var r=this;return ee(function*(){null==r.resourceIdToCapturedInput&&r.setResourceIdToCapturedInput(yield r.executeInitializerGraphAsync()),t=r.normalizeInputs(t),e=r.normalizeOutputs(e);const s=yield r.executor.executeAsync(t,e);return s.length>1?s:s[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,r)=>(e[r]=[t[r]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&ot(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}function WT(){return(WT=ee(function*(n,t={},e=Ue){if(null==n)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof n&&(n=mpe(n));const r=new t3(n,t,e);return yield r.load(),r})).apply(this,arguments)}function mpe(n){return n.endsWith("/")||(n+="/"),`${n}model.json?tfjs-format=file`}function Te(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&S("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const Hpe=eD;let Wpe=(()=>{class n extends _S{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new vP(this,No())}nextDataId(){return n.nextDataId++}write(e,r,s){this.firstUse&&(this.firstUse=!1,j().get("IS_NODE")&&Zs("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const i={id:this.nextDataId()};return this.data.set(i,{values:e,dtype:s,refCount:1}),i}makeTensorInfo(e,r,s){let i;if("string"===r&&null!=s&&s.length>0&&_f(s[0])){const o=s.map(a=>Xa(a));i=this.write(o,e,r)}else i=this.write(s,e,r);return{dataId:i,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,s,i,o){this.data.set(e,{values:r,dtype:i,refCount:o})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return ee(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:s}=this.data.get(e);return"complex64"===r?_a(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):this.data.get(e).values}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(i=>Ya(i));return it(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return it(e.shape,e.dtype,r)}makeOutput(e,r,s){return No().makeTensorFromTensorInfo(this.makeTensorInfo(r,s,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);null!=s&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return ee(function*(){const r=us();return e(),{kernelMs:us()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Te([e],"where");const r=this.readSync(e.dataId);return Hpe(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();function Ut(n,t,e){return({inputs:r,attrs:s,backend:i})=>{const{x:o}=r;if(Te(o,n),"string"===o.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=i,l=a.data.get(o.dataId).values,c=X(o.shape),u=e||o.dtype,d=Kn(u,c);for(let h=0;h<c;++h)d[h]=t(l[h],s);return a.makeTensorInfo(o.shape,u,d)}}function Cd(n,t,e){return({inputs:r,attrs:s,backend:i})=>{const{x:o}=r;if(Te(o,n),"string"===o.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=i,l=a.data.get(o.dataId).values,c=e||o.dtype,u=t(l,c,s);return a.makeTensorInfo(o.shape,c,u)}}DL("cpu",()=>new Wpe,1);const f3=Ut(Ff,n=>n>=0?n:Math.exp(n)-1),Gpe={kernelName:Ff,backendName:"cpu",kernelFunc:f3};function zo(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const qpe={kernelName:zf,backendName:"cpu",kernelFunc:zo};function p3(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:i}=r;Te([s],"leakyRelu");const o=X(s.shape),a=e.data.get(s.dataId).values,l=gr("float32",o);for(let c=0;c<a.length;c++)l[c]=a[c]<0?i*a[c]:a[c];return e.makeTensorInfo(s.shape,"float32",l)}const Kpe={kernelName:sb,backendName:"cpu",kernelFunc:p3};function Yn(n){return(t,e,r,s,i)=>{const o=Je(t,e),a=o.length,l=Pe(o),u=gr(i,X(o)),d=t.length,h=e.length,f=Pe(t),p=Pe(e),m=sd(t,o),g=sd(e,o);if(m.length+g.length===0)for(let y=0;y<u.length;++y)u[y]=n(r[y%r.length],s[y%s.length]);else for(let y=0;y<u.length;++y){const b=Ku(y,a,l),_=b.slice(-d);m.forEach(I=>_[I]=0);const v=To(_,d,f),w=b.slice(-h);g.forEach(I=>w[I]=0);const C=To(w,h,p);u[y]=n(r[v],s[C])}return[u,o]}}const Xpe=Yn((n,t)=>n<0?t*n:n);function m3(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t;Te([r,s],"prelu");const i=e.data.get(r.dataId).values,o=e.data.get(s.dataId).values,[a,l]=Xpe(r.shape,s.shape,i,o,"float32");return e.makeTensorInfo(l,"float32",a)}const Ype={kernelName:Cb,backendName:"cpu",kernelFunc:m3},g3=Ut(Jf,n=>Math.max(0,n)),Zpe={kernelName:Jf,backendName:"cpu",kernelFunc:g3},y3=Ut(ep,n=>Math.min(Math.max(0,n),6)),Qpe={kernelName:ep,backendName:"cpu",kernelFunc:y3};function yl(n){return(t,e,r)=>{const s=gr(e,t.length);for(let i=0;i<t.length;++i)s[i]=n(t[i],r);return s}}const Jpe=yl(n=>1/(1+Math.exp(-n))),b3=Ut(ap,n=>1/(1+Math.exp(-n))),eme={kernelName:ap,backendName:"cpu",kernelFunc:b3};function av(n,t,e,r,s){if("linear"===e)return zo({inputs:{x:t},backend:n});if("relu"===e)return g3({inputs:{x:t},backend:n});if("elu"===e)return f3({inputs:{x:t},backend:n});if("relu6"===e)return y3({inputs:{x:t},backend:n});if("prelu"===e)return m3({inputs:{x:t,alpha:r},backend:n});if("leakyrelu"===e)return p3({inputs:{x:t},backend:n,attrs:{alpha:s}});if("sigmoid"===e)return b3({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Rs(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,i=e.data.get(r.dataId).values,o=e.data.get(s.dataId).values,a=e.makeTensorInfo(r.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",i),imag:e.makeTensorInfo(s.shape,"float32",o)},a}const tme={kernelName:OS,backendName:"cpu",kernelFunc:Rs};function lv(n,t,e="float32"){if("complex64"===e)return Rs({inputs:{real:lv(n,t,"float32"),imag:lv(n,t,"float32")},backend:n});const r=$r(X(t),e);return n.makeTensorInfo(t,e,r)}function Cc(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.real,i=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,i)}const nme={kernelName:mE,backendName:"cpu",kernelFunc:Cc};function _3(n,t,e,r){if("int32"===r)return[t,"int32",Int32Array.from(n)];if("bool"===r){const s=ac([0],e),[i,o]=Yn((a,l)=>a!==l?1:0)(t,[],n,s,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function bl(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:i}=r;if("complex64"===i){if("complex64"===s.dtype)return zo({inputs:{x:s},backend:e});const u=lv(e,s.shape,s.dtype),d=bl({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),h=Rs({inputs:{real:d,imag:u},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),h}if("complex64"===s.dtype){const u=Cc({inputs:{input:s},backend:e}),d=bl({inputs:{x:u},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(u),d}if(!SP(s.dtype,i)){const u=zo({inputs:{x:s},backend:e});return{dataId:u.dataId,shape:u.shape,dtype:i}}const o=e.data.get(s.dataId).values,[a,l,c]=_3(o,s.shape,s.dtype,i);return e.makeTensorInfo(a,l,c)}const rme={kernelName:Tf,backendName:"cpu",kernelFunc:bl};function Cr(n,t,e,r){return null==e?({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;Te([o,a],n);const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,d="string"===o.dtype?mc(c):c,h="string"===o.dtype?mc(u):u,f=r||o.dtype,[p,m]=t(o.shape,a.shape,d,h,f);return l.makeTensorInfo(m,f,p)}:({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;if("complex64"===o.dtype||"complex64"===a.dtype){const c=bl({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),h=u.complexTensorInfos.imag,f=l.data.get(u.complexTensorInfos.real.dataId).values,p=l.data.get(h.dataId).values,m=bl({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),b=g.complexTensorInfos.imag,_=l.data.get(g.complexTensorInfos.real.dataId).values,v=l.data.get(b.dataId).values,[w,C,I]=e(o.shape,a.shape,f,p,_,v),D=l.makeTensorInfo(I,"float32",w),T=l.makeTensorInfo(I,"float32",C),N=Rs({inputs:{real:D,imag:T},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(D),l.disposeIntermediateTensorInfo(T),N}{const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,d=r||o.dtype,[h,f]=t(o.shape,a.shape,c,u,d);return l.makeTensorInfo(f,d,h)}}}function ZT(n){return(t,e,r,s,i,o)=>{const a=Je(t,e),l=X(a),c=a.length,u=Pe(a),d=gr("float32",l),h=gr("float32",l),f=sd(t,a),p=sd(e,a),m=_a(r,s),g=_a(i,o),y=t.length,b=Pe(t),_=e.length,v=Pe(e);if(f.length+p.length===0)for(let w=0;w<d.length;w++){const C=w%m.length,I=w%g.length,D=n(m[2*C],m[2*C+1],g[2*I],g[2*I+1]);d[w]=D.real,h[w]=D.imag}else for(let w=0;w<d.length;w++){const C=Ku(w,c,u),I=C.slice(-y);f.forEach(z=>I[z]=0);const D=To(I,y,b),T=C.slice(-_);p.forEach(z=>T[z]=0);const N=To(T,_,v),P=n(m[2*D],m[2*D+1],g[2*N],g[2*N+1]);d[w]=P.real,h[w]=P.imag}return[d,h,a]}}const v3=Yn((n,t)=>n+t),sme=ZT((n,t,e,r)=>({real:n+e,imag:t+r})),Sd=Cr(Yu,v3,sme),ime={kernelName:Yu,backendName:"cpu",kernelFunc:Sd};function sn(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:i}=r,o=X(s.shape),a=CP(i,o),l=X(a);S(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.incRef(s.dataId);const c=e.data.get(s.dataId);if(null!=c.complexTensorInfos){const d=c.complexTensorInfos.imag;c.complexTensorInfos.real.shape=a,d.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const ome={kernelName:Eb,backendName:"cpu",kernelFunc:sn};function x3(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i}=t,{transposeA:o,transposeB:a}=r;Te([s,i],"matMul");const l=s.shape.length,c=i.shape.length,u=o?s.shape[l-2]:s.shape[l-1],d=a?i.shape[c-1]:i.shape[c-2],h=o?s.shape[l-1]:s.shape[l-2],f=a?i.shape[c-2]:i.shape[c-1],p=s.shape.slice(0,-2),m=i.shape.slice(0,-2),g=X(p),y=X(m),_=Je(s.shape.slice(0,-2),i.shape.slice(0,-2)).concat([h,f]);S(u===d,()=>`Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${s.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const w=a?[y,f,d]:[y,d,f],C=sn({inputs:{x:s},backend:e,attrs:{shape:o?[g,u,h]:[g,h,u]}}),I=sn({inputs:{x:i},backend:e,attrs:{shape:w}}),D=o?C.shape[1]:C.shape[2],T=o?C.shape[2]:C.shape[1],N=a?I.shape[1]:I.shape[2],P=Math.max(g,y),z=e.data.get(C.dataId).values,W=e.data.get(I.dataId).values,G=Pe(C.shape),q=Pe(I.shape),[$,V,L]=o?[G[0],1,G[1]]:[G[0],G[1],1],[H,ne,ie]=a?[1,q[1],q[0]]:[q[1],1,q[0]],de=T*N,ue=it([P,T,N],C.dtype),he=ue.values,ge=e.blockSize;for(let Ee=0;Ee<P;Ee++)for(let _e=0;_e<T;_e+=ge)for(let Me=0;Me<N;Me+=ge)for(let ke=0;ke<D;ke+=ge){const Ze=Math.min(_e+ge,T),at=Math.min(Me+ge,N),Ht=Math.min(ke+ge,D);for(let an=_e;an<Ze;an++)for(let pn=Me;pn<at;pn++){let vn=0;for(let Gt=ke;Gt<Ht;Gt++){const Fn=Math.min(Ee,g-1)*$,Un=Math.min(Ee,y-1)*ie;vn+=z[Fn+an*V+Gt*L]*W[Gt*H+pn*ne+Un]}he[Ee*de+(an*N+pn)]+=vn}}return e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo(I),e.makeTensorInfo(_,ue.dtype,ue.values)}const ame={kernelName:Hy,backendName:"cpu",kernelFunc:x3},cme={kernelName:Lb,backendName:"cpu",kernelFunc:function lme(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:d}=r;let h,f,p;const m=[];h=x3({inputs:{a:s,b:i},attrs:{transposeA:l,transposeB:c},backend:e}),o&&(f=Sd({inputs:{a:h,b:o},backend:e}),m.push(h),h=f),u&&(p=av(e,h,u,a,d),m.push(h),h=p);for(const y of m)e.disposeIntermediateTensorInfo(y);return h}};function w3(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const ume={kernelName:Py,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend;Te(t,"abs");let r=new Float32Array(X(t.shape));return r=w3(e.data.get(t.dataId).values),e.makeOutput(r,t.shape,t.dtype)}},dme=Ut(xf,n=>Math.acos(n)),hme={kernelName:xf,backendName:"cpu",kernelFunc:dme},fme=Ut(wf,n=>Math.acosh(n)),pme={kernelName:wf,backendName:"cpu",kernelFunc:fme},gme={kernelName:Ly,backendName:"cpu",kernelFunc:function mme(n){const{inputs:t,backend:e}=n,r=t;Te(t,"addN");const s=r.map(a=>e.data.get(a.dataId).values),i=it(r[0].shape,r[0].dtype),o=i.values;for(let a=0;a<r.length;a++){const l=s[a];for(let c=0;c<o.length;c++)o[c]+=l[c]}return e.makeTensorInfo(i.shape,i.dtype,i.values)}};function QT(n,t,e,r,s){const i=t.length,o=X(t),a=Pe(t),l=Pe(s),c=gr(e,X(s));for(let u=0;u<o;++u){const d=Ku(u,i,a),h=new Array(d.length);for(let p=0;p<h.length;p++)h[p]=d[r[p]];c[To(h,i,l)]=n[u]}return c}function gs(n){const{inputs:t,attrs:e,backend:r}=n,{x:s}=t,{perm:i}=e;Te(s,"transpose");const a=new Array(s.shape.length);for(let d=0;d<a.length;d++)a[d]=s.shape[i[d]];const c=QT(r.data.get(s.dataId).values,s.shape,s.dtype,i,a);return{dataId:r.write(c,a,s.dtype),shape:a,dtype:s.dtype}}const yme={kernelName:Zu,backendName:"cpu",kernelFunc:gs},_me={kernelName:"All",backendName:"cpu",kernelFunc:function bme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;Te(s,"all");const a=ht(i,s.shape);let l=a;const c=En(l,s.shape.length);let u=s;null!=c&&(u=gs({inputs:{x:s},backend:e,attrs:{perm:c}}),l=Bn(l.length,s.shape.length)),kr("all",l,u.shape.length);const[d,h]=xr(u.shape,l),f=X(h),p=$r(X(d),u.dtype),m=e.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let _=m[b];for(let v=0;v<f;++v){const w=m[b+v];_=_&&w}p[y]=_}null!=c&&e.disposeIntermediateTensorInfo(u);const g=e.makeTensorInfo(d,u.dtype,p);if(o){const b=sn({inputs:{x:g},backend:e,attrs:{shape:Vn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},xme={kernelName:"Any",backendName:"cpu",kernelFunc:function vme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;Te(s,"any");const a=ht(i,s.shape);let l=a;const c=En(l,s.shape.length);let u=s;null!=c&&(u=gs({inputs:{x:s},backend:e,attrs:{perm:c}}),l=Bn(l.length,s.shape.length)),kr("any",l,u.shape.length);const[d,h]=xr(u.shape,l),f=X(h),p=$r(X(d),u.dtype),m=e.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let _=m[b];for(let v=0;v<f;++v){const w=m[b+v];_=_||w}p[y]=_}null!=c&&e.disposeIntermediateTensorInfo(u);const g=e.makeTensorInfo(d,u.dtype,p);if(o){const b=sn({inputs:{x:g},backend:e,attrs:{shape:Vn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},Cme={kernelName:Vy,backendName:"cpu",kernelFunc:function wme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;Te(s,"argMax");let o=ht(i,s.shape);const a=En(o,s.shape.length);let l=s;const c=[];null!=a&&(l=gs({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),o=Bn(o.length,l.shape.length)),o=[o[0]],kr("argMax",o,l.shape.length);const[u,d]=xr(l.shape,o),f=$r(X(u),"int32"),p=X(d),m=e.data.get(l.dataId).values;for(let g=0;g<f.length;++g){const y=g*p;let b=m[y],_=0;for(let v=0;v<p;++v){const w=m[y+v];w>b&&(b=w,_=v)}f[g]=_}return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(u,"int32",f)}},Eme={kernelName:By,backendName:"cpu",kernelFunc:function Sme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;Te(s,"argMin");let o=ht(i,s.shape);const a=En(o,s.shape.length);let l=s;const c=[];null!=a&&(l=gs({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),o=Bn(o.length,l.shape.length)),o=[o[0]],kr("argMin",o,l.shape.length);const[u,d]=xr(l.shape,o),f=$r(X(u),"int32"),p=X(d),m=e.data.get(l.dataId).values;for(let g=0;g<f.length;++g){const y=g*p;let b=m[y],_=0;for(let v=0;v<p;++v){const w=m[y+v];w<b&&(b=w,_=v)}f[g]=_}return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(u,"int32",f)}},Ime=Ut(Cf,n=>Math.asin(n)),Dme={kernelName:Cf,backendName:"cpu",kernelFunc:Ime},Tme=Ut(Sf,n=>Math.asinh(n)),kme={kernelName:Sf,backendName:"cpu",kernelFunc:Tme},Nme=Ut(Ef,n=>Math.atan(n)),Ame={kernelName:Ef,backendName:"cpu",kernelFunc:Nme},Rme=Yn((n,t)=>Math.atan2(n,t)),Mme=Cr(Df,Rme),Fme={kernelName:Df,backendName:"cpu",kernelFunc:Mme},Ome=Ut(If,n=>Math.atanh(n)),$me={kernelName:If,backendName:"cpu",kernelFunc:Ome};function JT(n,t,e,r,s,i){const o=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,c=s.dilationWidth,u=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,f=s.padInfo.left,p="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=it(s.outShape,e),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],_=s.outShape[3];for(let v=0;v<s.batchSize;++v){const w=v*y,C=v*r[0];for(let I=0;I<s.inChannels;++I)for(let D=0;D<s.outHeight;++D){const T=D*o-h,N=Math.max(0,T),P=Math.min(s.inHeight,u+T),z=w+D*b;for(let W=0;W<s.outWidth;++W){const G=W*a-f,q=Math.max(0,G),$=Math.min(s.inWidth,d+G);let V=p,L=0,H=0;for(let ie=N;ie<P;ie+=l){const de=C+ie*r[1];for(let ue=q;ue<$;ue+=c){const ge=n[de+ue*r[2]+I];"max"===i&&ge>V?V=ge:"avg"===i&&(L+=ge,H++)}if(isNaN(V))break}g[z+W*_+I]="avg"===i?L/H:V}}}return m}function C3(n,t,e,r,s=!1,i=!1){const o=it(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,f=r.padInfo.top,p=r.padInfo.left,m=it(t,e,n);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){const _=b*a-f;let v=_;for(;v<0;)v+=c;const w=Math.min(r.inHeight,d+_);for(let C=0;C<r.outWidth;++C){const I=C*l-p;let D=I;for(;D<0;)D+=u;const T=Math.min(r.inWidth,h+I);let N=Number.NEGATIVE_INFINITY,P=-1;for(let z=v;z<w;z+=c){const W=z-_;for(let G=D;G<T;G+=u){const q=G-I,$=m.get(g,z,G,y);$>N&&(N=$,P=s?i?((g*r.inHeight+z)*r.inWidth+G)*r.inChannels+y:(z*r.inWidth+G)*r.inChannels+y:W*h+q)}}o.set(P,g,b,C,y)}}return o}function S3(n,t,e,r,s,i){const o=s.strideDepth,a=s.strideHeight,l=s.strideWidth,c=s.dilationDepth,u=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,f=s.effectiveFilterHeight,p=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,_=it(s.outShape,e),v=_.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],C=s.outShape[2]*s.outShape[3]*s.outShape[4],I=s.outShape[3]*s.outShape[4],D=s.outShape[4];for(let T=0;T<s.batchSize;++T){const N=T*w,P=T*r[0];for(let z=0;z<s.inChannels;++z)for(let W=0;W<s.outDepth;++W){const G=W*o-m;let q=G;for(;q<0;)q+=c;const $=Math.min(s.inDepth,h+G),V=N+W*C;for(let L=0;L<s.outHeight;++L){const H=L*a-g;let ne=H;for(;ne<0;)ne+=u;const ie=Math.min(s.inHeight,f+H),de=V+L*I;for(let ue=0;ue<s.outWidth;++ue){const he=ue*l-y;let ge=he;for(;ge<0;)ge+=d;const Ee=Math.min(s.inWidth,p+he),_e=de+ue*D;let Me=b,ke=0,Ze=0;for(let Ht=q;Ht<$;Ht+=c){const an=P+Ht*r[1];for(let pn=ne;pn<ie;pn+=u){const vn=an+pn*r[2];for(let Gt=ge;Gt<Ee;Gt+=d){const Un=n[vn+Gt*r[3]+z];if("max"===i&&Un>Me?Me=Un:"avg"===i&&(ke+=Un,Ze++),isNaN(Me))break}if(isNaN(Me))break}if(isNaN(Me))break}v[_e+z]="avg"===i?ke/Ze:Me}}}}return _}const Vme={kernelName:zy,backendName:"cpu",kernelFunc:function Lme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Te(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r;S(Tr(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=Ii(s.shape,i,o,1,a,l);let d;if(1===u.filterWidth&&1===u.filterHeight&&It(u.inShape,u.outShape))d=zo({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,f=Pe(s.shape),p=JT(h,0,s.dtype,f,u,"avg");d=e.makeTensorInfo(u.outShape,s.dtype,p.values)}return d}},zme={kernelName:Uy,backendName:"cpu",kernelFunc:function Bme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r;Te(s,"avgPool3d");const u=pa(s.shape,i,o,1,a,l,c),h=S3(e.data.get(s.dataId).values,0,s.dtype,Pe(s.shape),u,"avg");return e.makeTensorInfo(h.shape,"float32",h.values)}},Hme={kernelName:RS,backendName:"cpu",kernelFunc:function Ume(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;Te([s,i],"avgPool3DGrad");const u=pa(i.shape,o,a,1,l,c),d=u.strideDepth,h=u.strideHeight,f=u.strideWidth,p=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,_=u.dilationWidth,v=u.effectiveFilterDepth,w=u.effectiveFilterHeight,C=u.effectiveFilterWidth,I=v-1-u.padInfo.front,D=C-1-u.padInfo.left,T=w-1-u.padInfo.top,N=it(i.shape,"float32"),P=1/(p*m*g),z=e.bufferSync(s);for(let W=0;W<u.batchSize;++W)for(let G=0;G<u.inChannels;++G)for(let q=0;q<u.inDepth;++q)for(let $=0;$<u.inHeight;++$)for(let V=0;V<u.inWidth;++V){const L=q-I,H=$-T,ne=V-D;let ie=0;for(let de=0;de<v;de+=y){const ue=(L+de)/d;if(!(ue<0||ue>=u.outDepth||Math.floor(ue)!==ue))for(let he=0;he<w;he+=b){const ge=(H+he)/h;if(!(ge<0||ge>=u.outHeight||Math.floor(ge)!==ge))for(let Ee=0;Ee<C;Ee+=_){const _e=(ne+Ee)/f;_e<0||_e>=u.outWidth||Math.floor(_e)!==_e||(ie+=z.get(W,ue,ge,_e,G))}}}N.set(ie*P,W,q,$,V,G)}return e.makeTensorInfo(N.shape,N.dtype,N.values)}},jme={kernelName:AS,backendName:"cpu",kernelFunc:function Wme(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i;Te([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=Ii(o.shape,a,l,1,c),d=u.strideHeight,h=u.strideWidth,f=u.filterHeight,p=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,_=b-1-u.padInfo.left,v=y-1-u.padInfo.top,w=it(o.shape,"float32"),C=1/(f*p),I=e.data.get(s.dataId).values,D=it(s.shape,"float32",I);for(let T=0;T<u.batchSize;++T)for(let N=0;N<u.inChannels;++N)for(let P=0;P<u.inHeight;++P)for(let z=0;z<u.inWidth;++z){const W=P-v,G=z-_;let q=0;for(let $=0;$<y;$+=m){const V=(W+$)/d;if(!(V<0||V>=u.outHeight||Math.floor(V)!==V))for(let L=0;L<b;L+=g){const H=(G+L)/h;H<0||H>=u.outWidth||Math.floor(H)!==H||(q+=D.get(T,V,H,N))}}w.set(q*C,T,P,z,N)}return e.makeTensorInfo(w.shape,w.dtype,w.values)}},qme={kernelName:tb,backendName:"cpu",kernelFunc:function Gme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,scale:i,offset:o,mean:a,variance:l}=t;S(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Te([s,a,l,i,o],"batchNorm");let{varianceEpsilon:c}=r;null==c&&(c=.001);const u=e.data.get(s.dataId).values,d=e.data.get(a.dataId).values,h=e.data.get(l.dataId).values,f=i?e.data.get(i.dataId).values:new Float32Array([1]),p=o?e.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=p.length,y=f.length,b=h.length,_=d.length;let v=0,w=0,C=0,I=0;for(let D=0;D<u.length;++D)m[D]=p[v++]+(u[D]-d[w++])*f[C++]/Math.sqrt(h[I++]+c),v>=g&&(v=0),w>=_&&(w=0),C>=y&&(C=0),I>=b&&(I=0);return e.makeTensorInfo(s.shape,s.dtype,m)}};function E3(n,t,e,r,s){const i=gI(r,t,e),o=X(e),a=Pe(r);if(i){const d=yI(t,a);return"string"===s?n.slice(d,d+o):n.subarray(d,d+o)}const c=it(r,s,"string"===s?mc(n):n),u=it(e,s);for(let d=0;d<u.size;++d){const h=u.indexToLoc(d),f=h.map((p,m)=>p+t[m]);u.set(c.get(...f),...h)}return"string"===s?cB(u.values):u.values}function Sc(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,size:o}=r;Te(s,"slice");const[a,l]=e_(s,i,o);pI(s,a,l);const u=E3(e.data.get(s.dataId).values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,u)}const Kme={kernelName:Nb,backendName:"cpu",kernelFunc:Sc},Yme={kernelName:Wy,backendName:"cpu",kernelFunc:function Xme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,crops:o}=r;Te([s],"batchToSpaceND");const a=i.reduce((y,b)=>y*b),l=$p(s.shape,i,a),c=Pp(l.length,i.length),u=Lp(s.shape,i,a),d=CD(o,i.length),h=SD(u,o,i.length),f=sn({inputs:{x:s},backend:e,attrs:{shape:l}}),p=gs({inputs:{x:f},backend:e,attrs:{perm:c}}),m=sn({inputs:{x:p},backend:e,attrs:{shape:u}}),g=Sc({inputs:{x:m},backend:e,attrs:{begin:d,size:h}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),g}};function e1(n,t,e,r,s){const i=X(r),o=$r(s,e);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(o[l]+=i>0?t[a]:1)}return o}function I3(n,t,e,r=!1){const s=n.shape[0],i=n.shape[1],o=it([s,e],t.dtype);for(let a=0;a<s;a++)for(let l=0;l<i;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=e||o.set(r?1:t.size>0?o.get(a,c)+t.get(a,l):o.get(a,c)+1,a,c)}return o}const Qme={kernelName:MS,backendName:"cpu",kernelFunc:function Zme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o}=r,c=e1(e.data.get(s.dataId).values,e.data.get(i.dataId).values,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,c)}},ege={kernelName:FS,backendName:"cpu",kernelFunc:function Jme(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,i=e.data.get(r.dataId).values,o=e.data.get(s.dataId).values,a=Je(Array.from(i),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},D3=yl(n=>Math.ceil(n)),tge=Cd(kf,D3),nge={kernelName:kf,backendName:"cpu",kernelFunc:tge},rge=Ut(Nf,(n,t)=>n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n),sge={kernelName:Nf,backendName:"cpu",kernelFunc:rge},ige={kernelName:jy,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend,r=new Float32Array(X(t.shape)),s=e.data.get(t.dataId),o=s.complexTensorInfos.imag,a=e.data.get(s.complexTensorInfos.real.dataId).values,l=e.data.get(o.dataId).values;for(let c=0;c<a.length;c++)r[c]=Math.hypot(a[c],l[c]);return e.makeOutput(r,t.shape,"float32")}};function T3(n,t,e,r){const s=Kn(e,X(t));if(r&&"string"!==e){let i=0;n.forEach(o=>{const a=X(o.shape);s.set(o.vals,i),i+=a})}else{let i=0;n.forEach(o=>{const a="string"===e?mc(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const u=c*t[1]+i;for(let d=0;d<o.shape[1];++d)s[u+d]=a[l++]}i+=o.shape[1]})}return s}function Ed(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.imag,i=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,i)}const oge={kernelName:tE,backendName:"cpu",kernelFunc:Ed};function Id(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,i=ht(s,t[0].shape)[0];vD(t.map(m=>m.shape),i);let a=Fo(t.map(m=>m.shape),i);if(0===X(a))return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(m=>X(m.shape)>0);if(1===l.length)return zo({inputs:{x:l[0]},backend:e});if("complex64"===l[0].dtype){const m=l.map(v=>Cc({inputs:{input:v},backend:e})),g=l.map(v=>Ed({inputs:{input:v},backend:e})),y=Id({inputs:m,backend:e,attrs:{axis:i}}),b=Id({inputs:g,backend:e,attrs:{axis:i}}),_=Rs({inputs:{real:y,imag:b},backend:e});return m.forEach(v=>e.disposeIntermediateTensorInfo(v)),g.forEach(v=>e.disposeIntermediateTensorInfo(v)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),_}const c=l.map(m=>{const y=[-1,X(m.shape.slice(i))];return sn({inputs:{x:m},backend:e,attrs:{shape:y}})}),u=c.map(m=>({vals:e.data.get(m.dataId).values,shape:m.shape}));a=Fo(c.map(m=>m.shape),1);const h=T3(u,a,t[0].dtype,1===c[0].shape[0]),f=Fo(l.map(m=>m.shape),i),p=e.makeTensorInfo(f,t[0].dtype,h);return c.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}const age={kernelName:Gy,backendName:"cpu",kernelFunc:Id};function k3(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r;Te([s,i],"conv2d");const d=ma(l),h=vr(s.shape,i.shape,o,c,a,u,!1,d),f=h.filterHeight,p=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,_="channelsLast"===h.dataFormat,v=new br(h.outShape,s.dtype),w=Pe(s.shape),C=Pe(i.shape),I=w[0],D=_?w[1]:w[2],T=_?w[2]:1,N=_?1:w[1],P=v.strides[0],z=_?v.strides[1]:v.strides[2],W=_?v.strides[2]:1,G=_?1:v.strides[1],q=e.data.get(s.dataId).values,$=e.data.get(i.dataId).values,V=v.values;for(let L=0;L<h.batchSize;++L){const H=L*I,ne=L*P;for(let ie=0;ie<h.outHeight;++ie){const de=ne+ie*z,ue=ie*h.strideHeight-b;for(let he=0;he<f;++he){const ge=ue+he*m;if(ge<0||ge>=h.inHeight)continue;const Ee=he*C[0],_e=H+ge*D;for(let Me=0;Me<h.outWidth;++Me){const ke=de+Me*W,Ze=Me*h.strideWidth-y;for(let at=0;at<p;++at){const Ht=Ze+at*g;if(Ht<0||Ht>=h.inWidth)continue;const pn=_e+Ht*T;let vn=Ee+at*C[1];for(let Gt=0;Gt<h.inChannels;++Gt){const Fn=q[pn+Gt*N];for(let Un=0;Un<h.outChannels;++Un)V[ke+Un*G]+=Fn*$[vn+Un];vn+=h.outChannels}}}}}}return e.makeTensorInfo(v.shape,v.dtype,V)}const lge={kernelName:qy,backendName:"cpu",kernelFunc:k3},uge={kernelName:$S,backendName:"cpu",kernelFunc:function cge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r;Te([s,i],"conv2dBackpropFilter");const d=ma(l),h=vr(s.shape,u,o,1,a,c,!1,d),{strideHeight:f,strideWidth:p,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,b=new br(h.filterShape,"float32"),_=h.padInfo.left,v=h.padInfo.top,w=e.data.get(s.dataId).values,C=e.data.get(i.dataId).values,I=new br(s.shape,s.dtype,w),D=new br(i.shape,i.dtype,C);for(let T=0;T<m;++T){const N=Math.max(0,Math.ceil((v-T)/f)),P=Math.min(h.outHeight,(h.inHeight+v-T)/f);for(let z=0;z<g;++z){const W=Math.max(0,Math.ceil((_-z)/p)),G=Math.min(h.outWidth,(h.inWidth+_-z)/p);for(let q=0;q<h.inChannels;++q)for(let $=0;$<h.outChannels;++$){let V=0;for(let L=0;L<h.batchSize;++L)for(let H=N;H<P;++H){const ne=T+H*f-v;for(let ie=W;ie<G;++ie){const de=z+ie*p-_;V+=y?I.get(L,ne,de,q)*D.get(L,H,ie,$):I.get(L,q,ne,de)*D.get(L,$,H,ie)}}b.set(V,T,z,q,$)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},hge={kernelName:Ky,backendName:"cpu",kernelFunc:function dge(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r;Te([s,i],"conv2dBackpropInput");const d=Pe(i.shape),h=Pe(s.shape);let f=ma(c);const p=vr(o,i.shape,a,1,l,u,!1,f),m=new br(p.inShape,"float32"),g=m.values,y=e.data.get(s.dataId).values,b=e.data.get(i.dataId).values,[_,v,w]=d,{batchSize:C,filterHeight:I,filterWidth:D,inChannels:T,inHeight:N,inWidth:P,outChannels:z,outHeight:W,outWidth:G,strideHeight:q,strideWidth:$}=p;f=p.dataFormat;const V=I-1-p.padInfo.top,L=D-1-p.padInfo.left,H="channelsLast"===f,ne=m.strides[0],ie=H?m.strides[1]:m.strides[2],de=H?m.strides[2]:1,ue=H?1:m.strides[1],he=h[0],ge=H?h[1]:h[2],Ee=H?h[2]:1,_e=H?1:h[1];for(let Me=0;Me<C;++Me)for(let ke=0;ke<T;++ke)for(let Ze=0;Ze<N;++Ze){const at=Ze-V,Ht=Math.max(0,Math.ceil(at/q)),an=Math.min(W,(I+at)/q);for(let pn=0;pn<P;++pn){const vn=pn-L,Gt=Math.max(0,Math.ceil(vn/$)),Fn=Math.min(G,(D+vn)/$);let Un=0;for(let Ar=Ht;Ar<an;++Ar){const kl=Ar*q-at;for(let di=Gt;di<Fn;++di){const mo=he*Me+ge*Ar+Ee*di,Na=_*(I-1-kl)+v*(D-1-(di*$-vn))+w*ke;for(let Nl=0;Nl<z;++Nl)Un+=y[mo+_e*Nl]*b[Na+Nl]}}g[ne*Me+ie*Ze+de*pn+ue*ke]=Un}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}},pge={kernelName:Xy,backendName:"cpu",kernelFunc:function fge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l}=r;Te([s,i],"conv3d");const c=nl(s.shape,i.shape,o,l,a),{filterDepth:u,filterHeight:d,filterWidth:h,dilationDepth:f,dilationHeight:p,dilationWidth:m,padInfo:g}=c,y=g.front,b=g.left,_=g.top,v=new br(c.outShape,s.dtype),w=e.data.get(s.dataId).values,C=e.data.get(i.dataId).values,I=v.values,D=Pe(s.shape),T=Pe(i.shape);for(let N=0;N<c.batchSize;++N){const P=N*D[0],z=N*v.strides[0];for(let W=0;W<c.outDepth;++W){const G=z+W*v.strides[1],q=W*c.strideDepth-y;for(let $=0;$<u;++$){const V=q+$*f;if(V<0||V>=c.inDepth)continue;const L=$*T[0],H=P+V*D[1];for(let ne=0;ne<c.outHeight;++ne){const ie=G+ne*v.strides[2],de=ne*c.strideHeight-_;for(let ue=0;ue<d;++ue){const he=de+ue*p;if(he<0||he>=c.inHeight)continue;const ge=L+ue*T[1],Ee=H+he*D[2];for(let _e=0;_e<c.outWidth;++_e){const Me=ie+_e*c.outChannels,ke=_e*c.strideWidth-b;for(let Ze=0;Ze<h;++Ze){const at=ke+Ze*m;if(at<0||at>=c.inWidth)continue;const an=Ee+at*c.inChannels;let pn=ge+Ze*T[2];for(let vn=0;vn<c.inChannels;++vn){const Gt=w[an+vn];for(let Fn=0;Fn<c.outChannels;++Fn)I[Me+Fn]+=Gt*C[pn+Fn];pn+=c.outChannels}}}}}}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}},gge={kernelName:PS,backendName:"cpu",kernelFunc:function mge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,filterShape:l}=r;Te([s,i],"conv3dBackpropFilterV2");const c=Pe(s.shape),u=Pe(i.shape),d=nl(s.shape,l,o,1,a),h=d.strideDepth,f=d.strideHeight,p=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new br(d.filterShape,"float32"),_=b.values,[v,w,C,I]=b.strides,D=e.data.get(i.dataId).values,[T,N,P,z]=u,W=e.data.get(s.dataId).values,[G,q,$,V]=c,L=d.padInfo.front,H=d.padInfo.left,ne=d.padInfo.top;for(let ie=0;ie<m;++ie){const de=Math.max(0,Math.ceil((L-ie)/h)),ue=Math.min(d.outDepth,(d.inDepth+L-ie)/h),he=ie*v;for(let ge=0;ge<g;++ge){const Ee=Math.max(0,Math.ceil((ne-ge)/f)),_e=Math.min(d.outHeight,(d.inHeight+ne-ge)/f),Me=ge*w+he;for(let ke=0;ke<y;++ke){const Ze=Math.max(0,Math.ceil((H-ke)/p)),at=Math.min(d.outWidth,(d.inWidth+H-ke)/p),Ht=ke*C+Me;for(let an=0;an<d.inChannels;++an){const pn=an*I+Ht;for(let vn=0;vn<d.outChannels;++vn){let Gt=0;for(let Fn=0;Fn<d.batchSize;++Fn){const Un=Fn*G,ka=Fn*T;for(let Ar=de;Ar<ue;++Ar){const di=(ie+Ar*h-L)*q+Un,Vc=Ar*N+ka;for(let mo=Ee;mo<_e;++mo){const Nl=(ge+mo*f-ne)*$+di,Al=mo*P+Vc;for(let Rl=Ze;Rl<at;++Rl)Gt+=W[(ke+Rl*p-H)*V+Nl+an]*D[Rl*z+Al+vn]}}}_[pn+vn]=Gt}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},bge={kernelName:LS,backendName:"cpu",kernelFunc:function yge(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{pad:o,strides:a,inputShape:l}=r;Te([s],"conv3dBackpropInputV2");const c=Pe(s.shape),u=Pe(i.shape),d=nl(l,i.shape,a,1,o),h=new br(d.inShape,"float32"),f=h.values,[p,m,g,y]=h.strides,b=e.data.get(s.dataId).values,[_,v,w,C]=c,I=e.data.get(i.dataId).values,[D,T,N,P]=u,{batchSize:z,filterDepth:W,filterHeight:G,filterWidth:q,inChannels:$,inDepth:V,inHeight:L,inWidth:H,outChannels:ne,outDepth:ie,outHeight:de,outWidth:ue,strideDepth:he,strideHeight:ge,strideWidth:Ee}=d,_e=W-1-d.padInfo.front,Me=G-1-d.padInfo.top,ke=q-1-d.padInfo.left;for(let Ze=0;Ze<z;++Ze)for(let at=0;at<$;++at)for(let Ht=0;Ht<V;++Ht){const an=Ht-_e,pn=Math.max(0,Math.ceil(an/he)),vn=Math.min(ie,(W+an)/he);for(let Gt=0;Gt<L;++Gt){const Fn=Gt-Me,Un=Math.max(0,Math.ceil(Fn/ge)),ka=Math.min(de,(G+Fn)/ge);for(let Ar=0;Ar<H;++Ar){const kl=Ar-ke,di=Math.max(0,Math.ceil(kl/Ee)),Vc=Math.min(ue,(q+kl)/Ee);let mo=0;for(let Na=pn;Na<vn;++Na){const Nl=Na*he-an;for(let Al=Un;Al<ka;++Al){const Rl=Al*ge-Fn;for(let Rm=di;Rm<Vc;++Rm){const Hk=_*Ze+v*Na+w*Al+C*Rm,j2e=D*(W-1-Nl)+T*(G-1-Rl)+N*(q-1-(Rm*Ee-kl))+P*at;for(let Sx=0;Sx<ne;++Sx)mo+=b[Hk+Sx]*I[j2e+Sx]}}}f[p*Ze+m*Ht+g*Gt+y*Ar+at]=mo}}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}},_ge=Ut(Af,n=>Math.cos(n)),vge={kernelName:Af,backendName:"cpu",kernelFunc:_ge},xge=Ut(Rf,n=>Math.cosh(n)),wge={kernelName:Rf,backendName:"cpu",kernelFunc:xge},Sge={kernelName:BS,backendName:"cpu",kernelFunc:function Cge(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:i,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:c}=r,[u,d,h,f]=s.shape,p=i.shape[0],[m,g]=a,y=it([p,m,g,f],"float32"),b=e.data.get(i.dataId).values,_=e.data.get(o.dataId).values,v=e.data.get(s.dataId).values,w=Pe(s.shape),C=Pe(y.shape);for(let I=0;I<p;I++){const D=4*I,T=b[D],N=b[D+1],P=b[D+2],z=b[D+3],W=_[I];if(W>=u)continue;const G=m>1?(P-T)*(d-1)/(m-1):0,q=g>1?(z-N)*(h-1)/(g-1):0;for(let $=0;$<m;$++){const V=m>1?T*(d-1)+$*G:.5*(T+P)*(d-1);if(V<0||V>d-1)for(let L=0;L<g;L++)for(let H=0;H<f;H++)y.values[H+L*C[2]+$*C[1]+I*C[0]]=c;else if("bilinear"===l){const L=Math.floor(V),H=Math.ceil(V),ne=V-L;for(let ie=0;ie<g;ie++){const de=g>1?N*(h-1)+ie*q:.5*(N+z)*(h-1);if(de<0||de>h-1){for(let Ee=0;Ee<f;Ee++)y.values[Ee+ie*C[2]+$*C[1]+I*C[0]]=c;continue}const ue=Math.floor(de),he=Math.ceil(de),ge=de-ue;for(let Ee=0;Ee<f;Ee++){let _e=Ee+ue*w[2]+L*w[1]+W*w[0];const Me=v[_e];_e=Ee+he*w[2]+L*w[1]+W*w[0];const ke=v[_e];_e=Ee+ue*w[2]+H*w[1]+W*w[0];const Ze=v[_e];_e=Ee+he*w[2]+H*w[1]+W*w[0];const at=v[_e],Ht=Me+(ke-Me)*ge;_e=Ee+ie*C[2]+$*C[1]+I*C[0],y.values[_e]=Ht+(Ze+(at-Ze)*ge-Ht)*ne}}}else for(let L=0;L<g;++L){const H=g>1?N*(h-1)+L*q:.5*(N+z)*(h-1);if(H<0||H>h-1){for(let de=0;de<f;de++)y.values[de+L*C[2]+$*C[1]+I*C[0]]=c;continue}const ne=Math.round(H),ie=Math.round(V);for(let de=0;de<f;de++)y.values[de+L*C[2]+$*C[1]+I*C[0]]=v[de+ne*w[2]+ie*w[1]+W*w[0]]}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},Ige={kernelName:VS,backendName:"cpu",kernelFunc:function Ege(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;Te(s,"cumprod");const l=En([i],s.shape.length);let c=s;null!=l&&(c=gs({inputs:{x:s},backend:e,attrs:{perm:l}}));const u=Bn(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const d=Ds(c.dtype,"int32"),h=IS(X(c.shape),d),f=e.data.get(c.dataId).values,p=c.shape[c.shape.length-1],m=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=p)for(let b=0;b<p;b++){const _=m(y,b);if(0===b)h[_]=o?1:f[_];else{const v=m(y,b-1);h[_]=o?f[v]*h[v]:f[_]*h[v]}}const g=e.makeTensorInfo(c.shape,d,h);if(null!=l){const b=gs({inputs:{x:g},backend:e,attrs:{perm:il(l)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(c),b}return g}},Tge={kernelName:Yy,backendName:"cpu",kernelFunc:function Dge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;Te(s,"cumsum");const l=En([i],s.shape.length);let c=s;null!=l&&(c=gs({inputs:{x:s},backend:e,attrs:{perm:l}}));const u=Bn(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const d=Ds(c.dtype,"int32"),h=$r(X(c.shape),d),f=e.data.get(c.dataId).values,p=c.shape[c.shape.length-1],m=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=p)for(let b=0;b<p;b++){const _=m(y,b);if(0===b)h[_]=o?0:f[_];else{const v=m(y,b-1);h[_]=o?f[v]+h[v]:f[_]+h[v]}}const g=e.makeTensorInfo(c.shape,d,h);if(null!=l){const b=gs({inputs:{x:g},backend:e,attrs:{perm:il(l)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(c),b}return g}},Nge={kernelName:zS,backendName:"cpu",kernelFunc:function kge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o,binaryOutput:a}=r;if(1===s.shape.length){const u=e1(e.data.get(s.dataId).values,e.data.get(i.dataId).values,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,u)}if(2===s.shape.length){const u=I3(e.bufferSync(s),e.bufferSync(i),o,a);return e.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},Rge={kernelName:US,backendName:"cpu",kernelFunc:function Age(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:i,dataFormat:o}=r;S("NHWC"===o,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=s.shape[0],l=s.shape[1],c=s.shape[2],u=s.shape[3],d=l*i,h=c*i,f=u/(i*i),p=e.data.get(s.dataId).values,m=new Float32Array(a*d*h*f);let g=0;for(let y=0;y<a;++y)for(let b=0;b<d;++b){const _=Math.floor(b/i),v=b%i;for(let w=0;w<h;++w){const C=Math.floor(w/i),D=(v*i+w%i)*f;for(let T=0;T<f;++T)m[g++]=p[T+D+u*(C+c*(_+l*y))]}}return e.makeTensorInfo([a,d,h,f],s.dtype,m)}};function N3(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;Te([s,i],"depthwiseConv2DNative");const u=Pe(s.shape),d=Pe(i.shape);let h=l;null==h&&(h=[1,1]),S(Tr(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const f=vr(s.shape,i.shape,o,h,a,c,!0),{filterHeight:p,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=f,_=b.left,v=b.top,w=f.outChannels/f.inChannels,C=new br(f.outShape,s.dtype),I=e.data.get(s.dataId).values,D=e.data.get(i.dataId).values,T=C.values;for(let N=0;N<f.batchSize;++N){const P=N*u[0],z=N*C.strides[0];for(let W=0;W<f.outHeight;++W){const G=z+W*C.strides[1],q=W*f.strideHeight-v;for(let $=0;$<p;++$){const V=q+$*g;if(V<0||V>=f.inHeight)continue;const L=$*d[0],H=P+V*u[1];for(let ne=0;ne<f.outWidth;++ne){const ie=G+ne*C.strides[2],de=ne*f.strideWidth-_;for(let ue=0;ue<m;++ue){const he=de+ue*y;if(he<0||he>=f.inWidth)continue;const Ee=H+he*f.inChannels;let _e=ie,Me=L+ue*d[1];for(let ke=0;ke<f.inChannels;++ke){const Ze=I[Ee+ke];for(let at=0;at<w;++at)T[_e+at]+=Ze*D[Me+at];_e+=w,Me+=w}}}}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}const Mge={kernelName:Zy,backendName:"cpu",kernelFunc:N3},Oge={kernelName:HS,backendName:"cpu",kernelFunc:function Fge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r;Te([s,i],"depthwiseConv2dNativeBackpropFilter");const d=vr(s.shape,u,o,a,l,c,!0),{strideHeight:h,strideWidth:f,filterHeight:p,filterWidth:m}=d,g=new br(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,_=d.outChannels/d.inChannels,v=e.data.get(s.dataId).values,w=new br(s.shape,s.dtype,v),C=e.data.get(i.dataId).values,I=new br(i.shape,i.dtype,C);for(let D=0;D<p;++D){const T=Math.max(0,Math.ceil((b-D)/h)),N=Math.min(d.outHeight,(d.inHeight+b-D)/h);for(let P=0;P<m;++P){const z=Math.max(0,Math.ceil((y-P)/f)),W=Math.min(d.outWidth,(d.inWidth+y-P)/f);for(let G=0;G<d.outChannels;++G){const q=Math.trunc(G/_),$=G%_;let V=0;for(let L=0;L<d.batchSize;++L)for(let H=T;H<N;++H){const ne=D+H*h-b;for(let ie=z;ie<W;++ie)V+=w.get(L,ne,P+ie*f-y,q)*I.get(L,H,ie,G)}g.set(V,D,P,q,$)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}},Pge={kernelName:WS,backendName:"cpu",kernelFunc:function $ge(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r;Te([s,i],"depthwiseConv2DNativeBackpropInput");const d=Pe(s.shape),h=Pe(i.shape),f=vr(u,i.shape,o,a,l,c,!0),p=new br(f.inShape,"float32"),m=p.values,[g,y,b]=p.strides,_=e.data.get(s.dataId).values,[v,w,C]=d,I=e.data.get(i.dataId).values,[D,T,N]=h,{batchSize:P,filterHeight:z,filterWidth:W,inChannels:G,inHeight:q,inWidth:$,outChannels:V,outHeight:L,outWidth:H,strideHeight:ne,strideWidth:ie}=f,de=z-1-f.padInfo.top,ue=W-1-f.padInfo.left,he=V/G;for(let ge=0;ge<P;++ge)for(let Ee=0;Ee<G;++Ee)for(let _e=0;_e<q;++_e){const Me=_e-de,ke=Math.max(0,Math.ceil(Me/ne)),Ze=Math.min(L,(z+Me)/ne);for(let at=0;at<$;++at){const Ht=at-ue,an=Math.max(0,Math.ceil(Ht/ie)),pn=Math.min(H,(W+Ht)/ie);let vn=0;for(let Gt=ke;Gt<Ze;++Gt){const Fn=Gt*ne-Me;for(let Un=an;Un<pn;++Un){const Ar=v*ge+w*Gt+C*Un,kl=D*(z-1-Fn)+T*(W-1-(Un*ie-Ht))+N*Ee;for(let di=0;di<he;++di)vn+=_[Ar+(Ee*he+di)]*I[kl+di]}}m[g*ge+y*_e+b*at+Ee]=vn}}return e.makeTensorInfo(p.shape,p.dtype,p.values)}},Vge={kernelName:jS,backendName:"cpu",kernelFunc:function Lge(n){const{inputs:t,backend:e}=n,{x:r}=t,s=X(r.shape),i=e.data.get(r.dataId).values,o=it([s,s],r.dtype),a=o.values;for(let c=0;c<i.length;c++)a[c*s+c]=i[c];const l=[...r.shape,...r.shape];return e.makeTensorInfo(l,o.dtype,o.values)}},Bge={kernelName:Qy,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s}=n,{strides:i,pad:o,dilations:a}=e,l=t,c=l.data.get(r.dataId).values,u=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:f,inHeight:p,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:_,strideHeight:v,strideWidth:w,filterHeight:C,filterWidth:I,dilationHeight:D,dilationWidth:T,outShape:N}=xp(r.shape,s.shape,i,o,"NHWC",a),P=X(N),z=N.length,W=Kn(r.dtype,P);for(let q=0;q<f;++q)for(let $=0;$<y;++$){const V=$*v-_.top;for(let L=0;L<b;++L){const H=L*w-_.left;for(let ne=0;ne<g;++ne){let ie=Number.MIN_SAFE_INTEGER;for(let ue=0;ue<C;++ue){const he=V+ue*D;if(he>=0&&he<p)for(let ge=0;ge<I;++ge){const Ee=H+ge*T;if(Ee>=0&&Ee<m){const _e=To([q,he,Ee,ne],u,Pe(r.shape)),Me=To([ue,ge,ne],h,Pe(s.shape)),ke=c[_e]+d[Me];ke>ie&&(ie=ke)}}}W[To([q,$,L,ne],z,Pe(N))]=ie}}}return{dataId:l.write(ac(W,r.dtype),N,r.dtype),shape:N,dtype:r.dtype}}},zge={kernelName:qS,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:l}=e,c=t,u=Si(r.shape,c.data.get(r.dataId).values),d=Si(s.shape,c.data.get(s.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:_,strideWidth:v,filterHeight:w,filterWidth:C,dilationHeight:I,dilationWidth:D,outShape:T}=xp(r.shape,s.shape,o,a,"NHWC",l);S(i.rank===T.length,()=>`Error in ${qS}, dy must have the same rank as output ${T.length}, but got ${i.rank}`);const N=Si(T,c.data.get(i.dataId).values),P=IP(s.shape,s.dtype);for(let W=0;W<h;++W)for(let G=0;G<g;++G){const q=G*_-b.top;for(let $=0;$<y;++$){const V=$*v-b.left;for(let L=0;L<m;++L){let H=Number.MIN_SAFE_INTEGER,ne=0,ie=0;for(let de=0;de<w;++de){const ue=q+de*I;if(ue>=0&&ue<f)for(let he=0;he<C;++he){const ge=V+he*D;if(ge>=0&&ge<p){const Ee=u[W][ue][ge][L]+d[de][he][L];Ee>H&&(H=Ee,ne=de,ie=he)}}}P[ne][ie][L]+=N[W][G][$][L]}}}return{dataId:c.write(ac(P,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},Uge={kernelName:GS,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:l}=e,c=t,u=Si(r.shape,c.data.get(r.dataId).values),d=Si(s.shape,c.data.get(s.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:_,strideWidth:v,filterHeight:w,filterWidth:C,dilationHeight:I,dilationWidth:D,outShape:T}=xp(r.shape,s.shape,o,a,"NHWC",l);S(i.rank===T.length,()=>`Error in ${GS}, dy must have the same rank as output ${T.length}, but got ${i.rank}`);const N=Si(T,c.data.get(i.dataId).values),P=IP(r.shape,r.dtype);for(let W=0;W<h;++W)for(let G=0;G<g;++G){const q=G*_-b.top;for(let $=0;$<y;++$){const V=$*v-b.left;for(let L=0;L<m;++L){let H=Number.MIN_SAFE_INTEGER,ne=q<0?0:q,ie=V<0?0:V;for(let de=0;de<w;++de){const ue=q+de*I;if(ue>=0&&ue<f)for(let he=0;he<C;++he){const ge=V+he*D;if(ge>=0&&ge<p){const Ee=u[W][ue][ge][L]+d[de][he][L];Ee>H&&(H=Ee,ne=ue,ie=ge)}}}P[W][ne][ie][L]+=N[W][G][$][L]}}}return{dataId:c.write(ac(P,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},t1=Yn((n,t)=>n*t),Hge=ZT((n,t,e,r)=>({real:n*e-t*r,imag:n*r+t*e})),cv=Cr(Yf,t1,Hge),Wge={kernelName:Yf,backendName:"cpu",kernelFunc:cv};function em(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;let a;Te(s,"sum"),a="bool"===s.dtype?bl({inputs:{x:s},backend:e,attrs:{dtype:"int32"}}):zo({inputs:{x:s},backend:e});const l=a.shape.length,c=ht(i,a.shape),u=En(c,l);let d=c,h=a;null!=u&&(h=gs({inputs:{x:a},backend:e,attrs:{perm:u}}),d=Bn(d.length,l)),kr("sum",d,h.shape.length);const[f,p]=xr(h.shape,d);let g=lv(e,f,Ds(h.dtype,"int32"));const y=X(p),b=e.data.get(g.dataId).values,_=e.data.get(h.dataId).values;for(let v=0;v<b.length;++v){const w=v*y;let C=0;for(let I=0;I<y;++I)C+=_[w+I];b[v]=C}if(o){const w=g;g=sn({inputs:{x:g},backend:e,attrs:{shape:Vn(g.shape,c)}}),e.disposeIntermediateTensorInfo(w)}return e.disposeIntermediateTensorInfo(a),null!=u&&e.disposeIntermediateTensorInfo(h),g}const jge={kernelName:Ab,backendName:"cpu",kernelFunc:em},qge={kernelName:KS,backendName:"cpu",kernelFunc:function Gge(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,i=t,{allDims:o,summedDims:a,idDims:l}=FD(s,i.length);$D(o.length,l,i);const{path:c,steps:u}=PD(a,l),d=u.length;let h=null,f=o.length;const p=[];for(let m=0;m<d;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=OD(f,l[g]);let _;LD(y)?_=i[g]:(_=gs({inputs:{x:i[g]},backend:e,attrs:{perm:y}}),p.push(_));const v=_.shape.slice();for(let w=0;w<b.length;++w)v.splice(b[w],0,1);It(_.shape,v)||(_=sn({inputs:{x:_},backend:e,attrs:{shape:v}}),p.push(_)),null===h?h=_:(h=cv({inputs:{a:_,b:h},backend:e}),p.push(h))}m<d-1&&(c[m]>=0&&(h=em({inputs:{x:h},backend:e,attrs:{axis:c[m]-(o.length-f),keepDims:!1}}),p.push(h)),f--)}for(const m of p)m!==h&&e.disposeIntermediateTensorInfo(m);return h}},Xge={kernelName:XS,backendName:"cpu",kernelFunc:function Kge(n){const{inputs:t,backend:e}=n,{dy:r,y:s}=t;Te([r,s],"eluGrad");const i=new Float32Array(X(s.shape)),o=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values;for(let l=0;l<o.length;++l){const c=o[l];i[l]=c>=1?a[l]:a[l]*(c+1)}return e.makeTensorInfo(s.shape,"float32",i)}},A3=Yn((n,t)=>n===t?1:0),R3=Cr(Jy,A3,null,"bool"),Yge={kernelName:Jy,backendName:"cpu",kernelFunc:R3},Zge=ID,Qge=DD,Jge=TD,eye=kD,tye=ND,nye=AD,rye=Ut(Of,n=>{const t=Math.sign(n),e=Math.abs(n),r=1/(1+Zge*e);return t*(1-((((nye*r+tye)*r+eye)*r+Jge)*r+Qge)*r*Math.exp(-e*e))}),sye={kernelName:Of,backendName:"cpu",kernelFunc:rye},M3=yl(n=>Math.exp(n)),F3=Cd($f,M3,"float32"),iye={kernelName:$f,backendName:"cpu",kernelFunc:F3};function uv(n){const{inputs:t,backend:e,attrs:r}=n,{input:s}=t,{dim:i}=r,o=s.shape.length,a=s.shape.slice();let l=i;return i<0&&(S(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),sn({inputs:{x:s},backend:e,attrs:{shape:a}})}const oye={kernelName:eb,backendName:"cpu",kernelFunc:uv},O3=yl(n=>Math.expm1(n)),aye=Cd(Pf,O3),lye={kernelName:Pf,backendName:"cpu",kernelFunc:aye},cye=Yn((n,t)=>n/t),n1=Cr(Mf,cye),r1={kernelName:Mf,backendName:"cpu",kernelFunc:n1},$3=Yn((n,t)=>n-t),uye=ZT((n,t,e,r)=>({real:n-e,imag:t-r})),s1=Cr(dp,$3,uye),dye={kernelName:dp,backendName:"cpu",kernelFunc:s1};function P3(n,t,e){const r=n.shape,s=r[0],i=r[1],o=e.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[s,i],u=X(c),d=gr("float32",u),h=gr("float32",u);for(let g=0;g<s;g++){const y=Sc({inputs:{x:a},backend:e,attrs:{begin:[g,0],size:[1,i]}}),b=Sc({inputs:{x:l},backend:e,attrs:{begin:[g,0],size:[1,i]}}),_=Rs({inputs:{real:y,imag:b},backend:e}),{real:v,imag:w}=hye(_,t,e),C=_a(v,w);for(let I=0;I<i;I++){const D=RD(C,I);d[g*i+I]=D.real,h[g*i+I]=D.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(_)}const f=e.makeTensorInfo(c,"float32",d),p=e.makeTensorInfo(c,"float32",h),m=Rs({inputs:{real:f,imag:p},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),m}function hye(n,t,e){const r=X(n.shape),s=e.data.get(n.dataId),i=e.data.get(s.complexTensorInfos.real.dataId).values,o=e.data.get(s.complexTensorInfos.imag.dataId).values;if(function fye(n){return 0==(n&n-1)}(r)){const a=o1(i,o,r,t,e),l=[n.shape[0],n.shape[1]];if(t){const c=e.makeTensorInfo(l,"float32",a.real),u=e.makeTensorInfo(l,"float32",a.imag),d=e.makeTensorInfo([],"float32",Ka(r,"float32")),h=zo({inputs:{x:d},backend:e}),f=r1.kernelFunc({inputs:{a:c,b:d},backend:e}),p=r1.kernelFunc({inputs:{a:u,b:h},backend:e}),m=e.data.get(f.dataId).values,g=e.data.get(p.dataId).values;return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),{real:m,imag:g}}return a}{const l=function pye(n,t,e){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let i=0,o=0;for(let a=0;a<t;a++){const l=qV(s*a,t,e),c=RD(n,a);i+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}e&&(i/=t,o/=t),jV(r,i,o,s)}return r}(_a(i,o),r,t);return UV(l)}}function o1(n,t,e,r,s){if(1===e)return{real:n,imag:t};const i=_a(n,t),o=e/2,a=HV(i),l=a.real,c=a.imag,u=[l.length],d=s.makeTensorInfo(u,"float32",l),h=s.makeTensorInfo(u,"float32",c),f=Rs({inputs:{real:d,imag:h},backend:s}),p=WV(i),m=p.real,g=p.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),_=s.makeTensorInfo(y,"float32",g),v=Rs({inputs:{real:b,imag:_},backend:s}),w=o1(l,c,o,r,s),C=w.real,I=w.imag,D=[C.length],T=s.makeTensorInfo(D,"float32",C),N=s.makeTensorInfo(D,"float32",I),P=Rs({inputs:{real:T,imag:N},backend:s}),z=o1(m,g,o,r,s),W=z.real,G=z.imag,q=[W.length],$=s.makeTensorInfo(q,"float32",W),V=s.makeTensorInfo(q,"float32",G),L=Rs({inputs:{real:$,imag:V},backend:s}),H=GV(e,r),ne=[H.real.length],ie=s.makeTensorInfo(ne,"float32",H.real),de=s.makeTensorInfo(ne,"float32",H.imag),ue=Rs({inputs:{real:ie,imag:de},backend:s}),he=cv({inputs:{a:ue,b:L},backend:s}),ge=Sd({inputs:{a:P,b:he},backend:s}),Ee=s1({inputs:{a:P,b:he},backend:s}),_e=Cc({inputs:{input:ge},backend:s}),Me=Cc({inputs:{input:Ee},backend:s}),ke=Ed({inputs:{input:ge},backend:s}),Ze=Ed({inputs:{input:Ee},backend:s}),at=Id({inputs:[_e,Me],backend:s,attrs:{axis:0}}),Ht=Id({inputs:[ke,Ze],backend:s,attrs:{axis:0}}),an=s.data.get(at.dataId).values,pn=s.data.get(Ht.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo(ie),s.disposeIntermediateTensorInfo(de),s.disposeIntermediateTensorInfo(ue),s.disposeIntermediateTensorInfo(he),s.disposeIntermediateTensorInfo(ge),s.disposeIntermediateTensorInfo(Ee),s.disposeIntermediateTensorInfo(_e),s.disposeIntermediateTensorInfo(ke),s.disposeIntermediateTensorInfo(Me),s.disposeIntermediateTensorInfo(Ze),s.disposeIntermediateTensorInfo(at),s.disposeIntermediateTensorInfo(Ht),{real:an,imag:pn}}const gye={kernelName:"FFT",backendName:"cpu",kernelFunc:function mye(n){const{inputs:t,backend:e}=n,{input:r}=t,s=X(r.shape),i=r.shape[r.shape.length-1],a=sn({inputs:{x:r},backend:e,attrs:{shape:[s/i,i]}}),l=P3(a,!1,e),c=sn({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}};function a1(n){const{backend:t,attrs:e}=n,{shape:r,value:s,dtype:i}=e,o=i||vf(s),a=Kn(o,X(r));return function bye(n,t,e){n.fill(t)}(a,s),t.makeTensorInfo(r,o,a)}const yye={kernelName:ZS,backendName:"cpu",kernelFunc:a1},_ye={kernelName:QS,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{image:r}=n,s=e,i=gr(r.dtype,X(r.shape)),[o,a,l,c]=r.shape,u=s.data.get(r.dataId).values;for(let h=0;h<o;h++){const f=h*l*a*c;for(let p=0;p<a;p++){const m=p*(l*c);for(let g=0;g<l;g++){const y=g*c;for(let b=0;b<c;b++){const _=Math.round(l-g-1),v=f+m+y+b;let w=u[v];_>=0&&_<l&&(w=u[f+m+_*c+b]),i[v]=w}}}}return{dataId:s.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},L3=yl(n=>Math.floor(n)),vye=Cd(Lf,L3),xye={kernelName:Lf,backendName:"cpu",kernelFunc:vye},wye=Yn((n,t)=>Math.floor(n/t)),Cye=Cr(Vf,wye,null,"int32"),Sye={kernelName:Vf,backendName:"cpu",kernelFunc:Cye},Iye={kernelName:Vb,backendName:"cpu",kernelFunc:function Eye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r;let m=k3({inputs:{x:s,filter:i},backend:e,attrs:{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h}});if(o){const g=m;if("NCHW"===u&&1===o.shape.length&&1!==o.shape[0]){const y=sn({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});m=Sd({inputs:{a:m,b:y},backend:e}),e.disposeIntermediateTensorInfo(y)}else m=Sd({inputs:{a:m,b:o},backend:e});e.disposeIntermediateTensorInfo(g)}if(f){const g=m;if("NCHW"===u&&"prelu"===f&&1===a.shape.length&&1!==a.shape[0]){const y=sn({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});m=av(e,m,f,y,p),e.disposeIntermediateTensorInfo(y)}else m=av(e,m,f,a,p);e.disposeIntermediateTensorInfo(g)}return m}},Tye={kernelName:Bb,backendName:"cpu",kernelFunc:function Dye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r;let m=N3({inputs:{x:s,filter:i},backend:e,attrs:{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h}});if(o){const g=m;m=Sd({inputs:{a:m,b:o},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){const g=m;m=av(e,m,f,a,p),e.disposeIntermediateTensorInfo(g)}return m}};function V3(n,t,e,r,s,i,o,a,l){const c=it([r,i],e);for(let u=0;u<r;u++){const d=[];let h=0;for(let f=0;f<s;f++){const p=n[u*s+f];h+=p*o[f],d.push(p)}if(h<0||h>=l/i)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let f=0;f<i;f++)c.values[u*i+f]=t.get(...t.indexToLoc(h*i+f))}return c}const Nye={kernelName:JS,backendName:"cpu",kernelFunc:function kye(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,i=X(r.shape),o=s.shape,a=o[o.length-1],[l,c,u,d]=ED(r,s);if(0===c)return e.makeTensorInfo(l,r.dtype,[]);const p=V3(e.data.get(s.dataId).values,e.bufferSync(r),r.dtype,c,a,u,d,r.shape,i);return e.makeTensorInfo(l,r.dtype,p.values)}};function B3(n,t,e){const r=it(e,n.dtype);for(let s=0;s<r.size;++s){const o=r.indexToLoc(s).slice(),c=t.locToIndex([o[0],o[2]]);o[2]=t.values[c];const u=n.locToIndex(o);0<=u&&u<n.values.length&&(r.values[s]=n.values[u])}return r}const Rye={kernelName:nb,backendName:"cpu",kernelFunc:function Aye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:i}=t,{axis:o,batchDims:a}=r;Te([s,i],"gatherV2");const l=ht(o,s.shape)[0],c=e.data.get(i.dataId).values,u=s.shape[l];for(let v=0;v<c.length;++v){const w=c[v];S(w<=u-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${u-1}]`)}let d=a;null==a&&(d=0);const h=X(i.shape),f=zD(s,i,l,d),p=sn({inputs:{x:s},backend:e,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),m=sn({inputs:{x:i},backend:e,attrs:{shape:[f.batchSize,h/f.batchSize]}}),g=[f.batchSize,f.outerSize,h/f.batchSize,f.sliceSize],y=e.bufferSync(m),_=B3(e.bufferSync(p),y,g);return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.makeTensorInfo(f.outputShape,_.dtype,_.values)}},z3=Yn((n,t)=>n>t?1:0),Mye=Cr(rb,z3,null,"bool"),Fye={kernelName:rb,backendName:"cpu",kernelFunc:Mye},U3=Yn((n,t)=>n>=t?1:0),Oye=Cr(Bf,U3,null,"bool"),$ye={kernelName:Bf,backendName:"cpu",kernelFunc:Oye},Lye={kernelName:eE,backendName:"cpu",kernelFunc:function Pye(n){const{inputs:t,backend:e}=n,{input:r}=t,s=X(r.shape),i=r.shape[r.shape.length-1],a=sn({inputs:{x:r},backend:e,attrs:{shape:[s/i,i]}}),l=P3(a,!0,e),c=sn({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}},Vye=Ut(Uf,n=>Number.isFinite(n)?1:0,"bool"),Bye={kernelName:Uf,backendName:"cpu",kernelFunc:Vye},zye=Ut(Hf,n=>Math.abs(n)===1/0?1:0,"bool"),Uye={kernelName:Hf,backendName:"cpu",kernelFunc:zye},Hye=Ut(Wf,n=>Number.isNaN(n)?1:0,"bool"),Wye={kernelName:Wf,backendName:"cpu",kernelFunc:Hye},H3=Yn((n,t)=>n<t?1:0),jye=Cr(ib,H3,null,"bool"),Gye={kernelName:ib,backendName:"cpu",kernelFunc:jye},W3=Yn((n,t)=>n<=t?1:0),qye=Cr(ob,W3,null,"bool"),Kye={kernelName:ob,backendName:"cpu",kernelFunc:qye};function j3(n,t,e){const r=(t-n)/(e-1),s=$r(e,"float32");s[0]=n;for(let i=1;i<s.length;i++)s[i]=s[i-1]+r;return s}const Yye={kernelName:nE,backendName:"cpu",kernelFunc:function Xye(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:i}=e,o=j3(r,s,i);return t.makeTensorInfo([o.length],"float32",o)}},G3=yl(n=>Math.log(n)),Zye=Cd(jf,G3),Qye={kernelName:jf,backendName:"cpu",kernelFunc:Zye},Jye=Ut(Gf,n=>Math.log1p(n)),ebe={kernelName:Gf,backendName:"cpu",kernelFunc:Jye},tbe=Yn((n,t)=>n&&t),nbe=Cr(ab,tbe,null,"bool"),rbe={kernelName:ab,backendName:"cpu",kernelFunc:nbe},sbe=Ut(lb,n=>n?0:1,"bool"),ibe={kernelName:lb,backendName:"cpu",kernelFunc:sbe},obe=Yn((n,t)=>n||t),abe=Cr(cb,obe,null,"bool"),lbe={kernelName:cb,backendName:"cpu",kernelFunc:abe},ube={kernelName:ub,backendName:"cpu",kernelFunc:function cbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:i,bias:o,alpha:a,beta:l}=r;Te(s,"LRN");const c=s.shape[3],u=c-1,d=e.data.get(s.dataId).values,h=X(s.shape),f=new Float32Array(h);function p(m){const g=m%c;let y=m-g+Math.max(0,g-i);const b=m-g+Math.min(g+i,u);let _=0;for(;y<=b;y++){const v=d[y];_+=v*v}return _}for(let m=0;m<h;m++){const g=p(m),y=d[m]*Math.pow(o+a*g,-l);f[m]=y}return e.makeTensorInfo(s.shape,s.dtype,f)}},hbe={kernelName:rE,backendName:"cpu",kernelFunc:function dbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,y:i,dy:o}=t,{depthRadius:a,bias:l,alpha:c,beta:u}=r;Te(o,"LRNGrad");const d=X(o.shape),h=o.shape[3],f=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,m=e.data.get(i.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){const _=b%h,v=b-_+Math.max(0,_-a),w=b-_+Math.min(h,_+a+1);let C=0;for(let I=v;I<w;I++)C+=Math.pow(p[I],2);C=c*C+l;for(let I=v;I<w;I++){let D=-2*c*u*p[I]*m[b]/C;b===I&&(D+=Math.pow(C,-u)),D*=f[b],g[I]+=D}}return e.makeTensorInfo(o.shape,s.dtype,g)}};function q3(n,t,e,r){const s=gr(r,X(e));for(let i=0;i<s.length;++i){const o=i*t;let a=n[o];for(let l=0;l<t;++l){const c=n[o+l];(Number.isNaN(c)||c>a)&&(a=c)}s[i]=a}return s}function K3(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:i,keepDims:o}=r,a=e;let l=s.shape;const c=l.length,u=ht(i,l);let d=u;const h=En(d,c);let f=a.data.get(s.dataId).values;if(null!=h){const v=new Array(c);for(let w=0;w<v.length;w++)v[w]=l[h[w]];f=QT(f,l,s.dtype,h,v),d=Bn(d.length,c),l=v}Te(s,"max"),kr("max",d,c);const[p,m]=xr(l,d),y=q3(f,X(m),p,s.dtype),b=a.write(y,p,s.dtype);let _=p;return o&&(_=Vn(p,u)),{dataId:b,shape:_,dtype:s.dtype}}const fbe={kernelName:db,backendName:"cpu",kernelFunc:K3},X3=Yn((n,t)=>Math.max(n,t)),pbe=Cr(qf,X3),mbe={kernelName:qf,backendName:"cpu",kernelFunc:pbe},ybe={kernelName:hb,backendName:"cpu",kernelFunc:function gbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Te(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r;S(Tr(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=Ii(s.shape,i,o,1,a,l);let d;if(1===u.filterWidth&&1===u.filterHeight&&It(u.inShape,u.outShape))d=zo({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,f=Pe(s.shape),p=JT(h,0,s.dtype,f,u,"max");d=e.makeTensorInfo(u.outShape,s.dtype,p.values)}return d}},_be={kernelName:fb,backendName:"cpu",kernelFunc:function bbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r;Te(s,"maxPool3d");const u=pa(s.shape,i,o,1,a,l,c),h=S3(e.data.get(s.dataId).values,0,s.dtype,Pe(s.shape),u,"max");return e.makeTensorInfo(h.shape,"float32",h.values)}},xbe={kernelName:iE,backendName:"cpu",kernelFunc:function vbe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;Te([s,i],"maxPool3DGrad");const u=pa(i.shape,o,a,1,l,c),h=function Pme(n,t){const e=it(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,i=t.strideWidth,o=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,u=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,f=t.padInfo.top,p=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-h;let _=b;for(;_<0;)_+=o;const v=Math.min(t.inDepth,c+b);for(let w=0;w<t.outHeight;++w){const C=w*s-f;let I=C;for(;I<0;)I+=a;const D=Math.min(t.inHeight,u+C);for(let T=0;T<t.outWidth;++T){const N=T*i-p;let P=N;for(;P<0;)P+=l;const z=Math.min(t.inWidth,d+N);let W=Number.NEGATIVE_INFINITY,G=-1;for(let q=_;q<v;q+=o){const $=q-b;for(let V=I;V<D;V+=a){const L=V-C;for(let H=P;H<z;H+=l){const ne=H-N,ie=n.get(m,q,V,H,g);ie>=W&&(W=ie,G=$*u*d+L*u+ne)}}}e.set(G,m,y,w,T,g)}}}return e}(e.bufferSync(i),u),f=u.strideDepth,p=u.strideHeight,m=u.strideWidth,g=u.dilationDepth,y=u.dilationHeight,b=u.dilationWidth,_=u.effectiveFilterDepth,v=u.effectiveFilterHeight,w=u.effectiveFilterWidth,C=_-1-u.padInfo.front,I=w-1-u.padInfo.left,D=v-1-u.padInfo.top,T=it(i.shape,"float32"),N=e.bufferSync(s);for(let P=0;P<u.batchSize;++P)for(let z=0;z<u.inChannels;++z)for(let W=0;W<u.inDepth;++W)for(let G=0;G<u.inHeight;++G)for(let q=0;q<u.inWidth;++q){const $=W-C,V=G-D,L=q-I;let H=0;for(let ne=0;ne<_;ne+=g){const ie=($+ne)/f;if(!(ie<0||ie>=u.outDepth||Math.floor(ie)!==ie))for(let de=0;de<v;de+=y){const ue=(V+de)/p;if(!(ue<0||ue>=u.outHeight||Math.floor(ue)!==ue))for(let he=0;he<w;he+=b){const ge=(L+he)/m;if(ge<0||ge>=u.outWidth||Math.floor(ge)!==ge)continue;const Me=_*v*w-1-h.get(P,ie,ue,ge,z)===ne*v*w+de*w+he?1:0;0!==Me&&(H+=N.get(P,ie,ue,ge,z)*Me)}}}T.set(H,P,W,G,q,z)}return e.makeTensorInfo(T.shape,T.dtype,T.values)}},Cbe={kernelName:sE,backendName:"cpu",kernelFunc:function wbe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i,output:o}=t,a=i;Te([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=r,h=Ii(a.shape,l,c,1,u,d),f=e.data.get(a.dataId).values,p=it(h.outShape,a.dtype,C3(f,a.shape,a.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,_=h.effectiveFilterHeight,v=h.effectiveFilterWidth,w=v-1-h.padInfo.left,C=_-1-h.padInfo.top,I=it(a.shape,"float32"),D=e.data.get(s.dataId).values,T=it(s.shape,"float32",D);for(let N=0;N<h.batchSize;++N)for(let P=0;P<h.inChannels;++P)for(let z=0;z<h.inHeight;++z)for(let W=0;W<h.inWidth;++W){const G=z-C,q=W-w;let $=0;for(let V=0;V<_;V+=y){const L=(G+V)/m;if(!(L<0||L>=h.outHeight||Math.floor(L)!==L))for(let H=0;H<v;H+=b){const ne=(q+H)/g;if(ne<0||ne>=h.outWidth||Math.floor(ne)!==ne)continue;const ue=_*v-1-p.get(N,L,ne,P)===V*v+H?1:0;0!==ue&&($+=T.get(N,L,ne,P)*ue)}}I.set($,N,z,W,P)}return e.makeTensorInfo(I.shape,I.dtype,I.values)}},Ebe={kernelName:oE,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=t,l=e;Te(r,"MaxPoolWithArgmax");const c=l.data.get(r.dataId).values,u=Ii(r.shape,s,i,[1,1],o),[d,h]=function Sbe(n,t,e,r,s){const o=JT(n,0,e,Pe(t),s,"max"),a=C3(n,t,e,s,!0,r);return[o.values,a.values]}(c,r.shape,r.dtype,a,u),f=l.write(d,u.outShape,r.dtype),p=l.write(h,u.outShape,r.dtype);return[{dataId:f,shape:u.outShape,dtype:r.dtype},{dataId:p,shape:u.outShape,dtype:"int32"}]}},Dbe={kernelName:pb,backendName:"cpu",kernelFunc:function Ibe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=ht(i,s.shape),u=X(xr(s.shape,a)[1]),d=[],h=e.makeTensorInfo([],"float32",new Float32Array([u]));d.push(h);const f=bl({inputs:{x:s},backend:e,attrs:{dtype:"float32"}});d.push(f);const p=n1({inputs:{a:f,b:h},backend:e});d.push(p);const m=em({inputs:{x:p},backend:e,attrs:{axis:i,keepDims:o}});return d.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}},kbe={kernelName:mb,backendName:"cpu",kernelFunc:function Tbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;Te(s,"min");const a=ht(i,s.shape);let l=a;const c=En(l,s.shape.length);let u=s;null!=c&&(u=gs({inputs:{x:s},backend:e,attrs:{perm:c}}),l=Bn(l.length,s.shape.length)),kr("min",l,u.shape.length);const[d,h]=xr(u.shape,l),f=X(h),p=$r(X(d),u.dtype),m=e.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let _=m[b];for(let v=0;v<f;++v){const w=m[b+v];(Number.isNaN(w)||w<_)&&(_=w)}p[y]=_}null!=c&&e.disposeIntermediateTensorInfo(u);const g=e.makeTensorInfo(d,u.dtype,p);if(o){const b=sn({inputs:{x:g},backend:e,attrs:{shape:Vn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},Y3=Yn((n,t)=>Math.min(n,t)),Nbe=Cr(Kf,Y3),Abe={kernelName:Kf,backendName:"cpu",kernelFunc:Nbe},Mbe={kernelName:gb,backendName:"cpu",kernelFunc:function Rbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:i,mode:o}=r;Te(s,"mirrorPad");const a=i.map((_,v)=>_[0]+s.shape[v]+_[1]),l=i.map(_=>_[0]),c=i.map((_,v)=>_[0]+s.shape[v]),u="reflect"===o?0:1,d=e.data.get(s.dataId).values,h=s.shape.length,f=Pe(s.shape),p=X(a),m=a.length,g=Pe(a),y=gr(s.dtype,p);for(let _=0;_<p;_++){let v=Ku(_,m,g);for(let C=0;C<m;C++)v[C]<l[C]?v[C]=2*l[C]-v[C]-u:v[C]>=c[C]&&(v[C]=2*(c[C]-1)-v[C]+u);v=v.map((C,I)=>C-l[I]);const w=To(v,h,f);y[_]=d[w]}return{dataId:e.write(y,a,s.dtype),shape:a,dtype:s.dtype}}},Fbe=Yn((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),Obe=Cr(Xf,Fbe),$be={kernelName:Xf,backendName:"cpu",kernelFunc:Obe};function Z3(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:i}=r,o=s.shape.length;let a=i;if(-1===a&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=ht([a],s.shape),c=K3({inputs:{x:s},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),u=Vn(c.shape,l),d=sn({inputs:{x:c},backend:e,attrs:{shape:u}}),h=s1({inputs:{a:s,b:d},backend:e}),f=F3({inputs:{x:h},backend:e}),p=em({inputs:{x:f},backend:e,attrs:{axis:l,keepDims:!1}}),m=sn({inputs:{x:p},backend:e,attrs:{shape:u}}),g=n1({inputs:{a:f,b:m},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),g}const Pbe={kernelName:Fb,backendName:"cpu",kernelFunc:Z3},Vbe={kernelName:aE,backendName:"cpu",kernelFunc:function Lbe(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:i,seed:o,normalized:a}=r;Te(s,"multinomial");const l=a?s:Z3({inputs:{logits:s},backend:e,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],d=e.data.get(l.dataId).values,h=[c,i],f=$r(X(h),"int32");for(let p=0;p<c;++p){const m=p*u,g=new Float32Array(u-1);g[0]=d[m];for(let _=1;_<g.length;++_)g[_]=g[_-1]+d[m+_];const y=y_.alea(o.toString()),b=p*i;for(let _=0;_<i;++_){const v=y();f[b+_]=g.length;for(let w=0;w<g.length;w++)if(v<g[w]){f[b+_]=w;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(h,"int32",f)}};function Q3(n,t,e){const r=Ka(-1,e);return t1([],t,r,n,e)}const zbe={kernelName:yb,backendName:"cpu",kernelFunc:function Bbe(n){const{inputs:t,backend:e}=n,{x:r}=t;Te(r,"neg");const s=e.data.get(r.dataId).values,[i,o]=Q3(s,r.shape,r.dtype);return e.makeTensorInfo(o,r.dtype,i)}},Ube=aD,Wbe={kernelName:lE,backendName:"cpu",kernelFunc:function Hbe(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r;Te(s,"NonMaxSuppression");const c=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values,{selectedIndices:d}=Ube(c,u,o,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},jbe=lD,qbe={kernelName:cE,backendName:"cpu",kernelFunc:function Gbe(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r;Te(s,"NonMaxSuppressionPadded");const u=e.data.get(s.dataId).values,d=e.data.get(i.dataId).values,{selectedIndices:h,validOutputs:f}=jbe(u,d,o,a,l,c);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},Kbe=cD,Ybe={kernelName:uE,backendName:"cpu",kernelFunc:function Xbe(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r;Te(s,"NonMaxSuppressionWithScore");const u=e.data.get(s.dataId).values,d=e.data.get(i.dataId).values,h=o,f=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=Kbe(u,d,h,f,p,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},J3=Yn((n,t)=>n!==t?1:0),Zbe=Cr(bb,J3,null,"bool"),Qbe={kernelName:bb,backendName:"cpu",kernelFunc:Zbe},e_e={kernelName:vb,backendName:"cpu",kernelFunc:function Jbe(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{dtype:i,depth:o,onValue:a,offValue:l}=r;Te(s,"oneHot");const c=X(s.shape),u=new Float32Array(c*o);u.fill(l);const d=e.data.get(s.dataId).values;for(let h=0;h<c;++h)d[h]>=0&&d[h]<o&&(u[h*o+d[h]]=a);return e.makeTensorInfo([...s.shape,o],i,u)}};function dv(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const s=Cc({inputs:{input:r},backend:e}),i=dv({inputs:{x:s},backend:e}),o=Ed({inputs:{input:r},backend:e}),a=dv({inputs:{x:o},backend:e}),l=Rs({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return a1({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const t_e={kernelName:Pb,backendName:"cpu",kernelFunc:dv},n_e={kernelName:_b,backendName:"cpu",kernelFunc:function eU(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const s=Cc({inputs:{input:r},backend:e}),i=eU({inputs:{x:s},backend:e}),o=Ed({inputs:{input:r},backend:e}),a=dv({inputs:{x:o},backend:e}),l=Rs({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return a1({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function tU(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return uv({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const i=t[0].shape,o=t[0].dtype;t.forEach(u=>{Is(i,u.shape,"All tensors passed to stack must have matching shapes"),S(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=Id({inputs:t.map(u=>{const d=uv({inputs:{input:u},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(u=>e.disposeIntermediateTensorInfo(u)),c}const r_e={kernelName:xb,backendName:"cpu",kernelFunc:tU},nU={kernelName:wb,backendName:"cpu",kernelFunc:function s_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:i,constantValue:o}=r;Te(s,"pad");const a=i.map((b,_)=>b[0]+s.shape[_]+b[1]),l=i.map(b=>b[0]),c=e.data.get(s.dataId).values,u=X(s.shape),d=s.shape.length,h=Pe(s.shape),f=X(a),p=a.length,m=Pe(a),g=gr(s.dtype,f);0!==o&&g.fill(o);for(let b=0;b<u;b++)g[To(Ku(b,d,h).map((C,I)=>C+l[I]),p,m)]=c[b];return{dataId:e.write(g,a,s.dtype),shape:a,dtype:s.dtype}}},i_e=Yn((n,t)=>Math.pow(n,t)),o_e=Cr(Zf,i_e),a_e={kernelName:Zf,backendName:"cpu",kernelFunc:o_e};function rU(n,t,e,r){const[s,i]=xr(n,r),o=Ds(t,"int32"),a=$r(X(s),o),l=X(i);for(let c=0;c<a.length;++c){const u=c*l;let d=1;for(let h=0;h<l;++h)d*=e[u+h];a[c]=d}return{outVals:a,outShape:s,outDtype:o}}const c_e={kernelName:Sb,backendName:"cpu",kernelFunc:function l_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;Te(s,"prod");const a=s.shape.length,l=ht(i,s.shape),c=En(l,a);let u=l,d=s;const h=[];null!=c&&(d=gs({inputs:{x:s},backend:e,attrs:{perm:c}}),h.push(d),u=Bn(u.length,a));const f=e.data.get(d.dataId).values,{outVals:p,outShape:m,outDtype:g}=rU(d.shape,d.dtype,f,u);let y=m;return o&&(y=Vn(m,l)),h.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(y,g,p)}};function sU(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let r=t;r<n.length;r++)e[t-1]*=n[r];return e}function iU(n,t,e,r,s,i,o,a){if(0===n.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function u_e(n,t,e){n.forEach((r,s)=>{if(r<0||r>=e){const i=Ku(s,t.length,Pe(t)).join(",");throw new Error(`indices[${i}] = ${r} is not in [0, ${e})`)}})}(i,o,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:u,valueSlices:d,numValues:h}=function h_e(n,t,e,r){const s=[];let i=0;const a=new Array(t.length-1+e.length).fill(null).map(()=>[0]);!function d_e(n,t){for(let e=0;e<n.length;++e){const r=n[e],s=e===n.length-1?t:n[e+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let i=1;i<r.length;++i)if(r[i-1]>r[i])throw new Error("Ragged splits must be sorted in ascending order")}}(e,r);let l=1;for(let c=0;c<t.length-1;++c){l*=t[c];const u=t[c+1];for(let d=1;d<l+1;++d)a[c].push(d*u)}for(let c=0;c<n.length;++c){let u=n[c],d=n[c]+1;for(let h=0;h<e.length;++h){const f=e[h],p=h+t.length-1;if(p>=0){const m=a[p],g=m[m.length-1]-f[u];for(let y=u;y<d;++y)a[p].push(f[y+1]+g)}u=f[u],d=f[d]}d!==u&&(s.push([u,d]),i+=d-u)}return{outSplits:a,valueSlices:s,numValues:i}}(i,o,n,c),f=function f_e(n){const t=[];for(let e=0;e<n.length;++e){const s=Kn("int32",n[e].length);t.push(s),n[e].forEach((i,o)=>s[o]=i)}return t}(u),p=function m_e(n,t,e,r,s){const i=t.slice();i[0]=s;const o=Kn(e,X(i)),a=n.length;return function p_e(n,t,e,r,s,i){const o=sU(t,2)[1],a=sU(i,2)[1];let l=0;for(const c of e)for(let u=c[0];u<c[1];++u){for(let d=0;d<r;++d)s[l*a+d]=n[u*o+d];++l}}(n,t,r,0===a?0:a/t[0],o,i),[o,i]}(e,r,s,d,h);return[f,p[0],p[1]]}const y_e={kernelName:dE,backendName:"cpu",kernelFunc:function g_e(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=t,l=s.map(y=>e.data.get(y.dataId).values),c=s.map(y=>y.shape),u=e.data.get(i.dataId).values,d=e.data.get(o.dataId).values,[h,f,p]=iU(l,c,u,i.shape,i.dtype,d,o.shape),m=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),g=e.makeTensorInfo(p,i.dtype,f);return m.concat([g])}},oU=2147483647;function aU(n,t,e,r,s,i,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=0===t.length,l=0===s.length,c=0===o.length,u=[];a||u.push(t[0]),l||u.push(s[0]),c||u.push(o[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===u.length?1:u[0],h=Kn("int32",d+1);h[0]=0;for(let g=0;g<d;++g){const y=a?n[0]:n[g],b=l?r[0]:r[g],_=c?i[0]:i[g];if(0===_)throw new Error("Requires delta != 0");let v;if(_>0&&b<y||_<0&&b>y)v=0;else if(v=Math.ceil(Math.abs((b-y)/_)),v>oU)throw new Error(`Requires ((limit - start) / delta) <= ${oU}`);h[g+1]=h[g]+v}const p=Kn(e,h[d]);let m=0;for(let g=0;g<d;++g){const y=h[g+1]-h[g];let b=a?n[0]:n[g];const _=c?i[0]:i[g];for(let v=0;v<y;++v)p[m++]=b,b+=_}return[h,p]}const __e={kernelName:hE,backendName:"cpu",kernelFunc:function b_e(n){const{inputs:t,backend:e}=n,{starts:r,limits:s,deltas:i}=t,o=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,[c,u]=aU(o,r.shape,r.dtype,a,s.shape,l,i.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([u.length],r.dtype,u)]}};var $i=Ai;class hv{constructor(t,e,r,s,i,o,a,l,c,u){this.shape=t,this.shapeShape=e,this.values=r,this.valuesShape=s,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=VV(u),this.raggedRank=BV(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===$i.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===$i.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case $i.VALUE_ROWIDS:return hv.getMaxWidthValueRowID(e);case $i.ROW_SPLITS:return hv.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${$i[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let r=0;for(let s=0;s<e-1;++s){const i=t[s+1]-t[s];i>r&&(r=i)}return r}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let r=0,s=t[0],i=0;for(let o=1;o<e;++o){const a=t[o];a!==s&&(s=a,i=Math.max(o-r,i),r=o)}return Math.max(e-r,i)}tensorShapeFromTensor(t,e,r=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return cU(t,r)}calculateOutputSize(t){const e=this.valuesShape;zV(this.defaultValueShape,e);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=LV(this.raggedRank,s,e);o[0]<0&&(o[0]=t);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(t,e,r){const s=Math.min(t,r),i=[];let o=0;for(let a=0;a<s;++a,o+=e)i.push(o);for(let a=s;a<t;++a)i.push(-1);return S(i.length===t,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(t,e,r,s){const i=t.length,o=[];for(let a=0;a<i-1;++a){const l=t[a+1]-t[a];let c=Math.min(s,l),u=e[a];-1===u&&(c=0);for(let d=0;d<c;++d)o.push(u),u+=r;for(let d=0;d<l-c;++d)o.push(-1)}if(i>0&&o.length!==t[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,e,r,s){const i=t.length,o=[];if(0===i)return[];let a=0,l=t[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let c=e[l];o.push(c);for(let u=1;u<i;++u){const d=t[u];if(d===l)c>=0&&(++a,a<s?c+=r:c=-1);else{if(a=0,l=d,d>=e.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${e.length}`);c=e[d]}o.push(c)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,e,r,s){const i=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case $i.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,e,r,s);case $i.ROW_SPLITS:if(i.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(i,e,r,s);default:throw new Error(`Unsupported partition type: ${$i[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case $i.FIRST_DIM_SIZE:return t[0];case $i.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case $i.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${$i[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const i=cU(r,!1),o=Kn(this.valuesDType,X(i));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(e,s[0],r[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,s[c],r[c]);this.setOutput(this.raggedRank,l,o,i)}return[i,o]}setOutput(t,e,r,s){if(0===r.length)return;const i=this.values,o=r;let a=s.slice();a=a.slice(t+1);const l=X(a),c=e.length;let u=this.defaultValue;if(u.length!==l&&1!==u.length){const p=this.defaultValueShape;B(()=>{const m=F(u,p);u=cd(m,a).dataSync()})}let d=0,h=0,f=0;for(let p=0;p<=c;++p){let m=p<c?e[p]:-1;if(m!==f){if(h<f){const g=i.subarray(d*l);lU(o.subarray(h*l),g,(f-h)*l)}if(p>=c&&(m=Math.floor(r.length/l)),m>f)if(1===this.defaultValue.length)o.subarray(f*l,m*l).fill(this.defaultValue[0]),f=m;else for(;m>f;)lU(o.slice(f*l),u,l),++f;m<0?(d=p+1,h=f):(d=p,h=f,f=h+1)}else++f}}}function lU(n,t,e){for(let r=0;r<e;r++)n[r]=t[r]}function cU(n,t){const e=[];for(let r of n){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function uU(n,t,e,r,s,i,o,a,l,c){return new hv(n,t,e,r,s,i,o,a,l,c).compute()}const x_e={kernelName:fE,backendName:"cpu",kernelFunc:function v_e(n){const{inputs:t,backend:e,attrs:r}=n,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=r,c=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values,d=e.data.get(o.dataId).values,h=a.map(g=>e.data.get(g.dataId).values),f=a.map(g=>g.shape),[p,m]=uU(c,s.shape,u,i.shape,i.dtype,d,o.shape,h,f,l);return e.makeTensorInfo(p,i.dtype,m)}};function dU(n,t,e,r){if(n===t||n<t&&e<0||t<n&&e>1)return $r(0,r);const l=$r(Math.abs(Math.ceil((t-n)/e)),r);t<n&&1===e&&(e=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+e;return l}const C_e={kernelName:pE,backendName:"cpu",kernelFunc:function w_e(n){const{backend:t,attrs:e}=n,{start:r,stop:s,dtype:i,step:o}=e,a=dU(r,s,o,i);return t.makeTensorInfo([a.length],i,a)}},S_e=Ut(Qf,n=>1/n),E_e={kernelName:Qf,backendName:"cpu",kernelFunc:S_e},D_e={kernelName:Db,backendName:"cpu",kernelFunc:function I_e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r;Te(s,"resizeBilinear");const l=Pe(s.shape),[c,u]=a,[d,h,f,p]=s.shape,m=e.data.get(s.dataId).values,g=new Float32Array(X([d,c,u,p])),y=[i&&c>1?h-1:h,i&&u>1?f-1:f],b=[i&&c>1?c-1:c,i&&u>1?u-1:u];let _=0;const v=y[0]/b[0],w=y[1]/b[1];for(let C=0;C<d;C++)for(let I=0;I<c;I++){let D;D=o?v*(I+.5)-.5:v*I;const T=Math.max(0,Math.floor(D)),N=D-T,P=Math.min(h-1,Math.ceil(D)),z=C*l[0]+T*l[1],W=C*l[0]+P*l[1];for(let G=0;G<u;G++){let q;q=o?w*(G+.5)-.5:w*G;const $=Math.max(0,Math.floor(q)),V=q-$,L=Math.min(f-1,Math.ceil(q)),H=z+$*l[2],ne=W+$*l[2],ie=z+L*l[2],de=W+L*l[2];for(let ue=0;ue<p;ue++){const he=m[H+ue],ge=m[ne+ue],Me=he+(m[ie+ue]-he)*V;g[_++]=Me+(ge+(m[de+ue]-ge)*V-Me)*N}}}return e.makeTensorInfo([d,c,u,p],"float32",g)}},k_e={kernelName:yE,backendName:"cpu",kernelFunc:function T_e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r;Te([i,s],"resizeBilinearGrad");const a=Pe(s.shape),[l,c,u,d]=s.shape,[,h,f]=i.shape,p=new Float32Array(l*c*u*d),m=[o&&h>1?c-1:c,o&&f>1?u-1:u],g=[o&&h>1?h-1:h,o&&f>1?f-1:f],y=m[0]/g[0],b=m[1]/g[1],_=e.data.get(i.dataId).values;let v=0;for(let w=0;w<l;w++){const C=w*a[0];for(let I=0;I<h;I++){const D=I*y,T=Math.floor(D),N=Math.min(Math.ceil(D),c-1),P=C+T*a[1],z=C+N*a[1],W=D-T,G=1-W;for(let q=0;q<f;q++){const $=q*b,V=Math.floor($),L=Math.min(Math.ceil($),u-1),H=$-V,ne=1-H,ie=P+V*a[2],de=P+L*a[2],ue=z+V*a[2],he=z+L*a[2],ge=G*ne,Ee=G*H,_e=W*ne,Me=W*H;for(let ke=0;ke<d;ke++){const Ze=_[v++];p[ie+ke]+=Ze*ge,p[de+ke]+=Ze*Ee,p[ue+ke]+=Ze*_e,p[he+ke]+=Ze*Me}}}}return e.makeTensorInfo([l,u,c,d],"float32",p)}},A_e={kernelName:Ib,backendName:"cpu",kernelFunc:function N_e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r;Te(s,"resizeNearestNeighbor");const l=Pe(s.shape),[c,u]=a,[d,h,f,p]=s.shape,m=e.data.get(s.dataId).values,g=new Float32Array(d*c*u*p),y=[i&&c>1?h-1:h,i&&u>1?f-1:f],b=[i&&c>1?c-1:c,i&&u>1?u-1:u],_=y[0]/b[0],v=y[1]/b[1];let w=0;for(let C=0;C<d;C++){const I=C*l[0];for(let D=0;D<c;D++){const T=o?_*(D+.5):_*D;let N=Math.min(h-1,i?Math.round(T):Math.floor(T));o&&(N=Math.max(0,N));const P=I+N*l[1];for(let z=0;z<u;z++){const W=o?v*(z+.5):v*z;let G=Math.min(f-1,i?Math.round(W):Math.floor(W));o&&(G=Math.max(0,G));const q=P+G*l[2];for(let $=0;$<p;$++)g[w++]=m[q+$]}}}return e.makeTensorInfo([d,c,u,p],s.dtype,g)}},M_e={kernelName:gE,backendName:"cpu",kernelFunc:function R_e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r;Te([i,s],"resizeNearestNeighborGrad");const a=Pe(s.shape),l=Pe(i.shape),[c,u,d,h]=s.shape,[,f,p]=i.shape,m=new Float32Array(c*u*d*h),g=e.data.get(i.dataId).values,y=[o&&f>1?u-1:u,o&&p>1?d-1:d],b=[o&&f>1?f-1:f,o&&p>1?p-1:p],_=y[0]/b[0],v=y[1]/b[1],w=1/_,C=1/v,I=2*Math.ceil(w)+2,D=2*Math.ceil(C)+2;for(let T=0;T<c;T++){const N=T*a[0];for(let P=0;P<u;P++){const z=N+P*a[1],W=Math.floor(P*w),G=Math.floor(W-I/2);for(let q=0;q<d;q++){const $=z+q*a[2],V=Math.floor(q*C),L=Math.floor(V-D/2);for(let H=0;H<h;H++){let ne=0;for(let ie=0;ie<I;ie++){const de=ie+G;if(de<0||de>=f)continue;const ue=N+de*l[1],he=de*_;if(P===Math.min(u-1,o?Math.round(he):Math.floor(he)))for(let Ee=0;Ee<D;Ee++){const _e=Ee+L;if(_e<0||_e>=p)continue;const Me=ue+_e*l[2],ke=_e*v;q===Math.min(d-1,o?Math.round(ke):Math.floor(ke))&&(ne+=g[Me+H])}}m[$+H]=ne}}}}return e.makeTensorInfo(s.shape,s.dtype,m)}},O_e={kernelName:Tb,backendName:"cpu",kernelFunc:function F_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:i}=r;Te(s,"reverse");const o=s.shape.length,a=ht(i,s.shape);if(0===o)return zo({inputs:{x:s},backend:e});const l=new br(s.shape,s.dtype),c=e.bufferSync(s);for(let u=0;u<l.size;u++){const d=l.indexToLoc(u),h=d.slice();a.forEach(f=>h[f]=s.shape[f]-1-h[f]),l.set(c.get(...h),...d)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}},$_e={kernelName:FE,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=t,a=e,l=gr(r.dtype,X(r.shape)),[c,u,d,h]=r.shape,[f,p]=wD(o,u,d),g=Math.sin(s),y=Math.cos(s),b=a.data.get(r.dataId).values;for(let v=0;v<c;v++){const w=v*d*u*h;for(let C=0;C<u;C++){const I=C*(d*h);for(let D=0;D<d;D++){const T=D*h;for(let N=0;N<h;N++){const P=[c,C,D,N],z=P[2],W=P[1];let G=(z-f)*y-(W-p)*g,q=(z-f)*g+(W-p)*y;G=Math.round(G+f),q=Math.round(q+p);let $=i;"number"!=typeof i&&($=3===N?255:i[N]),G>=0&&G<d&&q>=0&&q<u&&($=b[w+q*(d*h)+G*h+N]),l[w+I+T+N]=$}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},P_e=Ut(tp,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2==0?t:t+1}),L_e={kernelName:tp,backendName:"cpu",kernelFunc:P_e},hU=yl(n=>1/Math.sqrt(n)),V_e=Cd(np,hU),B_e={kernelName:np,backendName:"cpu",kernelFunc:V_e};function Dd(n,t,e,r,s,i,o,a,l,c){const u=[r/s,s],d=n.values,h=t.values;if(0===r)return it(e,t.dtype);const f=it(u,t.dtype);"string"==typeof l||"number"==typeof l?f.values.fill(l):"boolean"==typeof l&&f.values.fill(+l);for(let p=0;p<i;p++){const m=[];let g=0;for(let y=0;y<o;y++){const b=d[p*o+y];m.push(b),g+=b*a[y]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${e}`);for(let y=0;y<s;y++)c?f.values[g*s+y]+=h[p*s+y]:f.values[g*s+y]=0===t.rank?h[0]:h[p*s+y]}return f}const U_e={kernelName:bE,backendName:"cpu",kernelFunc:function z_e(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:i}=t,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=Op(0,s,o),m=Dd(e.bufferSync(s),e.bufferSync(i),o,d,c,l,a,u,0,!0);return e.makeTensorInfo(o,m.dtype,m.values)}};function H_e(n,t){let e=0,r=n.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),n[s]<t?e=s+1:r=s;return r}function W_e(n,t){let e=0,r=n.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),n[s]<=t?e=s+1:r=s;return r}const q_e={kernelName:_E,backendName:"cpu",kernelFunc:function G_e(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:s,values:i}=t,{side:o}=r,c=function j_e(n,t,e,r,s,i){const o=Kn("int32",e*s);for(let a=0;a<e;++a){const l=n.slice(a*r,(a+1)*r),c=a*s;for(let u=0;u<s;++u)o[c+u]="left"===i?H_e(l,t[u+c]):W_e(l,t[u+c])}return o}(e.data.get(s.dataId).values,e.data.get(i.dataId).values,s.shape[0],s.shape[1],i.shape[1],o);return e.makeTensorInfo(i.shape,"int32",c)}},X_e={kernelName:kb,backendName:"cpu",kernelFunc:function K_e(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:i}=t;Te([r,s,i],"select");const o=r.shape.length,a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values,u=Ds(s.dtype,i.dtype),d=$r(X(s.shape),u);let h=0;const f=0===o||o>1||1===s.shape.length?1:X(s.shape.slice(1));for(let p=0;p<a.length;p++)for(let m=0;m<f;m++)d[h++]=1===a[p]?l[p]:c[p];return e.makeTensorInfo(s.shape,u,d)}},Y_e=k_,Z_e=N_,Q_e=Ut(rp,n=>n>=0?Z_e*n:Y_e*(Math.exp(n)-1)),J_e={kernelName:rp,backendName:"cpu",kernelFunc:Q_e},eve=Ut(op,n=>n<0?-1:n>0?1:0),tve={kernelName:op,backendName:"cpu",kernelFunc:eve},nve=Ut(sp,n=>Math.sin(n)),rve={kernelName:sp,backendName:"cpu",kernelFunc:nve},sve=Ut(ip,n=>Math.sinh(n)),ive={kernelName:ip,backendName:"cpu",kernelFunc:sve},fU=Math.log(1.1920928955078125e-7)+2,ove=Ut(lp,n=>{const t=n>-fU,e=n<fU,r=Math.exp(n);let s;return s=e?r:t?n:Math.log(1+r),s}),ave={kernelName:lp,backendName:"cpu",kernelFunc:ove},cve={kernelName:Rb,backendName:"cpu",kernelFunc:function lve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,paddings:o}=r;Te([s],"spaceToBatchND");const a=X(i),l=[[0,0]];l.push(...o);for(let C=1+i.length;C<s.shape.length;++C)l.push([0,0]);const c=nU.kernelFunc({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),u=$p(c.shape,i,a,!1),d=Pp(u.length,i.length,!1),h=Lp(c.shape,i,a,!1),m=sn({inputs:{x:c},backend:e,attrs:{shape:u}}),b=gs({inputs:{x:m},backend:e,attrs:{perm:d}}),w=sn({inputs:{x:b},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(b),w}};function pU(n,t,e,r,s,i,o){const a=t[0],l=i[0],c=new Array(l),u=new Array(a),d=t[1];if(0===l){if(0!==a)throw new Error(YV(a));return[Kn(e,0),[0,d],Kn(s,0),c,u]}let h=!0,f=0;const p=new Array(l).fill(0);for(let g=0;g<a;++g){const y=n[g*d];if(y<0)throw new Error(ZV(g,y));if(y>=l)throw new Error(QV(g,y,l));++p[y],h=h&&y>=f,f=y}let m=!0;for(let g=0;g<l;++g){const y=0===p[g];c[g]=y,m=m&&!y,p[g]=Math.max(p[g],1),g>0&&(p[g]+=p[g-1])}if(m&&h){const g=n,y=r;for(let b=0;b<a;++b)u[b]=b;return[g,[a,d],y,c,u]}{const g=p[l-1],y=Kn(e,g*d),b=Kn(s,g),_=new Array(l).fill(0);for(let v=0;v<a;++v){const w=n[v*d],I=(0===w?0:p[w-1])+_[w];_[w]++;for(let D=0;D<d;++D)y[I*d+D]=n[v*d+D];b[I]=r[v],u[v]=I}for(let v=0;v<l;++v)if(0===_[v]){const C=0===v?0:p[v-1];y[C*d+0]=v;for(let I=1;I<d;++I)y[C*d+I]=0;b[C]=o}return[y,[g,d],b,c,u]}}const dve={kernelName:vE,backendName:"cpu",kernelFunc:function uve(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values,u=e.data.get(o.dataId).values[0],[d,h,f,p,m]=pU(a,r.shape,r.dtype,l,s.dtype,c,u);return[e.makeTensorInfo(h,r.dtype,d),e.makeTensorInfo([h[0]],s.dtype,f),e.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),e.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function mU(n,t,e,r,s){const i=X(r),o=t[0],a=s.length,l=[];let c=1,u=-1;for(let g=0;g<a;++g){const y=s[g];if(-1===y){if(-1!==u)throw new Error(JV(u,g));u=g,l.push(1)}else{if(y<0)throw new Error(eB(g,y));c*=y,l.push(y)}}if(-1!==u){if(c<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const g=Math.trunc(i/c);if(c*g!==i)throw new Error(nB(r,l));l[u]=g}if(X(l)!==i)throw new Error(rB(r,l));const h=r.length,f=[];if(h>0){f[h-1]=1;for(let g=h-2;g>=0;--g)f[g]=f[g+1]*r[g+1]}const p=[];if(a>0){p[a-1]=1;for(let g=a-2;g>=0;--g)p[g]=p[g+1]*l[g+1]}const m=Kn(e,o*a);for(let g=0;g<o;++g){let y=0;for(let b=0;b<h;++b)y+=n[g*h+b]*f[b];for(let b=0;b<a;++b)m[g*a+b]=Math.trunc(y/p[b]),y%=p[b]}return[m,[o,a],l]}const fve={kernelName:xE,backendName:"cpu",kernelFunc:function hve(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.data.get(s.dataId).values),a=e.data.get(r.dataId).values,l=Array.from(e.data.get(i.dataId).values),[c,u,d]=mU(a,r.shape,r.dtype,o,l);return[e.makeTensorInfo(u,r.dtype,c),e.makeTensorInfo([d.length],i.dtype,new Int32Array(d))]}};function l1(n,t,e,r,s,i=!1,o=0){const a=r.length,l=[t[0],n.length/t[0]],c=l[1],d=a>0?s[a-1]+1:0;if(d<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=d;const p=Kn(e,h.reduce((_,v)=>_*v,1));if(0===a)return d>0&&p.fill(o),[p,h];if(d<=0)throw new Error("segment ids must be >= 0");let m=0,g=1,y=0,b=s[m];for(;;){let _=0;if(g<a){if(_=s[g],b===_){++g;continue}if(b>=_)throw new Error("segment ids are not increasing")}if(b<0||b>=d)throw new Error(iB(b,d));b>y&&p.fill(o,y*c,b*c);for(let v=m;v<g;++v){const w=r[v];if(w<0||w>=l[0])throw new Error(oB(v,r[v],l[0]));for(let C=0;C<c;C++)p[b*c+C]+=n[w*c+C]}if(i)for(let v=0;v<c;v++)p[b*c+v]/=g-m;if(m=g,++g,y=b+1,b=_,g>a)break}return y<d&&p.fill(o,y*c,d*c),[p,h]}const mve={kernelName:wE,backendName:"cpu",kernelFunc:function pve(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,[c,u]=l1(o,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(u,r.dtype,c)}},yve={kernelName:CE,backendName:"cpu",kernelFunc:function gve(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,[c,u]=l1(o,r.shape,r.dtype,a,l);return e.makeTensorInfo(u,r.dtype,c)}},_ve={kernelName:SE,backendName:"cpu",kernelFunc:function bve(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=t,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:h}=Op(0,s,a),f=!1,p=e.bufferSync(s);let m;switch(i.dtype){case"bool":m=Dd(p,e.bufferSync(i),a,h,u,c,l,d,Boolean(e.data.get(o.dataId).values[0]),f);break;case"float32":case"int32":m=Dd(p,e.bufferSync(i),a,h,u,c,l,d,e.data.get(o.dataId).values[0],f);break;case"string":m=Dd(p,e.bufferSync(i),a,h,u,c,l,d,Ya(e.data.get(o.dataId).values[0]),f);break;default:throw new Error(`Unsupported type ${i.dtype}`)}return e.makeTensorInfo(a,m.dtype,m.values)}},xve={kernelName:Mb,backendName:"cpu",kernelFunc:function vve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:i,axis:o}=r,a=ht(o,s.shape)[0],l=VD(s,i,a),c=new Array(s.shape.length).fill(0),u=s.shape.slice();return l.map(d=>{const h=[...u];h[a]=d;const f=Sc({inputs:{x:s},backend:e,attrs:{begin:c,size:h}});return c[a]+=d,f})}},wve=yl(n=>Math.sqrt(n)),Cve=Ut(cp,n=>Math.sqrt(n)),Sve={kernelName:cp,backendName:"cpu",kernelFunc:Cve},Eve={kernelName:EE,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,r=t;Te(e,"square");const s=r.data.get(e.dataId).values,i=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];i[a]=l*l}return{dataId:r.write(i,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},gU=Yn((n,t)=>{const e=n-t;return e*e}),Ive=Cr(up,gU),Dve={kernelName:up,backendName:"cpu",kernelFunc:Ive},Tve=Ut(mp,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),kve={kernelName:mp,backendName:"cpu",kernelFunc:Tve};function yU(n,t,e,r){const s=it(n,t.dtype);for(let i=0;i<s.size;i++){const o=s.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*e[l]+r[l];s.set(t.get(...a),...o)}return s}const Ave={kernelName:IE,backendName:"cpu",kernelFunc:function Nve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=r;Te(s,"stridedSlice");const{finalShapeSparse:f,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:_,strides:v}=bI(s.shape,i,o,a,l,c,u,d,h);let w;if(m)w=sn({inputs:{x:s},backend:e,attrs:{shape:p}});else if(g||y){S(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const C=mI(b,_,v),I=Sc({inputs:{x:s},backend:e,attrs:{begin:b,size:C}});w=sn({inputs:{x:I},backend:e,attrs:{shape:p}}),e.disposeIntermediateTensorInfo(I)}else{const I=yU(f,e.bufferSync(s),v,b);w=e.makeTensorInfo(p,I.dtype,I.values)}return w}};class Rve{constructor(t,e,r,s,i,o){this.separator=Xa(t),this.nGramWidths=e,this.leftPad=Xa(r),this.rightPad=Xa(s),this.padWidth=i,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const r=this.getPadWidth(e);return Math.max(0,t+2*r-e+1)}createNGrams(t,e,r,s,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),u=Math.max(0,l-(i-(a+1))),d=o-(c+u),h=e+(c>0?0:a-l);let f=0;f+=c*this.leftPad.length;for(let b=0;b<d;++b)f+=t[h+b].length;f+=u*this.rightPad.length,f+=(c+u+d-1)*this.separator.length,r[s+a]=new Uint8Array(f);const m=r[s+a];let g=0;const y=b=>b.forEach(_=>m[g++]=_);for(let b=0;b<c;++b)y(this.leftPad),y(this.separator);for(let b=0;b<d-1;++b)y(t[h+b]),y(this.separator);if(d>0){y(t[h+d-1]);for(let b=0;b<u;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<u-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,e){const r=t.length,s=e.length;if(s>0){let l=e[0];if(0!==l)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<s;++c){let u=e[c]>=l;if(u=u&&e[c]<=r,!u)throw new Error(`Invalid split value ${e[c]}, must be in [${l}, ${r}]`);l=e[c]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const i=s-1,o=Kn("int32",s);if(0===r||0===s){const l=new Array(r);for(let c=0;c<=i;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const c=e[l]-e[l-1];let u=0;this.nGramWidths.forEach(d=>{u+=this.getNumNGrams(c,d)}),this.preserveShort&&c>0&&0===u&&(u=1),o[l]=o[l-1]+u}const a=new Array(o[i]);for(let l=0;l<i;++l){const c=e[l];let u=o[l];if(this.nGramWidths.forEach(d=>{const f=this.getNumNGrams(e[l+1]-e[l],d);this.createNGrams(t,c,a,u,f,d),u+=f}),this.preserveShort&&u===o[l]){const d=e[l+1]-e[l];if(0===d)continue;this.createNGrams(t,c,a,u,1,d+2*this.padWidth)}}return[a,o]}}function bU(n,t,e,r,s,i,o,a){return new Rve(e,r,s,i,o,a).compute(n,t)}const Fve={kernelName:DE,backendName:"cpu",kernelFunc:function Mve(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:d}=t,h=e.data.get(u.dataId).values,f=e.data.get(d.dataId).values,[p,m]=bU(h,f,s,i,o,a,l,c);return[e.makeTensorInfo([p.length],"string",p),e.makeTensorInfo(d.shape,"int32",m)]}};function Ove(n,t,e,r){if(!n.length)return;if(0===t.length){for(let i=0;i<n.length;++i)r.push(n.subarray(i,i+1));return}if(1===t.length){const i=t[0];let o=n.indexOf(i);for(;-1!==o;){const a=n.subarray(0,o);(!e||0!==a.length)&&r.push(a),o=(n=n.subarray(o+1)).indexOf(i)}return void((!e||0!==n.length)&&r.push(n))}let s=0;for(let i=0;i<n.length+1;i++)if(i===n.length||-1!==t.indexOf(n[i])){const o=n.subarray(s,i);(!e||0!==o.length)&&r.push(o),s=i+1}}function _U(n,t,e){const r=n.length,s=[];let i=0,o=0;const a=new Array(r);for(let h=0;h<r;++h){const f=s.length;Ove(n[h],t,e,s);const p=s.length-f;a[h]=p,i+=p,o=Math.max(o,p)}const l=Kn("int32",2*i),c=new Array(i),u=[r,o];let d=0;for(let h=0;h<r;++h)for(let f=0;f<a[h];++f)l[2*d]=h,l[2*d+1]=f,c[d]=s[d],++d;return[l,c,u]}const Pve={kernelName:TE,backendName:"cpu",kernelFunc:function $ve(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values[0],[c,u,d]=_U(a,l,s),h=u.length;return[e.makeTensorInfo([h,2],"int32",c),e.makeTensorInfo([h],"string",u),e.makeTensorInfo([2],"int32",new Int32Array(d))]}};function vU(n,t){const e=Kn("int32",n.length);for(let r=0;r<n.length;++r)e[r]=Ute(n[r]).modulo(t).getLowBitsUnsigned();return e}const Vve={kernelName:kE,backendName:"cpu",kernelFunc:function Lve(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=vU(e.data.get(i.dataId).values,s);return e.makeTensorInfo(i.shape,"int32",a)}},Bve=Ut(hp,n=>Math.tan(n)),zve={kernelName:hp,backendName:"cpu",kernelFunc:Bve},Uve=Ut(fp,n=>Math.tanh(n));function xU(n,t){const e=new Array(n.rank);for(let s=0;s<e.length;s++)e[s]=n.shape[s]*t[s];const r=it(e,n.dtype);for(let s=0;s<r.values.length;++s){const i=r.indexToLoc(s),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%n.shape[l];const a=n.locToIndex(o);r.values[s]=n.values[a]}return r}const tm=(n,t)=>{const e=t.value-n.value;return 0===e?n.index-t.index:e};function wU(n,t,e=0,r=n.length-1){for(;r>e;){if(r-e>600){const a=r-e+1,l=t-e+1,c=Math.log(a),u=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2);wU(n,t,Math.max(e,Math.floor(t-l*u/a+d)),Math.min(r,Math.floor(t+(a-l)*u/a+d)))}const s=n[t];let i=e,o=r;for(ja(n,e,t),tm(n[r],s)>0&&ja(n,e,r);i<o;){for(ja(n,i,o),i++,o--;tm(n[i],s)<0;)i+=1;for(;tm(n[o],s)>0;)o-=1}0===tm(n[e],s)?ja(n,e,o):(o+=1,ja(n,o,r)),o<=t&&(e=o+1),t<=o&&(r=o-1)}}function CU(n,t,e,r,s){const i=t[t.length-1],[o,a]=[n.length/i,i],l=gr(e,o*r),c=gr("int32",o*r);for(let d=0;d<o;d++){const h=d*a,f=n.subarray(h,h+a);let p=new Array(f.length);f.forEach((b,_)=>p[_]={value:b,index:_}),r<p.length&&(wU(p,r),p=p.slice(0,r)),s&&p.sort(tm);const m=d*r,g=l.subarray(m,m+r),y=c.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=p[b].value,y[b]=p[b].index}const u=t.slice();return u[u.length-1]=r,[it(u,e,l),it(u,"int32",c)]}function SU(n,t,e){switch(e){case"reflect":return function Yve(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const r=2*t;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-t?e+r:-e-1}else if(e>t-1)if(t<=1)e=0;else{const r=2*t;e-=r*Math.trunc(e/r),e>=t&&(e=r-e-1)}return sc(0,e,t-1)}(n,t);case"wrap":return function Zve(n,t){let e=n;return e<0?t<=1?e=0:e+=t*(Math.trunc(-e/(t-1))+1):e>t-1&&(t<=1?e=0:e-=t*Math.trunc(e/(t-1))),sc(0,e,t-1)}(n,t);case"nearest":return function Jve(n,t){return sc(0,n,t-1)}(n,t);default:return function Qve(n,t){return n}(n)}}function nm(n,t,e,r,s,i,o,a,l,c,u){return 0<=a&&a<t&&0<=l&&l<e?n[o*r+a*s+l*i+c]:u}function exe(n,t,e,r,s,i,o,a,l,c,u){return nm(n,t,e,r,s,i,o,Math.round(a),Math.round(l),c,u)}function txe(n,t,e,r,s,i,o,a,l,c,u){const d=Math.floor(a),h=Math.floor(l),f=d+1,p=h+1;return(f-a)*((p-l)*nm(n,t,e,r,s,i,o,d,h,c,u)+(l-h)*nm(n,t,e,r,s,i,o,d,p,c,u))+(a-d)*((p-l)*nm(n,t,e,r,s,i,o,f,h,c,u)+(l-h)*nm(n,t,e,r,s,i,o,f,p,c,u))}function EU(n,t,e,r){const s=ht(t,e)[0],i=[1,e[0],1];for(let p=0;p<s;p++)i[0]*=e[p];i[1]=e[s];for(let p=s+1;p<e.length;p++)i[2]*=e[p];const o={},a=new Int32Array(e[s]),l=new br(i,r,n),c=[],u=1===i[0]&&1===i[2];for(let p=0;p<e[s];p++){let m;if(u)m=n[p].toString();else{const g=[];for(let y=0;y<i[0];y++)for(let b=0;b<i[2];b++)g.push(l.get(y,p,b));m=g.join(",")}if(void 0!==o[m])a[p]=o[m];else{const g=Object.keys(o).length;o[m]=g,a[p]=g,c.push(p)}}const d=i.slice();d[1]=Object.keys(o).length;const h=new br(d,r);c.forEach((p,m)=>{for(let g=0;g<i[0];g++)for(let y=0;y<i[2];y++)h.set(l.get(g,p,y),g,m,y)});const f=e.slice();return f[s]=d[1],{outputValues:h.values,outputShape:f,indices:a}}const lxe=[cme,ume,hme,pme,ime,gme,_me,xme,Cme,Eme,Dme,kme,Ame,Fme,$me,Vme,zme,Hme,jme,ame,qme,Yme,Qme,ege,rme,nge,sge,tme,ige,age,lge,uge,hge,pge,gge,bge,vge,wge,Sge,Ige,Tge,Nge,Rge,Mge,Oge,Pge,Vge,Bge,zge,Uge,qge,Gpe,Xge,Yge,sye,iye,oye,lye,gye,yye,_ye,xye,Sye,Iye,Tye,Nye,Rye,Fye,$ye,qpe,Lye,oge,Bye,Uye,Wye,Kpe,Gye,Kye,Yye,Qye,ebe,rbe,ibe,lbe,ube,hbe,fbe,mbe,ybe,_be,xbe,Cbe,Ebe,Dbe,kbe,Abe,Mbe,$be,Vbe,Wge,zbe,Wbe,qbe,Ybe,Qbe,e_e,n_e,r_e,nU,a_e,Ype,c_e,y_e,__e,x_e,C_e,nme,r1,E_e,Zpe,Qpe,ome,D_e,k_e,A_e,M_e,O_e,$_e,L_e,B_e,U_e,q_e,X_e,J_e,eme,tve,rve,ive,Kme,Pbe,ave,cve,dve,fve,mve,yve,_ve,xve,Sve,Eve,Dve,kve,Ave,Fve,Pve,Vve,dye,jge,zve,{kernelName:fp,backendName:"cpu",kernelFunc:Uve},{kernelName:pp,backendName:"cpu",kernelFunc:function Wve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:i}=r;Te(s,"tile");const o=xU(e.bufferSync(s),i);return e.makeTensorInfo(o.shape,o.dtype,o.values)}},{kernelName:NE,backendName:"cpu",kernelFunc:function Gve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:i,sorted:o}=r;Te(s,"topk");const a=e.data.get(s.dataId).values,[l,c]=CU(a,s.shape,s.dtype,i,o);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}},{kernelName:AE,backendName:"cpu",kernelFunc:function Kve(n){const{inputs:t,attrs:e,backend:r}=n,{image:s,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=e,[u,d,h,f]=s.shape,[p,m]=c??[d,h],g=[u,p,m,f],y=Pe(s.shape),b=y[0],_=y[1],v=y[2],w=Pe(g),C=w[0],I=w[1],D=w[2],T=gr(s.dtype,X(g));T.fill(l);const N=r.data.get(s.dataId).values,P=r.data.get(i.dataId).values;for(let W=0;W<u;++W){const G=1===i.shape[0]?P:P.subarray(8*W,8*W+8);for(let q=0;q<p;++q)for(let $=0;$<m;++$)for(let V=0;V<f;++V){let L;const H=G[6]*$+G[7]*q+1;if(0===H)continue;const ie=(G[3]*$+G[4]*q+G[5])/H,de=SU((G[0]*$+G[1]*q+G[2])/H,h,a),ue=SU(ie,d,a);switch(o){case"nearest":L=exe(N,d,h,b,_,v,W,ue,de,V,l);break;case"bilinear":L=txe(N,d,h,b,_,v,W,ue,de,V,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}T[W*C+q*I+$*D+V]=L}return r.makeTensorInfo(g,s.dtype,T)}return{dataId:r.write(T,g,s.dtype),shape:s.shape,dtype:s.dtype}}},yme,{kernelName:RE,backendName:"cpu",kernelFunc:function nxe(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:i}=t;Te(i,"unique");const o=r.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:c}=EU(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},{kernelName:Ob,backendName:"cpu",kernelFunc:function sxe(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s.shape.length,a=s.shape[i],l=new Array(o-1);let c=0;for(let f=0;f<o;f++)f!==i&&(l[c++]=s.shape[f]);const u=new Array(o).fill(0),d=s.shape.slice();d[i]=1;const h=new Array(a);for(let f=0;f<h.length;f++){u[i]=f;const p=Sc({inputs:{x:s},backend:e,attrs:{begin:u,size:d}});h[f]=sn({inputs:{x:p},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(p)}return h}},{kernelName:$b,backendName:"cpu",kernelFunc:function oxe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:i}=t,{numSegments:o}=r;Te(s,"unsortedSegmentSum");const c=[],u=[],d=s.shape.length-i.shape.length;let h=i;for(let p=0;p<d;++p){const m=uv({inputs:{input:h},backend:e,attrs:{dim:p+1}});h=m,u.push(m)}for(let p=0;p<o;++p){const m=Ka(p,"int32"),g=e.makeTensorInfo([],"int32",m),y=R3({inputs:{a:g,b:h},backend:e}),b=bl({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),_=cv({inputs:{a:b,b:s},backend:e}),v=em({inputs:{x:_},backend:e,attrs:{axis:0,keepDims:!1}});c.push(v),u.push(g),u.push(y),u.push(b),u.push(_),u.push(v)}const f=tU({inputs:c,backend:e,attrs:{axis:0}});return u.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}},t_e];for(const n of lxe)PE(n);const _l={},fv={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function po(n,t){if(!(n in _l)||null!=t){const r=function dxe(n,t){if(1!==n&&2!==n)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??function uxe(n){if(typeof OffscreenCanvas<"u"&&2===n)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(n);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete _l[n]},!1),j().getBool("SOFTWARE_WEBGL_ENABLED")&&(fv.failIfMajorPerformanceCaveat=!1),1===n?e.getContext("webgl",fv)||e.getContext("experimental-webgl",fv):e.getContext("webgl2",fv)}(n,t);if(null===r)return console.log("Could not get context for WebGL version",n),null;_l[n]=r}const e=_l[n];return null==e||e.isContextLost()?(delete _l[n],po(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),_l[n])}var Td=(()=>{return(n=Td||(Td={}))[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH",Td;var n})(),Ms=(()=>{return(n=Ms||(Ms={}))[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD",Ms;var n})(),Sr=(()=>{return(n=Sr||(Sr={}))[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",Sr;var n})();function rm(n,t){return[t,n]}function pv(n){const t=X(n);return xS(Math.ceil(t/4))}function kd(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function c1(n,t){const e=n;let r,s,i,o,a,l,c,u,d,h;return 2===j().getNumber("WEBGL_VERSION")?(r=e.R32F,s=e.R16F,i=e.RGBA16F,o=e.RGBA32F,a=e.RED,c=4,u=1,d=e.HALF_FLOAT,h=e.FLOAT,l=e.RGBA8):(r=n.RGBA,s=n.RGBA,i=n.RGBA,o=e.RGBA,a=n.RGBA,c=4,u=4,d=null!=t?t.HALF_FLOAT_OES:null,h=n.FLOAT,l=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:h}}function ye(n,t){const e=t();return j().getBool("DEBUG")&&function pxe(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+function bxe(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(n,t))}(n),e}function yxe(n){return!!(j().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||5.96e-8<Math.abs(n)&&Math.abs(n)<65504)}function mv(n,t){return Sa(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const xxe=/ERROR: [0-9]+:([0-9]+):/g;function IU(n,t){const e=xxe.exec(t);if(null==e)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(n);const r=+e[1],s=n.split("\n"),i=s.length.toString().length+2,o=s.map((d,h)=>qu((h+1).toString(),i)+d);let a=0;for(let d=0;d<o.length;d++)a=Math.max(o[d].length,a);const l=o.slice(0,r-1),c=o.slice(r-1,r),u=o.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${qu(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function u1(n,t){if(ye(n,()=>n.validateProgram(t)),!1===n.getProgramParameter(t,n.VALIDATE_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function DU(n,t,e,r,s,i,o){const a=n.getAttribLocation(t,e);return-1!==a&&(ye(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),ye(n,()=>n.vertexAttribPointer(a,s,n.FLOAT,!1,i,o)),ye(n,()=>n.enableVertexAttribArray(a)),!0)}function Rxe(n,t,e,r){ye(n,()=>function kxe(n,t,e){(function kU(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+n.TEXTURE0;if(r<n.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(n,e),ye(n,()=>n.activeTexture(n.TEXTURE0+e)),ye(n,()=>n.bindTexture(n.TEXTURE_2D,t))}(n,t,r)),ye(n,()=>n.uniform1i(e,r))}function d1(n,t,e){ye(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),ye(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function TU(n,t){ye(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),ye(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function gv(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function Mxe(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(n,t))}function Sa(n,t,e){const r=ye(n,()=>t());if(null==r)throw new Error(e);return r}function Nd(n,t=2){return X(n.slice(0,n.length-t))}function Ad(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function yv(n){let t=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(t=[Nd(n),...Ad(n)]),t}function bv(n){return n%2==0}function _v(n,t){if(It(n=n.slice(-2),t=t.slice(-2))||!n.length||!t.length||0===n[0]||0===n[1]||0===t[0]||0===t[1])return!0;if(n.length!==t.length){const e=n.slice(-1)[0],r=t.slice(-1)[0];if(e===r||bv(e)&&bv(r)&&(1===n[0]||1===t[0]))return!0}return n[1]===t[1]&&bv(n[0])&&bv(t[0])}let vv,xv;function Pi(n,t){return null!=n.getExtension(t)}function NU(n){try{if(null!=po(n))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function h1(n){const t=c1(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(i),o}function sm(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&S("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const Re=j();function Zr(){let n,t,e,r,s,i,o,a,l,c;return 2===j().getNumber("WEBGL_VERSION")?(n="#version 300 es",t="in",e="out",r="in",s="texture",i="outputColor",o="out vec4 outputColor;",a=j().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(n="",t="attribute",e="varying",r="varying",s="texture2D",i="gl_FragColor",o="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:n,attribute:t,varyingVs:e,varyingFs:r,texture2D:s,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}function Ec(n,t,e="index"){const r=Pe(t);return r.map((s,i)=>`int ${n[i]} = ${e} / ${s}; ${i===r.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * ${s}`:`index -= ${n[i]} * ${s}`};`).join("")}function wv(n,t,e="index"){const r=Pe(t);return r.map((s,i)=>`int ${n[i]} = ${e} / outShapeStrides[${i}]; ${i===r.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`};`).join("")}function f1(n){const t=Pe(n).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Re.registerFlag("HAS_WEBGL",()=>Re.getNumber("WEBGL_VERSION")>0),Re.registerFlag("WEBGL_VERSION",()=>NU(2)?2:NU(1)?1:0),Re.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Re.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===Re.get("WEBGL_VERSION")),Re.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Re.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Re.registerFlag("WEBGL_PACK",()=>Re.getBool("HAS_WEBGL")),Re.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_CLIP",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_REDUCE",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_LAZILY_UNPACK",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_CONV_IM2COL",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function Oxe(n){if(null==vv){const t=po(n);vv=t.getParameter(t.MAX_TEXTURE_SIZE)}return vv}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function $xe(n){if(null==xv){const t=po(n);xv=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,xv)}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Re.getNumber("WEBGL_VERSION");return 0===n?0:function Pxe(n){if(0===n)return 0;let t;const e=po(n);return t=Pi(e,"EXT_disjoint_timer_query_webgl2")&&2===n?2:Pi(e,"EXT_disjoint_timer_query")?1:0,t}(n)}),Re.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Re.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!UP()),Re.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function Lxe(n){if(0===n)return!1;const t=po(n);if(1===n){if(!Pi(t,"OES_texture_float"))return!1}else if(!Pi(t,"EXT_color_buffer_float"))return!1;return h1(t)}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Re.getBool("WEBGL_FORCE_F16_TEXTURES")&&Re.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Re.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function Vxe(n){if(0===n)return!1;const t=po(n);if(1!==n){if(Pi(t,"EXT_color_buffer_float"))return h1(t);const r="EXT_color_buffer_half_float";if(Pi(t,r)){const s=t.getExtension(r);return function Bxe(n,t){const e=c1(n,t),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(o),a}(t,s)}return!1}return!(!Pi(t,"OES_texture_float")||!Pi(t,"WEBGL_color_buffer_float"))&&h1(t)}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function zxe(n){return 2===n&&null!=po(n).fenceSync}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Re.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Re.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),Re.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>UP()?1:-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)}),Re.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),Re.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),Re.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),Re.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),Re.registerFlag("WEBGL_EXP_CONV",()=>!1),Re.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Re.getBool("IS_TEST")),Re.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),Re.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),Re.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),Re.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const AU="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:RU}=lt;function Wxe(n,t,e){const r=[];if(n.forEach(f=>{const p=X(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?r.push(`uniform float ${f.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${f.name};`),r.push(`uniform int offset${f.name};`)),e.enableShapeUniforms){const{uniformShape:m}=m1(e.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${f.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${f.name}Shape;`)}r.push(`uniform ivec2 ${f.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(f=>{r.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});const s=r.join("\n"),i=n.map(f=>function jxe(n,t,e=!1,r){let s="";return s+=e?MU(n,r):Rd(n,r),n.shapeInfo.logicalShape.length<=t.logicalShape.length&&(s+=e?function S0e(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=t.logicalShape.length,a=RU(n.shapeInfo.logicalShape,t.logicalShape),l=on(o),c=o-i;let u;const d=["x","y","z","w","u","v"];u=0===i?"":o<2&&a.length>=1?"coords = 0;":a.map(b=>`coords.${d[b+c]} = 0;`).join("\n");let h="";h=o<2&&i>0?"coords":n.shapeInfo.logicalShape.map((b,_)=>`coords.${d[_+c]}`).join(", ");let f="return outputValue;";const m=1===X(n.shapeInfo.logicalShape),y=1===X(t.logicalShape);if(1!==i||m||y){if(m&&!y)f=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const b=i-2,_=i-1;a.indexOf(b)>-1&&a.indexOf(_)>-1?f="return vec4(outputValue.x);":a.indexOf(b)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(_)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${u}\n      vec4 outputValue = get${r}(${h});\n      ${f}\n    }\n  `}(n,t):function E0e(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",a=n.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&null==n.shapeInfo.flatOffset&&It(n.shapeInfo.texShape,t.texShape))return`\n      float ${s}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const c=on(l),u=RU(n.shapeInfo.logicalShape,t.logicalShape),d=l-a;let h;const f=["x","y","z","w","u","v"];h=0===a?"":l<2&&u.length>=1?"coords = 0;":u.map(m=>`coords.${f[m+d]} = 0;`).join("\n");let p="";return p=l<2&&a>0?"coords":n.shapeInfo.logicalShape.map((m,g)=>`coords.${f[g+d]}`).join(", "),`\n    float ${s}() {\n      ${c} coords = getOutputCoords();\n      ${h}\n      return get${r}(${p});\n    }\n  `}(n,t)),s}(f,t,e.packedInputs,e.enableShapeUniforms)).join("\n"),o=t.texShape,a=Zr(),l=function Kxe(n){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let c,u,d=function Zxe(n){return`${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${Qxe}\n    ${Jxe}\n    ${e0e}\n  `}(a);return t.isPacked?(c=function Gxe(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function n0e(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,e);case 2:return function u0e(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(It(n,t))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(n[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function s0e(n,t,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[2]/2),i=s*Math.ceil(n[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(n,t,e);default:return function o0e(n,t,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[n.length-1]/2),i=s*Math.ceil(n[n.length-2]/2);let o=i,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`\n      int b${c} = index / ${o};\n      index -= b${c} * ${o};\n    `+a,l=`b${c}, `+l;return`\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${n.length}(${l});\n    }\n  `}(n,t,e)}}(t.logicalShape,o,e.enableShapeUniforms),u=function Yxe(n){return`\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `}(a)):(c=function qxe(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function r0e(n,t,e){return 1===t[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,e);case 2:return function d0e(n,t,e){return It(n,t)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===n[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function i0e(n,t,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${wv(["r","c","d"],n)}\n    return ivec3(r, c, d);\n  }\n`;const r=Ec(["r","c","d"],n);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(n,t,e);case 4:return function a0e(n,t,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${wv(["r","c","d","d2"],n)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=Ec(["r","c","d","d2"],n);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(n,t,e);case 5:return function l0e(n,t){const e=Ec(["r","c","d","d2","d3"],n);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(n,t);case 6:return function c0e(n,t){const e=Ec(["r","c","d","d2","d3","d4"],n);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}(t.logicalShape,o,e.enableShapeUniforms),u=function Xxe(n){return`\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),e.packedInputs&&(d+=t0e),[d,l,u,s,c,i,e.userCode].join("\n")}function Rd(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return function f0e(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[s,i]=n.shapeInfo.texShape;if(1===s&&1===i)return`\n      float ${r}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=Ic(e);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[a,l]=n.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${l}, ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 1:return function m0e(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Md(n)}\n      }\n    `;const s=n.shapeInfo.texShape,i=s[0],o=s[1];if(1===o&&1===i)return`\n      float ${r}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=Ic(e);return 1===o?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 2:return function y0e(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape;if(null!=i&&It(e,i))return t?`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${i[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:o,keptDims:a}=Ga(e);if(o.length<e.length){const f=["row","col"];return`\n      ${Rd(Fd(n,o),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${Od(f,a)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Md(n)}\n      }\n    `;const c=i[0],u=i[1],d=Ic(r);return 1===u?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===c?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${c}, ${u}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(n,t);case 3:return function _0e(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e[1]*e[2],o=e[2],{newShape:a,keptDims:l}=Ga(e);if(a.length<e.length){const g=["row","col","depth"];return`\n        ${Rd(Fd(n,a),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${Od(g,l)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${o}, 1)));\n        ${Md(n)}\n      }\n    `;const u=n.shapeInfo.texShape,d=u[0],h=u[1],f=n.shapeInfo.flatOffset;if(h===i&&null==f)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===o&&null==f)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const p=Ic(r);return t?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${p};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${o} + depth + ${p};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(n,t);case 4:return function x0e(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e[3],o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:c}=Ga(e);if(l.length<e.length){const _=["row","col","depth","depth2"];return`\n      ${Rd(Fd(n,l),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${Od(_,c)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${o}, ${i}, 1)));\n        ${Md(n)}\n      }\n    `;const u=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],f=d[1],p=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(f===a&&null==u)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${p}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(f===i&&null==u)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=Ic(r);return t?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${p}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${f}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(n,t);case 5:return function w0e(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t[4],i=t[3]*s,o=t[2]*i,a=t[1]*o,{newShape:l,keptDims:c}=Ga(t);if(l.length<t.length){const g=["row","col","depth","depth2","depth3"];return`\n      ${Rd(Fd(n,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Od(g,c)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${o}, ${i}, ${s})) +\n          depth3;\n        ${Md(n)}\n      }\n    `;const u=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],f=d[1];if(f===a&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(f===s&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} + depth * ${i} +\n          depth2 * ${s} + depth3 + ${Ic(e)};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 6:return function C0e(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:s,keptDims:i}=Ga(t);if(s.length<t.length){const y=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Rd(Fd(n,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Od(y,i)});\n      }\n    `}const o=t[5],a=t[4]*o,l=t[3]*a,c=t[2]*l,u=t[1]*c;if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${c}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${Md(n)}\n      }\n    `;const d=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],p=h[1];if(p===u&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${l}, ${a}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(p===o&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${c} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${o} + depth4 + ${Ic(e)};\n      vec2 uv = uvFromFlat(${f}, ${p}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function MU(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return function h0e(n){const t=n.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${Zr().texture2D}(${t}, halfCR);\n    }\n  `}(n);case 1:return function p0e(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n.shapeInfo.texShape,i=Zr();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `;const o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `}(n,t);case 2:return function g0e(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=i[0],a=i[1],l=Zr();if(null!=i&&It(e,i))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${c[0]}, ${c[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(n,t);case 3:return function b0e(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===e[0]){const f=[1,2],m=["b","row","col"];return`\n        ${MU(Fd(n,e.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${Od(m,f)});\n        }\n      `}const a=Zr();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `;const l=o[0],c=o[1],u=Math.ceil(e[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${c}, ${u*Math.ceil(e[1]/2)}, ${u}, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `}(n,t);default:return function v0e(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Zr();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${e}, uv);\n    }\n  `;const i=n.shapeInfo.logicalShape,o=i.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],d=Math.ceil(i[o-1]/2);let h=d*Math.ceil(i[o-2]/2),f="int b, int row, int col",p=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<o-1;m++)f=`int b${m}, `+f,h*=i[o-m-1],p=`b${m} * ${h} + `+p;return`\n    vec4 ${r}(${f}) {\n      int index = ${p};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(n,t)}}const Qxe="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Jxe="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",e0e="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",t0e="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Ic(n){return`offset${n}`}function Md(n){const t=n.name,e=X(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function on(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function m1(n,t,e){const{newShape:r,keptDims:s}=Ga(t),i=t.length,o=n&&3===i&&1===t[0],a=o?t.slice(1):r,l=!n&&i>1&&!It(t,e)&&r.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:t,keptDims:s}}function Fd(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function Od(n,t){return t.map(e=>n[e]).join(", ")}function OU(n,t,e){const r={},s={},i={},o=[];let a,l,c,u=null,d=null;d=n.getUniformLocation(e,"NAN",!1),1===j().getNumber("WEBGL_VERSION")&&(u=n.getUniformLocation(e,"INFINITY",!1));const h=!1;for(let f=0;f<t.variableNames.length;f++){const p=t.variableNames[f];r[p]=n.getUniformLocation(e,p,h),r[`offset${p}`]=n.getUniformLocation(e,`offset${p}`,h),t.enableShapeUniforms&&(s[`${p}Shape`]=n.getUniformLocation(e,`${p}Shape`,h),i[`${p}TexShape`]=n.getUniformLocation(e,`${p}TexShape`,h))}return t.enableShapeUniforms&&(a=n.getUniformLocation(e,"outShape",h),c=n.getUniformLocation(e,"outShapeStrides",h),l=n.getUniformLocation(e,"outTexShape",h)),t.customUniforms&&t.customUniforms.forEach((f,p)=>{o[p]=n.getUniformLocation(e,f.name,h)}),{uniformLocations:r,customUniformLocations:o,infLoc:u,nanLoc:d,inShapesLocations:s,inTexShapesLocations:i,outShapeLocation:a,outShapeStridesLocation:c,outTexShapeLocation:l}}function $U(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,r)=>{const s=e.logicalShape,i=t[r],o=i.shape;if(!It(s,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${o} must match`);if(e.isUniform&&i.isUniform)return;const a=e.texShape,l=i.isUniform?null:i.texData.texShape;if(!It(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function Qr(n){return j().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class k0e{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Td.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Zr();this.outputShape=t,this.enableShapeUniforms=Qr(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?wv(["r","c","d"],t):Ec(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class N0e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Td.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Zr();this.outputShape=t,this.enableShapeUniforms=Qr(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?wv(["r","c","d"],t):Ec(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class A0e{constructor(t){this.variableNames=["A"],this.outTexUsage=Ms.DOWNLOAD;const e=Zr();this.outputShape=t,this.userCode=`\n      ${AU}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class R0e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Ms.DOWNLOAD;const e=Zr();this.outputShape=t,this.userCode=`\n      ${AU}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const M0e={R:0,G:1,B:2,A:3};class PU{constructor(t,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Zr();this.outputShape=t,this.enableShapeUniforms=Qr(this.outputShape.length);let i="result";e&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<r.length;a++)o+=`\n          if(offset == ${a}) {\n            result = values[${M0e[r[a]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":f1(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${r.length});\n\n        flatIndex = idiv(flatIndex, ${r.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${s.texture2D}(A, uv);\n          ${o}\n        }\n        ${s.output} = vec4(${i}, 0., 0., 0.);\n      }\n    `}}class F0e{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Zr();this.outputShape=t,this.enableShapeUniforms=Qr(this.outputShape.length);let s="",i="result";e&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=2*o+a;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${o};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${l}] = values[0];\n            } else if (offset == 1) {\n              result[${l}] = values[1];\n            } else if (offset == 2) {\n              result[${l}] = values[2];\n            } else {\n              result[${l}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":f1(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${r.output} = ${i};\n        }\n    `}}function im(n,t,e,r,s,i){!function Dxe(n,t){const e=j().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0)throw new Error(`Requested texture size [${n}x${t}] is invalid.`);if(n>e||t>e)throw new Error(`Requested texture size [${n}x${t}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(t,e);const o=function Ixe(n){return Sa(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}(n),a=n.TEXTURE_2D;return ye(n,()=>n.bindTexture(a,o)),ye(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),ye(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),ye(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),ye(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),1===j().getNumber("WEBGL_VERSION")?ye(n,()=>n.texImage2D(a,0,r,t,e,0,s,i,null)):ye(n,()=>n.texStorage2D(a,1,r,t,e)),ye(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[e,t]}}function LU(n){return n.internalFormatFloat}function VU(n){return n.internalFormatHalfFloat}function BU(n){return n.downloadTextureFormat}function zU(n){return n.internalFormatPackedFloat}function UU(n){return n.internalFormatPackedHalfFloat}class g1{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=j().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function cxe(n,t){_l[n]=t}(e,t)):this.gl=po(e),t=this.gl,2===j().getNumber("WEBGL_VERSION")){const i=t;this.createVertexArray=()=>ye(i,()=>i.createVertexArray()),this.bindVertexArray=o=>ye(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>ye(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>ye(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(null!=t){const i=t.getExtension("OES_vertex_array_object");if(null==i)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ye(t,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>ye(t,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>ye(t,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>ye(t,()=>t.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===j().getNumber("WEBGL_VERSION")){const o="OES_texture_half_float";if(this.textureFloatExtension=mv(this.gl,"OES_texture_float"),Pi(this.gl,o))this.textureHalfFloatExtension=mv(this.gl,o);else if(j().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Pi(this.gl,s))this.colorBufferHalfFloatExtension=mv(this.gl,s);else if(j().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Pi(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!Pi(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function $0e(n){return function Sxe(n,t){const e=Sa(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ye(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),ye(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function P0e(n){return function Exe(n,t){const e=Sa(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ye(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),ye(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function Txe(n){return Sa(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=c1(this.gl,this.textureHalfFloatExtension)}get debug(){return j().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;ye(t,()=>t.finish()),ye(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),ye(t,()=>t.deleteFramebuffer(this.framebuffer)),ye(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),ye(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),ye(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function L0e(n,t,e,r){const[s,i]=rm(t,e);return im(n,s,i,LU(r),r.textureFormatFloat,n.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function V0e(n,t,e,r){const[s,i]=rm(t,e);return im(n,s,i,VU(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function B0e(n,t,e,r){const[s,i]=rm(t,e);return im(n,s,i,BU(r),n.RGBA,n.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function j0e(n,t,e){ye(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?2===j().getNumber("WEBGL_VERSION")?ye(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):ye(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):2===j().getNumber("WEBGL_VERSION")?ye(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):ye(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),ye(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,r,s){this.throwIfDisposed(),function W0e(n,t,e,r,s,i){let o,a,l;ye(n,()=>n.bindTexture(n.TEXTURE_2D,t)),s instanceof Uint8Array?(o=new Uint8Array(e*r*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(e*r*4),a=n.FLOAT,l=i.internalFormatPackedFloat),o.set(s),2===j().getNumber("WEBGL_VERSION")?ye(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,r,n.RGBA,a,o)):ye(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,e,r,0,n.RGBA,a,o)),ye(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function U0e(n,t,e,r){const[s,i]=kd(t,e);return im(n,s,i,UU(r),n.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function z0e(n,t,e,r){const[s,i]=kd(t,e);return im(n,s,i,zU(r),n.RGBA,n.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(TU(this.gl,this.framebuffer),this.outputTexture=null),ye(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function K0e(n,t,e,r){const[s,i]=rm(t,e),a=new Uint8Array(function hxe(n,t){return n*t}(t*e,4));return ye(n,()=>n.readPixels(0,0,s,i,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,r,s,i,o){return function X0e(n,t,e,r,s,i,o,a){const l=n,c=new Float32Array(function fxe(n,t){const[e,r]=kd(n,t);return e*r*4}(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}(this.gl,t,0,0,0,i,o)}downloadFloat32MatrixFromBuffer(t,e){return function q0e(n,t,e){const r=n,s=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,t,e)}createBufferFromTexture(t,e,r){this.bindTextureToFrameBuffer(t);const s=function G0e(n,t,e,r){const s=n.createBuffer();ye(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const a=16*t*e;return ye(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),ye(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),ye(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,r;if(j().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,i=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{const o=s.clientWaitSync(i,0,0);return o===s.ALREADY_SIGNALED||o===s.CONDITION_SATISFIED},e=i}else j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function Y0e(n,t,e){const r=new Float32Array(t*e*4);return ye(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,r)),r}(this.gl,e,r))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function O0e(n){const t=Zr();return function _xe(n,t){const e=Sa(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ye(n,()=>n.shaderSource(e,t)),ye(n,()=>n.compileShader(e)),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(n,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const r=function wxe(n){return Sa(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}(e);let s;return ye(e,()=>e.attachShader(r,this.vertexShader)),ye(e,()=>e.attachShader(r,t)),function Cxe(n,t){if(ye(n,()=>n.linkProgram(t)),!j().get("ENGINE_COMPILE_ONLY")&&!1===n.getProgramParameter(t,n.LINK_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(e,r),s=Object.assign(r,{vao:this.createVertexArray()}),this.bindVertexArray(s.vao),ye(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(function H0e(n,t,e){return ye(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),DU(n,t,"clipSpacePos",e,3,20,0)&&DU(n,t,"uv",e,2,20,12)}(e,s,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&u1(e,s),this.setProgram(s),s}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(ye(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&(this.bindVertexArray(this.program.vao),this.debug&&u1(this.gl,this.program)),ye(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,r=!0){return this.throwIfDisposed(),r?function Nxe(n,t,e){return Sa(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}(this.gl,t,e):function Axe(n,t,e){return n.getUniformLocation(t,e)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),ye(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),Rxe(this.gl,t,e,r)}setOutputMatrixTexture(t,e,r){this.setOutputMatrixTextureDriver(t,r,e)}setOutputPackedMatrixTexture(t,e,r){this.throwIfDisposed();const[s,i]=kd(e,r);this.setOutputMatrixTextureDriver(t,s,i)}setOutputMatrixWriteRegion(t,e,r,s){this.setOutputMatrixWriteRegionDriver(r,t,s,e)}setOutputPackedMatrixWriteRegion(t,e,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&u1(this.gl,this.program),gv(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ye(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ye(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=mv(this.gl,2===j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,i),i}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return ee(function*(){return yield wP(()=>e.disposed||e.isQueryAvailable(t,j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function Z0e(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in j().platform&&(r=j().platform.setTimeoutCustom.bind(j().platform)),wP(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),d1(this.gl,t,this.framebuffer),this.debug&&gv(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(d1(this.gl,this.outputTexture,this.framebuffer),this.debug&&gv(this.gl)):TU(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,e,r){this.throwIfDisposed();const s=this.gl;d1(s,t,this.framebuffer),this.debug&&gv(s),this.outputTexture=t,ye(s,()=>s.viewport(0,0,e,r)),ye(s,()=>s.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(t,e,r,s){this.throwIfDisposed(),ye(this.gl,()=>this.gl.scissor(t,e,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:Q0e,bincountImpl:HU,bincountReduceImpl:J0e,castImpl:ewe,ceilImpl:twe,concatImpl:nwe,equalImpl:rwe,expImpl:swe,expm1Impl:iwe,floorImpl:owe,gatherNdImpl:awe,gatherV2Impl:lwe,greaterImpl:cwe,greaterEqualImpl:uwe,lessImpl:dwe,lessEqualImpl:hwe,linSpaceImpl:fwe,logImpl:pwe,maxImpl:mwe,maximumImpl:gwe,minimumImpl:ywe,multiplyImpl:bwe,negImpl:_we,notEqualImpl:vwe,prodImpl:xwe,raggedGatherImpl:wwe,raggedRangeImpl:Cwe,raggedTensorToTensorImpl:Swe,rangeImpl:Ewe,rsqrtImpl:Iwe,scatterImpl:Dwe,sigmoidImpl:Twe,simpleAbsImpl:WU,sliceImpl:kwe,sparseFillEmptyRowsImpl:Nwe,sparseReshapeImpl:Awe,sparseSegmentReductionImpl:jU,sqrtImpl:Rwe,stridedSliceImpl:Mwe,stringNGramsImpl:Fwe,stringSplitImpl:Owe,stringToHashBucketFastImpl:$we,subImpl:Pwe,tileImpl:Lwe,topKImpl:Vwe,transposeImpl:y1,uniqueImpl:Bwe}=k;function GU(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function Jr(n,t){return 1===t?[n]:GU(n,t)}class Uwe{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Qr(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Jr("rc",this.rank),r=on(this.rank),s=this.getOutOfBoundsCondition(e),i=this.getSetup(e),o=this.getOutput(e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let i=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${t[t.length-1-o]},`+i;e.push(i)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class qU{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Qr(this.outputShape.length);let r="";for(let s=0;s<4;s++){let i="thisRC = rc;";s%2==1&&(i+="thisRC.z += 1;"),s>1&&(i+="thisRC.y += 1;"),r+=`\n        ${i}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}this.userCode=`\n      ${function Hwe(n,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?function Hxe(n,t,e="index"){const s=function Uxe(n,t){const e=n.length,r=n.map(i=>`${t}[${i}]`),s=new Array(e-1);s[e-2]=r[e-1];for(let i=e-3;i>=0;--i)s[i]=`(${s[i+1]} * ${r[i+1]})`;return s}(n.map((i,o)=>o),t);return s.map((i,o)=>`int ${n[o]} = ${e} / ${s[o]}; ${o===s.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${s[o]}`:`index -= ${n[o]} * ${s[o]}`};`).join("")}(["r","c","d"],"inputShape"):Ec(["r","c","d"],n)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":f1(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class Wwe{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,r){const s=XU(e,r),i=YU(t,s,r);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=KU(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].shift();return this.usedTextures[i].push(l),l}let a;return s===Sr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===Sr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===Sr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===Sr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===Sr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(t,e,r,s){if(null==this.freeTextures)return;const i=XU(r,s),o=YU(e,i,s);o in this.freeTextures||(this.freeTextures[o]=[]);const a=KU(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=j().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],u=c.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(u,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function KU(n,t,e,r,s){const i=function Gwe(n,t){switch(n){case Sr.PACKED_2X2_FLOAT32:return zU(t);case Sr.PACKED_2X2_FLOAT16:return UU(t);case Sr.UNPACKED_FLOAT32:return LU(t);case Sr.UNPACKED_FLOAT16:return VU(t);case Sr.PACKED_4X1_UNSIGNED_BYTE:return BU(t);default:throw new Error(`Unknown physical texture type ${n}`)}}(t,r);let o;if(s){const[l,c]=kd(n[0],n[1]);o=l*c}else{const[l,c]=rm(n[0],n[1]);o=l*c}const a=function jwe(n,t){if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(e,i);return o*a}function XU(n,t){if(n===Ms.UPLOAD)return Sr.PACKED_2X2_FLOAT32;if(n===Ms.RENDER||null==n)return function qwe(n){return j().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Sr.PACKED_2X2_FLOAT32:Sr.UNPACKED_FLOAT32:n?Sr.PACKED_2X2_FLOAT16:Sr.UNPACKED_FLOAT16}(t);if(n===Ms.DOWNLOAD||n===Ms.PIXELS)return Sr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function YU(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class Uo{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Qr(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const ZU="return abs(x);",vl="return x;";class xl{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Qr(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class sCe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=Qr(this.outputShape.length);const e=t.length,r=Jr("rc",e),s=on(e),i=function zwe(n,t){if(1===n)return"rc";let e="";for(let r=0;r<n;r++)e+=t[r],r<n-1&&(e+=",");return e}(e,r),o=r.slice(-2),a=e<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${i});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const iCe=eD,Sv={},cCe=j().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let hCe=(()=>{class n extends _S{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!j().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=e){if(e instanceof g1)r=e;else{const s=po(j().getNumber("WEBGL_VERSION"),e);r=new g1(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=po(j().getNumber("WEBGL_VERSION"));r=new g1(s),this.binaryCache=function lCe(n){return n in Sv||(Sv[n]={}),Sv[n]}(j().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Wwe(this.gpgpu),this.numMBBeforeWarning=function dCe(){return null==j().global.screen?1024:j().global.screen.height*j().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new vP(this,No())}nextDataId(){return n.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,s,i,o,a){const l=this.makeTensorInfo(r,s),c=this.texData.get(l.dataId);c.isPacked=!1,c.texture={texture:e,texShape:[i,o]},c.texShape=[i,o];const u=yv(r),d=new PU(u,!1,a),h=this.runWebGLProgram(d,[l],s,[[i,o]]);return h.shape=r,c.texture=null,this.disposeIntermediateTensorInfo(l),h.dataId}write(e,r,s){if((j().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||j().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===s&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:r,dtype:s,values:e,usage:Ms.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,s,i,o){if(j().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===i)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:i,values:r,usage:Ms.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:s,dtype:i,complexTensorInfos:o,slice:a,shape:l,isPacked:c}=r;if(null!=a){let f;f=c?new xl(l,vl):new Uo(l,vl);const p=this.runWebGLProgram(f,[{dataId:e,shape:l,dtype:i}],i),m=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),m}if(null!=s)return this.convertAndCacheOnCPU(e);if("string"===i)return s;const u=null!=this.activeTimers;let d,h;return u&&(d=us()),h="complex64"===i?_a(this.readSync(o.real.dataId),this.readSync(o.imag.dataId)):this.getValuesFromTexture(e),u&&(this.downloadWaitMs+=us()-d),this.convertAndCacheOnCPU(e,h)}read(e){var r=this;return ee(function*(){if(r.pendingRead.has(e)){const g=r.pendingRead.get(e);return new Promise(y=>g.push(y))}const s=r.texData.get(e),{values:i,shape:o,slice:a,dtype:l,complexTensorInfos:c,isPacked:u}=s;if(null!=a){let g;g=u?new xl(o,vl):new Uo(o,vl);const y=r.runWebGLProgram(g,[{dataId:e,shape:o,dtype:l}],l),b=r.read(y.dataId);return r.disposeIntermediateTensorInfo(y),b}if(null!=i)return r.convertAndCacheOnCPU(e);if(j().getBool("DEBUG")&&!j().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===j().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h,f,d=null;if("complex64"!==l&&j().get("WEBGL_BUFFER_SUPPORTED")){h=r.decode(e);const g=r.texData.get(h.dataId);d=r.gpgpu.createBufferFromTexture(g.texture.texture,...pv(o))}if(r.pendingRead.set(e,[]),"complex64"!==l&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===l){const g=yield Promise.all([r.read(c.real.dataId),r.read(c.imag.dataId)]);f=_a(g[0],g[1])}else if(null==d)f=r.getValuesFromTexture(e);else{const g=X(o);f=r.gpgpu.downloadFloat32MatrixFromBuffer(d,g)}if(null!=h&&r.disposeIntermediateTensorInfo(h),null!=d){const g=r.gpgpu.gl;ye(g,()=>g.deleteBuffer(d))}const p=r.convertAndCacheOnCPU(e,f),m=r.pendingRead.get(e);return r.pendingRead.delete(e),m.forEach(g=>g(p)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&No().removeDataId(e,r),r.pendingDeletes--),p})()}readToGPU(e,r={}){const s=this.texData.get(e),{values:i,shape:o,slice:a,dtype:l,isPacked:c,texture:u}=s;if("complex64"===l)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let p;p=c?new xl(o,vl):new Uo(o,vl);const m=this.runWebGLProgram(p,[{dataId:e,shape:o,dtype:l}],l),g=this.readToGPU(m,r);return this.disposeIntermediateTensorInfo(m),g}if(null==u)throw null!=i?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,r.customTexShape),h=No().makeTensorFromTensorInfo(d),f=this.texData.get(d.dataId);return Object.assign({tensorRef:h},f.texture)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(i=>Ya(i));return it(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return it(e.shape,e.dtype,r)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const s=e[r];if(!yxe(s))throw j().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:s,isPacked:i}=this.texData.get(e),o=X(r);if(j().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),p=this.texData.get(f.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...pv(r)).subarray(0,o);return this.disposeIntermediateTensorInfo(f),m}const a=j().getBool("WEBGL_PACK")&&!0===i,l=a?yv(r):r,c=a?new R0e(l):new A0e(l),u=this.runWebGLProgram(c,[{shape:l,dtype:s,dataId:e}],"float32"),d=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;const s=this.activeTimers,i=[];let o=!1;null==this.programTimersStack?(this.programTimersStack=i,o=!0):this.activeTimers.push(i),this.activeTimers=i,e();const a=ju(this.activeTimers.map(u=>u.query)).filter(u=>null!=u),l=ju(this.activeTimers.map(u=>u.name)).filter(u=>null!=u);this.activeTimers=s,o&&(this.programTimersStack=null);const c={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return ee(function*(){if(j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=yield Promise.all(a);c.kernelMs=function wte(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}(u),c.getExtraProfileInfo=()=>u.map((d,h)=>({name:l[h],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else c.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,c})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:us(),endMs:null}}endTimer(e){return j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=us(),e)}getQueryTime(e){var r=this;return ee(function*(){return j().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return null!=s&&(this.disposeData(s.real.dataId,r),this.disposeData(s.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:s,texShape:i,usage:o,isPacked:a,slice:l}=this.texData.get(e),c=l&&l.origDataId||e,u=this.dataRefCount.get(c);u>1?this.dataRefCount.set(c,u-1):(this.dataRefCount.delete(c),null!=r&&(this.numBytesInGPU-=this.computeBytes(i,s),this.textureManager.releaseTexture(r,i,o,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=cCe){return j().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>null==this.texData.get(s.dataId).texture&&X(s.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){Zs("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return iCe(e.shape,r)}packedUnaryOp(e,r,s){const i=new xl(e.shape,r),o=this.compileAndRun(i,[e],s);return No().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const i=WU(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(j().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,ZU,e.dtype);const r=new Uo(e.shape,ZU),s=this.compileAndRun(r,[e]);return No().makeTensorFromTensorInfo(s)}makeTensorInfo(e,r,s){let i;if("string"===r&&null!=s&&s.length>0&&_f(s[0])){const o=s.map(a=>Xa(a));i=this.write(o,e,r)}else i=this.write(s,e,r);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:r}}makeOutput(e,r,s){return No().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,s),this)}unpackTensor(e){const r=new sCe(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new Uwe(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const s=[Nd(e.shape),...Ad(e.shape)],i={dtype:e.dtype,shape:s,dataId:e.dataId},o=[Nd(r),...Ad(r)],a=new qU(o,s),u=this.runWebGLProgram(a,[i],e.dtype,[s],!0);return{dataId:u.dataId,shape:r,dtype:u.dtype}}decode(e,r){const s=this.texData.get(e),{isPacked:i,shape:o,dtype:a}=s;null!=r&&S(X(o)<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const l=yv(o);let c;c=i?new N0e(l):new k0e(l);const d=[r??pv(l)];return{dtype:a,shape:o,dataId:this.runWebGLProgram(c,[{shape:l,dtype:a,dataId:e}],a,d,!0,r).dataId}}runWebGLProgram(e,r,s,i,o=!1,a){const l=this.makeTensorInfo(e.outputShape,s),c=this.texData.get(l.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===Td.DENSE){const b=a??pv(e.outputShape);c.texShape=b.map(_=>2*_)}if(null!=e.outTexUsage&&(c.usage=e.outTexUsage),0===X(l.shape))return c.values=gr(l.dtype,0),l;const u=[],d=r.map(b=>{if("complex64"===b.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let _=this.texData.get(b.dataId);if(null==_.texture){if(!e.packedInputs&&X(b.shape)<=j().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:_.values};e.packedInputs&&(_.isPacked=!0,_.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!_.isPacked!=!!e.packedInputs)b=_.isPacked?this.unpackTensor(b):this.packTensor(b),u.push(b),_=this.texData.get(b.dataId);else if(_.isPacked&&!_v(_.shape,b.shape)){const v=b,w=b.shape;b.shape=_.shape,b=this.packedReshape(b,w),u.push(b),_=this.texData.get(b.dataId),v.shape=w}return{shape:b.shape,texData:_,isUniform:!1}});this.uploadToGPU(l.dataId);const h={shape:l.shape,texData:c,isUniform:!1},f=function T0e(n,t,e){let r="";t.concat(e).forEach(o=>{const a=null!=o.texData&&null!=o.texData.slice&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:d}=m1(n.packedInputs,o.shape,l);let h="",f="",p="";if(1===u.length&&n.packedInputs){const w=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${w[0]>1}_${w[1]>1}`}else if(2!==u.length||n.packedInputs){if(u.length>2&&!n.packedInputs){const w=Pe(u);p=`${w[0]===l[1]}_${w[w.length-1]===l[1]}`}}else f=`${u[0]>1}_${u[1]>1}`;const m=o.shape.length,g=2===u.length&&It(o.shape,l),y=1===X(o.shape),b=sd(o.shape,e.shape),_=!n.packedInputs&&m===e.shape.length&&It(l,e.texData.texShape);r+=`${m}_${_}_${c?d:""}_${u.length}_${y}_${b}_${g}_${h}_${f}_${p}_${n.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`}_${a}`}else r+=`${o.shape}_${o.isUniform?"uniform":o.texData.texShape}_${a}`});let i=n.constructor.name;return i+="_"+r+"_"+n.userCode+`${j().getNumber("WEBGL_VERSION")}`,i}(e,d,h),p=this.getAndSaveBinary(f,()=>function I0e(n,t,e,r){const s=e.map((u,d)=>{const h={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:!u.isUniform&&u.texData.isPacked,flatOffset:null};return null!=u.texData&&null!=u.texData.slice&&u.texData.slice.flatOffset>0&&(h.flatOffset=u.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:h}}),i=s.map(u=>u.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=Wxe(s,o,t),l=function vxe(n,t){const e=Sa(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ye(n,()=>n.shaderSource(e,t)),ye(n,()=>n.compileShader(e)),j().get("ENGINE_COMPILE_ONLY"))return e;if(!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw IU(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(n.gl,a),c=n.createProgram(l);return j().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o},OU(n,t,c))}(this.gpgpu,e,d,h)),m=null!=this.activeTimers;let g;m&&(g=this.startTimer()),j().get("ENGINE_COMPILE_ONLY")||function D0e(n,t,e,r,s){t.program.enableShapeUniforms||($U(t.inShapeInfos,e),$U([t.outShapeInfo],[r]));const i=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(t.webGLProgram),1===j().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&n.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&n.gl.uniform1f(t.nanLoc,NaN),e.forEach((l,c)=>{const u=t.program.variableNames[c],d=t.uniformLocations[u],h=t.uniformLocations[`offset${u}`],f=t.inShapesLocations[`${u}Shape`],p=t.inTexShapesLocations[`${u}TexShape`];if(f){const{uniformShape:m}=m1(t.program.packedInputs,l.shape,l.texData.texShape);switch(m.length){case 1:n.gl.uniform1iv(f,new Int32Array(m));break;case 2:n.gl.uniform2iv(f,new Int32Array(m));break;case 3:n.gl.uniform3iv(f,new Int32Array(m));break;case 4:n.gl.uniform4iv(f,new Int32Array(m))}}if(p&&n.gl.uniform2i(p,l.texData.texShape[0],l.texData.texShape[1]),null!=d){if(l.isUniform){if(X(l.shape)<2)n.gl.uniform1f(d,l.uniformValues[0]);else{let m=l.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),n.gl.uniform1fv(d,m)}return}null!=l.texData.slice&&null!=h&&n.gl.uniform1i(h,l.texData.slice.flatOffset),n.setInputMatrixTexture(l.texData.texture.texture,d,c)}});const a=t.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const l=Pe(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l))}}t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s&&t.program.customUniforms.forEach((l,c)=>{const u=t.customUniformLocations[c],d=s[c];if("float"===l.type)n.gl.uniform1fv(u,d);else if("vec2"===l.type)n.gl.uniform2fv(u,d);else if("vec3"===l.type)n.gl.uniform3fv(u,d);else if("vec4"===l.type)n.gl.uniform4fv(u,d);else if("int"===l.type)n.gl.uniform1iv(u,d);else if("ivec2"===l.type)n.gl.uniform2iv(u,d);else if("ivec3"===l.type)n.gl.uniform3iv(u,d);else{if("ivec4"!==l.type)throw Error(`uniform type ${l.type} is not supported yet.`);n.gl.uniform4iv(u,d)}}),n.executeProgram()}(this.gpgpu,p,d,h,i),u.forEach(b=>this.disposeIntermediateTensorInfo(b)),m&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const y=j().get("WEBGL_FLUSH_THRESHOLD");if(y>0){const b=us();b-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!j().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&!1===o){const b=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),b}return l}compileAndRun(e,r,s,i,o=!1){return this.runWebGLProgram(e,r,s=s||r[0].dtype,i,o)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(j().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=B(()=>{if(!j().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=j().getBool("DEBUG");j().set("DEBUG",!1);const r=this.abs(Le(1e-8)).dataSync()[0];if(j().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:s,dtype:i,values:o,texture:a,usage:l,isPacked:c}=r;if(null!=a)return;const u=null!=this.activeTimers;let d;u&&(d=us());let h=r.texShape;if(null==h&&(h=function Fxe(n,t=!1){let e=j().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=j().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&j().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),t&&(e*=2,r*=2,1===(n=n.map((a,l)=>l>=n.length-2?vS(n[l]):n[l])).length&&(n=[2,n[0]])),2!==n.length&&(n=Ga(n).newShape);let s=X(n),i=null;n.length<=1&&s<=e?i=[1,s]:2===n.length&&n[0]<=e&&n[1]<=e?i=n:3===n.length&&n[0]*n[1]<=e&&n[2]<=e?i=[n[0]*n[1],n[2]]:3===n.length&&n[0]<=e&&n[1]*n[2]<=e?i=[n[0],n[1]*n[2]]:4===n.length&&n[0]*n[1]*n[2]<=e&&n[3]<=e?i=[n[0]*n[1]*n[2],n[3]]:4===n.length&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(i=[n[0],n[1]*n[2]*n[3]]);const o=null!=i&&Math.max(...i)>r&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(null==i||o)if(t){const a=Nd(n);let l=2,c=2;n.length&&([l,c]=Ad(n)),s=a*(l/2)*(c/2),i=xS(s).map(u=>2*u)}else i=xS(s);return i}(s,c),r.texShape=h),null!=o){const f=yv(s);let p,m=h[1],g=h[0];const y=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(c||!y)&&([m,g]=kd(h[0],h[1])),p=c?new F0e(f,y):new PU(f,y);const b=y?[g,m]:h,_=this.makeTensorInfo(b,i),v=this.texData.get(_.dataId);v.usage=y?Ms.PIXELS:Ms.UPLOAD,v.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(_.dataId),m,g,o);const I=this.runWebGLProgram(p,[_],i,[[g,m]],!0),D=this.texData.get(I.dataId);r.texShape=D.texShape,r.isPacked=D.isPacked,r.usage=D.usage,j().get("ENGINE_COMPILE_ONLY")?this.disposeData(I.dataId):(r.texture=D.texture,r.values=null,this.texData.delete(I.dataId)),this.disposeIntermediateTensorInfo(_),u&&(this.uploadWaitMs+=us()-d)}else{const f=this.acquireTexture(h,l,i,c);r.texture=f}}convertAndCacheOnCPU(e,r){const s=this.texData.get(e),{dtype:i}=s;return null!=r&&(s.values=function fCe(n,t){if("float32"===t||"complex64"===t)return n;if("int32"===t||"bool"===t){const e="int32"===t?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<e.length;++r)e[r]=Math.round(n[r]);return e}throw new Error(`Unknown dtype ${t}`)}(r,i)),s.values}acquireTexture(e,r,s,i){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,i)}computeBytes(e,r){return e[0]*e[1]*wS(r)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return ee(function*(){const r=[];if(e.gpgpu.parallelCompilationExtension){for(const[,s]of Object.entries(e.binaryCache))r.push(e.checkCompletionAsync_(s));return Promise.all(r)}for(const[,s]of Object.entries(e.binaryCache)){const i=new Promise(o=>{try{e.checkCompletion_(s),o(!0)}catch(a){throw a}});r.push(i)}return Promise.all(r)})()}checkCompletionAsync_(e){var r=this;return ee(function*(){return r.gpgpu.gl.getProgramParameter(e.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(e):(yield PV(),r.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(IU(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:r,customUniformLocations:s,infLoc:i,nanLoc:o,inShapesLocations:a,inTexShapesLocations:l,outShapeLocation:c,outShapeStridesLocation:u,outTexShapeLocation:d}=OU(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=r,e.customUniformLocations=s,e.infLoc=i,e.nanLoc=o,e.inShapesLocations=a,e.inTexShapesLocations=l,e.outShapeLocation=c,e.outShapeStridesLocation=u,e.outTexShapeLocation=d}}createTensorFromTexture(e,r,s){const{texture:i,height:o,width:a,channels:l}=e,c=No().backend;if(!c.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=c.writeTexture(i,r,s,o,a,l);return No().makeTensorFromDataId(u,r,s,c)}}return n.nextDataId=0,n})();HP()&&DL("webgl",()=>new hCe,2);class $d{constructor(t,e,r){this.variableNames=["A","B"],this.outputShape=Je(e,r),this.enableShapeUniforms=Qr(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class am{constructor(t,e,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Je(e,r);const i=this.outputShape.length;this.enableShapeUniforms=Qr(i);let o="";if(s)if(0===i||1===X(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(o=`\n          ${on(i)} coords = getOutputCoords();\n        `,1===i)o+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const l=Jr("coords",i);o+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${l[i-2]} + 1) >= outShape[${i} - 2];\n            bool nextColOutOfBounds =\n              (${l[i-1]} + 1) >= outShape[${i} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};\n            bool nextColOutOfBounds =\n              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${o}\n\n        setOutput(result);\n      }\n    `}}function Fs(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const gCe={kernelName:zf,backendName:"webgl",kernelFunc:Fs};function wl(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,i=e.makeTensorInfo(r.shape,"complex64"),o=e.texData.get(i.dataId),a=Fs({inputs:{x:r},backend:e}),l=Fs({inputs:{x:s},backend:e});return o.complexTensorInfos={real:a,imag:l},i}const yCe={kernelName:OS,backendName:"webgl",kernelFunc:wl},QU="return (a < 0.) ? b * a : a;",JU="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",_Ce={kernelName:sb,backendName:"webgl",kernelFunc:function bCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:i}=r,o=e.makeTensorInfo([],"float32",Ka(i,"float32")),a=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new am(JU,s.shape,o.shape):new $d(QU,s.shape,o.shape),l=e.runWebGLProgram(a,[s,o],"float32");return e.disposeIntermediateTensorInfo(o),l}},e4="return (a < 0.) ? b * a : a;",t4="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",xCe={kernelName:Cb,backendName:"webgl",kernelFunc:function vCe(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t,i=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new am(t4,r.shape,s.shape):new $d(e4,r.shape,s.shape);return e.runWebGLProgram(i,[r,s],"float32")}};function kt({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:r}){return({inputs:s,backend:i})=>{const{x:o}=s,a=i,l=r||o.dtype;if(a.shouldExecuteOnCPU([o])&&null!=e){const d=a.texData.get(o.dataId),h=e(d.values,l);return a.makeTensorInfo(o.shape,l,h)}let u;return u=j().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new xl(o.shape,t):new Uo(o.shape,n),a.runWebGLProgram(u,[o],l)}}function Nr({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(r&&"complex64"===l.dtype){const p=u.texData.get(l.dataId),m=u.texData.get(c.dataId),[g,y]=[[p.complexTensorInfos.real,m.complexTensorInfos.real],[p.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(_=>{const[v,w]=_,C={dataId:v.dataId,dtype:v.dtype,shape:l.shape},I={dataId:w.dataId,dtype:w.dtype,shape:c.shape},D=new $d(n,l.shape,c.shape);return u.runWebGLProgram(D,[C,I],Ds(v.dtype,w.dtype))}),b=wl({inputs:{real:g,imag:y},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(y),b}const d=i||Ds(l.dtype,c.dtype);if(("string"===l.dtype||"string"===c.dtype||u.shouldExecuteOnCPU([l,c]))&&null!=s){const p=u.texData.get(l.dataId).values,m=u.texData.get(c.dataId).values,g="string"===l.dtype?mc(p):p,y="string"===l.dtype?mc(m):m,[b,_]=s(l.shape,c.shape,g,y,d),v=u.makeTensorInfo(_,d);return u.texData.get(v.dataId).values=b,v}let f;return f=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new am(t,l.shape,c.shape,e):new $d(n,l.shape,c.shape),u.runWebGLProgram(f,[l,c],d)}}function lm(n,t=!1){if("linear"===n)return"return x;";if("relu"===n)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===n)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===n)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===n)return t?t4:e4;if("leakyrelu"===n)return t?JU:QU;if("sigmoid"===n)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class n4{constructor(t,e,r,s=!1,i=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Qr(this.outputShape.length);const d=Math.ceil((s?t[1]:t[2])/2),h=s?"i * 2, rc.y":"rc.y, i * 2",f=i?"rc.z, i * 2":"i * 2, rc.z",p=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";a&&(g=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:c?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,y="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let _="rc.x",v="rc.x";t[0]<e[0]?_=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(v=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`\n      ${g}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${d}; i++) {\n          int batchA = ${_};\n          int batchB = ${v};\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${f});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${m[0]});\n          result += (${p[1]} * ${m[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${y}\n\n        setOutput(result);\n      }\n    `}}class s4{constructor(t,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Je(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const o4="return a * b;";function _1(n){const{inputs:t,backend:e}=n,{a:r,b:s}=t,i=Ds(r.dtype,s.dtype);if("complex64"===r.dtype){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),c=new s4("return areal * breal - aimag * bimag;",r.shape,s.shape),u=new s4("return areal * bimag + aimag * breal;",r.shape,s.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],h=e.runWebGLProgram(c,d,"float32"),f=e.runWebGLProgram(u,d,"float32"),p=wl({inputs:{real:h,imag:f},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}if(e.shouldExecuteOnCPU([r,s])){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),[c,u]=bwe(r.shape,s.shape,a.values,l.values,i),d=e.makeTensorInfo(u,i);return e.texData.get(d.dataId).values=c,d}let o;return o=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new am(o4,r.shape,s.shape):new $d(o4,r.shape,s.shape),e.runWebGLProgram(o,[r,s],i)}const wCe={kernelName:Yf,backendName:"webgl",kernelFunc:_1};function xe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:i}=r,o=e,a=X(s.shape),l=CP(i,a),c=X(l);S(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const u=o.texData.get(s.dataId);return!u.isPacked||_v(s.shape,l)||null!==u.texture&&_v(u.shape,l)?(o.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function CCe(n,t,e){const r=[Nd(n.shape),...Ad(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},i=[Nd(t),...Ad(t)],o=new qU(i,r),c=e.runWebGLProgram(o,[s],n.dtype,[r],!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(s,l,o)}const SCe={kernelName:Eb,backendName:"webgl",kernelFunc:xe};class a4{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=t;this.outputShape=[s,o];const a=4*Math.floor(r/4),l=r%4;let c="sumValue += dot(values, ones);";if(null!=e){const d=1/e;c=`sumValue += dot(values * ${Gu(d)?d.toPrecision(2):d}, ones);`}let u="";i%r>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${c}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${c}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}class ECe{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=t;this.outputShape=[s,o];let a="0.0",l="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",l="min"):"max"===e&&(a="-1.0 / 1e-20",l="max");let c=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?c="sumValue":"prod"===e?c="prodValue":"all"===e?c="allValue":"any"===e&&(c="anyValue");const u=4*Math.floor(r/4),d=r%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${l}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${l}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,f="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",f="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",f="bvec4");let p="";i%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${c});\n      }\n    `}}function Dc(n,t,e,r){const s=function ICe(n){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const e=t.length?t[t.length-1].outSize:n[1],r=T_(e);t.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return t}(n.shape);let i=n;for(let o=0;o<s.length;o++){const{inSize:a,windowSize:l,outSize:c}=s[o];let u,d;u="mean"===e?0===o?new a4({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new a4({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):new ECe({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},e),d=i,i=r.runWebGLProgram(u,[i],t),d.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(d)}return i}class DCe{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let o=0;o<r.length;o++)r[o]=t[e[o]];this.outputShape=r,this.rank=r.length;const s=on(this.rank),i=function TCe(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<n.length;s++)r[n[s]]=e[s];return r.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${i}));\n    }\n    `}}class kCe{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(t.length);for(let u=0;u<r.length;u++)r[u]=t[e[u]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=on(this.rank),i=GU("rc",this.rank),o=new Array(this.rank);for(let u=0;u<e.length;u++)o[e[u]]=i[u];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${l}) {\n        result[1] = ${c};\n      }\n      --${i[this.rank-1]};\n      if(++${i[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${c};\n        if(${l}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Ev(n,t,e){const r=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new kCe(n.shape,t):new DCe(n.shape,t);return e.runWebGLProgram(r,[n],n.dtype)}function Iv(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;return function NCe(n,t,e,r){const i=n.shape.length,o=ht(t,n.shape);let a=o;const l=En(a,i),c=null!=l;let u=n;c&&(u=Ev(n,l,r),a=Bn(a.length,i)),kr("sum",a,i);const[d,h]=xr(u.shape,a);let f=d;e&&(f=Vn(d,o));const p=X(h),y=xe({inputs:{x:u},attrs:{shape:[X(n.shape)/p,p]},backend:r}),_=Dc(y,zE(n.dtype),"sum",r),v=xe({inputs:{x:_},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(_),c&&r.disposeIntermediateTensorInfo(u),v}(s,i,o,e)}const ACe={kernelName:Ab,backendName:"webgl",kernelFunc:Iv};function es(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{perm:i}=r,o=e,l=new Array(s.shape.length);for(let u=0;u<l.length;u++)l[u]=s.shape[i[u]];let c;if(o.shouldExecuteOnCPU([s])){const d=o.texData.get(s.dataId).values,h=y1(d,s.shape,s.dtype,i,l);c=o.makeTensorInfo(l,s.dtype),o.texData.get(c.dataId).values=h}else c=Ev(s,i,o);return c}const RCe={kernelName:Zu,backendName:"webgl",kernelFunc:es};function Dv({a:n,b:t,transposeA:e,transposeB:r,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=t.shape.length,d=e?n.shape[c-2]:n.shape[c-1],h=r?t.shape[u-1]:t.shape[u-2],f=e?n.shape[c-1]:n.shape[c-2],p=r?t.shape[u-2]:t.shape[u-1],m=n.shape.slice(0,-2),g=t.shape.slice(0,-2),y=X(m),b=X(g),v=Je(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,p]);S(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${r} must match.`);const w=e?[y,d,f]:[y,f,d],C=r?[b,p,h]:[b,h,p],I=xe({inputs:{x:n},backend:s,attrs:{shape:w}}),D=xe({inputs:{x:t},backend:s,attrs:{shape:C}}),T=[I,D],N=Math.max(y,b),P=e?I.shape[1]:I.shape[2],z=null!=i,W=null!=o,G="leakyrelu"===l,q=null!=l?lm(l,!0):null;let V;if((1===f||1===p)&&P>1e3&&!1===(z||W||G||null!=q)){let H=I,ne=D;e&&(H=es({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),T.push(H)),r&&(ne=es({inputs:{x:D},backend:s,attrs:{perm:[0,2,1]}}),T.push(ne));const de=1===p;let ue=H;1!==p&&(ue=xe({inputs:{x:H},backend:s,attrs:{shape:[N,P,1]}}),T.push(ue));const he=1===p?2:1;let ge=ne;de&&(ge=xe({inputs:{x:ne},backend:s,attrs:{shape:[N,1,P]}}),T.push(ge));const Ee=_1({inputs:{a:ue,b:ge},backend:s});V=Iv({inputs:{x:Ee},backend:s,attrs:{axis:he,keepDims:!0}}),T.push(Ee)}else{const H=Ds(n.dtype,t.dtype),ne=new n4(w,C,[N,f,p],e,r,z,q,W,G),ie=[I,D];if(null!=i&&ie.push(i),W&&ie.push(o),G){const de=s.makeTensorInfo([],"float32",Ka(a,"float32"));ie.push(de),T.push(de)}V=s.runWebGLProgram(ne,ie,H)}const L=xe({inputs:{x:V},backend:s,attrs:{shape:v}});T.push(V);for(const H of T)s.disposeIntermediateTensorInfo(H);return L}const FCe={kernelName:Lb,backendName:"webgl",kernelFunc:function MCe(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:d}=r;return Dv({a:s,b:i,transposeA:l,transposeB:c,backend:e,bias:o,preluActivationWeights:a,leakyreluAlpha:d,activation:u})}},c4="return abs(x);",$Ce={kernelName:Py,backendName:"webgl",kernelFunc:function OCe(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const i=e.texData.get(r.dataId),o=WU(i.values);return e.makeTensorInfo(r.shape,r.dtype,o)}let s;return s=j().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new xl(r.shape,c4):new Uo(r.shape,c4),e.runWebGLProgram(s,[r],r.dtype)}},LCe=kt({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),VCe={kernelName:xf,backendName:"webgl",kernelFunc:LCe},zCe=kt({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),UCe={kernelName:wf,backendName:"webgl",kernelFunc:zCe},u4="return a + b;",HCe=Nr({opSnippet:u4,packedOpSnippet:u4,supportsComplex:!0,cpuKernelImpl:Q0e}),WCe={kernelName:Yu,backendName:"webgl",kernelFunc:HCe};class jCe{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`float v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class GCe{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`vec4 v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const qCe={kernelName:Ly,backendName:"webgl",kernelFunc:function Tv(n){const{inputs:t,backend:e}=n,r=t;if(1===r.length)return Fs({inputs:{x:r[0]},backend:e});if(r.length>j().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),c=Tv({inputs:r.slice(0,l),backend:e}),u=Tv({inputs:r.slice(l),backend:e});return Tv({inputs:[c,u],backend:e})}const s=r.map(l=>l.dtype).reduce((l,c)=>Ds(l,c)),i=r.map(l=>l.shape),a=j().getBool("WEBGL_PACK")?new GCe(r[0].shape,i):new jCe(r[0].shape,i);return e.runWebGLProgram(a,r,s)}},XCe={kernelName:"All",backendName:"webgl",kernelFunc:function KCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,l=ht(i,s.shape);let c=l;const u=En(c,a);let d=s;null!=u&&(d=es({inputs:{x:s},backend:e,attrs:{perm:u}}),c=Bn(c.length,a)),kr("all",c,a);const[h,f]=xr(d.shape,c),m=xe({inputs:{x:d},backend:e,attrs:{shape:[-1,X(f)]}}),g=Dc(m,m.dtype,"all",e);let y;return y=xe(o?{inputs:{x:g},backend:e,attrs:{shape:Vn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=u&&e.disposeIntermediateTensorInfo(d),y}},ZCe={kernelName:"Any",backendName:"webgl",kernelFunc:function YCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,l=ht(i,s.shape);let c=l;const u=En(c,a);let d=s;null!=u&&(d=es({inputs:{x:s},backend:e,attrs:{perm:u}}),c=Bn(c.length,a)),kr("any",c,a);const[h,f]=xr(d.shape,c),m=xe({inputs:{x:d},backend:e,attrs:{shape:[-1,X(f)]}}),g=Dc(m,m.dtype,"any",e);let y;return y=xe(o?{inputs:{x:g},backend:e,attrs:{shape:Vn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=u&&e.disposeIntermediateTensorInfo(d),y}};class QCe{constructor(t,e,r){this.variableNames=["A"];const{windowSize:s,batchSize:i,outSize:o}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class JCe{constructor(t,e,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,S(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),o>1&&this.outputShape.push(o),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=on(l),u=Jr("coords",l);let d,h;if(1===o){h=l+1;const D=on(h);d=`\n        ${D} sourceLocR = ${D}(${u.join()}, 0);\n        ++${u[l-1]};\n        ${D} sourceLocG = ${D}(${u.join()}, 0);\n        ++${u[l-2]};\n        ${D} sourceLocA = ${D}(${u.join()}, 0);\n        --${u[l-1]};\n        ${D} sourceLocB = ${D}(${u.join()}, 0);\n        --${u[l-2]};`}else h=l,d=`\n        ${c} sourceLocR = coords;\n        ++${u[l-1]};\n        ${c} sourceLocG = coords;\n        ++${u[l-2]};\n        ${c} sourceLocA = coords;\n        --${u[l-1]};\n        ${c} sourceLocB = coords;\n        --${u[l-2]};`;const f=["x","y","z","w","u","v"].slice(0,h),p="."+f[h-1],m=f.map(D=>"int "+D),g=Jr("sourceLocR",h-1).concat("inIdx.r"),y=Jr("sourceLocG",h-1).concat("inIdx.g"),b=Jr("sourceLocB",h-1).concat("inIdx.b"),_=Jr("sourceLocA",h-1).concat("inIdx.a"),v="max"===r?"greaterThan":"lessThan",w=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${_.join()})));`,C=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${y.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${_.join()}) : 0.)`,I=s?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${f.join()}),\n                                          vec2(${f.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${f.join()}),\n                               vec2(${f.slice(-2).join()}));\n      }\n      ${I}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};\n        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${C};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${C};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function d4(n,t,e,r=null){let s=t.shape[0],i=t.shape[1];null!=r&&(s=r.shape[0],i=r.shape[1]);const o=T_(i),a={windowSize:o,inSize:i,batchSize:s,outSize:Math.ceil(i/o)},l=new QCe(a,e,null==r),c=[t];null!=r&&c.push(r);const u=n.runWebGLProgram(l,c,"int32");if(1===u.shape[1])return u;const d=d4(n,t,e,u);return n.disposeIntermediateTensorInfo(u),d}function h4(n,t,e,r=null){const s=null!=r?r.shape:t.shape,o=T_(s[s.length-1]),a=new JCe(s,o,e,null==r),c=n.runWebGLProgram(a,null==r?[t]:[t,r],"int32");if(c.shape.length===t.shape.length){const u=h4(n,t,e,c);return n.disposeIntermediateTensorInfo(c),u}return c}function f4(n,t,e,r){const s=[e];if(kr("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!j().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const i=[],o=n.texData.get(t.dataId);let l=t;null!==o&&o.isPacked&&(l=n.unpackTensor(t),i.push(l));const[c,u]=xr(l.shape,s),d=X(u),h=xe({inputs:{x:l},backend:n,attrs:{shape:[-1,d]}});i.push(h);const f=d4(n,h,r);i.push(f);const p=xe({inputs:{x:f},backend:n,attrs:{shape:c}});return i.forEach(m=>n.disposeIntermediateTensorInfo(m)),p}return h4(n,t,r)}const tSe={kernelName:Vy,backendName:"webgl",kernelFunc:function eSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;let o=ht(i,s.shape);const a=En(o,s.shape.length);let l=s;const c=[];null!=a&&(l=es({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),o=Bn(o.length,l.shape.length)),kr("argMax",[o[0]],l.shape.length);const u=f4(e,l,o[0],"max");return c.forEach(d=>e.disposeIntermediateTensorInfo(d)),u}},rSe={kernelName:By,backendName:"webgl",kernelFunc:function nSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;let o=ht(i,s.shape);const a=En(o,s.shape.length);let l=s;const c=[];null!=a&&(l=es({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),o=Bn(o.length,l.shape.length)),kr("argMin",[o[0]],l.shape.length);const u=f4(e,l,o[0],"min");return c.forEach(d=>e.disposeIntermediateTensorInfo(d)),u}},iSe=kt({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),oSe={kernelName:Cf,backendName:"webgl",kernelFunc:iSe},lSe=kt({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),cSe={kernelName:Sf,backendName:"webgl",kernelFunc:lSe},dSe=kt({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),hSe={kernelName:Ef,backendName:"webgl",kernelFunc:dSe},mSe=Nr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),gSe={kernelName:Df,backendName:"webgl",kernelFunc:mSe},bSe=kt({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),_Se={kernelName:If,backendName:"webgl",kernelFunc:bSe};class cm{constructor(t,e,r,s=!1,i=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,u=t.dilationWidth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,f=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const m="avg"===e;let b="0.0";if(m||(b="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${l});\n        const ivec2 pads = ivec2(${f}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?i?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let v=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(v="avgValue / count");const w=4*Math.floor(o/4),C=o%4,I=`\n      if (${m}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${f}, ${p});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${c}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${w}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${I}\n          }\n\n          int xC = xCCorner + ${w};\n          if (${1===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${I}\n          } else if (${2===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${I}\n          } else if (${3===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${I}\n          }\n        }\n        setOutput(${v});\n      }\n    `}}class v1{constructor(t,e,r,s=!1,i=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideDepth,l=t.strideHeight,c=t.strideWidth,u=t.dilationDepth,d=t.dilationHeight,h=t.dilationWidth,f=t.effectiveFilterDepth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth,g=t.padInfo.front,y=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const _="avg"===e;let v="0.0";if(_||(v="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${l}, ${c});\n        const ivec3 pads = ivec3(${g}, ${y}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${f};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${m};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?i?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${m} +\n                      wR * ${m} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let C=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(C="avgValue / count");const I=4*Math.floor(o/4),D=o%4,T=`\n      if (${_}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${l}, ${c});\n      const ivec3 pads = ivec3(${g}, ${y}, ${b});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${f};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${I}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${T}\n            }\n\n            int xC = xCCorner + ${I};\n            if (${1===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${T}\n            } else if (${2===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${T}\n            } else if (${3===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${T}\n            }\n          }\n          setOutput(${C});\n        }\n      }\n    `}}const xSe={kernelName:zy,backendName:"webgl",kernelFunc:function vSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;sm(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r;S(Tr(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=Ii(s.shape,i,o,1,a,l);if(1===u.filterWidth&&1===u.filterHeight&&It(u.inShape,u.outShape))return Fs({inputs:{x:s},backend:e});const d=new cm(u,"avg",!1);return e.runWebGLProgram(d,[s],"float32")}},CSe={kernelName:Uy,backendName:"webgl",kernelFunc:function wSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r,d=pa(s.shape,i,o,[1,1,1],a,l,c),h=new v1(d,"avg",!1);return e.runWebGLProgram(h,[s],"float32")}};class SSe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const l=t.effectiveFilterHeight,c=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${l-1-t.padInfo.top}, ${c-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${c};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ESe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const d=t.effectiveFilterDepth,h=t.effectiveFilterHeight,f=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${d-1-t.padInfo.front}, ${h-1-t.padInfo.top}, ${f-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${f};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const DSe={kernelName:RS,backendName:"webgl",kernelFunc:function ISe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=pa(o.shape,a,l,[1,1,1],c,u),f=new ESe(h);return e.runWebGLProgram(f,[s],o.dtype)}},kSe={kernelName:AS,backendName:"webgl",kernelFunc:function TSe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i;sm([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=Ii(o.shape,a,l,1,c),d=new SSe(u);return e.runWebGLProgram(d,[s],o.dtype)}},ASe={kernelName:Hy,backendName:"webgl",kernelFunc:function NSe(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i}=t,{transposeA:o,transposeB:a}=r;return Dv({a:s,b:i,transposeA:o,transposeB:a,backend:e})}};class RSe{constructor(t,e,r,s,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Je(t,e),Je(t,r);let a="0.0";null!=s&&(Je(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";null!=i&&(Je(t,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${o}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class MSe{constructor(t,e,r,s,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Je(t,e),Je(t,r);let a="vec4(0.0)";null!=s&&(Je(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=i&&(Je(t,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${o}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const FSe={kernelName:tb,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,mean:s,variance:i,offset:o,scale:a}=n;S(s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==o||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;null==l&&(l=.001);const c=[r,s,i];let u=null;null!=o&&(u=o.shape,c.push(o));let d=null;null!=a&&(d=a.shape,c.push(a));const h=j().getBool("WEBGL_PACK_NORMALIZATION")?new MSe(r.shape,s.shape,i.shape,u,d,l):new RSe(r.shape,s.shape,i.shape,u,d,l);return t.runWebGLProgram(h,c,c[0].dtype)}};class OSe{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=on(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function $Se(n){if(1===n)return"sourceLoc";if(n<=6)return x1.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}(this.rank);let s;s=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((o,a)=>`sourceLoc.${x1[a]} = start[${a}] + coords.${x1[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}}const x1=["x","y","z","w","u","v"];class PSe{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=on(this.rank),r=Jr("coords",this.rank),s=Jr("sourceLoc",this.rank),i=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,o=`getChannel(getSource(${s.join()}), ${i})`,a=`\n      result.x = ${o};\n      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${o};\n        --${s[this.rank-1]};\n      }\n    `,l=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${o};\n        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,c=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((u,d)=>`start[${d}]`).join()});`:t.map((u,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${c}\n        vec4 result = vec4(0.);\n        ${a}\n        ${l}\n        setOutput(result);\n      }\n    `}}function Ld(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,size:o}=r,[a,l]=e_(s,i,o);if(pI(s,a,l),0===X(l))return e.makeTensorInfo(l,s.dtype,[]);if(e.shouldExecuteOnCPU([s])||"string"===s.dtype){const d=e.texData.get(s.dataId),h=kwe(d.values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,h)}const{isPacked:c}=e.texData.get(s.dataId),u=gI(s.shape,a,l);if(c||!u){const d=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PSe(l):new OSe(l);return e.runWebGLProgram(d,[s],s.dtype,[a])}return e.uploadToGPU(s.dataId),function LSe(n,t,e,r){const s=r.texData.get(n.dataId),i=r.makeTensorInfo(e,n.dtype),o=r.texData.get(i.dataId);Object.assign(o,s),o.refCount=1,o.shape=e,o.dtype=n.dtype;let a=yI(t,Pe(n.shape));s.slice&&(a+=s.slice.flatOffset),o.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||n.dataId};const l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),i}(s,a,l,e)}const VSe={kernelName:Nb,backendName:"webgl",kernelFunc:Ld},BSe={kernelName:Wy,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,crops:o}=r;S(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((b,_)=>b*_),l=$p(s.shape,i,a),c=Pp(l.length,i.length),u=Lp(s.shape,i,a),d=CD(o,i.length),h=SD(u,o,i.length),f=[],p=xe({inputs:{x:s},backend:e,attrs:{shape:l}}),m=es({inputs:{x:p},backend:e,attrs:{perm:c}}),g=xe({inputs:{x:m},backend:e,attrs:{shape:u}}),y=Ld({inputs:{x:g},backend:e,attrs:{begin:d,size:h}});return f.push(p),f.push(m),f.push(g),f.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}},USe={kernelName:MS,backendName:"webgl",kernelFunc:function zSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o}=r,a=e.readSync(s.dataId),l=e.readSync(i.dataId),c=HU(a,l,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,c)}},WSe={kernelName:FS,backendName:"webgl",kernelFunc:function HSe(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,i=e.readSync(r.dataId),o=e.readSync(s.dataId),a=Je(Array.from(i),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},p4=Nr({opSnippet:"return float(a != b);",cpuKernelImpl:vwe,dtype:"bool"}),jSe={kernelName:bb,backendName:"webgl",kernelFunc:p4};function um(n){const{inputs:t,backend:e}=n,{input:r}=t;return Fs({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const GSe={kernelName:mE,backendName:"webgl",kernelFunc:um},XSe={kernelName:Tf,backendName:"webgl",kernelFunc:function w1(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:i}=r;if("complex64"===i){if("complex64"===s.dtype)return Fs({inputs:{x:s},backend:e});const o=sr(s.shape),a=w1({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),l=wl({inputs:{real:a,imag:o},backend:e});return o.dispose(),e.disposeIntermediateTensorInfo(a),l}if("complex64"===s.dtype){const o=um({inputs:{input:s},backend:e}),a=w1({inputs:{x:o},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(o),a}if(!SP(s.dtype,i)){const o=Fs({inputs:{x:s},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(e.shouldExecuteOnCPU([s])){const o=e.texData.get(s.dataId).values,[a,l,c]=ewe(o,s.shape,s.dtype,i);return e.makeTensorInfo(a,l,c)}if("int32"===i)return function KSe(n,t){const e=new Uo(n.shape,"return float(int(x));"),r=t.runWebGLProgram(e,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,e);if("bool"===i){const o=e.makeTensorInfo([],"bool",gr("bool",1)),l=p4({inputs:{a:s,b:o},backend:e});return e.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}},m4="return ceil(x);",YSe=kt({opSnippet:m4,packedOpSnippet:m4,cpuKernelImpl:twe}),ZSe={kernelName:kf,backendName:"webgl",kernelFunc:YSe};class QSe{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class JSe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const tEe={kernelName:Nf,backendName:"webgl",kernelFunc:function eEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{clipValueMin:i,clipValueMax:o}=r;let a;return a=j().getBool("WEBGL_PACK_CLIP")?new JSe(s.shape):new QSe(s.shape),e.runWebGLProgram(a,[s],s.dtype,[[i],[o]])}};class nEe{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function g4(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}const sEe={kernelName:jy,backendName:"webgl",kernelFunc:function rEe(n){const{inputs:t,backend:e}=n,{x:r}=t,s=e.texData.get(r.dataId),i=new nEe(r.shape),o=[g4(r,s.complexTensorInfos.real),g4(r,s.complexTensorInfos.imag)];return e.runWebGLProgram(i,o,o[0].dtype)}};class iEe{constructor(t){this.outputShape=[],this.outputShape=Fo(t,1),this.variableNames=t.map((o,a)=>`T${a}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let o=1;o<e.length;o++)e[o]=e[o-1]+t[o][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<e.length;o++)r.push(`else if (yC < ${e[o]}) setOutput(getT${o}(yR, yC-${e[o-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class oEe{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Fo(t,e);const r=this.outputShape,s=r.length,i=on(s),o=Jr("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((m,g)=>`T${g}`);const l=new Array(t.length-1);l[0]=t[0][e];for(let m=1;m<l.length;m++)l[m]=l[m-1]+t[m][e];const c=a[e],u=a.slice(-2),d=a.join();let h=`if (${c} < ${l[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${u.join()}));\n        }`;for(let m=1;m<l.length;m++){const g=l[m-1];h+=`\n        if (${c} < ${l[m]}  && ${c} >= ${l[m-1]}) {\n          return getChannel(\n            getT${m}(${kv(a,c,g)}),\n            vec2(${kv(u,c,g)}));\n        }`}const p=l[l.length-1];h+=`\n        return getChannel(\n          getT${l.length}(${kv(a,c,p)}),\n          vec2(${kv(u,c,p)}));`,this.userCode=`\n      float getValue(${a.map(m=>"int "+m)}) {\n        ${h}\n      }\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${o}), 0., 0., 0.);\n\n        ${o[s-1]} = ${o[s-1]} + 1;\n        if (${o[s-1]} < ${r[s-1]}) {\n          result.g = getValue(${o});\n        }\n\n        ${o[s-2]} = ${o[s-2]} + 1;\n        if (${o[s-2]} < ${r[s-2]}) {\n          result.a = getValue(${o});\n        }\n\n        ${o[s-1]} = ${o[s-1]} - 1;\n        if (${o[s-2]} < ${r[s-2]} &&\n            ${o[s-1]} < ${r[s-1]}) {\n          result.b = getValue(${o});\n        }\n        setOutput(result);\n      }\n    `}}function kv(n,t,e){const r=n.indexOf(t);return n.map((i,o)=>o===r?`${i} - ${e}`:i).join()}function Nv(n){const{inputs:t,backend:e}=n,{input:r}=t;return Fs({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const aEe={kernelName:tE,backendName:"webgl",kernelFunc:Nv};function dm(n,t,e){const r=n[0].dtype;if("complex64"===r){const f=n.map(b=>um({inputs:{input:b},backend:e})),p=n.map(b=>Nv({inputs:{input:b},backend:e})),m=dm(f,t,e),g=dm(p,t,e),y=wl({inputs:{real:m,imag:g},backend:e});return f.forEach(b=>e.disposeIntermediateTensorInfo(b)),p.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),y}let s=e.shouldExecuteOnCPU(n);if("string"===r&&(s=!0),s){const f=n.map(v=>{const C=[-1,X(v.shape.slice(t))];return xe({inputs:{x:v},backend:e,attrs:{shape:C}})}),p=f.map(v=>({vals:e.readSync(v.dataId),shape:v.shape})),m=Fo(f.map(v=>v.shape),1),y=nwe(p,m,r,1===f[0].shape[0]),b=Fo(n.map(v=>v.shape),t),_=e.makeTensorInfo(b,r,y);return f.forEach(v=>e.disposeIntermediateTensorInfo(v)),_}const i=n.filter(f=>X(f.shape)>0),o=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(1===i.length){const f=o?new Uo(n[0].shape,vl):new xl(n[0].shape,vl);return e.runWebGLProgram(f,n,r)}const a=j().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const f=[];for(let m=0;m<i.length;m+=a){const g=i.slice(m,m+a);f.push(dm(g,t,e))}const p=dm(f,t,e);for(const m of f)e.disposeIntermediateTensorInfo(m);return p}if(o){const f=new oEe(i.map(p=>p.shape),t);return e.runWebGLProgram(f,i,r)}const{tensors2D:l,outShape:c}=function lEe(n,t,e){const r=Fo(n.map(i=>i.shape),t);return{tensors2D:n.map(i=>xe({inputs:{x:i},attrs:{shape:[-1,X(i.shape.slice(t))]},backend:e})),outShape:r}}(i,t,e),u=new iEe(l.map(f=>f.shape)),d=e.runWebGLProgram(u,l,r);l.forEach(f=>e.disposeIntermediateTensorInfo(f));const h=xe({inputs:{x:d},attrs:{shape:c},backend:e});return e.disposeIntermediateTensorInfo(d),h}function y4(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,i=ht(s,t[0].shape)[0];vD(t.map(c=>c.shape),i);const a=Fo(t.map(c=>c.shape),i);if(0===X(a))return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(c=>X(c.shape)>0);return 1===l.length?Fs({inputs:{x:l[0]},backend:e}):dm(l,i,e)}const cEe={kernelName:Gy,backendName:"webgl",kernelFunc:y4};class b4{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,c=t.strideWidth,u=t.dilationHeight,d=t.dilationWidth,h=t.filterHeight,f=t.filterWidth,p=4*Math.floor(t.inChannels/4),m=t.inChannels%4,g="channelsLast"===t.dataFormat,y=g?1:2,b=g?2:3,_=g?3:1;let v="",w="";r&&(v=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,w="result = activation(result);");const C=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${_}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${y}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${g}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===m}) {\n\n              if (${g}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===m}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===m}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${C}\n        ${w}\n        setOutput(result);\n      }\n    `}}class uEe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,r=t.padInfo.top,s=t.padInfo.left,i=t.strideDepth,o=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,u=t.dilationWidth,d=t.filterDepth,h=t.filterHeight,f=t.filterWidth,p=4*Math.floor(t.inChannels/4),m=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${i}, ${o}, ${a});\n      const ivec3 pads = ivec3(${e}, ${r}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${l};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${c};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${f}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===m}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class _4{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Qr(this.outputShape.length);const o=t.padInfo.left,a=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,u=t.filterWidth,d=u;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<u;g++)h+=`\n           vec4 xTexelC${2*g};\n           int xTexelC${2*g}Ready;\n           vec4 xTexelC${2*g+1};\n           int xTexelC${2*g+1}Ready;\n           vec4 xC${g};`;h+=`\n     for (int r = 0; r < ${c}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let g=0;g<u;g++)h+=`\n           xTexelC${2*g} = vec4(0.0);\n           xTexelC${2*g}Ready = 0;\n           xTexelC${2*g+1} = vec4(0.0);\n           xTexelC${2*g+1}Ready = 0;\n           xC${g} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let g=0;g<(d+1)/2;g++){const y=2*g;if(h+=`\n           xC = xCCorner + ${y*l};\n           `,1===a){if(y<u&&(o%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n               `,h+=1===l&&y>0?`\n                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);\n                   } else {\n                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xC${y} = xTexelC${y};\n                 `,y+1<u)){const b=o%2==0?vS(l):l;l%2==0&&o%2==1||l%2!=0&&o%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${b};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${y+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${y+1}Ready = 1;\n                   }\n                   `,h+=l>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);\n                     } else {\n                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);\n                     }\n                     `:`\n                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);\n                     `):h+=1===b?`\n                     xC${y+1} = xTexelC${y};\n                     `:`\n                     xCOffset = xC + ${b};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${y+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${y+1}Ready = 1;\n                     }\n\n                     xC${y+1} = xTexelC${y+1};\n                     `}}else y<u&&(o%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n               `,y+1<u&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(\n                   xTexelC${y}.xy, xTexelC${y+1}.xy);\n               `,y+1<u&&(h+=`\n                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n                 `)));y<u&&(h+=`\n             wTexel = getW(r, ${y}, d1, d2);\n             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,y+1<u&&(h+=`\n               wTexel = getW(r, ${y+1}, d1, d2);\n               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let f="",p="";r&&(f=s?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${r}\n         }`:i?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${r}\n         }`:`vec4 activation(vec4 x) {\n           ${r}\n         }`,p="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${f}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${m}\n         ${p}\n         setOutput(result);\n       }\n     `}}class dEe{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Qr(this.outputShape.length);const{dataFormat:r}=e,s=Zr(),i="channelsLast"===r,o=i?1:2,a=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let c="";for(let u=0;u<=1;u++)for(let d=0;d<=1;d++)c+=`\n          blockIndex = rc.z + ${d};\n          pos = rc.y + ${u};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${o}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${i}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+d}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+d}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${c}\n\n        ${s.output} = result;\n      }\n    `}}function Av(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&1===e&&n[0]>1?[n[0],1]:null}function v4({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,c=r.texData.get(n.dataId),u=e.inChannels,d=l[0]*l[1]*l[2],h=e.outChannels,f="channelsLast"===e.dataFormat;let g;const y=[];if(null!=i){const v=Av(i.shape,f);null!=v&&(i=xe({inputs:{x:i},backend:r,attrs:{shape:v}}),y.push(i))}if(null!=s){const v=Av(s.shape,f);null!=v&&(s=xe({inputs:{x:s},backend:r,attrs:{shape:v}}),y.push(s))}if((1!==d&&1!==h||!(u>1e3))&&c.isPacked&&f&&null!=c.texture&&l[2]%2!=0&&It(c.shape.slice(-3),l.slice(-3))){const w={dataId:n.dataId,shape:[1,l[0]*l[1]*(l[2]+1),e.inChannels],dtype:n.dtype},C=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,S(_v(c.shape,w.shape),()=>`packed reshape ${c.shape} to ${w.shape} isn't free`);const I=xe({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(I);const D=Dv({a:w,b:I,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),T=r.texData.get(D.dataId);S(T.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=C,T.shape=e.outShape,g=Fs({inputs:{x:D},backend:r}),g.shape=e.outShape,y.push(D)}else{const v=e.outHeight*e.outWidth,w=xe({inputs:{x:n},backend:r,attrs:{shape:f?[e.batchSize,v,e.inChannels]:[e.batchSize,e.inChannels,v]}}),C=xe({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),I=Dv({a:f?w:C,b:f?C:w,transposeA:!f,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o});g=xe({inputs:{x:I},backend:r,attrs:{shape:e.outShape}}),y.push(w),y.push(C),y.push(I)}for(const v of y)r.disposeIntermediateTensorInfo(v);return g}function x4({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:d,outHeight:h,dataFormat:f}=e,p="channelsLast"===f,m=l*c*u,g=h*d,y=[e.batchSize,m,g],v=[];if(null!=i){const L=Av(i.shape,p);null!=L&&(i=xe({inputs:{x:i},backend:r,attrs:{shape:L}}),v.push(i))}if(null!=s){const L=Av(s.shape,p);null!=L&&(s=xe({inputs:{x:s},backend:r,attrs:{shape:L}}),v.push(s))}const w=xe({inputs:{x:t},backend:r,attrs:{shape:[1,m,X(t.shape)/m]}});v.push(w);const C=new dEe(y,e),D=r.runWebGLProgram(C,[n],"float32",[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),T=xe({inputs:{x:D},backend:r,attrs:{shape:y}});v.push(D),v.push(T);const N=null!=s,P=null!=i,z="leakyrelu"===a,W=a?lm(a,!0):null,G=new n4(p?T.shape:w.shape,p?w.shape:T.shape,p?[e.batchSize,g,e.outChannels]:[e.batchSize,e.outChannels,g],!0,!1,N,W,P,z),q=p?[T,w]:[w,T];if(s&&q.push(s),P&&q.push(i),z){const L=r.makeTensorInfo([],"float32",Ka(o,"float32"));q.push(L),v.push(L)}const $=r.runWebGLProgram(G,q,"float32"),V=xe({inputs:{x:$},backend:r,attrs:{shape:e.outShape}});v.push($);for(const L of v)r.disposeIntermediateTensorInfo(L);return V}const fEe={kernelName:qy,backendName:"webgl",kernelFunc:function hEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r,d=ma(l),h=vr(s.shape,i.shape,o,c,a,u,!1,d);let f;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&j().getBool("WEBGL_EXP_CONV")){const m=new _4(h);f=e.runWebGLProgram(m,[s,i],"float32",[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]])}else if(j().getBool("WEBGL_CONV_IM2COL"))f=x4({x:s,filter:i,convInfo:h,backend:e});else{const m=new b4(h);f=e.runWebGLProgram(m,[s,i],"float32")}else f=v4({x:s,filter:i,convInfo:h,backend:e});const p=xe({inputs:{x:f},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(f),p}};class pEe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===t.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class mEe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,o="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${o?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${o?1:2}], coords[${o?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${o}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class gEe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class yEe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,r=t.filterHeight,s=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${r-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const _Ee={kernelName:$S,backendName:"webgl",kernelFunc:function bEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,d=ma(l),h=vr(s.shape,u,o,1,a,c,!1,d),f=new pEe(h);return e.runWebGLProgram(f,[s,i],"float32")}},xEe={kernelName:Ky,backendName:"webgl",kernelFunc:function vEe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r,d=ma(c),h=vr(o,i.shape,a,1,l,u,!1,d),f=new mEe(h);return e.runWebGLProgram(f,[s,i],"float32")}},CEe={kernelName:Xy,backendName:"webgl",kernelFunc:function wEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l}=r,c=nl(s.shape,i.shape,o,l,a),u=new uEe(c);return e.runWebGLProgram(u,[s,i],"float32")}},EEe={kernelName:PS,backendName:"webgl",kernelFunc:function SEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,filterShape:l}=r,c=nl(s.shape,l,o,1,a),u=new gEe(c);return e.runWebGLProgram(u,[s,i],"float32")}},DEe={kernelName:LS,backendName:"webgl",kernelFunc:function IEe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{pad:o,strides:a,inputShape:l}=r,c=nl(l,i.shape,a,1,o),u=new yEe(c);return e.runWebGLProgram(u,[s,i],"float32")}},kEe=kt({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),NEe={kernelName:Af,backendName:"webgl",kernelFunc:kEe},AEe=kt({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),REe={kernelName:Rf,backendName:"webgl",kernelFunc:AEe};class MEe{constructor(t,e,r,s,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=t,[u]=e,[d,h]=r;this.outputShape=[u,d,h,c];const f="bilinear"===s?1:0,[p,m]=[a-1+".0",l-1+".0"],[g,y,b]=d>1?[""+(a-1)/(d-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[_,v,w]=h>1?[""+(l-1)/(h-1),"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${_});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${y};\n        float width_scale = ${v};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${i}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${m} ) {\n          setOutput(float(${i}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${f} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const FEe={kernelName:BS,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:i,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:c}=r,u=new MEe(s.shape,i.shape,a,l,c);return e.runWebGLProgram(u,[s,i,o],"float32")}};var Vd=(()=>{return(n=Vd||(Vd={})).Prod="*",n.Sum="+",Vd;var n})();class w4{constructor(t,e,r,s){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,a=r?this.op===Vd.Prod?"1.0":"0.0":`getX(${C4(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",u="";r?(c=s?"end != "+(l-1):"end != 0",u=s?"end + 1":"end - 1"):(c=s?`end + pow2 < ${l}`:"end >= pow2",u=s?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${on(i)} coords = getOutputCoords();\n        int end = ${S4(i,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${c}) {\n          int idx = ${u};\n          ${S4(i,"coords",this.op)} = idx;\n          val ${this.op}= getX(${C4(i,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function C4(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.x, ${t}.y`;if(3===n)return`${t}.x, ${t}.y, ${t}.z`;if(4===n)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function S4(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.y`;if(3===n)return`${t}.z`;if(4===n)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function E4(n,t,e,r,s,i){const o=t.shape.length,a=En([r],o);let l=t;null!=a&&(l=es({inputs:{x:t},backend:e,attrs:{perm:a}}));const c=Bn(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const u=l.shape[c];let d=Fs({inputs:{x:l},backend:e});for(let h=0;h<=Math.ceil(Math.log2(u))-1;h++){const f=new w4(n,l.shape,!1,i),m=d;d=e.runWebGLProgram(f,[d],d.dtype,[[h]]),e.disposeIntermediateTensorInfo(m)}if(s){const h=new w4(n,l.shape,s,i),f=d;d=e.runWebGLProgram(h,[d],d.dtype),e.disposeIntermediateTensorInfo(f)}if(null!=a){const f=es({inputs:{x:d},backend:e,attrs:{perm:il(a)}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(l),f}return d}const $Ee={kernelName:VS,backendName:"webgl",kernelFunc:function OEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;return E4(Vd.Prod,s,e,i,o,a)}},LEe={kernelName:Yy,backendName:"webgl",kernelFunc:function PEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;return E4(Vd.Sum,s,e,i,o,a)}},BEe={kernelName:zS,backendName:"webgl",kernelFunc:function VEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o,binaryOutput:a}=r;if(1===s.shape.length){const l=e.readSync(s.dataId),c=e.readSync(i.dataId),u=HU(l,c,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,u)}if(2===s.shape.length){const l=e.bufferSync(s),c=e.bufferSync(i),u=J0e(l,c,o,a);return e.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class zEe{constructor(t,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const HEe={kernelName:US,backendName:"webgl",kernelFunc:function UEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:i,dataFormat:o}=r,a=s.shape[0],d=("NHWC"===o?s.shape[1]:s.shape[2])*i,h=("NHWC"===o?s.shape[2]:s.shape[3])*i,f=("NHWC"===o?s.shape[3]:s.shape[1])/(i*i),m=new zEe("NHWC"===o?[a,d,h,f]:[a,f,d,h],i,o);return e.runWebGLProgram(m,[s],s.dtype)}};class I4{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Qr(this.outputShape.length);const o=t.filterHeight,a=t.filterWidth,l=t.outChannels/t.inChannels;let c="",u="";r&&(c=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,u="result = activation(result);");const d=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${c}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${o}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${d}\n        ${u}\n        setOutput(result);\n      }\n    `}}class D4{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Qr(this.outputShape.length);const o=t.outChannels/t.inChannels,a=t.padInfo.left,l=t.strideWidth,c=t.dilationWidth,u=t.filterHeight,d=t.filterWidth,h=d;let f="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let y=0;y<d;y++)f+=`\n          vec4 xTexelC${2*y};\n          int xTexelC${2*y}Ready;\n          vec4 xTexelC${2*y+1};\n          int xTexelC${2*y+1}Ready;\n          vec4 xC${y};`;f+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let y=0;y<d;y++)f+=`\n          xTexelC${2*y} = vec4(0.0);\n          xTexelC${2*y}Ready = 0;\n          xTexelC${2*y+1} = vec4(0.0);\n          xTexelC${2*y+1}Ready = 0;\n          xC${y} = vec4(0.0);`;f+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let y=0;y<(h+1)/2;y++){const b=2*y;if(f+=`\n          xC = xCCorner + ${b*c};\n          `,1===l){if(b<d&&(a%2==1?(f+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n              `,f+=1===c&&b>0?`\n                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);\n                  } else {\n                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);\n                  }\n                  `):f+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xC${b} = xTexelC${b};\n                `,b+1<d)){const _=a%2==0?vS(c):c;c%2==0&&a%2==1||c%2!=0&&a%2!=1?(f+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${_};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${b+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${b+1}Ready = 1;\n                  }\n                  `,f+=c>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);\n                    } else {\n                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);\n                    }\n                    `:`\n                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);\n                    `):f+=1===_?`\n                    xC${b+1} = xTexelC${b};\n                    `:`\n                    xCOffset = xC + ${_};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${b+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${b+1}Ready = 1;\n                    }\n\n                    xC${b+1} = xTexelC${b+1};\n                    `}}else b<d&&(a%2==1?(f+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n              `,b+1<d&&(f+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);\n                `)):(f+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(\n                  xTexelC${b}.xy, xTexelC${b+1}.xy);\n              `,b+1<d&&(f+=`\n                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n                `)));b<d&&(f+=`\n            wTexel = getW(r, ${b}, d1, q);\n            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);\n          `,b+1<d&&(f+=`\n              wTexel = getW(r, ${b+1}, d1, q);\n              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}f+="\n    }\n  ",f+="\n      }\n    ";let p="",m="";r&&(p=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:i?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,m="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${f}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${g}\n        ${m}\n        setOutput(result);\n      }\n    `}}const jEe={kernelName:Zy,backendName:"webgl",kernelFunc:function WEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;let u=l;null==u&&(u=[1,1]),S(Tr(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const d=vr(s.shape,i.shape,o,u,a,c,!0);let h;return h=j().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new D4(d):new I4(d),e.runWebGLProgram(h,[s,i],"float32",[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]])}};class GEe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class qEe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,l=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${l}; dm++) {\n              int d2 = d1 * ${l} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const XEe={kernelName:HS,backendName:"webgl",kernelFunc:function KEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r,d=vr(s.shape,u,o,a,l,c,!0),h=new GEe(d);return e.runWebGLProgram(h,[s,i],"float32")}},ZEe={kernelName:WS,backendName:"webgl",kernelFunc:function YEe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r,d=vr(u,i.shape,o,a,l,c,!0),h=new qEe(d);return e.runWebGLProgram(h,[s,i],"float32")}};class QEe{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const eIe={kernelName:jS,backendName:"webgl",kernelFunc:function JEe(n){const{inputs:t,backend:e}=n,{x:r}=t,s=[...r.shape,...r.shape],i=X(r.shape),o=xe({inputs:{x:r},backend:e,attrs:{shape:[i]}}),a=new QEe(i),l=e.runWebGLProgram(a,[o],o.dtype),c=xe({inputs:{x:l},backend:e,attrs:{shape:s}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}};class tIe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:r,padInfo:s,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=t,{top:d,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${c};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${l}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const rIe={kernelName:Qy,backendName:"webgl",kernelFunc:function nIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l}=r,c=xp(s.shape,i.shape,o,a,"NHWC",l);let u;const d=new tIe(c);u=e.runWebGLProgram(d,[s,i],"float32");const h=xe({inputs:{x:u},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(u),h}},iIe={kernelName:KS,backendName:"webgl",kernelFunc:function sIe(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,i=t,{allDims:o,summedDims:a,idDims:l}=FD(s,i.length);$D(o.length,l,i);const{path:c,steps:u}=PD(a,l),d=u.length;let h=null,f=o.length;const p=[];for(let m=0;m<d;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=OD(f,l[g]);let _;LD(y)?_=i[g]:(_=es({inputs:{x:i[g]},backend:e,attrs:{perm:y}}),p.push(_));const v=_.shape.slice();for(let w=0;w<b.length;++w)v.splice(b[w],0,1);It(_.shape,v)||(_=xe({inputs:{x:_},backend:e,attrs:{shape:v}}),p.push(_)),null===h?h=_:(h=_1({inputs:{a:_,b:h},backend:e}),p.push(h))}m<d-1&&(c[m]>=0&&(h=Iv({inputs:{x:h},backend:e,attrs:{axis:c[m]-(o.length-f),keepDims:!1}}),p.push(h)),f--)}for(const m of p)m!==h&&e.disposeIntermediateTensorInfo(m);return h}},oIe=kt({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),aIe={kernelName:Ff,backendName:"webgl",kernelFunc:oIe},uIe={kernelName:XS,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e}=n,{dy:r,y:s}=t,i=j().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new am("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new $d("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,s.shape);return e.runWebGLProgram(i,[r,s],r.dtype)}},dIe=Nr({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:rwe}),hIe={kernelName:Jy,backendName:"webgl",kernelFunc:dIe},pIe=kt({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${ID};\n  float a1 = ${DD};\n  float a2 = ${TD};\n  float a3 = ${kD};\n  float a4 = ${ND};\n  float a5 = ${AD};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),mIe={kernelName:Of,backendName:"webgl",kernelFunc:pIe},T4=kt({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:swe,dtype:"float32"}),yIe={kernelName:$f,backendName:"webgl",kernelFunc:T4};function C1(n){const{inputs:t,attrs:e,backend:r}=n,{dim:s}=e,{input:i}=t,o=i.shape.length,a=i.shape.slice();let l=s;return s<0&&(S(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+s+1),a.splice(l,0,1),xe({inputs:{x:i},backend:r,attrs:{shape:a}})}const bIe={kernelName:eb,backendName:"webgl",kernelFunc:C1},k4="return exp(x) - 1.0;",_Ie=kt({opSnippet:k4,packedOpSnippet:k4,cpuKernelImpl:iwe}),vIe={kernelName:Pf,backendName:"webgl",kernelFunc:_Ie};class N4{constructor(t,e,r){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const i=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${s}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${i};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function A4(n,t,e){const r=e.texData.get(n.dataId),s=X(n.shape),i=n.shape[n.shape.length-1],a=xe({inputs:{x:n},backend:e,attrs:{shape:[s/i,i]}}),l=a.shape,c=new N4("real",l,t),u=new N4("imag",l,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=e.runWebGLProgram(c,d,"float32"),f=e.runWebGLProgram(u,d,"float32"),p=wl({inputs:{real:h,imag:f},backend:e});e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f);const m=xe({inputs:{x:p},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(p),m}const wIe={kernelName:"FFT",backendName:"webgl",kernelFunc:function xIe(n){const{inputs:t,backend:e}=n,{input:r}=t;return A4(r,!1,e)}};class CIe{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function hm(n){const{backend:t,attrs:e}=n,{shape:r,value:s}=e;let{dtype:i}=e;if(i=i||vf(s),"string"===i){const o=Kn(i,X(r));return o.fill(s),t.makeTensorInfo(r,i,o)}{const o=new CIe(r,s);return t.runWebGLProgram(o,[],i,[[s]])}}const SIe={kernelName:ZS,backendName:"webgl",kernelFunc:hm};class EIe{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const IIe={kernelName:QS,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,r=t,s=new EIe(e.shape);return r.runWebGLProgram(s,[e],e.dtype)}},R4="return floor(x);",DIe=kt({opSnippet:R4,packedOpSnippet:R4,cpuKernelImpl:owe}),TIe={kernelName:Lf,backendName:"webgl",kernelFunc:DIe},kIe=Nr({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),NIe={kernelName:Vf,backendName:"webgl",kernelFunc:kIe};class AIe{constructor(t){this.variableNames=["A"];const e=Zr(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class RIe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Zr(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const MIe={kernelName:ME,backendName:"webgl",kernelFunc:function FIe(n){const{inputs:t,backend:e,attrs:r}=n;let{pixels:s}=t;const{numChannels:i}=r,o=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,c]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],u=[c,l],d=[c,l,i];if(a||o){const m=j().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==Bd||m!==S1)&&(S1=m,Bd=document.createElement("canvas").getContext("2d",{willReadFrequently:S1})),Bd.canvas.width=l,Bd.canvas.height=c,Bd.drawImage(s,0,0,l,c),s=Bd.canvas}const h=e.makeTensorInfo(u,"int32");e.texData.get(h.dataId).usage=Ms.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId),s);const f=j().getBool("WEBGL_PACK")?new RIe(d):new AIe(d),p=e.runWebGLProgram(f,[h],"int32");return e.disposeData(h.dataId),p}};let Bd,S1=j().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const $Ie={kernelName:Vb,backendName:"webgl",kernelFunc:function OIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r,m=ma(u),g=vr(s.shape,i.shape,l,d,c,h,!1,m);let y;const b=[],_=null!=o,v=null!=a,w="leakyrelu"===f,C=()=>{const D=[s,i],T=(N,P)=>{if("NCHW"===P&&1===N.shape.length&&1!==N.shape[0]){const z=xe({inputs:{x:N},backend:e,attrs:{shape:[N.shape[0],1,1]}});return b.push(z),z}return N};if(_&&D.push(T(o,u)),v&&D.push(T(a,u)),w){const N=e.makeTensorInfo([],"float32",Ka(p,"float32"));D.push(N),b.push(N)}return D};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&j().getBool("WEBGL_EXP_CONV")){const D=f?lm(f,!0):null,T=new _4(g,_,D,v,w),N=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],P=C();y=e.runWebGLProgram(T,P,"float32",N)}else if(j().getBool("WEBGL_CONV_IM2COL"))y=x4({x:s,filter:i,convInfo:g,backend:e,bias:o,activation:f,preluActivationWeights:a,leakyreluAlpha:p});else{const D=f?lm(f,!1):null,T=new b4(g,_,D,v,w),N=C();y=e.runWebGLProgram(T,N,"float32")}else y=v4({x:s,filter:i,convInfo:g,backend:e,bias:o,activation:f,preluActivationWeights:a,leakyreluAlpha:p});const I=xe({inputs:{x:y},backend:e,attrs:{shape:g.outShape}});return b.push(y),b.forEach(D=>e.disposeIntermediateTensorInfo(D)),I}},LIe={kernelName:Bb,backendName:"webgl",kernelFunc:function PIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dilations:u,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,p=[];let m=u;null==m&&(m=[1,1]),S(Tr(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=vr(s.shape,i.shape,l,m,c,d,!0),y=j().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,b=h?lm(h,y):null,_=[s,i],v=null!=o,w=null!=a,C="leakyrelu"===h;if(v&&_.push(o),w&&_.push(a),C){const N=e.makeTensorInfo([],"float32",Ka(f,"float32"));_.push(N),p.push(N)}let I;I=y?new D4(g,v,b,w,C):new I4(g,v,b,w,C);const T=e.runWebGLProgram(I,_,"float32",[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]]);return p.forEach(N=>e.disposeIntermediateTensorInfo(N)),T}};class VIe{constructor(t,e,r,s){this.sliceDim=t,this.strides=e,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const i=on(r.length);let o="\n    int index;";for(let a=0;a<this.sliceDim;a++)o+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${i} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${o}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const zIe={kernelName:JS,backendName:"webgl",kernelFunc:function BIe(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,i=s.shape,o=i[i.length-1],a=X(r.shape),[l,c,u,d]=ED(r,s),h=xe({inputs:{x:s},backend:e,attrs:{shape:[c,o]}}),f=xe({inputs:{x:r},backend:e,attrs:{shape:[X(r.shape)/u,u]}});if(e.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const y=e.readSync(s.dataId),b=e.bufferSync(r),_=awe(y,b,r.dtype,c,o,u,d,r.shape,a);return e.makeTensorInfo(l,r.dtype,_.values)}const p=new VIe(o,d,[c,u],r.shape),m=e.runWebGLProgram(p,[f,h],f.dtype),g=xe({inputs:{x:m},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),g}};class UIe{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=on(this.rank),s=function HIe(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)r.push(2===s?"index":`${e[s]}`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}function M4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:i}=t,{axis:o,batchDims:a}=r,l=ht(o,s.shape)[0];if(j().get("DEBUG")){const b=e.readSync(i.dataId),_=s.shape[l];for(let v=0;v<b.length;++v){const w=b[v];S(w<=_-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${_-1}]`)}}const c=zD(s,i,l,a),u=X(i.shape),d=[],h=xe({inputs:{x:s},backend:e,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),f=xe({inputs:{x:i},backend:e,attrs:{shape:[c.batchSize,u/c.batchSize]}});d.push(h),d.push(f);const p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(e.shouldExecuteOnCPU([s,i])||"string"===s.dtype){const b=e.bufferSync(f),_=e.bufferSync(h),v=lwe(_,b,p);return d.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.makeTensorInfo(c.outputShape,v.dtype,v.values)}const m=new UIe(h.shape,p),g=e.runWebGLProgram(m,[h,f],h.dtype);d.push(g);const y=xe({inputs:{x:g},backend:e,attrs:{shape:c.outputShape}});return d.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}const WIe={kernelName:nb,backendName:"webgl",kernelFunc:M4},jIe=Nr({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:cwe,dtype:"bool"}),GIe={kernelName:rb,backendName:"webgl",kernelFunc:jIe},qIe=Nr({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:uwe}),KIe={kernelName:Bf,backendName:"webgl",kernelFunc:qIe},YIe={kernelName:eE,backendName:"webgl",kernelFunc:function XIe(n){const{inputs:t,backend:e}=n,{input:r}=t;return A4(r,!0,e)}},ZIe=kt({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),QIe={kernelName:Uf,backendName:"webgl",kernelFunc:ZIe},JIe=kt({opSnippet:"return float(isinf(x));",dtype:"bool"}),eDe={kernelName:Hf,backendName:"webgl",kernelFunc:JIe},tDe=kt({opSnippet:"return float(isnan(x));",dtype:"bool"}),nDe={kernelName:Wf,backendName:"webgl",kernelFunc:tDe},rDe=Nr({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:dwe,dtype:"bool"}),sDe={kernelName:ib,backendName:"webgl",kernelFunc:rDe},iDe=Nr({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:hwe,dtype:"bool"}),oDe={kernelName:ob,backendName:"webgl",kernelFunc:iDe},lDe={kernelName:nE,backendName:"webgl",kernelFunc:function aDe(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:i}=e,o=fwe(r,s,i);return t.makeTensorInfo([o.length],"float32",o)}},uDe=kt({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:pwe}),dDe={kernelName:jf,backendName:"webgl",kernelFunc:uDe},fDe=kt({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"}),pDe={kernelName:Gf,backendName:"webgl",kernelFunc:fDe},mDe=Nr({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),gDe={kernelName:ab,backendName:"webgl",kernelFunc:mDe},yDe=kt({opSnippet:"return float(!(x >= 1.0));"}),bDe={kernelName:lb,backendName:"webgl",kernelFunc:yDe},_De=Nr({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),vDe={kernelName:cb,backendName:"webgl",kernelFunc:_De};class xDe{constructor(t,e,r,s,i){this.variableNames=["x"],this.outputShape=[];const o=e,a=t[3]-1;let l;this.outputShape=t;const c=`float(${r}) + float(${s}) * sum`;l=.5===i?`inversesqrt(${c})`:1===i?`1.0/(${c})`:`exp(log(${c}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${l};\n        setOutput(val);\n      }\n    `}}class wDe{constructor(t,e,r,s,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=e,a=t[3]-1;let l;this.outputShape=t;const c=`float(${r}) + float(${s}) * sum`;l=.5===i?`inversesqrt(${c})`:1===i?`1.0/(${c})`:`exp(log(${c}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${l};\n        setOutput(result);\n      }\n    `}}const CDe={kernelName:ub,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:i,bias:o,alpha:a,beta:l}=r,c=j().getBool("WEBGL_PACK_NORMALIZATION")?new wDe(s.shape,i,o,a,l):new xDe(s.shape,i,o,a,l);return e.runWebGLProgram(c,[s],s.dtype)}};class SDe{constructor(t,e,r,s,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=r,this.alpha=s,this.beta=i,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${i})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${i});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const EDe={kernelName:rE,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s,y:i,dy:o}=t,{depthRadius:a,bias:l,alpha:c,beta:u}=r,d=new SDe(s.shape,a,l,c,u);return e.runWebGLProgram(d,[s,i,o],s.dtype)}};function F4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:i,keepDims:o}=r,a=s.shape.length,l=ht(i,s.shape);let c=l;const u=En(c,a),d=null!=u,h=e.shouldExecuteOnCPU([s]);let f=s;if(d){if(h){const _=e.texData.get(f.dataId).values,v=new Array(a);for(let I=0;I<v.length;I++)v[I]=s.shape[u[I]];const w=y1(_,s.shape,s.dtype,u,v);f=e.makeTensorInfo(v,s.dtype),e.texData.get(f.dataId).values=w}else f=Ev(s,u,e);c=Bn(c.length,a)}kr("max",c,a);const[p,m]=xr(f.shape,c);let y,g=p;if(o&&(g=Vn(p,l)),h){const _=e.texData.get(f.dataId).values,v=mwe(_,X(m),g,s.dtype);y=e.makeTensorInfo(g,s.dtype),e.texData.get(y.dataId).values=v}else y=function IDe(n,t,e,r){const s=X(t),a=xe({inputs:{x:n},attrs:{shape:[X(n.shape)/s,s]},backend:r}),l=Dc(a,n.dtype,"max",r),c=xe({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}(f,m,g,e);return d&&e.disposeIntermediateTensorInfo(f),y}const DDe={kernelName:db,backendName:"webgl",kernelFunc:F4},NDe=Nr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:gwe}),ADe={kernelName:qf,backendName:"webgl",kernelFunc:NDe},MDe={kernelName:hb,backendName:"webgl",kernelFunc:function RDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;sm(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r;S(Tr(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=Ii(s.shape,i,o,1,a,l);if(1===u.filterWidth&&1===u.filterHeight&&It(u.inShape,u.outShape))return Fs({inputs:{x:s},backend:e});const d=new cm(u,"max",!1);return e.runWebGLProgram(d,[s],s.dtype)}},ODe={kernelName:fb,backendName:"webgl",kernelFunc:function FDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,d=pa(s.shape,i,o,[1,1,1],a,c,l),h=new v1(d,"max",!1);return e.runWebGLProgram(h,[s],s.dtype)}};class $De{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const i=t.effectiveFilterHeight,o=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${i-1-t.padInfo.top}, ${o-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${i*o-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${o} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class PDe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,u=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${l-1-t.padInfo.front}, ${c-1-t.padInfo.top}, ${u-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${l*c*u-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${c} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const VDe={kernelName:iE,backendName:"webgl",kernelFunc:function LDe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=pa(o.shape,a,l,[1,1,1],c,u),f=new v1(h,"max",!0),p=e.runWebGLProgram(f,[o],o.dtype),m=new PDe(h),g=e.runWebGLProgram(m,[s,p],o.dtype);return e.disposeIntermediateTensorInfo(p),g}},zDe={kernelName:sE,backendName:"webgl",kernelFunc:function BDe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i,output:o}=t,a=i;sm([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=r,h=Ii(a.shape,l,c,1,u,d),p=new cm(h,"max",!0),m=e.runWebGLProgram(p,[a],a.dtype),g=new $De(h),y=e.runWebGLProgram(g,[s,m],a.dtype);return e.disposeIntermediateTensorInfo(m),y}},HDe={kernelName:oE,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=t,l=e;S(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];S(Tr(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const u=Ii(r.shape,s,i,c,o),[d,h]=function UDe(n,t,e,r){let s=new cm(e,"max",!1);const i=r.runWebGLProgram(s,[n],"float32");return s=new cm(e,"max",!0,!0,t),[i,r.runWebGLProgram(s,[n],"float32")]}(r,a,u,l);return[d,h]}},jDe={kernelName:pb,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{keepDims:s,axis:i}=t,o=e,a=r.shape.length,l=ht(i,r.shape);let c=l;const u=En(c,a),d=null!=u,h=o.shouldExecuteOnCPU([r]),f=[];let p=r;if(d){if(h){const v=o.texData.get(p.dataId).values,w=new Array(a);for(let D=0;D<w.length;D++)w[D]=r.shape[u[D]];const C=y1(v,r.shape,r.dtype,u,w);p=o.makeTensorInfo(w,r.dtype),o.texData.get(p.dataId).values=C}else p=Ev(r,u,o);f.push(p),c=Bn(c.length,a)}kr("sum",c,a);const[m,g]=xr(p.shape,c);let y=m;s&&(y=Vn(m,l));const b=function WDe(n,t,e,r){const s=X(t),a=xe({inputs:{x:n},attrs:{shape:[X(n.shape)/s,s]},backend:r}),l=Dc(a,"float32","mean",r),c=xe({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}(p,g,y,o);for(const _ of f)o.disposeIntermediateTensorInfo(_);return b}},qDe={kernelName:mb,backendName:"webgl",kernelFunc:function GDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,l=ht(i,s.shape);let c=l;const u=En(c,a);let d=s;null!=u&&(d=es({inputs:{x:s},backend:e,attrs:{perm:u}}),c=Bn(c.length,s.shape.length)),kr("min",c,a);const[h,f]=xr(d.shape,c),m=xe({inputs:{x:d},backend:e,attrs:{shape:[-1,X(f)]}}),g=Dc(m,m.dtype,"min",e);let y;return y=xe(o?{inputs:{x:g},backend:e,attrs:{shape:Vn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=u&&e.disposeIntermediateTensorInfo(d),y}},YDe=Nr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:ywe}),ZDe={kernelName:Kf,backendName:"webgl",kernelFunc:YDe};class QDe{constructor(t,e,r){this.variableNames=["x"],this.outputShape=e.map((u,d)=>u[0]+t[d]+u[1]);const s=t.length,i=on(s),o=e.map(u=>u[0]).join(","),a=e.map((u,d)=>u[0]+t[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c="reflect"===r?0:1;this.userCode=1!==s?`\n      ${i} start = ${i}(${o});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${c};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};\n          }\n        }\n        ${i} coords = outC - start;\n        setOutput(getX(${l}));\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${c};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${c};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class JDe{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((p,m)=>p[0]+t[m]+p[1]);const s=t.length,i=on(s),o=e.map(p=>p[0]).join(","),a=e.map((p,m)=>p[0]+t[m]).join(","),l=Jr("rc",s),c=Jr("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${c.slice(-2).join()})`,h="reflect"===r?0:1;let f="";if(1===s){const p=`\n        ${i} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;f=`\n        ${i} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${c.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${u}) {\n          ${p}\n          result[1] = getChannel(getX(${c.join()}), ${d});\n        }\n      `}else{const p=`\n        ${i} source = rc;\n        ${i} lt = ${i}(lessThan(source, start));\n        ${i} gte = ${i}(greaterThanEqual(source, end));\n        ${i} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;f=`\n        ${i} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${c.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${u}) {\n          ${p}\n          result[1] = getChannel(getX(${c.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${l[s-2]} += 1;\n        if(${l[s-2]} < ${this.outputShape[s-2]}) {\n          ${p}\n          result[2] = getChannel(getX(${c.join()}), ${d});\n          ${l[s-1]} += 1;\n          if(${u}) {\n            ${p}\n            result[3] = getChannel(getX(${c.join()}), ${d});\n          }\n        }\n      `}this.userCode=`\n      const ${i} start = ${i}(${o});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}const eTe={kernelName:gb,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r}=n,{paddings:s,mode:i}=e,o=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new JDe(r.shape,s,i):new QDe(r.shape,s,i);return t.runWebGLProgram(o,[r],r.dtype)}},rTe=Nr({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),sTe={kernelName:Xf,backendName:"webgl",kernelFunc:rTe};class iTe{constructor(t,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const O4=Nr({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),oTe={kernelName:Mf,backendName:"webgl",kernelFunc:O4},$4="return a - b;",P4=Nr({opSnippet:$4,packedOpSnippet:$4,supportsComplex:!0,cpuKernelImpl:Pwe}),aTe={kernelName:dp,backendName:"webgl",kernelFunc:P4};function L4(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:i}=r,o=ht([i],s.shape),a=F4({inputs:{x:s},backend:e,attrs:{reductionIndices:o,keepDims:!1}}),l=Vn(a.shape,o),c=xe({inputs:{x:a},backend:e,attrs:{shape:l}}),u=P4({inputs:{a:s,b:c},backend:e}),d=T4({inputs:{x:u},backend:e}),h=Iv({inputs:{x:d},backend:e,attrs:{axis:o,keepDims:!1}}),f=xe({inputs:{x:h},backend:e,attrs:{shape:l}}),p=O4({inputs:{a:d,b:f},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}const lTe={kernelName:Fb,backendName:"webgl",kernelFunc:L4},uTe={kernelName:aE,backendName:"webgl",kernelFunc:function cTe(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:i,seed:o,normalized:a}=r,l=a?s:L4({inputs:{logits:s},backend:e,attrs:{dim:s.shape.length-1}}),d=new iTe(l.shape[0],l.shape[1],i),f=e.runWebGLProgram(d,[l],"int32",[[o]]);return a||e.disposeIntermediateTensorInfo(l),f}},pTe={kernelName:yb,backendName:"webgl",kernelFunc:function fTe(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])){const i=e.texData.get(r.dataId),[o,a]=_we(i.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,o)}let s;return s=j().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new xl(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Uo(r.shape,"if (isnan(x)) return x;\n  return -x;\n"),e.runWebGLProgram(s,[r],r.dtype)}},mTe=aD,yTe={kernelName:lE,backendName:"webgl",kernelFunc:function gTe(n){Zs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r,c=e.readSync(s.dataId),u=e.readSync(i.dataId),{selectedIndices:d}=mTe(c,u,o,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},bTe=lD,vTe={kernelName:cE,backendName:"webgl",kernelFunc:function _Te(n){Zs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r,u=e.readSync(s.dataId),d=e.readSync(i.dataId),{selectedIndices:h,validOutputs:f}=bTe(u,d,o,a,l,c);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},xTe=cD,CTe={kernelName:uE,backendName:"webgl",kernelFunc:function wTe(n){Zs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,u=e.readSync(s.dataId),d=e.readSync(i.dataId),h=o,f=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=xTe(u,d,h,f,p,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class STe{constructor(t,e,r,s){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const ETe={kernelName:vb,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{dtype:i,depth:o,onValue:a,offValue:l}=r,c=X(s.shape),u=new STe(c,o,a,l),d=xe({inputs:{x:s},backend:e,attrs:{shape:[c]}}),h=e.runWebGLProgram(u,[d],i);e.disposeIntermediateTensorInfo(d);const p=xe({inputs:{x:h},backend:e,attrs:{shape:[...s.shape,o]}});return e.disposeIntermediateTensorInfo(h),p}};function Rv(n){const{inputs:t,backend:e}=n,{x:r}=t;if("complex64"===r.dtype){const s=um({inputs:{input:r},backend:e}),i=Rv({inputs:{x:s},backend:e}),o=Nv({inputs:{input:r},backend:e}),a=Rv({inputs:{x:o},backend:e}),l=wl({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return hm({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const ITe={kernelName:Pb,backendName:"webgl",kernelFunc:Rv},DTe={kernelName:_b,backendName:"webgl",kernelFunc:function V4(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const s=um({inputs:{input:r},backend:e}),i=V4({inputs:{x:s},backend:e}),o=Nv({inputs:{input:r},backend:e}),a=Rv({inputs:{x:o},backend:e}),l=wl({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return hm({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},kTe={kernelName:xb,backendName:"webgl",kernelFunc:function TTe(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return C1({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const i=t[0].shape,o=t[0].dtype;t.forEach(u=>{Is(i,u.shape,"All tensors passed to stack must have matching shapes"),S(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=y4({inputs:t.map(u=>{const d=C1({inputs:{input:u},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(u=>e.disposeIntermediateTensorInfo(u)),c}};class NTe{constructor(t,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((c,u)=>c[0]+t[u]+c[1]);const s=t.length,i=on(s),o=e.map(c=>c[0]).join(","),a=e.map((c,u)=>c[0]+t[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${i} start = ${i}(${o});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${i} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class ATe{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((m,g)=>m[0]+t[g]+m[1]);const s=t.length,i=on(s),o=e.map(m=>m[0]).join(","),a=e.map((m,g)=>m[0]+t[g]).join(","),l=Jr("rc",s),c=Jr("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${c.slice(-2).join()})`,h=[`${i} rc = outputLoc;`,`${l[s-1]} += 1;\n       if(${u}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${l[s-2]} += 1;\n       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${l[s-1]} += 1;\n         if(${u}) {`],f=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let m=0,g=1===s?2:4;m<g;m++)p+=`\n        ${h[m]}\n        if (${f}) {\n          result[${m}] = float(value);\n        } else {\n          ${i} source = rc - start;\n          result[${m}] = getChannel(getX(${c.join()}), ${d});\n        }\n      `;p+=1===s?"} ":"}}",this.userCode=`\n      const ${i} start = ${i}(${o});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const B4=n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:i,constantValue:o}=r;if(0===X(s.shape))return hm({backend:e,attrs:{shape:i.map((u,d)=>u[0]+s.shape[d]+u[1]),value:o,dtype:s.dtype}});const a=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ATe(s.shape,i,o):new NTe(s.shape,i,o);return e.runWebGLProgram(a,[s],s.dtype,[[o]])},RTe={kernelName:wb,backendName:"webgl",kernelFunc:B4},OTe=Nr({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),$Te={kernelName:Zf,backendName:"webgl",kernelFunc:OTe},LTe={kernelName:Sb,backendName:"webgl",kernelFunc:function PTe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,l=[],c=ht(i,s.shape);let u=c;const d=En(u,a);let f,h=s;if(null!=d&&(h=es({inputs:{x:s},backend:e,attrs:{perm:d}}),u=Bn(u.length,a),l.push(h)),kr("prod",u,a),e.shouldExecuteOnCPU([h])){const p=e.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:y}=xwe(h.shape,h.dtype,p,u);f=e.makeTensorInfo(g,y,m)}else{const[p,m]=xr(h.shape,u),g=X(m),y=xe({inputs:{x:h},backend:e,attrs:{shape:[-1,g]}}),_=Dc(y,zE(s.dtype),"prod",e);f=xe({inputs:{x:_},backend:e,attrs:{shape:p}}),l.push(y),l.push(_)}if(o){l.push(f);const p=Vn(f.shape,c);f=xe({inputs:{x:f},backend:e,attrs:{shape:p}})}return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}},BTe={kernelName:dE,backendName:"webgl",kernelFunc:function VTe(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=t,{outputRaggedRank:a}=r,l=s.map(y=>e.readSync(y.dataId)),c=s.map(y=>y.shape),u=e.readSync(i.dataId),d=e.readSync(o.dataId),[h,f,p]=wwe(l,c,u,i.shape,i.dtype,d,o.shape,a),m=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),g=e.makeTensorInfo(p,i.dtype,f);return m.concat([g])}},UTe={kernelName:hE,backendName:"webgl",kernelFunc:function zTe(n){const{inputs:t,backend:e}=n,{starts:r,limits:s,deltas:i}=t,o=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(i.dataId),[c,u]=Cwe(o,r.shape,r.dtype,a,s.shape,l,i.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([u.length],r.dtype,u)]}},WTe={kernelName:fE,backendName:"webgl",kernelFunc:function HTe(n){const{inputs:t,backend:e,attrs:r}=n,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=r,c=e.readSync(s.dataId),u=e.readSync(i.dataId),d=e.readSync(o.dataId),h=a.map(g=>e.readSync(g.dataId)),f=a.map(g=>g.shape),[p,m]=Swe(c,s.shape,u,i.shape,i.dtype,d,o.shape,h,f,l);return e.makeTensorInfo(p,i.dtype,m)}},z4=n=>{const{backend:t,attrs:e}=n,{start:r,stop:s,step:i,dtype:o}=e,a=Ewe(r,s,i,o);return t.makeTensorInfo([a.length],o,a)},jTe={kernelName:pE,backendName:"webgl",kernelFunc:z4},GTe=kt({opSnippet:"return 1.0 / x;"}),qTe={kernelName:Qf,backendName:"webgl",kernelFunc:GTe},XTe=kt({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),YTe={kernelName:Jf,backendName:"webgl",kernelFunc:XTe},QTe=kt({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),JTe={kernelName:ep,backendName:"webgl",kernelFunc:QTe};class e1e{constructor(t,e,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=i?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class t1e{constructor(t,e,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=i?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]},\n          ${u[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const r1e={kernelName:Db,backendName:"webgl",kernelFunc:function n1e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=j().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new t1e(s.shape,l,c,i,o):new e1e(s.shape,l,c,i,o);return e.runWebGLProgram(u,[s],"float32")}};class s1e{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,i]=e,[,o,a]=t,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],d=l[1]/c[1],h=1/u,f=1/d,p=2*Math.ceil(h)+2,m=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const o1e={kernelName:yE,backendName:"webgl",kernelFunc:function i1e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r,a=new s1e(i.shape,s.shape,o);return e.runWebGLProgram(a,[i],i.dtype)}};class a1e{constructor(t,e,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let f;f=i?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class l1e{constructor(t,e,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let f;f=i?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]},\n          ${u[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const u1e={kernelName:Ib,backendName:"webgl",kernelFunc:function c1e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=j().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new l1e(s.shape,l,c,i,o):new a1e(s.shape,l,c,i,o);return e.runWebGLProgram(u,[s],s.dtype)}};class d1e{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,i]=e,[,o,a]=t,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],d=l[1]/c[1],h=1/u,f=1/d,p=2*Math.ceil(h)+2,m=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${l[0]}) *\n                (float(dyR) / float(${c[0]}));\n\n            float sourceFracCol =\n                float(${l[1]}) *\n                  (float(dyC) / float(${c[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${i}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const f1e={kernelName:gE,backendName:"webgl",kernelFunc:function h1e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r,a=new d1e(i.shape,s.shape,o);return e.runWebGLProgram(a,[i],i.dtype)}};class p1e{constructor(t,e){this.variableNames=["x"];const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const i=t.map((a,l)=>(a=>-1!==e.indexOf(a)&&1!==t[a]?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`)(l)).join(","),o=on(r);this.userCode=`\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}class m1e{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;const s=Jr("rc",r),i=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,o=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=on(r);function h(p){const m=t.map((b,_)=>function f(p,m){return-1!==e.indexOf(p)&&1!==t[p]?`${t[p]} - ${m[p]} - 1`:`${m[p]}`}(_,p));return`getChannel(getX(${m.join(",")}), vec2(${m.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${i}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function l(p){return h(p)}(s.slice())};\n          if(${i}){\n            result.g = ${function c(p){return p[r-1]="("+p[r-1]+" + 1)",h(p)}(s.slice())};\n          }\n          if(${o}) {\n            result.b = ${function u(p){return p[r-2]="("+p[r-2]+" + 1)",h(p)}(s.slice())};\n            if(${i}) {\n              result.a = ${function d(p){return p[r-1]="("+p[r-1]+" + 1)",p[r-2]="("+p[r-2]+" + 1)",h(p)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const y1e={kernelName:Tb,backendName:"webgl",kernelFunc:function g1e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:i}=r,o=s.shape.length,a=ht(i,s.shape);if(0===o)return Fs({inputs:{x:s},backend:e});const l=j().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new m1e(s.shape,a):new p1e(s.shape,a);return e.runWebGLProgram(l,[s],s.dtype)}};class b1e{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=t[1],s=t[2];this.outputShape=t;let i="";i="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${i}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const _1e={kernelName:FE,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=t,a=e,l=new b1e(r.shape,i),[c,u]=wD(o,r.shape[1],r.shape[2]),d=[[c,u,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,d)}},v1e=kt({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),x1e={kernelName:tp,backendName:"webgl",kernelFunc:v1e},w1e=kt({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Iwe}),C1e={kernelName:np,backendName:"webgl",kernelFunc:w1e};class U4{constructor(t,e,r,s,i,o,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const l=on(i.length),c=on(o.length);let u="";1===r?u="i":2===r&&(u="i, j");let h="";1===s?h="i":2===s&&(h="i, coords[1]"),this.userCode=`\n        ${l} strides = ${l}(${i});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${u}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${h});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const E1e={kernelName:bE,backendName:"webgl",kernelFunc:function S1e(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:i}=t,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=Op(0,s,o),h=[d/c,c];if(0===d)return e.makeTensorInfo(o,s.dtype);const f=xe({inputs:{x:s},backend:e,attrs:{shape:[l,a]}}),p=xe({inputs:{x:i},backend:e,attrs:{shape:[l,c]}}),m=e.makeTensorInfo([],"float32",new Float32Array([0])),g=new U4(l,a,f.shape.length,p.shape.length,u,h),y=e.runWebGLProgram(g,[p,f,m],p.dtype),b=xe({inputs:{x:y},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(m),b}};class I1e{constructor(t,e,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,r];const o=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=2===j().getNumber("WEBGL_VERSION")?"while (left < right) {":o;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===s?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const T1e={kernelName:_E,backendName:"webgl",kernelFunc:function D1e(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:s,values:i}=t,{side:o}=r,a=new I1e(s.shape[0],s.shape[1],i.shape[1],o);return e.runWebGLProgram(a,[s,i],"int32",[[s.shape[1]]])}};class k1e{constructor(t,e,r){let s,i;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)i="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<e.length;u++)c.push(`${a[u]}`),u<t&&l.push(`${a[u]}`);s=l.join(),i=c.join()}const o=on(r);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${i}));\n        } else {\n          setOutput(getB(${i}));\n        }\n      }\n    `}}const A1e={kernelName:kb,backendName:"webgl",kernelFunc:function N1e(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:i}=t,o=new k1e(r.shape.length,s.shape,s.shape.length);return e.runWebGLProgram(o,[r,s,i],Ds(s.dtype,i.dtype))}},M1e=kt({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${k_};\n  float scale = ${N_};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),F1e={kernelName:rp,backendName:"webgl",kernelFunc:M1e},$1e=kt({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Twe}),P1e={kernelName:ap,backendName:"webgl",kernelFunc:$1e},L1e=kt({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),V1e={kernelName:op,backendName:"webgl",kernelFunc:L1e},z1e=kt({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),U1e={kernelName:sp,backendName:"webgl",kernelFunc:z1e},H1e=kt({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),W1e={kernelName:ip,backendName:"webgl",kernelFunc:H1e},j1e=kt({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),G1e={kernelName:lp,backendName:"webgl",kernelFunc:j1e},q1e={kernelName:Rb,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,paddings:o}=r;S(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((y,b)=>y*b),l=[[0,0]];l.push(...o);for(let y=1+i.length;y<s.shape.length;++y)l.push([0,0]);const c=[],u=B4({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),d=$p(u.shape,i,a,!1),h=Pp(d.length,i.length,!1),f=Lp(u.shape,i,a,!1),p=xe({inputs:{x:u},backend:e,attrs:{shape:d}}),m=es({inputs:{x:p},backend:e,attrs:{perm:h}}),g=xe({inputs:{x:m},backend:e,attrs:{shape:f}});return c.push(u),c.push(p),c.push(m),c.forEach(y=>e.disposeIntermediateTensorInfo(y)),g}},X1e={kernelName:vE,backendName:"webgl",kernelFunc:function K1e(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.readSync(r.dataId),l=e.readSync(s.dataId),c=e.readSync(i.dataId),u=e.readSync(o.dataId)[0],[d,h,f,p,m]=Nwe(a,r.shape,r.dtype,l,s.dtype,c,u);return[e.makeTensorInfo(h,r.dtype,d),e.makeTensorInfo([h[0]],s.dtype,f),e.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),e.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},Z1e={kernelName:xE,backendName:"webgl",kernelFunc:function Y1e(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.readSync(s.dataId)),a=e.readSync(r.dataId),l=Array.from(e.readSync(i.dataId)),[c,u,d]=Awe(a,r.shape,r.dtype,o,l);return[e.makeTensorInfo(u,r.dtype,c),e.makeTensorInfo([d.length],i.dtype,new Int32Array(d))]}},J1e={kernelName:wE,backendName:"webgl",kernelFunc:function Q1e(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${i.shape}`);const o=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(i.dataId),[c,u]=jU(o,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(u,r.dtype,c)}},tke={kernelName:CE,backendName:"webgl",kernelFunc:function eke(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${i.shape}`);const o=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(i.dataId),[c,u]=jU(o,r.shape,r.dtype,a,l);return e.makeTensorInfo(u,r.dtype,c)}},rke={kernelName:SE,backendName:"webgl",kernelFunc:function nke(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=t,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:h}=Op(0,s,a);if("string"===i.dtype){const y=e.bufferSync(s),b=e.bufferSync(i),_=Ya(e.readSync(o.dataId)[0]),v=Dwe(y,b,a,h,u,c,l,d,_,!1);return e.makeTensorInfo(a,v.dtype,v.values)}const p=new U4(c,l,s.shape.length,i.shape.length,d,[h,1],!1),m=e.runWebGLProgram(p,[i,s,o],i.dtype),g=xe({inputs:{x:m},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(m),g}},ike={kernelName:Mb,backendName:"webgl",kernelFunc:function ske(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:i,axis:o}=r,a=ht(o,s.shape)[0],l=VD(s,i,a),u=new Array(s.shape.length).fill(0),d=s.shape.slice();return l.map(h=>{const f=[...d];f[a]=h;const p=Ld({inputs:{x:s},backend:e,attrs:{begin:u,size:f}});return u[a]+=h,p})}},H4="return sqrt(x);",oke=kt({opSnippet:H4,packedOpSnippet:H4,cpuKernelImpl:Rwe}),ake={kernelName:cp,backendName:"webgl",kernelFunc:oke},cke={kernelName:EE,backendName:"webgl",kernelFunc:kt({opSnippet:"return x * x;"})},W4="return (a - b) * (a - b);",uke=Nr({opSnippet:W4,packedOpSnippet:W4}),dke={kernelName:up,backendName:"webgl",kernelFunc:uke},fke={kernelName:mp,backendName:"webgl",kernelFunc:function hke({inputs:n,attrs:t,backend:e}){const{x:r}=n,i=new Uo(r.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return e.runWebGLProgram(i,[r],r.dtype)}};class pke{constructor(t,e,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,i=on(r.length),o=on(r.length);let a="";if(1===s)a="coords * strides + begin";else{let l=0;a=r.map((c,u)=>(l++,1===r.length?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`\n      ${i} begin = ${i}(${t});\n      ${i} strides = ${i}(${e});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const gke={kernelName:IE,backendName:"webgl",kernelFunc:function mke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:f,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:_,strides:v}=bI(s.shape,i,o,a,l,c,u,d,h);let w;if(m)w=xe({inputs:{x:s},backend:e,attrs:{shape:p}});else if(g||y){S(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const I=mI(b,_,v),D=Ld({inputs:{x:s},backend:e,attrs:{begin:b,size:I}});w=xe({inputs:{x:D},backend:e,attrs:{shape:p}}),e.disposeIntermediateTensorInfo(D)}else if(e.shouldExecuteOnCPU([s])){const D=e.readSync(s.dataId),T=it(s.shape,s.dtype,D),N=Mwe(f,T,v,b);w=e.makeTensorInfo(p,s.dtype,N.values)}else{const D=new pke(b,v,f);w=e.runWebGLProgram(D,[s],s.dtype)}const C=xe({inputs:{x:w},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(w),C}},bke={kernelName:DE,backendName:"webgl",kernelFunc:function yke(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:d}=t,h=e.readSync(u.dataId),f=e.readSync(d.dataId),[p,m]=Fwe(h,f,s,i,o,a,l,c);return[e.makeTensorInfo([p.length],"string",p),e.makeTensorInfo(d.shape,"int32",m)]}},vke={kernelName:TE,backendName:"webgl",kernelFunc:function _ke(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.readSync(i.dataId),l=e.readSync(o.dataId)[0],[c,u,d]=Owe(a,l,s),h=u.length;return[e.makeTensorInfo([h,2],"int32",c),e.makeTensorInfo([h],"string",u),e.makeTensorInfo([2],"int32",new Int32Array(d))]}},wke={kernelName:kE,backendName:"webgl",kernelFunc:function xke(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const o=e.readSync(i.dataId),a=$we(o,s);return e.makeTensorInfo(i.shape,"int32",a)}},Cke=kt({opSnippet:"return tan(x);"}),Ske={kernelName:hp,backendName:"webgl",kernelFunc:Cke},Eke=kt({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),Ike={kernelName:fp,backendName:"webgl",kernelFunc:Eke};class Dke{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let o=0;o<r.length;o++)r[o]=t[o]*e[o];this.outputShape=r,this.rank=r.length;const s=on(this.rank),i=function Tke(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${e[s]}, ${n[s]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}function j4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:i}=r;if("string"===s.dtype||s.shape.length>5){const l=e.readSync(s.dataId),c="string"===s.dtype?l.map(h=>Ya(h)):l,u=it(s.shape,s.dtype,c),d=Lwe(u,i);return e.makeTensorInfo(d.shape,d.dtype,d.values)}const o=new Dke(s.shape,i);return e.runWebGLProgram(o,[s],s.dtype)}const kke={kernelName:pp,backendName:"webgl",kernelFunc:j4};class Nke{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class Ake{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function Tc(n,t){null!==t&&n.disposeIntermediateTensorInfo(t)}function G4(n){let t=1;for(;t<n;)t*=2;return t}const Mke={kernelName:NE,backendName:"webgl",kernelFunc:function Rke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:i,sorted:o}=r,a=j().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=j().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,u=c[c.length-1];if(e.shouldExecuteOnCPU([s])||u<a||i>l){const N=e.readSync(s.dataId),[P,z]=Vwe(N,c,s.dtype,i,o);return[e.makeTensorInfo(P.shape,P.dtype,P.values),e.makeTensorInfo(z.shape,z.dtype,z.values)]}if(0===i)return c[c.length-1]=0,[e.makeTensorInfo(c,s.dtype,[]),e.makeTensorInfo(c,"int32",[])];if(1===u)return[s,hm({attrs:{shape:c,dtype:"int32",value:0},backend:e})];const d=e.texData.get(s.dataId),h=null!==d&&d.isPacked,f=h?e.unpackTensor(s):s,m=X(c)/u,g=xe({inputs:{x:f},attrs:{shape:[m,u]},backend:e});h&&Tc(e,f);const y=G4(i),b=G4(u);let _=null;const v=()=>null===_?[g,g]:[g,_],w=(N,P,z)=>{const W=v(),G=new Nke(z),V=_;_=e.runWebGLProgram(G,W,"int32",[[u],[null===_?1:0],[Number.NEGATIVE_INFINITY],[N],[P]]),Tc(e,V)};for(let N=1;N<y;N*=2){const P=2*N;for(let z=N;z>=1;z/=2)w(P,z,[m,b])}for(let N=b;N>y;N/=2){const P=v(),z=new Ake([m,N/2]),q=_;_=e.runWebGLProgram(z,P,"int32",[[u],[null===_?1:0],[y]]),Tc(e,q);const $=y/2,V=2*$;for(let L=$;L>=1;L/=2)w(V,L,_.shape)}let C=_;_=Ld({inputs:{x:_},backend:e,attrs:{begin:0,size:[m,i]}}),Tc(e,C);let I=M4({inputs:{x:g,indices:_},backend:e,attrs:{axis:1,batchDims:1}});Tc(e,g);const D=c.slice(0,-1);D.push(i),C=_,_=xe({inputs:{x:_},attrs:{shape:D},backend:e}),Tc(e,C);const T=I;return I=xe({inputs:{x:I},attrs:{shape:D},backend:e}),Tc(e,T),[I,_]}};class Fke{constructor(t,e,r,s,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a="nearest"===r?1:2;let l;switch(s){case"constant":default:l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${l} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${i});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${i});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const $ke={kernelName:AE,backendName:"webgl",kernelFunc:function Oke(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=r,[u,d,h,f]=s.shape,[p,m]=c??[d,h],y=new Fke(d,h,o,a,l,[u,p,m,f]);return e.runWebGLProgram(y,[s,i],"float32")}},Lke={kernelName:RE,backendName:"webgl",kernelFunc:function Pke(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:i}=t;sm(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(i.dataId),{outputValues:a,outputShape:l,indices:c}=Bwe(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},Bke={kernelName:Ob,backendName:"webgl",kernelFunc:function Vke(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s,a=o.shape.length,l=s.shape[i],c=new Array(a-1);let u=0;for(let m=0;m<a;m++)m!==i&&(c[u++]=o.shape[m]);const d=[],h=new Array(a).fill(0),f=o.shape.slice();f[i]=1;const p=new Array(l);for(let m=0;m<p.length;m++){h[i]=m;const g=Ld({inputs:{x:o},backend:e,attrs:{begin:h,size:f}}),y=xe({inputs:{x:g},backend:e,attrs:{shape:c}});p[m]=y,d.push(g)}return d.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}};class zke{constructor(t,e){this.variableNames=["x","segmentIds"];const r=t.windowSize,s=t.batchSize,i=t.inSize,o=t.numSegments,a=o*Math.ceil(i/r);this.outputShape=[s,a];const u=4*Math.floor(r/4),d=r%4,h="\n        sumValue += dot(values, segFilter);\n    ";let f="";i%r>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `);let p="";i%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${p}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}const Wke=[FCe,$Ce,VCe,UCe,WCe,qCe,XCe,ZCe,tSe,rSe,oSe,cSe,hSe,gSe,_Se,xSe,CSe,DSe,kSe,ASe,FSe,BSe,USe,WSe,XSe,ZSe,tEe,yCe,sEe,cEe,fEe,_Ee,xEe,CEe,EEe,DEe,NEe,REe,FEe,$Ee,LEe,BEe,HEe,jEe,XEe,ZEe,eIe,rIe,iIe,aIe,uIe,hIe,mIe,yIe,bIe,vIe,wIe,SIe,IIe,TIe,NIe,MIe,$Ie,LIe,zIe,WIe,GIe,KIe,gCe,YIe,aEe,QIe,eDe,nDe,_Ce,sDe,oDe,lDe,dDe,pDe,gDe,bDe,vDe,CDe,EDe,DDe,ADe,MDe,ODe,VDe,zDe,HDe,jDe,qDe,ZDe,eTe,sTe,uTe,wCe,pTe,yTe,vTe,CTe,jSe,ETe,DTe,kTe,RTe,$Te,xCe,LTe,BTe,UTe,WTe,jTe,GSe,oTe,qTe,YTe,JTe,SCe,r1e,o1e,u1e,f1e,y1e,_1e,x1e,C1e,E1e,T1e,A1e,F1e,P1e,V1e,U1e,W1e,VSe,lTe,G1e,q1e,X1e,Z1e,J1e,tke,rke,ike,ake,cke,dke,fke,gke,bke,vke,wke,aTe,ACe,Ske,Ike,kke,Mke,$ke,RCe,Lke,Bke,{kernelName:$b,backendName:"webgl",kernelFunc:function Uke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:i}=t,{numSegments:o}=r,a=s.shape.length,l=[];let c=0;const u=En([c],a);let d=s;null!=u&&(d=es({inputs:{x:s},backend:e,attrs:{perm:u}}),l.push(d),c=Bn(1,a)[0]);const h=lB(d.shape,c,o),f=X([d.shape[c]]),p=xe({inputs:{x:d},backend:e,attrs:{shape:[-1,f]}});l.push(p);const m=zE(s.dtype),g=(v,w,C,I,D)=>{const T=v.shape[0],N=v.shape[1],P=aB(N,D),W=new zke({windowSize:P,inSize:N,batchSize:T,numSegments:D},w),G=e.compileAndRun(W,[v,C],I);if(l.push(G),G.shape[1]===D)return G;const q=z4({backend:e,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),$=j4({inputs:{x:q},backend:e,attrs:{reps:[N/P]}});return l.push(q),l.push($),g(G,w,$,I,D)},b=xe({inputs:{x:g(p,"unsortedSegmentSum",i,m,o)},backend:e,attrs:{shape:h}});let _=b;if(null!=u){l.push(b);const v=il(u);_=es({inputs:{x:_},backend:e,attrs:{perm:v}})}return l.forEach(v=>e.disposeIntermediateTensorInfo(v)),_}},ITe];for(const n of Wke)PE(n);function q4(n,t){const e=new Map;for(let r=0;r<t.length;r++){let s=n.findIndex(i=>(console.log(t[r]),i===t[r]));-1!==s&&e.set(s,t[r])}return e}const E1=["Person","Sneakers","Chair","Other Shoes","Hat","Car","Lamp","Glasses","Bottle","Desk","Cup","Street Lights","Cabinet/shelf","Handbag/Satchel","Bracelet","Plate","Picture/Frame","Helmet","Book","Gloves","Storage box","Boat","Leather Shoes","Flower","Bench","Potted Plant","Bowl/Basin","Flag","Pillow","Boots","Vase","Microphone","Necklace","Ring","SUV","Wine Glass","Belt","Monitor/TV","Backpack","Umbrella","Traffic Light","Speaker","Watch","Tie","Trash bin Can","Slippers","Bicycle","Stool","Barrel/bucket","Van","Couch","Sandals","Basket","Drum","Pen/Pencil","Bus","Wild Bird","High Heels","Motorcycle","Guitar","Carpet","Cell Phone","Bread","Camera","Canned","Truck","Traffic cone","Cymbal","Lifesaver","Towel","Stuffed Toy","Candle","Sailboat","Laptop","Awning","Bed","Faucet","Tent","Horse","Mirror","Power outlet","Sink","Apple","Air Conditioner","Knife","Hockey Stick","Paddle","Pickup Truck","Fork","Traffic Sign","Balloon","Tripod","Dog","Spoon","Clock","Pot","Cow","Cake","Dinning Table","Sheep","Hanger","Blackboard/Whiteboard","Napkin","Other Fish","Orange/Tangerine","Toiletry","Keyboard","Tomato","Lantern","Machinery Vehicle","Fan","Green Vegetables","Banana","Baseball Glove","Airplane","Mouse","Train","Pumpkin","Soccer","Skiboard","Luggage","Nightstand","Tea pot","Telephone","Trolley","Head Phone","Sports Car","Stop Sign","Dessert","Scooter","Stroller","Crane","Remote","Refrigerator","Oven","Lemon","Duck","Baseball Bat","Surveillance Camera","Cat","Jug","Broccoli","Piano","Pizza","Elephant","Skateboard","Surfboard","Gun","Skating and Skiing shoes","Gas stove","Donut","Bow Tie","Carrot","Toilet","Kite","Strawberry","Other Balls","Shovel","Pepper","Computer Box","Toilet Paper","Cleaning Products","Chopsticks","Microwave","Pigeon","Baseball","Cutting/chopping Board","Coffee Table","Side Table","Scissors","Marker","Pie","Ladder","Snowboard","Cookies","Radiator","Fire Hydrant","Basketball","Zebra","Grape","Giraffe","Potato","Sausage","Tricycle","Violin","Egg","Fire Extinguisher","Candy","Fire Truck","Billiards","Converter","Bathtub","Wheelchair","Golf Club","Briefcase","Cucumber","Cigar/Cigarette","Paint Brush","Pear","Heavy Truck","Hamburger","Extractor","Extension Cord","Tong","Tennis Racket","Folder","American Football","earphone","Mask","Kettle","Tennis","Ship","Swing","Coffee Machine","Slide","Carriage","Onion","Green beans","Projector","Frisbee","Washing Machine/Drying Machine","Chicken","Printer","Watermelon","Saxophone","Tissue","Toothbrush","Ice cream","Hot-air balloon","Cello","French Fries","Scale","Trophy","Cabbage","Hot dog","Blender","Peach","Rice","Wallet/Purse","Volleyball","Deer","Goose","Tape","Tablet","Cosmetics","Trumpet","Pineapple","Golf Ball","Ambulance","Parking meter","Mango","Key","Hurdle","Fishing Rod","Medal","Flute","Brush","Penguin","Megaphone","Corn","Lettuce","Garlic","Swan","Helicopter","Green Onion","Sandwich","Nuts","Speed Limit Sign","Induction Cooker","Broom","Trombone","Plum","Rickshaw","Goldfish","Kiwi fruit","Router/modem","Poker Card","Toaster","Shrimp","Sushi","Cheese","Notepaper","Cherry","Pliers","CD","Pasta","Hammer","Cue","Avocado","Hamimelon","Flask","Mushroom","Screwdriver","Soap","Recorder","Bear","Eggplant","Board Eraser","Coconut","Tape Measure/Ruler","Pig","Showerhead","Globe","Chips","Steak","Crosswalk Sign","Stapler","Camel","Formula 1","Pomegranate","Dishwasher","Crab","Hoverboard","Meat ball","Rice Cooker","Tuba","Calculator","Papaya","Antelope","Parrot","Seal","Butterfly","Dumbbell","Donkey","Lion","Urinal","Dolphin","Electric Drill","Hair Dryer","Egg tart","Jellyfish","Treadmill","Lighter","Grapefruit","Game board","Mop","Radish","Baozi","Target","French","Spring Rolls","Monkey","Rabbit","Pencil Case","Yak","Red Cabbage","Binoculars","Asparagus","Barbell","Scallop","Noddles","Comb","Dumpling","Oyster","Table Tennis paddle","Cosmetics Brush/Eyeliner Pencil","Chainsaw","Eraser","Lobster","Durian","Okra","Lipstick","Cosmetics Mirror","Curling","Table Tennis"],Gke=["Person","Sneakers","Chair","Other Shoes","Hat","Car","Lamp","Glasses","Bottle","Desk","Cup","Street Lights","Cabinet/shelf","Handbag/Satchel","Bracelet","Plate","Picture/Frame","Helmet","Pizza"];let I1,Kke=null;class Mv{constructor(){this.modelLoaded=!1,this.modelLoaded$=new Wt,this.obj365ClassMap=new Map,this.font="10px sans-serif",Kke=E1,this.obj365ClassMap=q4(E1,Gke),console.log(this.obj365ClassMap),this.model$=$n(function ppe(n){return WT.apply(this,arguments)}("assets/model/model.json")).pipe(ze(t=>(console.info("Loaded model",t.inputs),t?.inputs[0]?.shape&&([this.modelWidth,this.modelHeight]=t.inputs[0].shape.slice(1,3)),t)),no(1)),this.model$.subscribe(t=>{this.model=t,console.info("Loaded model",this.model.inputs),t?.inputs[0]?.shape&&([this.modelWidth,this.modelHeight]=t.inputs[0].shape.slice(1,3),console.log("model loaded"),this.modelLoaded=!0,this.modelLoaded$.next(!0))})}isModelLoaded(){return this.modelLoaded}predict(t,e,r,s,i,o){return fy(()=>{let a=t.getContext("2d");if(o&&i){let c=this.getScaledImageRect(i,t);this.drawImageOnCanvas(i,e,[0,0,i.width,i.height],c)}else s&&a.drawImage(s,0,0,s.videoWidth,s.videoHeight);const l=B(()=>ba.resizeBilinear(rre(t),[this.modelWidth,this.modelHeight]).div(255).expandDims(0));return $n(this.model.executeAsync(l)).pipe(ze(c=>{r.drawImage(t,0,0,640,640),r.font=this.font,r.textBaseline="top";const[u,d,h,f]=c,p=u.dataSync(),m=d.dataSync(),g=h.dataSync(),y=f.dataSync()[0];var b;for(console.log(y),ot(c),ot(l),b=0;b<y;++b){console.log(this.obj365ClassMap.get(b));const _=m[b].toFixed(2);if(!this.obj365ClassMap.get(g[b])||_<.5)continue;let[v,w,C,I]=p.slice(4*b,4*(b+1));v*=t.width,C*=t.width,w*=t.height,I*=t.height;const D=C-v,T=I-w,N=this.obj365ClassMap.get(g[b]);r.strokeStyle="#00FFFF",r.lineWidth=1,r.strokeRect(v,w,D,T),r.fillStyle="#00FFFF";const P=r.measureText(N+":"+_).width,z=parseInt(this.font,10);r.fillRect(v,w,P+4,z+1)}for(b=0;b<y;++b){const _=m[b].toFixed(2);if(!this.obj365ClassMap.get(g[b])||_<.5)continue;let[v,w,,]=p.slice(4*b,4*(b+1));v*=t.width,w*=t.height;const C=this.obj365ClassMap.get(g[b]);r.fillStyle="#000000",r.fillText(C+":"+_,v,w)}return Oe(1)}))})}getClassNames(){return this.obj365ClassMap}setClassNames(t){this.obj365ClassMap=q4(E1,t)}getScaledImageRect(t,e){console.log(e.width,e.height);const r=Math.min(e.width/t.naturalWidth,e.height/t.naturalHeight),s=Math.round(t.naturalWidth*r),i=Math.round(t.naturalHeight*r);return[(e.width-s)/2,(e.height-i)/2,s,i]}drawImageOnCanvas(t,e,r,s){const[i,o,a,l]=r,[c,u,d,h]=s;console.log(e.canvas.width),e.fillStyle="#000000",console.log(a,l),e.fillRect(0,0,e.canvas.width,e.canvas.height),e.drawImage(t,i,o,a,l,c,u,d,h)}static#e=this.\u0275fac=function(e){return new(e||Mv)};static#t=this.\u0275cmp=pi({type:Mv,selectors:[["app-model-import"]],decls:0,vars:0,template:function(e,r){}})}try{I1=typeof Intl<"u"&&Intl.v8BreakIterator}catch{I1=!1}let fm,kc,D1,Li=(()=>{class n{constructor(e){this._platformId=e,this.isBrowser=this._platformId?function kZ(n){return n===I2}(this._platformId):"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!I1)&&typeof CSS<"u"&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return n.\u0275fac=function(e){return new(e||n)(J(sC))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function Fv(n){return function Xke(){if(null==fm&&typeof window<"u")try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>fm=!0}))}finally{fm=fm||!1}return fm}()?n:!!n.capture}function Yke(){if(null==kc){if("object"!=typeof document||!document||"function"!=typeof Element||!Element)return kc=!1,kc;if("scrollBehavior"in document.documentElement.style)kc=!0;else{const n=Element.prototype.scrollTo;kc=!!n&&!/\{\s*\[native code\]\s*\}/.test(n.toString())}}return kc}function Nc(n){return n.composedPath?n.composedPath()[0]:n.target}function T1(){return typeof __karma__<"u"&&!!__karma__||typeof jasmine<"u"&&!!jasmine||typeof jest<"u"&&!!jest||typeof Mocha<"u"&&!!Mocha}function pm(n,...t){return t.length?t.some(e=>n[e]):n.altKey||n.shiftKey||n.ctrlKey||n.metaKey}function J4(n,t=$y){return Dn((e,r)=>{let s=null,i=null,o=null;const a=()=>{if(s){s.unsubscribe(),s=null;const c=i;i=null,r.next(c)}};function l(){const c=o+n,u=t.now();if(u<c)return s=this.schedule(void 0,c-u),void r.add(s);a()}e.subscribe(ln(r,c=>{i=c,o=t.now(),s||(s=t.schedule(l,n),r.add(s))},()=>{a(),r.complete()},void 0,()=>{i=s=null}))})}function eH(n){return Ss((t,e)=>n<=e)}function tH(n,t=Aa){return n=n??fNe,Dn((e,r)=>{let s,i=!0;e.subscribe(ln(r,o=>{const a=t(o);(i||!n(s,a))&&(i=!1,s=a,r.next(o))}))})}function fNe(n,t){return n===t}function Ea(n){return Dn((t,e)=>{Vr(n).subscribe(ln(e,()=>e.complete(),Mr)),!e.closed&&t.subscribe(e)})}function Vi(n){return null!=n&&"false"!=`${n}`}function mm(n,t=0){return function pNe(n){return!isNaN(parseFloat(n))&&!isNaN(Number(n))}(n)?Number(n):t}function $v(n){return Array.isArray(n)?n:[n]}function cr(n){return null==n?"":"string"==typeof n?n:`${n}px`}function Ud(n){return n instanceof Cn?n.nativeElement:n}const nH=new Set;let Hd,mNe=(()=>{class n{constructor(e){this._platform=e,this._matchMedia=this._platform.isBrowser&&window.matchMedia?window.matchMedia.bind(window):yNe}matchMedia(e){return(this._platform.WEBKIT||this._platform.BLINK)&&function gNe(n){if(!nH.has(n))try{Hd||(Hd=document.createElement("style"),Hd.setAttribute("type","text/css"),document.head.appendChild(Hd)),Hd.sheet&&(Hd.sheet.insertRule(`@media ${n} {body{ }}`,0),nH.add(n))}catch(t){console.error(t)}}(e),this._matchMedia(e)}}return n.\u0275fac=function(e){return new(e||n)(J(Li))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function yNe(n){return{matches:"all"===n||""===n,media:n,addListener:()=>{},removeListener:()=>{}}}let bNe=(()=>{class n{constructor(e,r){this._mediaMatcher=e,this._zone=r,this._queries=new Map,this._destroySubject=new Wt}ngOnDestroy(){this._destroySubject.next(),this._destroySubject.complete()}isMatched(e){return rH($v(e)).some(s=>this._registerQuery(s).mql.matches)}observe(e){let i=HC(rH($v(e)).map(o=>this._registerQuery(o).observable));return i=hy(i.pipe(no(1)),i.pipe(eH(1),J4(0))),i.pipe(ze(o=>{const a={matches:!1,breakpoints:{}};return o.forEach(({matches:l,query:c})=>{a.matches=a.matches||l,a.breakpoints[c]=l}),a}))}_registerQuery(e){if(this._queries.has(e))return this._queries.get(e);const r=this._mediaMatcher.matchMedia(e),i={observable:new xn(o=>{const a=l=>this._zone.run(()=>o.next(l));return r.addListener(a),()=>{r.removeListener(a)}}).pipe(py(r),ze(({matches:o})=>({query:e,matches:o})),Ea(this._destroySubject)),mql:r};return this._queries.set(e,i),i}}return n.\u0275fac=function(e){return new(e||n)(J(mNe),J(St))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function rH(n){return n.map(t=>t.split(",")).reduce((t,e)=>t.concat(e)).map(t=>t.trim())}class xNe{constructor(t){this._items=t,this._activeItemIndex=-1,this._activeItem=null,this._wrap=!1,this._letterKeyStream=new Wt,this._typeaheadSubscription=He.EMPTY,this._vertical=!0,this._allowedModifierKeys=[],this._homeAndEnd=!1,this._pageUpAndDown={enabled:!1,delta:10},this._skipPredicateFn=e=>e.disabled,this._pressedLetters=[],this.tabOut=new Wt,this.change=new Wt,t instanceof jh&&(this._itemChangesSubscription=t.changes.subscribe(e=>{if(this._activeItem){const s=e.toArray().indexOf(this._activeItem);s>-1&&s!==this._activeItemIndex&&(this._activeItemIndex=s)}}))}skipPredicate(t){return this._skipPredicateFn=t,this}withWrap(t=!0){return this._wrap=t,this}withVerticalOrientation(t=!0){return this._vertical=t,this}withHorizontalOrientation(t){return this._horizontal=t,this}withAllowedModifierKeys(t){return this._allowedModifierKeys=t,this}withTypeAhead(t=200){return this._typeaheadSubscription.unsubscribe(),this._typeaheadSubscription=this._letterKeyStream.pipe(tr(e=>this._pressedLetters.push(e)),J4(t),Ss(()=>this._pressedLetters.length>0),ze(()=>this._pressedLetters.join(""))).subscribe(e=>{const r=this._getItemsArray();for(let s=1;s<r.length+1;s++){const i=(this._activeItemIndex+s)%r.length,o=r[i];if(!this._skipPredicateFn(o)&&0===o.getLabel().toUpperCase().trim().indexOf(e)){this.setActiveItem(i);break}}this._pressedLetters=[]}),this}cancelTypeahead(){return this._pressedLetters=[],this}withHomeAndEnd(t=!0){return this._homeAndEnd=t,this}withPageUpDown(t=!0,e=10){return this._pageUpAndDown={enabled:t,delta:e},this}setActiveItem(t){const e=this._activeItem;this.updateActiveItem(t),this._activeItem!==e&&this.change.next(this._activeItemIndex)}onKeydown(t){const e=t.keyCode,s=["altKey","ctrlKey","metaKey","shiftKey"].every(i=>!t[i]||this._allowedModifierKeys.indexOf(i)>-1);switch(e){case 9:return void this.tabOut.next();case 40:if(this._vertical&&s){this.setNextItemActive();break}return;case 38:if(this._vertical&&s){this.setPreviousItemActive();break}return;case 39:if(this._horizontal&&s){"rtl"===this._horizontal?this.setPreviousItemActive():this.setNextItemActive();break}return;case 37:if(this._horizontal&&s){"rtl"===this._horizontal?this.setNextItemActive():this.setPreviousItemActive();break}return;case 36:if(this._homeAndEnd&&s){this.setFirstItemActive();break}return;case 35:if(this._homeAndEnd&&s){this.setLastItemActive();break}return;case 33:if(this._pageUpAndDown.enabled&&s){const i=this._activeItemIndex-this._pageUpAndDown.delta;this._setActiveItemByIndex(i>0?i:0,1);break}return;case 34:if(this._pageUpAndDown.enabled&&s){const i=this._activeItemIndex+this._pageUpAndDown.delta,o=this._getItemsArray().length;this._setActiveItemByIndex(i<o?i:o-1,-1);break}return;default:return void((s||pm(t,"shiftKey"))&&(t.key&&1===t.key.length?this._letterKeyStream.next(t.key.toLocaleUpperCase()):(e>=65&&e<=90||e>=48&&e<=57)&&this._letterKeyStream.next(String.fromCharCode(e))))}this._pressedLetters=[],t.preventDefault()}get activeItemIndex(){return this._activeItemIndex}get activeItem(){return this._activeItem}isTyping(){return this._pressedLetters.length>0}setFirstItemActive(){this._setActiveItemByIndex(0,1)}setLastItemActive(){this._setActiveItemByIndex(this._items.length-1,-1)}setNextItemActive(){this._activeItemIndex<0?this.setFirstItemActive():this._setActiveItemByDelta(1)}setPreviousItemActive(){this._activeItemIndex<0&&this._wrap?this.setLastItemActive():this._setActiveItemByDelta(-1)}updateActiveItem(t){const e=this._getItemsArray(),r="number"==typeof t?t:e.indexOf(t);this._activeItem=e[r]??null,this._activeItemIndex=r}destroy(){this._typeaheadSubscription.unsubscribe(),this._itemChangesSubscription?.unsubscribe(),this._letterKeyStream.complete(),this.tabOut.complete(),this.change.complete(),this._pressedLetters=[]}_setActiveItemByDelta(t){this._wrap?this._setActiveInWrapMode(t):this._setActiveInDefaultMode(t)}_setActiveInWrapMode(t){const e=this._getItemsArray();for(let r=1;r<=e.length;r++){const s=(this._activeItemIndex+t*r+e.length)%e.length;if(!this._skipPredicateFn(e[s]))return void this.setActiveItem(s)}}_setActiveInDefaultMode(t){this._setActiveItemByIndex(this._activeItemIndex+t,t)}_setActiveItemByIndex(t,e){const r=this._getItemsArray();if(r[t]){for(;this._skipPredicateFn(r[t]);)if(!r[t+=e])return;this.setActiveItem(t)}}_getItemsArray(){return this._items instanceof jh?this._items.toArray():this._items}}class wNe extends xNe{setActiveItem(t){this.activeItem&&this.activeItem.setInactiveStyles(),super.setActiveItem(t),this.activeItem&&this.activeItem.setActiveStyles()}}function aH(n){return 0===n.buttons||0===n.offsetX&&0===n.offsetY}function lH(n){const t=n.touches&&n.touches[0]||n.changedTouches&&n.changedTouches[0];return!(!t||-1!==t.identifier||null!=t.radiusX&&1!==t.radiusX||null!=t.radiusY&&1!==t.radiusY)}const TNe=new me("cdk-input-modality-detector-options"),kNe={ignoreKeys:[18,17,224,91,16]},Wd=Fv({passive:!0,capture:!0});let NNe=(()=>{class n{constructor(e,r,s,i){this._platform=e,this._mostRecentTarget=null,this._modality=new wi(null),this._lastTouchMs=0,this._onKeydown=o=>{this._options?.ignoreKeys?.some(a=>a===o.keyCode)||(this._modality.next("keyboard"),this._mostRecentTarget=Nc(o))},this._onMousedown=o=>{Date.now()-this._lastTouchMs<650||(this._modality.next(aH(o)?"keyboard":"mouse"),this._mostRecentTarget=Nc(o))},this._onTouchstart=o=>{lH(o)?this._modality.next("keyboard"):(this._lastTouchMs=Date.now(),this._modality.next("touch"),this._mostRecentTarget=Nc(o))},this._options={...kNe,...i},this.modalityDetected=this._modality.pipe(eH(1)),this.modalityChanged=this.modalityDetected.pipe(tH()),e.isBrowser&&r.runOutsideAngular(()=>{s.addEventListener("keydown",this._onKeydown,Wd),s.addEventListener("mousedown",this._onMousedown,Wd),s.addEventListener("touchstart",this._onTouchstart,Wd)})}get mostRecentModality(){return this._modality.value}ngOnDestroy(){this._modality.complete(),this._platform.isBrowser&&(document.removeEventListener("keydown",this._onKeydown,Wd),document.removeEventListener("mousedown",this._onMousedown,Wd),document.removeEventListener("touchstart",this._onTouchstart,Wd))}}return n.\u0275fac=function(e){return new(e||n)(J(Li),J(St),J(Et),J(TNe,8))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const ANe=new me("liveAnnouncerElement",{providedIn:"root",factory:function RNe(){return null}}),MNe=new me("LIVE_ANNOUNCER_DEFAULT_OPTIONS");let FNe=(()=>{class n{constructor(e,r,s,i){this._ngZone=r,this._defaultOptions=i,this._document=s,this._liveElement=e||this._createLiveElement()}announce(e,...r){const s=this._defaultOptions;let i,o;return 1===r.length&&"number"==typeof r[0]?o=r[0]:[i,o]=r,this.clear(),clearTimeout(this._previousTimeout),i||(i=s&&s.politeness?s.politeness:"polite"),null==o&&s&&(o=s.duration),this._liveElement.setAttribute("aria-live",i),this._ngZone.runOutsideAngular(()=>(this._currentPromise||(this._currentPromise=new Promise(a=>this._currentResolve=a)),clearTimeout(this._previousTimeout),this._previousTimeout=setTimeout(()=>{this._liveElement.textContent=e,"number"==typeof o&&(this._previousTimeout=setTimeout(()=>this.clear(),o)),this._currentResolve(),this._currentPromise=this._currentResolve=void 0},100),this._currentPromise))}clear(){this._liveElement&&(this._liveElement.textContent="")}ngOnDestroy(){clearTimeout(this._previousTimeout),this._liveElement?.remove(),this._liveElement=null,this._currentResolve?.(),this._currentPromise=this._currentResolve=void 0}_createLiveElement(){const e="cdk-live-announcer-element",r=this._document.getElementsByClassName(e),s=this._document.createElement("div");for(let i=0;i<r.length;i++)r[i].remove();return s.classList.add(e),s.classList.add("cdk-visually-hidden"),s.setAttribute("aria-atomic","true"),s.setAttribute("aria-live","polite"),this._document.body.appendChild(s),s}}return n.\u0275fac=function(e){return new(e||n)(J(ANe,8),J(St),J(Et),J(MNe,8))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const ONe=new me("cdk-focus-monitor-default-options"),Pv=Fv({passive:!0,capture:!0});let $Ne=(()=>{class n{constructor(e,r,s,i,o){this._ngZone=e,this._platform=r,this._inputModalityDetector=s,this._origin=null,this._windowFocused=!1,this._originFromTouchInteraction=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=window.setTimeout(()=>this._windowFocused=!1)},this._stopInputModalityDetector=new Wt,this._rootNodeFocusAndBlurListener=a=>{for(let c=Nc(a);c;c=c.parentElement)"focus"===a.type?this._onFocus(a,c):this._onBlur(a,c)},this._document=i,this._detectionMode=o?.detectionMode||0}monitor(e,r=!1){const s=Ud(e);if(!this._platform.isBrowser||1!==s.nodeType)return Oe(null);const i=function Qke(n){if(function Zke(){if(null==D1){const n=typeof document<"u"?document.head:null;D1=!(!n||!n.createShadowRoot&&!n.attachShadow)}return D1}()){const t=n.getRootNode?n.getRootNode():null;if(typeof ShadowRoot<"u"&&ShadowRoot&&t instanceof ShadowRoot)return t}return null}(s)||this._getDocument(),o=this._elementInfo.get(s);if(o)return r&&(o.checkChildren=!0),o.subject;const a={checkChildren:r,subject:new Wt,rootNode:i};return this._elementInfo.set(s,a),this._registerGlobalListeners(a),a.subject}stopMonitoring(e){const r=Ud(e),s=this._elementInfo.get(r);s&&(s.subject.complete(),this._setClasses(r),this._elementInfo.delete(r),this._removeGlobalListeners(s))}focusVia(e,r,s){const i=Ud(e);i===this._getDocument().activeElement?this._getClosestElementsInfo(i).forEach(([a,l])=>this._originChanged(a,r,l)):(this._setOrigin(r),"function"==typeof i.focus&&i.focus(s))}ngOnDestroy(){this._elementInfo.forEach((e,r)=>this.stopMonitoring(r))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_getFocusOrigin(e){return this._origin?this._originFromTouchInteraction?this._shouldBeAttributedToTouch(e)?"touch":"program":this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:e&&this._isLastInteractionFromInputLabel(e)?"mouse":"program"}_shouldBeAttributedToTouch(e){return 1===this._detectionMode||!!e?.contains(this._inputModalityDetector._mostRecentTarget)}_setClasses(e,r){e.classList.toggle("cdk-focused",!!r),e.classList.toggle("cdk-touch-focused","touch"===r),e.classList.toggle("cdk-keyboard-focused","keyboard"===r),e.classList.toggle("cdk-mouse-focused","mouse"===r),e.classList.toggle("cdk-program-focused","program"===r)}_setOrigin(e,r=!1){this._ngZone.runOutsideAngular(()=>{this._origin=e,this._originFromTouchInteraction="touch"===e&&r,0===this._detectionMode&&(clearTimeout(this._originTimeoutId),this._originTimeoutId=setTimeout(()=>this._origin=null,this._originFromTouchInteraction?650:1))})}_onFocus(e,r){const s=this._elementInfo.get(r),i=Nc(e);!s||!s.checkChildren&&r!==i||this._originChanged(r,this._getFocusOrigin(i),s)}_onBlur(e,r){const s=this._elementInfo.get(r);!s||s.checkChildren&&e.relatedTarget instanceof Node&&r.contains(e.relatedTarget)||(this._setClasses(r),this._emitOrigin(s,null))}_emitOrigin(e,r){e.subject.observers.length&&this._ngZone.run(()=>e.subject.next(r))}_registerGlobalListeners(e){if(!this._platform.isBrowser)return;const r=e.rootNode,s=this._rootNodeFocusListenerCount.get(r)||0;s||this._ngZone.runOutsideAngular(()=>{r.addEventListener("focus",this._rootNodeFocusAndBlurListener,Pv),r.addEventListener("blur",this._rootNodeFocusAndBlurListener,Pv)}),this._rootNodeFocusListenerCount.set(r,s+1),1==++this._monitoredElementCount&&(this._ngZone.runOutsideAngular(()=>{this._getWindow().addEventListener("focus",this._windowFocusListener)}),this._inputModalityDetector.modalityDetected.pipe(Ea(this._stopInputModalityDetector)).subscribe(i=>{this._setOrigin(i,!0)}))}_removeGlobalListeners(e){const r=e.rootNode;if(this._rootNodeFocusListenerCount.has(r)){const s=this._rootNodeFocusListenerCount.get(r);s>1?this._rootNodeFocusListenerCount.set(r,s-1):(r.removeEventListener("focus",this._rootNodeFocusAndBlurListener,Pv),r.removeEventListener("blur",this._rootNodeFocusAndBlurListener,Pv),this._rootNodeFocusListenerCount.delete(r))}--this._monitoredElementCount||(this._getWindow().removeEventListener("focus",this._windowFocusListener),this._stopInputModalityDetector.next(),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._originTimeoutId))}_originChanged(e,r,s){this._setClasses(e,r),this._emitOrigin(s,r),this._lastFocusOrigin=r}_getClosestElementsInfo(e){const r=[];return this._elementInfo.forEach((s,i)=>{(i===e||s.checkChildren&&i.contains(e))&&r.push([i,s])}),r}_isLastInteractionFromInputLabel(e){const{_mostRecentTarget:r,mostRecentModality:s}=this._inputModalityDetector;if("mouse"!==s||!r||r===e||"INPUT"!==e.nodeName&&"TEXTAREA"!==e.nodeName||e.disabled)return!1;const i=e.labels;if(i)for(let o=0;o<i.length;o++)if(i[o].contains(r))return!0;return!1}}return n.\u0275fac=function(e){return new(e||n)(J(St),J(Li),J(NNe),J(Et,8),J(ONe,8))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const uH="cdk-high-contrast-black-on-white",dH="cdk-high-contrast-white-on-black",M1="cdk-high-contrast-active";let PNe=(()=>{class n{constructor(e,r){this._platform=e,this._document=r,this._breakpointSubscription=Mt(bNe).observe("(forced-colors: active)").subscribe(()=>{this._hasCheckedHighContrastMode&&(this._hasCheckedHighContrastMode=!1,this._applyBodyHighContrastModeCssClasses())})}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const e=this._document.createElement("div");e.style.backgroundColor="rgb(1,2,3)",e.style.position="absolute",this._document.body.appendChild(e);const r=this._document.defaultView||window,s=r&&r.getComputedStyle?r.getComputedStyle(e):null,i=(s&&s.backgroundColor||"").replace(/ /g,"");switch(e.remove(),i){case"rgb(0,0,0)":case"rgb(45,50,54)":case"rgb(32,32,32)":return 2;case"rgb(255,255,255)":case"rgb(255,250,239)":return 1}return 0}ngOnDestroy(){this._breakpointSubscription.unsubscribe()}_applyBodyHighContrastModeCssClasses(){if(!this._hasCheckedHighContrastMode&&this._platform.isBrowser&&this._document.body){const e=this._document.body.classList;e.remove(M1,uH,dH),this._hasCheckedHighContrastMode=!0;const r=this.getHighContrastMode();1===r?e.add(M1,uH):2===r&&e.add(M1,dH)}}}return n.\u0275fac=function(e){return new(e||n)(J(Li),J(Et))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const LNe=new me("cdk-dir-doc",{providedIn:"root",factory:function VNe(){return Mt(Et)}}),BNe=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;let F1=(()=>{class n{constructor(e){if(this.value="ltr",this.change=new Ft,e){const s=e.documentElement?e.documentElement.dir:null;this.value=function zNe(n){const t=n?.toLowerCase()||"";return"auto"===t&&typeof navigator<"u"&&navigator?.language?BNe.test(navigator.language)?"rtl":"ltr":"rtl"===t?"rtl":"ltr"}((e.body?e.body.dir:null)||s||"ltr")}}ngOnDestroy(){this.change.complete()}}return n.\u0275fac=function(e){return new(e||n)(J(LNe,8))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),gm=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({}),n})();function UNe(n,t){if(1&n&&as(0,"mat-pseudo-checkbox",4),2&n){const e=Yi();tn("state",e.selected?"checked":"unchecked")("disabled",e.disabled)}}function HNe(n,t){if(1&n&&(Xt(0,"span",5),Xl(1),Nn()),2&n){const e=Yi();en(1),Ag("(",e.group.label,")")}}const WNe=["*"],GNe=new me("mat-sanity-checks",{providedIn:"root",factory:function jNe(){return!0}});let ys=(()=>{class n{constructor(e,r,s){this._sanityChecks=r,this._document=s,this._hasDoneGlobalChecks=!1,e._applyBodyHighContrastModeCssClasses(),this._hasDoneGlobalChecks||(this._hasDoneGlobalChecks=!0)}_checkIsEnabled(e){return!T1()&&("boolean"==typeof this._sanityChecks?this._sanityChecks:!!this._sanityChecks[e])}}return n.\u0275fac=function(e){return new(e||n)(J(PNe),J(GNe,8),J(Et))},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({imports:[gm,gm]}),n})();function pH(n){return class extends n{constructor(...t){super(...t),this._disabled=!1}get disabled(){return this._disabled}set disabled(t){this._disabled=Vi(t)}}}function O1(n,t){return class extends n{constructor(...e){super(...e),this.defaultColor=t,this.color=t}get color(){return this._color}set color(e){const r=e||this.defaultColor;r!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),r&&this._elementRef.nativeElement.classList.add(`mat-${r}`),this._color=r)}}}function mH(n){return class extends n{constructor(...t){super(...t),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=Vi(t)}}}function qNe(n,t=0){return class extends n{constructor(...e){super(...e),this._tabIndex=t,this.defaultTabIndex=t}get tabIndex(){return this.disabled?-1:this._tabIndex}set tabIndex(e){this._tabIndex=null!=e?mm(e):this.defaultTabIndex}}}function KNe(n){return class extends n{constructor(...t){super(...t),this.errorState=!1}updateErrorState(){const t=this.errorState,i=(this.errorStateMatcher||this._defaultErrorStateMatcher).isErrorState(this.ngControl?this.ngControl.control:null,this._parentFormGroup||this._parentForm);i!==t&&(this.errorState=i,this.stateChanges.next())}}}let YNe=(()=>{class n{isErrorState(e,r){return!!(e&&e.invalid&&(e.touched||r&&r.submitted))}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class ZNe{constructor(t,e,r,s=!1){this._renderer=t,this.element=e,this.config=r,this._animationForciblyDisabledThroughCss=s,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const gH={enterDuration:225,exitDuration:150},$1=Fv({passive:!0}),yH=["mousedown","touchstart"],bH=["mouseup","mouseleave","touchend","touchcancel"];class JNe{constructor(t,e,r,s){this._target=t,this._ngZone=e,this._isPointerDown=!1,this._activeRipples=new Map,this._pointerUpEventsRegistered=!1,s.isBrowser&&(this._containerElement=Ud(r))}fadeInRipple(t,e,r={}){const s=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),i={...gH,...r.animation};r.centered&&(t=s.left+s.width/2,e=s.top+s.height/2);const o=r.radius||function eAe(n,t,e){const r=Math.max(Math.abs(n-e.left),Math.abs(n-e.right)),s=Math.max(Math.abs(t-e.top),Math.abs(t-e.bottom));return Math.sqrt(r*r+s*s)}(t,e,s),a=t-s.left,l=e-s.top,c=i.enterDuration,u=document.createElement("div");u.classList.add("mat-ripple-element"),u.style.left=a-o+"px",u.style.top=l-o+"px",u.style.height=2*o+"px",u.style.width=2*o+"px",null!=r.color&&(u.style.backgroundColor=r.color),u.style.transitionDuration=`${c}ms`,this._containerElement.appendChild(u);const d=window.getComputedStyle(u),f=d.transitionDuration,p="none"===d.transitionProperty||"0s"===f||"0s, 0s"===f,m=new ZNe(this,u,r,p);u.style.transform="scale3d(1, 1, 1)",m.state=0,r.persistent||(this._mostRecentTransientRipple=m);let g=null;return!p&&(c||i.exitDuration)&&this._ngZone.runOutsideAngular(()=>{const y=()=>this._finishRippleTransition(m),b=()=>this._destroyRipple(m);u.addEventListener("transitionend",y),u.addEventListener("transitioncancel",b),g={onTransitionEnd:y,onTransitionCancel:b}}),this._activeRipples.set(m,g),(p||!c)&&this._finishRippleTransition(m),m}fadeOutRipple(t){if(2===t.state||3===t.state)return;const e=t.element,r={...gH,...t.config.animation};e.style.transitionDuration=`${r.exitDuration}ms`,e.style.opacity="0",t.state=2,(t._animationForciblyDisabledThroughCss||!r.exitDuration)&&this._finishRippleTransition(t)}fadeOutAll(){this._getActiveRipples().forEach(t=>t.fadeOut())}fadeOutAllNonPersistent(){this._getActiveRipples().forEach(t=>{t.config.persistent||t.fadeOut()})}setupTriggerEvents(t){const e=Ud(t);!e||e===this._triggerElement||(this._removeTriggerEvents(),this._triggerElement=e,this._registerEvents(yH))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._registerEvents(bH),this._pointerUpEventsRegistered=!0)}_finishRippleTransition(t){0===t.state?this._startFadeOutTransition(t):2===t.state&&this._destroyRipple(t)}_startFadeOutTransition(t){const e=t===this._mostRecentTransientRipple,{persistent:r}=t.config;t.state=1,!r&&(!e||!this._isPointerDown)&&t.fadeOut()}_destroyRipple(t){const e=this._activeRipples.get(t)??null;this._activeRipples.delete(t),this._activeRipples.size||(this._containerRect=null),t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),t.state=3,null!==e&&(t.element.removeEventListener("transitionend",e.onTransitionEnd),t.element.removeEventListener("transitioncancel",e.onTransitionCancel)),t.element.remove()}_onMousedown(t){const e=aH(t),r=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;!this._target.rippleDisabled&&!e&&!r&&(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&&!lH(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let r=0;r<e.length;r++)this.fadeInRipple(e[r].clientX,e[r].clientY,this._target.rippleConfig)}}_onPointerUp(){!this._isPointerDown||(this._isPointerDown=!1,this._getActiveRipples().forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_registerEvents(t){this._ngZone.runOutsideAngular(()=>{t.forEach(e=>{this._triggerElement.addEventListener(e,this,$1)})})}_getActiveRipples(){return Array.from(this._activeRipples.keys())}_removeTriggerEvents(){this._triggerElement&&(yH.forEach(t=>{this._triggerElement.removeEventListener(t,this,$1)}),this._pointerUpEventsRegistered&&bH.forEach(t=>{this._triggerElement.removeEventListener(t,this,$1)}))}}const tAe=new me("mat-ripple-global-options");let Lv=(()=>{class n{constructor(e,r,s,i,o){this._elementRef=e,this._animationMode=o,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=i||{},this._rippleRenderer=new JNe(this,r,e,s)}get disabled(){return this._disabled}set disabled(e){e&&this.fadeOutAllNonPersistent(),this._disabled=e,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(e){this._trigger=e,this._setupTriggerEventsIfEnabled()}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}fadeOutAllNonPersistent(){this._rippleRenderer.fadeOutAllNonPersistent()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:{...this._globalOptions.animation,..."NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{},...this.animation},terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(e,r=0,s){return"number"==typeof e?this._rippleRenderer.fadeInRipple(e,r,{...this.rippleConfig,...s}):this._rippleRenderer.fadeInRipple(0,0,{...this.rippleConfig,...e})}}return n.\u0275fac=function(e){return new(e||n)(K(Cn),K(St),K(Li),K(tAe,8),K(Va,8))},n.\u0275dir=Ve({type:n,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(e,r){2&e&&Gs("mat-ripple-unbounded",r.unbounded)},inputs:{color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],radius:["matRippleRadius","radius"],animation:["matRippleAnimation","animation"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"]},exportAs:["matRipple"]}),n})(),P1=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({imports:[ys,ys]}),n})(),nAe=(()=>{class n{constructor(e){this._animationMode=e,this.state="unchecked",this.disabled=!1}}return n.\u0275fac=function(e){return new(e||n)(K(Va,8))},n.\u0275cmp=pi({type:n,selectors:[["mat-pseudo-checkbox"]],hostAttrs:[1,"mat-pseudo-checkbox"],hostVars:8,hostBindings:function(e,r){2&e&&Gs("mat-pseudo-checkbox-indeterminate","indeterminate"===r.state)("mat-pseudo-checkbox-checked","checked"===r.state)("mat-pseudo-checkbox-disabled",r.disabled)("_mat-animation-noopable","NoopAnimations"===r._animationMode)},inputs:{state:"state",disabled:"disabled"},decls:0,vars:0,template:function(e,r){},styles:['.mat-pseudo-checkbox{border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border-color:rgba(0,0,0,0)}.mat-pseudo-checkbox._mat-animation-noopable{transition:none !important;animation:none !important}.mat-pseudo-checkbox._mat-animation-noopable::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{left:1px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{left:1px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}.mat-pseudo-checkbox{width:18px;height:18px}.mat-pseudo-checkbox-indeterminate::after{top:6px;width:12px}.mat-pseudo-checkbox-checked::after{top:2.7px;width:10px;height:4px}'],encapsulation:2,changeDetection:0}),n})(),rAe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({imports:[ys]}),n})();const _H=new me("MAT_OPTION_PARENT_COMPONENT"),vH=new me("MatOptgroup");let sAe=0;class iAe{constructor(t,e=!1){this.source=t,this.isUserInput=e}}let oAe=(()=>{class n{constructor(e,r,s,i){this._element=e,this._changeDetectorRef=r,this._parent=s,this.group=i,this._selected=!1,this._active=!1,this._disabled=!1,this._mostRecentViewValue="",this.id="mat-option-"+sAe++,this.onSelectionChange=new Ft,this._stateChanges=new Wt}get multiple(){return this._parent&&this._parent.multiple}get selected(){return this._selected}get disabled(){return this.group&&this.group.disabled||this._disabled}set disabled(e){this._disabled=Vi(e)}get disableRipple(){return!(!this._parent||!this._parent.disableRipple)}get active(){return this._active}get viewValue(){return(this._getHostElement().textContent||"").trim()}select(){this._selected||(this._selected=!0,this._changeDetectorRef.markForCheck(),this._emitSelectionChangeEvent())}deselect(){this._selected&&(this._selected=!1,this._changeDetectorRef.markForCheck(),this._emitSelectionChangeEvent())}focus(e,r){const s=this._getHostElement();"function"==typeof s.focus&&s.focus(r)}setActiveStyles(){this._active||(this._active=!0,this._changeDetectorRef.markForCheck())}setInactiveStyles(){this._active&&(this._active=!1,this._changeDetectorRef.markForCheck())}getLabel(){return this.viewValue}_handleKeydown(e){(13===e.keyCode||32===e.keyCode)&&!pm(e)&&(this._selectViaInteraction(),e.preventDefault())}_selectViaInteraction(){this.disabled||(this._selected=!this.multiple||!this._selected,this._changeDetectorRef.markForCheck(),this._emitSelectionChangeEvent(!0))}_getAriaSelected(){return this.selected||!this.multiple&&null}_getTabIndex(){return this.disabled?"-1":"0"}_getHostElement(){return this._element.nativeElement}ngAfterViewChecked(){if(this._selected){const e=this.viewValue;e!==this._mostRecentViewValue&&(this._mostRecentViewValue=e,this._stateChanges.next())}}ngOnDestroy(){this._stateChanges.complete()}_emitSelectionChangeEvent(e=!1){this.onSelectionChange.emit(new iAe(this,e))}}return n.\u0275fac=function(e){Ih()},n.\u0275dir=Ve({type:n,inputs:{value:"value",id:"id",disabled:"disabled"},outputs:{onSelectionChange:"onSelectionChange"}}),n})(),xH=(()=>{class n extends oAe{constructor(e,r,s,i){super(e,r,s,i)}}return n.\u0275fac=function(e){return new(e||n)(K(Cn),K(Nu),K(_H,8),K(vH,8))},n.\u0275cmp=pi({type:n,selectors:[["mat-option"]],hostAttrs:["role","option",1,"mat-mdc-option","mat-mdc-focus-indicator","mdc-list-item"],hostVars:12,hostBindings:function(e,r){1&e&&Gn("click",function(){return r._selectViaInteraction()})("keydown",function(i){return r._handleKeydown(i)}),2&e&&(Pw("id",r.id),kn("tabindex",r._getTabIndex())("aria-selected",r._getAriaSelected())("aria-disabled",r.disabled.toString()),Gs("mdc-list-item--selected",r.selected)("mat-mdc-option-multiple",r.multiple)("mat-mdc-option-active",r.active)("mdc-list-item--disabled",r.disabled))},exportAs:["matOption"],features:[bt],ngContentSelectors:WNe,decls:5,vars:4,consts:[["class","mat-mdc-option-pseudo-checkbox",3,"state","disabled",4,"ngIf"],[1,"mdc-list-item__primary-text"],["class","cdk-visually-hidden",4,"ngIf"],["mat-ripple","",1,"mat-mdc-option-ripple",3,"matRippleTrigger","matRippleDisabled"],[1,"mat-mdc-option-pseudo-checkbox",3,"state","disabled"],[1,"cdk-visually-hidden"]],template:function(e,r){1&e&&(Cu(),bi(0,UNe,1,2,"mat-pseudo-checkbox",0),Xt(1,"span",1),sa(2),Nn(),bi(3,HNe,2,1,"span",2),as(4,"div",3)),2&e&&(tn("ngIf",r.multiple),en(3),tn("ngIf",r.group&&r.group._inert),en(1),tn("matRippleTrigger",r._getHostElement())("matRippleDisabled",r.disabled||r.disableRipple))},dependencies:[Lv,kC,nAe],styles:['.mat-mdc-option{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:16px;padding-right:16px;-webkit-user-select:none;user-select:none;cursor:pointer;min-height:48px}.mat-mdc-option:focus{outline:none}[dir=rtl] .mat-mdc-option,.mat-mdc-option[dir=rtl]{padding-left:16px;padding-right:16px}.mat-mdc-option.mdc-list-item{align-items:center}.mat-mdc-option.mdc-list-item--disabled{opacity:.38;cursor:default}.mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:32px}[dir=rtl] .mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:16px;padding-right:32px}.mat-mdc-option .mat-pseudo-checkbox{margin-right:16px}[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox{margin-right:0;margin-left:16px}.mat-mdc-option .mat-mdc-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-mdc-option .mdc-list-item__primary-text{white-space:normal;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit}.cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}[dir=rtl] .cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{right:auto;left:16px}.mat-mdc-option-active::before{content:""}'],encapsulation:2,changeDetection:0}),n})(),wH=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({imports:[P1,Ru,ys,rAe]}),n})();const cAe=["determinateSpinner"];function uAe(n,t){if(1&n&&(dh(),Xt(0,"svg",11),as(1,"circle",12),Nn()),2&n){const e=Yi();kn("viewBox",e._viewBox()),en(1),Oh("stroke-dasharray",e._strokeCircumference(),"px")("stroke-dashoffset",e._strokeCircumference()/2,"px")("stroke-width",e._circleStrokeWidth(),"%"),kn("r",e._circleRadius())}}const dAe=O1(class{constructor(n){this._elementRef=n}},"primary"),hAe=new me("mat-progress-spinner-default-options",{providedIn:"root",factory:function fAe(){return{diameter:CH}}}),CH=100;let mAe=(()=>{class n extends dAe{constructor(e,r,s){super(e),this.mode="mat-spinner"===this._elementRef.nativeElement.nodeName.toLowerCase()?"indeterminate":"determinate",this._value=0,this._diameter=CH,this._noopAnimations="NoopAnimations"===r&&!!s&&!s._forceAnimations,s&&(s.color&&(this.color=this.defaultColor=s.color),s.diameter&&(this.diameter=s.diameter),s.strokeWidth&&(this.strokeWidth=s.strokeWidth))}get value(){return"determinate"===this.mode?this._value:0}set value(e){this._value=Math.max(0,Math.min(100,mm(e)))}get diameter(){return this._diameter}set diameter(e){this._diameter=mm(e)}get strokeWidth(){return this._strokeWidth??this.diameter/10}set strokeWidth(e){this._strokeWidth=mm(e)}_circleRadius(){return(this.diameter-10)/2}_viewBox(){const e=2*this._circleRadius()+this.strokeWidth;return`0 0 ${e} ${e}`}_strokeCircumference(){return 2*Math.PI*this._circleRadius()}_strokeDashOffset(){return"determinate"===this.mode?this._strokeCircumference()*(100-this._value)/100:null}_circleStrokeWidth(){return this.strokeWidth/this.diameter*100}}return n.\u0275fac=function(e){return new(e||n)(K(Cn),K(Va,8),K(hAe))},n.\u0275cmp=pi({type:n,selectors:[["mat-progress-spinner"],["mat-spinner"]],viewQuery:function(e,r){if(1&e&&ia(cAe,5),2&e){let s;qs(s=Ks())&&(r._determinateCircle=s.first)}},hostAttrs:["role","progressbar","tabindex","-1",1,"mat-mdc-progress-spinner","mdc-circular-progress"],hostVars:12,hostBindings:function(e,r){2&e&&(kn("aria-valuemin",0)("aria-valuemax",100)("aria-valuenow","determinate"===r.mode?r.value:null)("mode",r.mode),Oh("width",r.diameter,"px")("height",r.diameter,"px"),Gs("_mat-animation-noopable",r._noopAnimations)("mdc-circular-progress--indeterminate","indeterminate"===r.mode))},inputs:{color:"color",mode:"mode",value:"value",diameter:"diameter",strokeWidth:"strokeWidth"},exportAs:["matProgressSpinner"],features:[bt],decls:14,vars:11,consts:[["circle",""],["aria-hidden","true",1,"mdc-circular-progress__determinate-container"],["determinateSpinner",""],["xmlns","http://www.w3.org/2000/svg","focusable","false",1,"mdc-circular-progress__determinate-circle-graphic"],["cx","50%","cy","50%",1,"mdc-circular-progress__determinate-circle"],["aria-hidden","true",1,"mdc-circular-progress__indeterminate-container"],[1,"mdc-circular-progress__spinner-layer"],[1,"mdc-circular-progress__circle-clipper","mdc-circular-progress__circle-left"],[3,"ngTemplateOutlet"],[1,"mdc-circular-progress__gap-patch"],[1,"mdc-circular-progress__circle-clipper","mdc-circular-progress__circle-right"],["xmlns","http://www.w3.org/2000/svg","focusable","false",1,"mdc-circular-progress__indeterminate-circle-graphic"],["cx","50%","cy","50%"]],template:function(e,r){if(1&e&&(bi(0,uAe,2,8,"ng-template",null,0,iO),Xt(2,"div",1,2),dh(),Xt(4,"svg",3),as(5,"circle",4),Nn()(),a0(),Xt(6,"div",5)(7,"div",6)(8,"div",7),Mh(9,8),Nn(),Xt(10,"div",9),Mh(11,8),Nn(),Xt(12,"div",10),Mh(13,8),Nn()()()),2&e){const s=Rh(1);en(4),kn("viewBox",r._viewBox()),en(1),Oh("stroke-dasharray",r._strokeCircumference(),"px")("stroke-dashoffset",r._strokeDashOffset(),"px")("stroke-width",r._circleStrokeWidth(),"%"),kn("r",r._circleRadius()),en(4),tn("ngTemplateOutlet",s),en(2),tn("ngTemplateOutlet",s),en(2),tn("ngTemplateOutlet",s)}},dependencies:[C2],styles:["@keyframes mdc-circular-progress-container-rotate{to{transform:rotate(360deg)}}@keyframes mdc-circular-progress-spinner-layer-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}@keyframes mdc-circular-progress-color-1-fade-in-out{from{opacity:.99}25%{opacity:.99}26%{opacity:0}89%{opacity:0}90%{opacity:.99}to{opacity:.99}}@keyframes mdc-circular-progress-color-2-fade-in-out{from{opacity:0}15%{opacity:0}25%{opacity:.99}50%{opacity:.99}51%{opacity:0}to{opacity:0}}@keyframes mdc-circular-progress-color-3-fade-in-out{from{opacity:0}40%{opacity:0}50%{opacity:.99}75%{opacity:.99}76%{opacity:0}to{opacity:0}}@keyframes mdc-circular-progress-color-4-fade-in-out{from{opacity:0}65%{opacity:0}75%{opacity:.99}90%{opacity:.99}to{opacity:0}}@keyframes mdc-circular-progress-left-spin{from{transform:rotate(265deg)}50%{transform:rotate(130deg)}to{transform:rotate(265deg)}}@keyframes mdc-circular-progress-right-spin{from{transform:rotate(-265deg)}50%{transform:rotate(-130deg)}to{transform:rotate(-265deg)}}.mdc-circular-progress{display:inline-flex;position:relative;direction:ltr;line-height:0;transition:opacity 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-circular-progress__determinate-container,.mdc-circular-progress__indeterminate-circle-graphic,.mdc-circular-progress__indeterminate-container,.mdc-circular-progress__spinner-layer{position:absolute;width:100%;height:100%}.mdc-circular-progress__determinate-container{transform:rotate(-90deg)}.mdc-circular-progress__indeterminate-container{font-size:0;letter-spacing:0;white-space:nowrap;opacity:0}.mdc-circular-progress__determinate-circle-graphic,.mdc-circular-progress__indeterminate-circle-graphic{fill:rgba(0,0,0,0)}.mdc-circular-progress__determinate-circle{transition:stroke-dashoffset 500ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-circular-progress__gap-patch{position:absolute;top:0;left:47.5%;box-sizing:border-box;width:5%;height:100%;overflow:hidden}.mdc-circular-progress__gap-patch .mdc-circular-progress__indeterminate-circle-graphic{left:-900%;width:2000%;transform:rotate(180deg)}.mdc-circular-progress__circle-clipper{display:inline-flex;position:relative;width:50%;height:100%;overflow:hidden}.mdc-circular-progress__circle-clipper .mdc-circular-progress__indeterminate-circle-graphic{width:200%}.mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{left:-100%}.mdc-circular-progress--indeterminate .mdc-circular-progress__determinate-container{opacity:0}.mdc-circular-progress--indeterminate .mdc-circular-progress__indeterminate-container{opacity:1}.mdc-circular-progress--indeterminate .mdc-circular-progress__indeterminate-container{animation:mdc-circular-progress-container-rotate 1568.2352941176ms linear infinite}.mdc-circular-progress--indeterminate .mdc-circular-progress__spinner-layer{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-1{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-1-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-2{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-2-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-3{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-3-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-4{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-4-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-left .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--closed{opacity:0}.mat-mdc-progress-spinner{display:block;overflow:hidden;line-height:0}.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:var(--mdc-circular-progress-active-indicator-color, transparent)}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-1 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-2 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-3 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-4 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}.mat-mdc-progress-spinner._mat-animation-noopable,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__determinate-circle{transition:none}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-circle-graphic,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__spinner-layer,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container{animation:none}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container circle{stroke-dasharray:0 !important}.cdk-high-contrast-active .mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic,.cdk-high-contrast-active .mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle{stroke:currentColor;stroke:CanvasText}"],encapsulation:2,changeDetection:0}),n})(),gAe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({imports:[Ru,ys]}),n})();function SH(...n){const t=aN(n),{args:e,keys:r}=J2(n),s=new xn(i=>{const{length:o}=e;if(!o)return void i.complete();const a=new Array(o);let l=o,c=o;for(let u=0;u<o;u++){let d=!1;Vr(e[u]).subscribe(ln(i,h=>{d||(d=!0,c--),a[u]=h},()=>l--,void 0,()=>{(!l||!d)&&(c||i.next(r?e$(r,a):a),i.complete())}))}});return t?s.pipe(UC(t)):s}class L1{}class Cl{constructor(t){this.normalizedNames=new Map,this.lazyUpdate=null,t?this.lazyInit="string"==typeof t?()=>{this.headers=new Map,t.split("\n").forEach(e=>{const r=e.indexOf(":");if(r>0){const s=e.slice(0,r),i=s.toLowerCase(),o=e.slice(r+1).trim();this.maybeSetNormalizedName(s,i),this.headers.has(i)?this.headers.get(i).push(o):this.headers.set(i,[o])}})}:()=>{this.headers=new Map,Object.keys(t).forEach(e=>{let r=t[e];const s=e.toLowerCase();"string"==typeof r&&(r=[r]),r.length>0&&(this.headers.set(s,r),this.maybeSetNormalizedName(e,s))})}:this.headers=new Map}has(t){return this.init(),this.headers.has(t.toLowerCase())}get(t){this.init();const e=this.headers.get(t.toLowerCase());return e&&e.length>0?e[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(t){return this.init(),this.headers.get(t.toLowerCase())||null}append(t,e){return this.clone({name:t,value:e,op:"a"})}set(t,e){return this.clone({name:t,value:e,op:"s"})}delete(t,e){return this.clone({name:t,value:e,op:"d"})}maybeSetNormalizedName(t,e){this.normalizedNames.has(e)||this.normalizedNames.set(e,t)}init(){this.lazyInit&&(this.lazyInit instanceof Cl?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(t=>this.applyUpdate(t)),this.lazyUpdate=null))}copyFrom(t){t.init(),Array.from(t.headers.keys()).forEach(e=>{this.headers.set(e,t.headers.get(e)),this.normalizedNames.set(e,t.normalizedNames.get(e))})}clone(t){const e=new Cl;return e.lazyInit=this.lazyInit&&this.lazyInit instanceof Cl?this.lazyInit:this,e.lazyUpdate=(this.lazyUpdate||[]).concat([t]),e}applyUpdate(t){const e=t.name.toLowerCase();switch(t.op){case"a":case"s":let r=t.value;if("string"==typeof r&&(r=[r]),0===r.length)return;this.maybeSetNormalizedName(t.name,e);const s=("a"===t.op?this.headers.get(e):void 0)||[];s.push(...r),this.headers.set(e,s);break;case"d":const i=t.value;if(i){let o=this.headers.get(e);if(!o)return;o=o.filter(a=>-1===i.indexOf(a)),0===o.length?(this.headers.delete(e),this.normalizedNames.delete(e)):this.headers.set(e,o)}else this.headers.delete(e),this.normalizedNames.delete(e)}}forEach(t){this.init(),Array.from(this.normalizedNames.keys()).forEach(e=>t(this.normalizedNames.get(e),this.headers.get(e)))}}class yAe{encodeKey(t){return IH(t)}encodeValue(t){return IH(t)}decodeKey(t){return decodeURIComponent(t)}decodeValue(t){return decodeURIComponent(t)}}const _Ae=/%(\d[a-f0-9])/gi,vAe={40:"@","3A":":",24:"$","2C":",","3B":";","3D":"=","3F":"?","2F":"/"};function IH(n){return encodeURIComponent(n).replace(_Ae,(t,e)=>vAe[e]??t)}function Vv(n){return`${n}`}class Sl{constructor(t={}){if(this.updates=null,this.cloneFrom=null,this.encoder=t.encoder||new yAe,t.fromString){if(t.fromObject)throw new Error("Cannot specify both fromString and fromObject.");this.map=function bAe(n,t){const e=new Map;return n.length>0&&n.replace(/^\?/,"").split("&").forEach(s=>{const i=s.indexOf("="),[o,a]=-1==i?[t.decodeKey(s),""]:[t.decodeKey(s.slice(0,i)),t.decodeValue(s.slice(i+1))],l=e.get(o)||[];l.push(a),e.set(o,l)}),e}(t.fromString,this.encoder)}else t.fromObject?(this.map=new Map,Object.keys(t.fromObject).forEach(e=>{const r=t.fromObject[e],s=Array.isArray(r)?r.map(Vv):[Vv(r)];this.map.set(e,s)})):this.map=null}has(t){return this.init(),this.map.has(t)}get(t){this.init();const e=this.map.get(t);return e?e[0]:null}getAll(t){return this.init(),this.map.get(t)||null}keys(){return this.init(),Array.from(this.map.keys())}append(t,e){return this.clone({param:t,value:e,op:"a"})}appendAll(t){const e=[];return Object.keys(t).forEach(r=>{const s=t[r];Array.isArray(s)?s.forEach(i=>{e.push({param:r,value:i,op:"a"})}):e.push({param:r,value:s,op:"a"})}),this.clone(e)}set(t,e){return this.clone({param:t,value:e,op:"s"})}delete(t,e){return this.clone({param:t,value:e,op:"d"})}toString(){return this.init(),this.keys().map(t=>{const e=this.encoder.encodeKey(t);return this.map.get(t).map(r=>e+"="+this.encoder.encodeValue(r)).join("&")}).filter(t=>""!==t).join("&")}clone(t){const e=new Sl({encoder:this.encoder});return e.cloneFrom=this.cloneFrom||this,e.updates=(this.updates||[]).concat(t),e}init(){null===this.map&&(this.map=new Map),null!==this.cloneFrom&&(this.cloneFrom.init(),this.cloneFrom.keys().forEach(t=>this.map.set(t,this.cloneFrom.map.get(t))),this.updates.forEach(t=>{switch(t.op){case"a":case"s":const e=("a"===t.op?this.map.get(t.param):void 0)||[];e.push(Vv(t.value)),this.map.set(t.param,e);break;case"d":if(void 0===t.value){this.map.delete(t.param);break}{let r=this.map.get(t.param)||[];const s=r.indexOf(Vv(t.value));-1!==s&&r.splice(s,1),r.length>0?this.map.set(t.param,r):this.map.delete(t.param)}}}),this.cloneFrom=this.updates=null)}}class xAe{constructor(){this.map=new Map}set(t,e){return this.map.set(t,e),this}get(t){return this.map.has(t)||this.map.set(t,t.defaultValue()),this.map.get(t)}delete(t){return this.map.delete(t),this}has(t){return this.map.has(t)}keys(){return this.map.keys()}}function DH(n){return typeof ArrayBuffer<"u"&&n instanceof ArrayBuffer}function TH(n){return typeof Blob<"u"&&n instanceof Blob}function kH(n){return typeof FormData<"u"&&n instanceof FormData}class bm{constructor(t,e,r,s){let i;if(this.url=e,this.body=null,this.reportProgress=!1,this.withCredentials=!1,this.responseType="json",this.method=t.toUpperCase(),function wAe(n){switch(n){case"DELETE":case"GET":case"HEAD":case"OPTIONS":case"JSONP":return!1;default:return!0}}(this.method)||s?(this.body=void 0!==r?r:null,i=s):i=r,i&&(this.reportProgress=!!i.reportProgress,this.withCredentials=!!i.withCredentials,i.responseType&&(this.responseType=i.responseType),i.headers&&(this.headers=i.headers),i.context&&(this.context=i.context),i.params&&(this.params=i.params)),this.headers||(this.headers=new Cl),this.context||(this.context=new xAe),this.params){const o=this.params.toString();if(0===o.length)this.urlWithParams=e;else{const a=e.indexOf("?");this.urlWithParams=e+(-1===a?"?":a<e.length-1?"&":"")+o}}else this.params=new Sl,this.urlWithParams=e}serializeBody(){return null===this.body?null:DH(this.body)||TH(this.body)||kH(this.body)||function CAe(n){return typeof URLSearchParams<"u"&&n instanceof URLSearchParams}(this.body)||"string"==typeof this.body?this.body:this.body instanceof Sl?this.body.toString():"object"==typeof this.body||"boolean"==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||kH(this.body)?null:TH(this.body)?this.body.type||null:DH(this.body)?null:"string"==typeof this.body?"text/plain":this.body instanceof Sl?"application/x-www-form-urlencoded;charset=UTF-8":"object"==typeof this.body||"number"==typeof this.body||"boolean"==typeof this.body?"application/json":null}clone(t={}){const e=t.method||this.method,r=t.url||this.url,s=t.responseType||this.responseType,i=void 0!==t.body?t.body:this.body,o=void 0!==t.withCredentials?t.withCredentials:this.withCredentials,a=void 0!==t.reportProgress?t.reportProgress:this.reportProgress;let l=t.headers||this.headers,c=t.params||this.params;const u=t.context??this.context;return void 0!==t.setHeaders&&(l=Object.keys(t.setHeaders).reduce((d,h)=>d.set(h,t.setHeaders[h]),l)),t.setParams&&(c=Object.keys(t.setParams).reduce((d,h)=>d.set(h,t.setParams[h]),c)),new bm(e,r,i,{params:c,headers:l,context:u,reportProgress:a,responseType:s,withCredentials:o})}}var Lr=(()=>((Lr=Lr||{})[Lr.Sent=0]="Sent",Lr[Lr.UploadProgress=1]="UploadProgress",Lr[Lr.ResponseHeader=2]="ResponseHeader",Lr[Lr.DownloadProgress=3]="DownloadProgress",Lr[Lr.Response=4]="Response",Lr[Lr.User=5]="User",Lr))();class SAe{constructor(t,e=200,r="OK"){this.headers=t.headers||new Cl,this.status=void 0!==t.status?t.status:e,this.statusText=t.statusText||r,this.url=t.url||null,this.ok=this.status>=200&&this.status<300}}class V1 extends SAe{constructor(t={}){super(t),this.type=Lr.Response,this.body=void 0!==t.body?t.body:null}clone(t={}){return new V1({body:void 0!==t.body?t.body:this.body,headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}function B1(n,t){return{body:t,headers:n.headers,context:n.context,observe:n.observe,params:n.params,reportProgress:n.reportProgress,responseType:n.responseType,withCredentials:n.withCredentials}}let z1=(()=>{class n{constructor(e){this.handler=e}request(e,r,s={}){let i;if(e instanceof bm)i=e;else{let l,c;l=s.headers instanceof Cl?s.headers:new Cl(s.headers),s.params&&(c=s.params instanceof Sl?s.params:new Sl({fromObject:s.params})),i=new bm(e,r,void 0!==s.body?s.body:null,{headers:l,context:s.context,params:c,reportProgress:s.reportProgress,responseType:s.responseType||"json",withCredentials:s.withCredentials})}const o=Oe(i).pipe(Ha(l=>this.handler.handle(l)));if(e instanceof bm||"events"===s.observe)return o;const a=o.pipe(Ss(l=>l instanceof V1));switch(s.observe||"body"){case"body":switch(i.responseType){case"arraybuffer":return a.pipe(ze(l=>{if(null!==l.body&&!(l.body instanceof ArrayBuffer))throw new Error("Response is not an ArrayBuffer.");return l.body}));case"blob":return a.pipe(ze(l=>{if(null!==l.body&&!(l.body instanceof Blob))throw new Error("Response is not a Blob.");return l.body}));case"text":return a.pipe(ze(l=>{if(null!==l.body&&"string"!=typeof l.body)throw new Error("Response is not a string.");return l.body}));default:return a.pipe(ze(l=>l.body))}case"response":return a;default:throw new Error(`Unreachable: unhandled observe type ${s.observe}}`)}}delete(e,r={}){return this.request("DELETE",e,r)}get(e,r={}){return this.request("GET",e,r)}head(e,r={}){return this.request("HEAD",e,r)}jsonp(e,r){return this.request("JSONP",e,{params:(new Sl).append(r,"JSONP_CALLBACK"),observe:"body",responseType:"json"})}options(e,r={}){return this.request("OPTIONS",e,r)}patch(e,r,s={}){return this.request("PATCH",e,B1(s,r))}post(e,r,s={}){return this.request("POST",e,B1(s,r))}put(e,r,s={}){return this.request("PUT",e,B1(s,r))}}return n.\u0275fac=function(e){return new(e||n)(J(L1))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac}),n})();const PAe=["*"];let zv;function _m(n){return function LAe(){if(void 0===zv&&(zv=null,typeof window<"u")){const n=window;void 0!==n.trustedTypes&&(zv=n.trustedTypes.createPolicy("angular#components",{createHTML:t=>t}))}return zv}()?.createHTML(n)||n}function PH(n){return Error(`Unable to find icon with the name "${n}"`)}function LH(n){return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${n}".`)}function VH(n){return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${n}".`)}class Ac{constructor(t,e,r){this.url=t,this.svgText=e,this.options=r}}let Uv=(()=>{class n{constructor(e,r,s,i){this._httpClient=e,this._sanitizer=r,this._errorHandler=i,this._svgIconConfigs=new Map,this._iconSetConfigs=new Map,this._cachedIconsByUrl=new Map,this._inProgressUrlFetches=new Map,this._fontCssClassesByAlias=new Map,this._resolvers=[],this._defaultFontSetClass=["material-icons","mat-ligature-font"],this._document=s}addSvgIcon(e,r,s){return this.addSvgIconInNamespace("",e,r,s)}addSvgIconLiteral(e,r,s){return this.addSvgIconLiteralInNamespace("",e,r,s)}addSvgIconInNamespace(e,r,s,i){return this._addSvgIconConfig(e,r,new Ac(s,null,i))}addSvgIconResolver(e){return this._resolvers.push(e),this}addSvgIconLiteralInNamespace(e,r,s,i){const o=this._sanitizer.sanitize(Pt.HTML,s);if(!o)throw VH(s);const a=_m(o);return this._addSvgIconConfig(e,r,new Ac("",a,i))}addSvgIconSet(e,r){return this.addSvgIconSetInNamespace("",e,r)}addSvgIconSetLiteral(e,r){return this.addSvgIconSetLiteralInNamespace("",e,r)}addSvgIconSetInNamespace(e,r,s){return this._addSvgIconSetConfig(e,new Ac(r,null,s))}addSvgIconSetLiteralInNamespace(e,r,s){const i=this._sanitizer.sanitize(Pt.HTML,r);if(!i)throw VH(r);const o=_m(i);return this._addSvgIconSetConfig(e,new Ac("",o,s))}registerFontClassAlias(e,r=e){return this._fontCssClassesByAlias.set(e,r),this}classNameForFontAlias(e){return this._fontCssClassesByAlias.get(e)||e}setDefaultFontSetClass(...e){return this._defaultFontSetClass=e,this}getDefaultFontSetClass(){return this._defaultFontSetClass}getSvgIconFromUrl(e){const r=this._sanitizer.sanitize(Pt.RESOURCE_URL,e);if(!r)throw LH(e);const s=this._cachedIconsByUrl.get(r);return s?Oe(Hv(s)):this._loadSvgIconFromConfig(new Ac(e,null)).pipe(tr(i=>this._cachedIconsByUrl.set(r,i)),ze(i=>Hv(i)))}getNamedSvgIcon(e,r=""){const s=BH(r,e);let i=this._svgIconConfigs.get(s);if(i)return this._getSvgFromConfig(i);if(i=this._getIconConfigFromResolvers(r,e),i)return this._svgIconConfigs.set(s,i),this._getSvgFromConfig(i);const o=this._iconSetConfigs.get(r);return o?this._getSvgFromIconSetConfigs(e,o):Mu(PH(s))}ngOnDestroy(){this._resolvers=[],this._svgIconConfigs.clear(),this._iconSetConfigs.clear(),this._cachedIconsByUrl.clear()}_getSvgFromConfig(e){return e.svgText?Oe(Hv(this._svgElementFromConfig(e))):this._loadSvgIconFromConfig(e).pipe(ze(r=>Hv(r)))}_getSvgFromIconSetConfigs(e,r){const s=this._extractIconWithNameFromAnySet(e,r);return s?Oe(s):SH(r.filter(o=>!o.svgText).map(o=>this._loadSvgIconSetFromConfig(o).pipe(ca(a=>{const c=`Loading icon set URL: ${this._sanitizer.sanitize(Pt.RESOURCE_URL,o.url)} failed: ${a.message}`;return this._errorHandler.handleError(new Error(c)),Oe(null)})))).pipe(ze(()=>{const o=this._extractIconWithNameFromAnySet(e,r);if(!o)throw PH(e);return o}))}_extractIconWithNameFromAnySet(e,r){for(let s=r.length-1;s>=0;s--){const i=r[s];if(i.svgText&&i.svgText.toString().indexOf(e)>-1){const o=this._svgElementFromConfig(i),a=this._extractSvgIconFromSet(o,e,i.options);if(a)return a}}return null}_loadSvgIconFromConfig(e){return this._fetchIcon(e).pipe(tr(r=>e.svgText=r),ze(()=>this._svgElementFromConfig(e)))}_loadSvgIconSetFromConfig(e){return e.svgText?Oe(null):this._fetchIcon(e).pipe(tr(r=>e.svgText=r))}_extractSvgIconFromSet(e,r,s){const i=e.querySelector(`[id="${r}"]`);if(!i)return null;const o=i.cloneNode(!0);if(o.removeAttribute("id"),"svg"===o.nodeName.toLowerCase())return this._setSvgAttributes(o,s);if("symbol"===o.nodeName.toLowerCase())return this._setSvgAttributes(this._toSvgElement(o),s);const a=this._svgElementFromString(_m("<svg></svg>"));return a.appendChild(o),this._setSvgAttributes(a,s)}_svgElementFromString(e){const r=this._document.createElement("DIV");r.innerHTML=e;const s=r.querySelector("svg");if(!s)throw Error("<svg> tag not found");return s}_toSvgElement(e){const r=this._svgElementFromString(_m("<svg></svg>")),s=e.attributes;for(let i=0;i<s.length;i++){const{name:o,value:a}=s[i];"id"!==o&&r.setAttribute(o,a)}for(let i=0;i<e.childNodes.length;i++)e.childNodes[i].nodeType===this._document.ELEMENT_NODE&&r.appendChild(e.childNodes[i].cloneNode(!0));return r}_setSvgAttributes(e,r){return e.setAttribute("fit",""),e.setAttribute("height","100%"),e.setAttribute("width","100%"),e.setAttribute("preserveAspectRatio","xMidYMid meet"),e.setAttribute("focusable","false"),r&&r.viewBox&&e.setAttribute("viewBox",r.viewBox),e}_fetchIcon(e){const{url:r,options:s}=e,i=s?.withCredentials??!1;if(!this._httpClient)throw function VAe(){return Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.")}();if(null==r)throw Error(`Cannot fetch icon from URL "${r}".`);const o=this._sanitizer.sanitize(Pt.RESOURCE_URL,r);if(!o)throw LH(r);const a=this._inProgressUrlFetches.get(o);if(a)return a;const l=this._httpClient.get(o,{responseType:"text",withCredentials:i}).pipe(ze(c=>_m(c)),gy(()=>this._inProgressUrlFetches.delete(o)),dN());return this._inProgressUrlFetches.set(o,l),l}_addSvgIconConfig(e,r,s){return this._svgIconConfigs.set(BH(e,r),s),this}_addSvgIconSetConfig(e,r){const s=this._iconSetConfigs.get(e);return s?s.push(r):this._iconSetConfigs.set(e,[r]),this}_svgElementFromConfig(e){if(!e.svgElement){const r=this._svgElementFromString(e.svgText);this._setSvgAttributes(r,e.options),e.svgElement=r}return e.svgElement}_getIconConfigFromResolvers(e,r){for(let s=0;s<this._resolvers.length;s++){const i=this._resolvers[s](r,e);if(i)return zAe(i)?new Ac(i.url,null,i.options):new Ac(i,null)}}}return n.\u0275fac=function(e){return new(e||n)(J(z1,8),J(zC),J(Et,8),J(ea))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function Hv(n){return n.cloneNode(!0)}function BH(n,t){return n+":"+t}function zAe(n){return!(!n.url||!n.options)}const UAe=O1(class{constructor(n){this._elementRef=n}}),HAe=new me("MAT_ICON_DEFAULT_OPTIONS"),WAe=new me("mat-icon-location",{providedIn:"root",factory:function jAe(){const n=Mt(Et),t=n?n.location:null;return{getPathname:()=>t?t.pathname+t.search:""}}}),zH=["clip-path","color-profile","src","cursor","fill","filter","marker","marker-start","marker-mid","marker-end","mask","stroke"],GAe=zH.map(n=>`[${n}]`).join(", "),qAe=/^url\(['"]?#(.*?)['"]?\)$/;let KAe=(()=>{class n extends UAe{constructor(e,r,s,i,o,a){super(e),this._iconRegistry=r,this._location=i,this._errorHandler=o,this._inline=!1,this._previousFontSetClass=[],this._currentIconFetch=He.EMPTY,a&&(a.color&&(this.color=this.defaultColor=a.color),a.fontSet&&(this.fontSet=a.fontSet)),s||e.nativeElement.setAttribute("aria-hidden","true")}get inline(){return this._inline}set inline(e){this._inline=Vi(e)}get svgIcon(){return this._svgIcon}set svgIcon(e){e!==this._svgIcon&&(e?this._updateSvgIcon(e):this._svgIcon&&this._clearSvgElement(),this._svgIcon=e)}get fontSet(){return this._fontSet}set fontSet(e){const r=this._cleanupFontValue(e);r!==this._fontSet&&(this._fontSet=r,this._updateFontIconClasses())}get fontIcon(){return this._fontIcon}set fontIcon(e){const r=this._cleanupFontValue(e);r!==this._fontIcon&&(this._fontIcon=r,this._updateFontIconClasses())}_splitIconName(e){if(!e)return["",""];const r=e.split(":");switch(r.length){case 1:return["",r[0]];case 2:return r;default:throw Error(`Invalid icon name: "${e}"`)}}ngOnInit(){this._updateFontIconClasses()}ngAfterViewChecked(){const e=this._elementsWithExternalReferences;if(e&&e.size){const r=this._location.getPathname();r!==this._previousPath&&(this._previousPath=r,this._prependPathToReferences(r))}}ngOnDestroy(){this._currentIconFetch.unsubscribe(),this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear()}_usingFontIcon(){return!this.svgIcon}_setSvgElement(e){this._clearSvgElement();const r=this._location.getPathname();this._previousPath=r,this._cacheChildrenWithExternalReferences(e),this._prependPathToReferences(r),this._elementRef.nativeElement.appendChild(e)}_clearSvgElement(){const e=this._elementRef.nativeElement;let r=e.childNodes.length;for(this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear();r--;){const s=e.childNodes[r];(1!==s.nodeType||"svg"===s.nodeName.toLowerCase())&&s.remove()}}_updateFontIconClasses(){if(!this._usingFontIcon())return;const e=this._elementRef.nativeElement,r=(this.fontSet?this._iconRegistry.classNameForFontAlias(this.fontSet).split(/ +/):this._iconRegistry.getDefaultFontSetClass()).filter(s=>s.length>0);this._previousFontSetClass.forEach(s=>e.classList.remove(s)),r.forEach(s=>e.classList.add(s)),this._previousFontSetClass=r,this.fontIcon!==this._previousFontIconClass&&!r.includes("mat-ligature-font")&&(this._previousFontIconClass&&e.classList.remove(this._previousFontIconClass),this.fontIcon&&e.classList.add(this.fontIcon),this._previousFontIconClass=this.fontIcon)}_cleanupFontValue(e){return"string"==typeof e?e.trim().split(" ")[0]:e}_prependPathToReferences(e){const r=this._elementsWithExternalReferences;r&&r.forEach((s,i)=>{s.forEach(o=>{i.setAttribute(o.name,`url('${e}#${o.value}')`)})})}_cacheChildrenWithExternalReferences(e){const r=e.querySelectorAll(GAe),s=this._elementsWithExternalReferences=this._elementsWithExternalReferences||new Map;for(let i=0;i<r.length;i++)zH.forEach(o=>{const a=r[i],l=a.getAttribute(o),c=l?l.match(qAe):null;if(c){let u=s.get(a);u||(u=[],s.set(a,u)),u.push({name:o,value:c[1]})}})}_updateSvgIcon(e){if(this._svgNamespace=null,this._svgName=null,this._currentIconFetch.unsubscribe(),e){const[r,s]=this._splitIconName(e);r&&(this._svgNamespace=r),s&&(this._svgName=s),this._currentIconFetch=this._iconRegistry.getNamedSvgIcon(s,r).pipe(no(1)).subscribe(i=>this._setSvgElement(i),i=>{this._errorHandler.handleError(new Error(`Error retrieving icon ${r}:${s}! ${i.message}`))})}}}return n.\u0275fac=function(e){return new(e||n)(K(Cn),K(Uv),Jc("aria-hidden"),K(WAe),K(ea),K(HAe,8))},n.\u0275cmp=pi({type:n,selectors:[["mat-icon"]],hostAttrs:["role","img",1,"mat-icon","notranslate"],hostVars:8,hostBindings:function(e,r){2&e&&(kn("data-mat-icon-type",r._usingFontIcon()?"font":"svg")("data-mat-icon-name",r._svgName||r.fontIcon)("data-mat-icon-namespace",r._svgNamespace||r.fontSet)("fontIcon",r._usingFontIcon()?r.fontIcon:null),Gs("mat-icon-inline",r.inline)("mat-icon-no-color","primary"!==r.color&&"accent"!==r.color&&"warn"!==r.color))},inputs:{color:"color",inline:"inline",svgIcon:"svgIcon",fontSet:"fontSet",fontIcon:"fontIcon"},exportAs:["matIcon"],features:[bt],ngContentSelectors:PAe,decls:1,vars:0,template:function(e,r){1&e&&(Cu(),sa(0))},styles:[".mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}"],encapsulation:2,changeDetection:0}),n})(),XAe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({imports:[ys,ys]}),n})();const YAe=[[["",8,"material-icons",3,"iconPositionEnd",""],["mat-icon",3,"iconPositionEnd",""],["","matButtonIcon","",3,"iconPositionEnd",""]],"*",[["","iconPositionEnd","",8,"material-icons"],["mat-icon","iconPositionEnd",""],["","matButtonIcon","","iconPositionEnd",""]]],ZAe=[".material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])","*",".material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]"],JAe=["mat-mini-fab",""],tRe=["mat-icon-button",""],nRe=["*"],rRe=[{selector:"mat-button",mdcClasses:["mdc-button","mat-mdc-button"]},{selector:"mat-flat-button",mdcClasses:["mdc-button","mdc-button--unelevated","mat-mdc-unelevated-button"]},{selector:"mat-raised-button",mdcClasses:["mdc-button","mdc-button--raised","mat-mdc-raised-button"]},{selector:"mat-stroked-button",mdcClasses:["mdc-button","mdc-button--outlined","mat-mdc-outlined-button"]},{selector:"mat-fab",mdcClasses:["mdc-fab","mat-mdc-fab"]},{selector:"mat-mini-fab",mdcClasses:["mdc-fab","mdc-fab--mini","mat-mdc-mini-fab"]},{selector:"mat-icon-button",mdcClasses:["mdc-icon-button","mat-mdc-icon-button"]}],sRe=O1(pH(mH(class{constructor(n){this._elementRef=n}})));let UH=(()=>{class n extends sRe{constructor(e,r,s,i){super(e),this._platform=r,this._ngZone=s,this._animationMode=i,this._focusMonitor=Mt($Ne),this._isFab=!1;const o=e.nativeElement.classList;for(const a of rRe)this._hasHostAttributes(a.selector)&&a.mdcClasses.forEach(l=>{o.add(l)})}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(e="program",r){e?this._focusMonitor.focusVia(this._elementRef.nativeElement,e,r):this._elementRef.nativeElement.focus(r)}_hasHostAttributes(...e){return e.some(r=>this._elementRef.nativeElement.hasAttribute(r))}_isRippleDisabled(){return this.disableRipple||this.disabled}}return n.\u0275fac=function(e){Ih()},n.\u0275dir=Ve({type:n,viewQuery:function(e,r){if(1&e&&ia(Lv,5),2&e){let s;qs(s=Ks())&&(r.ripple=s.first)}},features:[bt]}),n})();const oRe=new me("mat-mdc-fab-default-options",{providedIn:"root",factory:HH});function HH(){return{color:"accent"}}const WH=HH();let aRe=(()=>{class n extends UH{constructor(e,r,s,i,o){super(e,r,s,i),this._options=o,this._isFab=!0,this._options=this._options||WH,this.color=this.defaultColor=this._options.color||WH.color}}return n.\u0275fac=function(e){return new(e||n)(K(Cn),K(Li),K(St),K(Va,8),K(oRe,8))},n.\u0275cmp=pi({type:n,selectors:[["button","mat-mini-fab",""]],hostVars:7,hostBindings:function(e,r){2&e&&(kn("disabled",r.disabled||null),Gs("_mat-animation-noopable","NoopAnimations"===r._animationMode)("mat-unthemed",!r.color)("mat-mdc-button-base",!0))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[bt],attrs:JAe,ngContentSelectors:ZAe,decls:8,vars:6,consts:[[1,"mat-mdc-button-persistent-ripple"],[1,"mdc-button__label"],[1,"mat-mdc-focus-indicator"],["matRipple","",1,"mat-mdc-button-ripple",3,"matRippleDisabled","matRippleTrigger"],[1,"mat-mdc-button-touch-target"]],template:function(e,r){1&e&&(Cu(YAe),as(0,"span",0),sa(1),Xt(2,"span",1),sa(3,1),Nn(),sa(4,2),as(5,"span",2)(6,"span",3)(7,"span",4)),2&e&&(Gs("mdc-button__ripple",!r._isFab)("mdc-fab__ripple",r._isFab),en(6),tn("matRippleDisabled",r._isRippleDisabled())("matRippleTrigger",r._elementRef.nativeElement))},dependencies:[Lv],styles:['.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-fab{position:relative;display:inline-flex;position:relative;align-items:center;justify-content:center;box-sizing:border-box;width:56px;height:56px;padding:0;border:none;fill:currentColor;text-decoration:none;cursor:pointer;user-select:none;-moz-appearance:none;-webkit-appearance:none;overflow:visible;transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),opacity 15ms linear 30ms,transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-fab .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-fab[hidden]{display:none}.mdc-fab::-moz-focus-inner{padding:0;border:0}.mdc-fab .mdc-fab__focus-ring{position:absolute}.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(\n      100% + 4px\n    );width:calc(\n      100% + 4px\n    )}@media screen and (forced-colors: active){.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{border-color:CanvasText}}.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{border-color:CanvasText}}.mdc-fab:active,.mdc-fab:focus{outline:none}.mdc-fab:hover{cursor:pointer}.mdc-fab>svg{width:100%}.mdc-fab--mini{width:40px;height:40px}.mdc-fab--extended{border-radius:24px;padding-left:20px;padding-right:20px;width:auto;max-width:100%;height:48px;line-height:normal}.mdc-fab--extended .mdc-fab__ripple{border-radius:24px}.mdc-fab--extended .mdc-fab__icon{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mdc-fab--extended .mdc-fab__icon,.mdc-fab--extended .mdc-fab__icon[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mdc-fab--extended .mdc-fab__label+.mdc-fab__icon{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mdc-fab--extended .mdc-fab__label+.mdc-fab__icon,.mdc-fab--extended .mdc-fab__label+.mdc-fab__icon[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mdc-fab--touch{margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}.mdc-fab--touch .mdc-fab__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mdc-fab::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-fab::before{border-color:CanvasText}}.mdc-fab__label{justify-content:flex-start;text-overflow:ellipsis;white-space:nowrap;overflow-x:hidden;overflow-y:visible}.mdc-fab__icon{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mdc-fab .mdc-fab__icon{display:inline-flex;align-items:center;justify-content:center}.mdc-fab--exited{transform:scale(0);opacity:0;transition:opacity 15ms linear 150ms,transform 180ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-fab--exited .mdc-fab__icon{transform:scale(0);transition:transform 135ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-fab .mdc-fab__icon{width:24px;height:24px;font-size:24px}.mdc-fab:not(.mdc-fab--extended){border-radius:50%}.mdc-fab:not(.mdc-fab--extended) .mdc-fab__ripple{border-radius:50%}.mat-mdc-fab,.mat-mdc-mini-fab{background-color:var(--mdc-fab-container-color, transparent);box-shadow:0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12);color:var(--mat-mdc-fab-color, inherit);flex-shrink:0}.mat-mdc-fab .mat-mdc-button-ripple,.mat-mdc-fab .mat-mdc-button-persistent-ripple,.mat-mdc-fab .mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab .mat-mdc-button-ripple,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-fab .mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-fab .mat-ripple-element,.mat-mdc-mini-fab .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-fab .mdc-button__label,.mat-mdc-mini-fab .mdc-button__label{z-index:1}.mat-mdc-fab .mat-mdc-focus-indicator,.mat-mdc-mini-fab .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-fab:focus .mat-mdc-focus-indicator::before,.mat-mdc-mini-fab:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-fab .mat-mdc-button-touch-target,.mat-mdc-mini-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mat-mdc-fab._mat-animation-noopable,.mat-mdc-mini-fab._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-fab:not(:disabled) .mdc-fab__icon,.mat-mdc-mini-fab:not(:disabled) .mdc-fab__icon{color:var(--mdc-fab-icon-color, inherit)}.mat-mdc-fab:not(.mdc-fab--extended),.mat-mdc-mini-fab:not(.mdc-fab--extended){border-radius:var(--mdc-fab-container-shape, 50%)}.mat-mdc-fab:not(.mdc-fab--extended) .mdc-fab__ripple,.mat-mdc-mini-fab:not(.mdc-fab--extended) .mdc-fab__ripple{border-radius:var(--mdc-fab-container-shape, 50%)}.mat-mdc-fab:hover,.mat-mdc-fab:focus,.mat-mdc-mini-fab:hover,.mat-mdc-mini-fab:focus{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12)}.mat-mdc-fab:active,.mat-mdc-fab:focus:active,.mat-mdc-mini-fab:active,.mat-mdc-mini-fab:focus:active{box-shadow:0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 12px 17px 2px rgba(0, 0, 0, 0.14), 0px 5px 22px 4px rgba(0, 0, 0, 0.12)}.mat-mdc-fab[disabled],.mat-mdc-mini-fab[disabled]{cursor:default;pointer-events:none;box-shadow:0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12)}.mat-mdc-fab:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-mini-fab:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}.mat-mdc-fab .mat-icon,.mat-mdc-fab .material-icons,.mat-mdc-mini-fab .mat-icon,.mat-mdc-mini-fab .material-icons{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mat-mdc-fab .mat-mdc-focus-indicator::before,.mat-mdc-mini-fab .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-extended-fab{border-radius:24px;padding-left:20px;padding-right:20px;width:auto;max-width:100%;height:48px;line-height:normal}.mat-mdc-extended-fab .mdc-fab__ripple{border-radius:24px}.mat-mdc-extended-fab .mdc-fab__icon{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mat-mdc-extended-fab .mdc-fab__icon,.mat-mdc-extended-fab .mdc-fab__icon[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mat-mdc-extended-fab .mdc-fab__label+.mdc-fab__icon{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mat-mdc-extended-fab .mdc-fab__label+.mdc-fab__icon,.mat-mdc-extended-fab .mdc-fab__label+.mdc-fab__icon[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mat-mdc-extended-fab>.mat-icon,.mat-mdc-extended-fab>.material-icons{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mat-mdc-extended-fab>.mat-icon,[dir=rtl] .mat-mdc-extended-fab>.material-icons,.mat-mdc-extended-fab>.mat-icon[dir=rtl],.mat-mdc-extended-fab>.material-icons[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mat-mdc-extended-fab .mdc-button__label+.mat-icon,.mat-mdc-extended-fab .mdc-button__label+.material-icons{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.material-icons,.mat-mdc-extended-fab .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-extended-fab .mdc-button__label+.material-icons[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mat-mdc-extended-fab .mat-mdc-button-touch-target{width:100%}'],encapsulation:2,changeDetection:0}),n})(),lRe=(()=>{class n extends UH{constructor(e,r,s,i){super(e,r,s,i)}}return n.\u0275fac=function(e){return new(e||n)(K(Cn),K(Li),K(St),K(Va,8))},n.\u0275cmp=pi({type:n,selectors:[["button","mat-icon-button",""]],hostVars:7,hostBindings:function(e,r){2&e&&(kn("disabled",r.disabled||null),Gs("_mat-animation-noopable","NoopAnimations"===r._animationMode)("mat-unthemed",!r.color)("mat-mdc-button-base",!0))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[bt],attrs:tRe,ngContentSelectors:nRe,decls:5,vars:3,consts:[[1,"mat-mdc-button-persistent-ripple","mdc-icon-button__ripple"],[1,"mat-mdc-focus-indicator"],["matRipple","",1,"mat-mdc-button-ripple",3,"matRippleDisabled","matRippleCentered","matRippleTrigger"],[1,"mat-mdc-button-touch-target"]],template:function(e,r){1&e&&(Cu(),as(0,"span",0),sa(1),as(2,"span",1)(3,"span",2)(4,"span",3)),2&e&&(en(3),tn("matRippleDisabled",r._isRippleDisabled())("matRippleCentered",!0)("matRippleTrigger",r._elementRef.nativeElement))},dependencies:[Lv],styles:['.mdc-icon-button{font-size:24px;width:48px;height:48px;padding:12px}.mdc-icon-button .mdc-icon-button__focus-ring{max-height:48px;max-width:48px}.mdc-icon-button.mdc-icon-button--reduced-size .mdc-icon-button__ripple{width:40px;height:40px;margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}.mdc-icon-button.mdc-icon-button--reduced-size .mdc-icon-button__focus-ring{max-height:40px;max-width:40px}.mdc-icon-button .mdc-icon-button__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mdc-icon-button svg,.mdc-icon-button img{width:24px;height:24px}.mdc-icon-button{display:inline-block;position:relative;box-sizing:border-box;border:none;outline:none;background-color:rgba(0,0,0,0);fill:currentColor;color:inherit;text-decoration:none;cursor:pointer;user-select:none;z-index:0;overflow:visible}.mdc-icon-button .mdc-icon-button__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}@media screen and (forced-colors: active){.mdc-icon-button.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring,.mdc-icon-button:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring{display:block}}.mdc-icon-button:disabled{cursor:default;pointer-events:none}.mdc-icon-button[hidden]{display:none}.mdc-icon-button--display-flex{align-items:center;display:inline-flex;justify-content:center}.mdc-icon-button__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:100%;width:100%;display:none}@media screen and (forced-colors: active){.mdc-icon-button__focus-ring{border-color:CanvasText}}.mdc-icon-button__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-icon-button__focus-ring::after{border-color:CanvasText}}.mdc-icon-button__icon{display:inline-block}.mdc-icon-button__icon.mdc-icon-button__icon--on{display:none}.mdc-icon-button--on .mdc-icon-button__icon{display:none}.mdc-icon-button--on .mdc-icon-button__icon.mdc-icon-button__icon--on{display:inline-block}.mdc-icon-button__link{height:100%;left:0;outline:none;position:absolute;top:0;width:100%}.mat-mdc-icon-button{height:var(--mdc-icon-button-state-layer-size, 48px);width:var(--mdc-icon-button-state-layer-size, 48px);color:var(--mdc-icon-button-icon-color, inherit);border-radius:50%;flex-shrink:0}.mat-mdc-icon-button .mdc-button__icon{font-size:var(--mdc-icon-button-icon-size, 24px)}.mat-mdc-icon-button svg,.mat-mdc-icon-button img{width:var(--mdc-icon-button-icon-size, 24px);height:var(--mdc-icon-button-icon-size, 24px)}.mat-mdc-icon-button:disabled{opacity:var(--mdc-icon-button-disabled-icon-opacity, 0.38)}.mat-mdc-icon-button:disabled{color:var(--mdc-icon-button-disabled-icon-color, #000)}.mat-mdc-icon-button[disabled]{cursor:default;pointer-events:none;opacity:1}.mat-mdc-icon-button .mat-mdc-button-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-icon-button .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-icon-button .mdc-button__label{z-index:1}.mat-mdc-icon-button .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-icon-button:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-icon-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mat-mdc-icon-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple{border-radius:50%}.mat-mdc-icon-button.mat-unthemed:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-primary:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-accent:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-warn:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}',".cdk-high-contrast-active .mat-mdc-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-unelevated-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-raised-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-outlined-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-icon-button{outline:solid 1px}"],encapsulation:2,changeDetection:0}),n})(),cRe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({imports:[ys,P1,ys]}),n})();const uRe=["addListener","removeListener"],dRe=["addEventListener","removeEventListener"],hRe=["on","off"];function H1(n,t,e,r){if(ae(e)&&(r=e,e=void 0),r)return H1(n,t,e).pipe(UC(r));const[s,i]=function mRe(n){return ae(n.addEventListener)&&ae(n.removeEventListener)}(n)?dRe.map(o=>a=>n[o](t,a,e)):function fRe(n){return ae(n.addListener)&&ae(n.removeListener)}(n)?uRe.map(jH(n,t)):function pRe(n){return ae(n.on)&&ae(n.off)}(n)?hRe.map(jH(n,t)):[];if(!s&&Ax(n))return Er(o=>H1(o,t,e))(Vr(n));if(!s)throw new TypeError("Invalid event target");return new xn(o=>{const a=(...l)=>o.next(1<l.length?l:l[0]);return s(a),()=>i(a)})}function jH(n,t){return e=>r=>n[e](t,r)}const vm={schedule(n){let t=requestAnimationFrame,e=cancelAnimationFrame;const{delegate:r}=vm;r&&(t=r.requestAnimationFrame,e=r.cancelAnimationFrame);const s=t(i=>{e=void 0,n(i)});return new He(()=>e?.(s))},requestAnimationFrame(...n){const{delegate:t}=vm;return(t?.requestAnimationFrame||requestAnimationFrame)(...n)},cancelAnimationFrame(...n){const{delegate:t}=vm;return(t?.cancelAnimationFrame||cancelAnimationFrame)(...n)},delegate:void 0};new class yRe extends bS{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let s;t=t||r.shift();do{if(s=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,s){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw s}}}(class gRe extends yS{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=vm.requestAnimationFrame(()=>t.flush(void 0))))}recycleAsyncId(t,e,r=0){var s;if(null!=r?r>0:this.delay>0)return super.recycleAsyncId(t,e,r);const{actions:i}=t;null!=e&&(null===(s=i[i.length-1])||void 0===s?void 0:s.id)!==e&&(vm.cancelAnimationFrame(e),t._scheduled=void 0)}});let W1,_Re=1;const Wv={};function GH(n){return n in Wv&&(delete Wv[n],!0)}const vRe={setImmediate(n){const t=_Re++;return Wv[t]=!0,W1||(W1=Promise.resolve()),W1.then(()=>GH(t)&&n()),t},clearImmediate(n){GH(n)}},{setImmediate:xRe,clearImmediate:wRe}=vRe,jv={setImmediate(...n){const{delegate:t}=jv;return(t?.setImmediate||xRe)(...n)},clearImmediate(n){const{delegate:t}=jv;return(t?.clearImmediate||wRe)(n)},delegate:void 0};new class SRe extends bS{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let s;t=t||r.shift();do{if(s=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,s){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw s}}}(class CRe extends yS{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=jv.setImmediate(t.flush.bind(t,void 0))))}recycleAsyncId(t,e,r=0){var s;if(null!=r?r>0:this.delay>0)return super.recycleAsyncId(t,e,r);const{actions:i}=t;null!=e&&(null===(s=i[i.length-1])||void 0===s?void 0:s.id)!==e&&(jv.clearImmediate(e),t._scheduled=void 0)}});function qH(n,t=$y){return function IRe(n){return Dn((t,e)=>{let r=!1,s=null,i=null,o=!1;const a=()=>{if(i?.unsubscribe(),i=null,r){r=!1;const c=s;s=null,e.next(c)}o&&e.complete()},l=()=>{i=null,o&&e.complete()};t.subscribe(ln(e,c=>{r=!0,s=c,i||Vr(n(c)).subscribe(i=ln(e,a,l))},()=>{o=!0,(!r||!i||i.closed)&&e.complete()}))})}(()=>yP(n,t))}let TRe=(()=>{class n{constructor(e,r,s){this._ngZone=e,this._platform=r,this._scrolled=new Wt,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=s}register(e){this.scrollContainers.has(e)||this.scrollContainers.set(e,e.elementScrolled().subscribe(()=>this._scrolled.next(e)))}deregister(e){const r=this.scrollContainers.get(e);r&&(r.unsubscribe(),this.scrollContainers.delete(e))}scrolled(e=20){return this._platform.isBrowser?new xn(r=>{this._globalSubscription||this._addGlobalListener();const s=e>0?this._scrolled.pipe(qH(e)).subscribe(r):this._scrolled.subscribe(r);return this._scrolledCount++,()=>{s.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):Oe()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((e,r)=>this.deregister(r)),this._scrolled.complete()}ancestorScrolled(e,r){const s=this.getAncestorScrollContainers(e);return this.scrolled(r).pipe(Ss(i=>!i||s.indexOf(i)>-1))}getAncestorScrollContainers(e){const r=[];return this.scrollContainers.forEach((s,i)=>{this._scrollableContainsElement(i,e)&&r.push(i)}),r}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(e,r){let s=Ud(r),i=e.getElementRef().nativeElement;do{if(s==i)return!0}while(s=s.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>H1(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return n.\u0275fac=function(e){return new(e||n)(J(St),J(Li),J(Et,8))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),j1=(()=>{class n{constructor(e,r,s){this._platform=e,this._change=new Wt,this._changeListener=i=>{this._change.next(i)},this._document=s,r.runOutsideAngular(()=>{if(e.isBrowser){const i=this._getWindow();i.addEventListener("resize",this._changeListener),i.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._viewportSize=null)})}ngOnDestroy(){if(this._platform.isBrowser){const e=this._getWindow();e.removeEventListener("resize",this._changeListener),e.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const e={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),e}getViewportRect(){const e=this.getViewportScrollPosition(),{width:r,height:s}=this.getViewportSize();return{top:e.top,left:e.left,bottom:e.top+s,right:e.left+r,height:s,width:r}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const e=this._document,r=this._getWindow(),s=e.documentElement,i=s.getBoundingClientRect();return{top:-i.top||e.body.scrollTop||r.scrollY||s.scrollTop||0,left:-i.left||e.body.scrollLeft||r.scrollX||s.scrollLeft||0}}change(e=20){return e>0?this._change.pipe(qH(e)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const e=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:e.innerWidth,height:e.innerHeight}:{width:0,height:0}}}return n.\u0275fac=function(e){return new(e||n)(J(Li),J(St),J(Et,8))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Gv=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({}),n})(),KH=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({imports:[gm,Gv,gm,Gv]}),n})();class G1{attach(t){return this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null!=t&&(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class NRe extends G1{constructor(t,e,r,s,i){super(),this.component=t,this.viewContainerRef=e,this.injector=r,this.componentFactoryResolver=s,this.projectableNodes=i}}class XH extends G1{constructor(t,e,r,s){super(),this.templateRef=t,this.viewContainerRef=e,this.context=r,this.injector=s}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class ARe extends G1{constructor(t){super(),this.element=t instanceof Cn?t.nativeElement:t}}class RRe{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t instanceof NRe?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof XH?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&&t instanceof ARe?(this._attachedPortal=t,this.attachDomPortal(t)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class MRe extends RRe{constructor(t,e,r,s,i){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=r,this._defaultInjector=s,this.attachDomPortal=o=>{const a=o.element,l=this._document.createComment("dom-portal");a.parentNode.insertBefore(l,a),this.outletElement.appendChild(a),this._attachedPortal=o,super.setDisposeFn(()=>{l.parentNode&&l.parentNode.replaceChild(a,l)})},this._document=i}attachComponentPortal(t){const r=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let s;return t.viewContainerRef?(s=t.viewContainerRef.createComponent(r,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector,t.projectableNodes||void 0),this.setDisposeFn(()=>s.destroy())):(s=r.create(t.injector||this._defaultInjector||os.NULL),this._appRef.attachView(s.hostView),this.setDisposeFn(()=>{this._appRef.viewCount>0&&this._appRef.detachView(s.hostView),s.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(s)),this._attachedPortal=t,s}attachTemplatePortal(t){let e=t.viewContainerRef,r=e.createEmbeddedView(t.templateRef,t.context,{injector:t.injector});return r.rootNodes.forEach(s=>this.outletElement.appendChild(s)),r.detectChanges(),this.setDisposeFn(()=>{let s=e.indexOf(r);-1!==s&&e.remove(s)}),this._attachedPortal=t,r}dispose(){super.dispose(),this.outletElement.remove()}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let FRe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({}),n})();const YH=Yke();class ORe{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||"",this._previousHTMLStyles.top=t.style.top||"",t.style.left=cr(-this._previousScrollPosition.left),t.style.top=cr(-this._previousScrollPosition.top),t.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,r=t.style,s=this._document.body.style,i=r.scrollBehavior||"",o=s.scrollBehavior||"";this._isEnabled=!1,r.left=this._previousHTMLStyles.left,r.top=this._previousHTMLStyles.top,t.classList.remove("cdk-global-scrollblock"),YH&&(r.scrollBehavior=s.scrollBehavior="auto"),window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),YH&&(r.scrollBehavior=i,s.scrollBehavior=o)}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const e=this._document.body,r=this._viewportRuler.getViewportSize();return e.scrollHeight>r.height||e.scrollWidth>r.width}}class $Re{constructor(t,e,r,s){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=r,this._config=s,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(t){this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0);this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=>{const e=this._viewportRuler.getViewportScrollPosition().top;Math.abs(e-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class ZH{enable(){}disable(){}attach(){}}function q1(n,t){return t.some(e=>n.bottom<e.top||n.top>e.bottom||n.right<e.left||n.left>e.right)}function QH(n,t){return t.some(e=>n.top<e.top||n.bottom>e.bottom||n.left<e.left||n.right>e.right)}class PRe{constructor(t,e,r,s){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=r,this._config=s,this._scrollSubscription=null}attach(t){this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const e=this._overlayRef.overlayElement.getBoundingClientRect(),{width:r,height:s}=this._viewportRuler.getViewportSize();q1(e,[{width:r,height:s,bottom:s,right:r,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let LRe=(()=>{class n{constructor(e,r,s,i){this._scrollDispatcher=e,this._viewportRuler=r,this._ngZone=s,this.noop=()=>new ZH,this.close=o=>new $Re(this._scrollDispatcher,this._ngZone,this._viewportRuler,o),this.block=()=>new ORe(this._viewportRuler,this._document),this.reposition=o=>new PRe(this._scrollDispatcher,this._viewportRuler,this._ngZone,o),this._document=i}}return n.\u0275fac=function(e){return new(e||n)(J(TRe),J(j1),J(St),J(Et))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class JH{constructor(t){if(this.scrollStrategy=new ZH,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,t){const e=Object.keys(t);for(const r of e)void 0!==t[r]&&(this[r]=t[r])}}}class VRe{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}let eW=(()=>{class n{constructor(e){this._attachedOverlays=[],this._document=e}ngOnDestroy(){this.detach()}add(e){this.remove(e),this._attachedOverlays.push(e)}remove(e){const r=this._attachedOverlays.indexOf(e);r>-1&&this._attachedOverlays.splice(r,1),0===this._attachedOverlays.length&&this.detach()}}return n.\u0275fac=function(e){return new(e||n)(J(Et))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),BRe=(()=>{class n extends eW{constructor(e,r){super(e),this._ngZone=r,this._keydownListener=s=>{const i=this._attachedOverlays;for(let o=i.length-1;o>-1;o--)if(i[o]._keydownEvents.observers.length>0){const a=i[o]._keydownEvents;this._ngZone?this._ngZone.run(()=>a.next(s)):a.next(s);break}}}add(e){super.add(e),this._isAttached||(this._ngZone?this._ngZone.runOutsideAngular(()=>this._document.body.addEventListener("keydown",this._keydownListener)):this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return n.\u0275fac=function(e){return new(e||n)(J(Et),J(St,8))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),zRe=(()=>{class n extends eW{constructor(e,r,s){super(e),this._platform=r,this._ngZone=s,this._cursorStyleIsSet=!1,this._pointerDownListener=i=>{this._pointerDownEventTarget=Nc(i)},this._clickListener=i=>{const o=Nc(i),a="click"===i.type&&this._pointerDownEventTarget?this._pointerDownEventTarget:o;this._pointerDownEventTarget=null;const l=this._attachedOverlays.slice();for(let c=l.length-1;c>-1;c--){const u=l[c];if(u._outsidePointerEvents.observers.length<1||!u.hasAttached())continue;if(u.overlayElement.contains(o)||u.overlayElement.contains(a))break;const d=u._outsidePointerEvents;this._ngZone?this._ngZone.run(()=>d.next(i)):d.next(i)}}}add(e){if(super.add(e),!this._isAttached){const r=this._document.body;this._ngZone?this._ngZone.runOutsideAngular(()=>this._addEventListeners(r)):this._addEventListeners(r),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=r.style.cursor,r.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0}}detach(){if(this._isAttached){const e=this._document.body;e.removeEventListener("pointerdown",this._pointerDownListener,!0),e.removeEventListener("click",this._clickListener,!0),e.removeEventListener("auxclick",this._clickListener,!0),e.removeEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(e.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1}}_addEventListeners(e){e.addEventListener("pointerdown",this._pointerDownListener,!0),e.addEventListener("click",this._clickListener,!0),e.addEventListener("auxclick",this._clickListener,!0),e.addEventListener("contextmenu",this._clickListener,!0)}}return n.\u0275fac=function(e){return new(e||n)(J(Et),J(Li),J(St,8))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),tW=(()=>{class n{constructor(e,r){this._platform=r,this._document=e}ngOnDestroy(){this._containerElement?.remove()}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const e="cdk-overlay-container";if(this._platform.isBrowser||T1()){const s=this._document.querySelectorAll(`.${e}[platform="server"], .${e}[platform="test"]`);for(let i=0;i<s.length;i++)s[i].remove()}const r=this._document.createElement("div");r.classList.add(e),T1()?r.setAttribute("platform","test"):this._platform.isBrowser||r.setAttribute("platform","server"),this._document.body.appendChild(r),this._containerElement=r}}return n.\u0275fac=function(e){return new(e||n)(J(Et),J(Li))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class URe{constructor(t,e,r,s,i,o,a,l,c,u=!1){this._portalOutlet=t,this._host=e,this._pane=r,this._config=s,this._ngZone=i,this._keyboardDispatcher=o,this._document=a,this._location=l,this._outsideClickDispatcher=c,this._animationsDisabled=u,this._backdropElement=null,this._backdropClick=new Wt,this._attachments=new Wt,this._detachments=new Wt,this._locationChanges=He.EMPTY,this._backdropClickHandler=d=>this._backdropClick.next(d),this._backdropTransitionendHandler=d=>{this._disposeBackdrop(d.target)},this._keydownEvents=new Wt,this._outsidePointerEvents=new Wt,s.scrollStrategy&&(this._scrollStrategy=s.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=s.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host);const e=this._portalOutlet.attach(t);return this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.pipe(no(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher.add(this),"function"==typeof e?.onDestroy&&e.onDestroy(()=>{this.hasAttached()&&this._ngZone.runOutsideAngular(()=>Promise.resolve().then(()=>this.detach()))}),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher.remove(this),t}dispose(){const t=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this._disposeBackdrop(this._backdropElement),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher.remove(this),this._host?.remove(),this._previousHostParent=this._pane=this._host=null,t&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&&(t.attach(this),this.updatePosition()))}updateSize(t){this._config={...this._config,...t},this._updateElementSize()}setDirection(t){this._config={...this._config,direction:t},this._updateElementDirection()}addPanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?"string"==typeof t?t:t.value:"ltr"}updateScrollStrategy(t){t!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&&(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=cr(this._config.width),t.height=cr(this._config.height),t.minWidth=cr(this._config.minWidth),t.minHeight=cr(this._config.minHeight),t.maxWidth=cr(this._config.maxWidth),t.maxHeight=cr(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?"":"none"}_attachBackdrop(){const t="cdk-overlay-backdrop-showing";this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._animationsDisabled&&this._backdropElement.classList.add("cdk-overlay-backdrop-noop-animation"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),!this._animationsDisabled&&typeof requestAnimationFrame<"u"?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add(t)})}):this._backdropElement.classList.add(t)}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){const t=this._backdropElement;if(t){if(this._animationsDisabled)return void this._disposeBackdrop(t);t.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{t.addEventListener("transitionend",this._backdropTransitionendHandler)}),t.style.pointerEvents="none",this._backdropTimeout=this._ngZone.runOutsideAngular(()=>setTimeout(()=>{this._disposeBackdrop(t)},500))}}_toggleClasses(t,e,r){const s=$v(e||[]).filter(i=>!!i);s.length&&(r?t.classList.add(...s):t.classList.remove(...s))}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const t=this._ngZone.onStable.pipe(Ea(Jd(this._attachments,this._detachments))).subscribe(()=>{(!this._pane||!this._host||0===this._pane.children.length)&&(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._host.remove()),t.unsubscribe())})})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&&(t.disable(),t.detach&&t.detach())}_disposeBackdrop(t){t&&(t.removeEventListener("click",this._backdropClickHandler),t.removeEventListener("transitionend",this._backdropTransitionendHandler),t.remove(),this._backdropElement===t&&(this._backdropElement=null)),this._backdropTimeout&&(clearTimeout(this._backdropTimeout),this._backdropTimeout=void 0)}}const nW="cdk-overlay-connected-position-bounding-box",HRe=/([A-Za-z%]+)$/;class WRe{constructor(t,e,r,s,i){this._viewportRuler=e,this._document=r,this._platform=s,this._overlayContainer=i,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new Wt,this._resizeSubscription=He.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(t)}get positions(){return this._preferredPositions}attach(t){this._validatePositions(),t.hostElement.classList.add(nW),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const t=this._originRect,e=this._overlayRect,r=this._viewportRect,s=this._containerRect,i=[];let o;for(let a of this._preferredPositions){let l=this._getOriginPoint(t,s,a),c=this._getOverlayPoint(l,e,a),u=this._getOverlayFit(c,e,r,a);if(u.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(a,l);this._canFitWithFlexibleDimensions(u,c,r)?i.push({position:a,origin:l,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(l,a)}):(!o||o.overlayFit.visibleArea<u.visibleArea)&&(o={overlayFit:u,overlayPoint:c,originPoint:l,position:a,overlayRect:e})}if(i.length){let a=null,l=-1;for(const c of i){const u=c.boundingBoxRect.width*c.boundingBoxRect.height*(c.position.weight||1);u>l&&(l=u,a=c)}return this._isPushed=!1,void this._applyPosition(a.position,a.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(o.position,o.originPoint);this._applyPosition(o.position,o.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&Rc(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove(nW),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(this._isDisposed||!this._platform.isBrowser)return;const t=this._lastPosition;if(t){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const e=this._getOriginPoint(this._originRect,this._containerRect,t);this._applyPosition(t,e)}else this.apply()}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e,r){let s,i;if("center"==r.originX)s=t.left+t.width/2;else{const o=this._isRtl()?t.right:t.left,a=this._isRtl()?t.left:t.right;s="start"==r.originX?o:a}return e.left<0&&(s-=e.left),i="center"==r.originY?t.top+t.height/2:"top"==r.originY?t.top:t.bottom,e.top<0&&(i-=e.top),{x:s,y:i}}_getOverlayPoint(t,e,r){let s,i;return s="center"==r.overlayX?-e.width/2:"start"===r.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,i="center"==r.overlayY?-e.height/2:"top"==r.overlayY?0:-e.height,{x:t.x+s,y:t.y+i}}_getOverlayFit(t,e,r,s){const i=sW(e);let{x:o,y:a}=t,l=this._getOffset(s,"x"),c=this._getOffset(s,"y");l&&(o+=l),c&&(a+=c);let h=0-a,f=a+i.height-r.height,p=this._subtractOverflows(i.width,0-o,o+i.width-r.width),m=this._subtractOverflows(i.height,h,f),g=p*m;return{visibleArea:g,isCompletelyWithinViewport:i.width*i.height===g,fitsInViewportVertically:m===i.height,fitsInViewportHorizontally:p==i.width}}_canFitWithFlexibleDimensions(t,e,r){if(this._hasFlexibleDimensions){const s=r.bottom-e.y,i=r.right-e.x,o=rW(this._overlayRef.getConfig().minHeight),a=rW(this._overlayRef.getConfig().minWidth),c=t.fitsInViewportHorizontally||null!=a&&a<=i;return(t.fitsInViewportVertically||null!=o&&o<=s)&&c}return!1}_pushOverlayOnScreen(t,e,r){if(this._previousPushAmount&&this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const s=sW(e),i=this._viewportRect,o=Math.max(t.x+s.width-i.width,0),a=Math.max(t.y+s.height-i.height,0),l=Math.max(i.top-r.top-t.y,0),c=Math.max(i.left-r.left-t.x,0);let u=0,d=0;return u=s.width<=i.width?c||-o:t.x<this._viewportMargin?i.left-r.left-t.x:0,d=s.height<=i.height?l||-a:t.y<this._viewportMargin?i.top-r.top-t.y:0,this._previousPushAmount={x:u,y:d},{x:t.x+u,y:t.y+d}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&&this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const r=this._getScrollVisibility(),s=new VRe(t,r);this._positionChanges.next(s)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let r,s=t.overlayY;r="center"===t.overlayX?"center":this._isRtl()?"start"===t.overlayX?"right":"left":"start"===t.overlayX?"left":"right";for(let i=0;i<e.length;i++)e[i].style.transformOrigin=`${r} ${s}`}_calculateBoundingBoxRect(t,e){const r=this._viewportRect,s=this._isRtl();let i,o,a,u,d,h;if("top"===e.overlayY)o=t.y,i=r.height-o+this._viewportMargin;else if("bottom"===e.overlayY)a=r.height-t.y+2*this._viewportMargin,i=r.height-a+this._viewportMargin;else{const f=Math.min(r.bottom-t.y+r.top,t.y),p=this._lastBoundingBoxSize.height;i=2*f,o=t.y-f,i>p&&!this._isInitialRender&&!this._growAfterOpen&&(o=t.y-p/2)}if("end"===e.overlayX&&!s||"start"===e.overlayX&&s)h=r.width-t.x+this._viewportMargin,u=t.x-this._viewportMargin;else if("start"===e.overlayX&&!s||"end"===e.overlayX&&s)d=t.x,u=r.right-t.x;else{const f=Math.min(r.right-t.x+r.left,t.x),p=this._lastBoundingBoxSize.width;u=2*f,d=t.x-f,u>p&&!this._isInitialRender&&!this._growAfterOpen&&(d=t.x-p/2)}return{top:o,left:d,bottom:a,right:h,width:u,height:i}}_setBoundingBoxStyles(t,e){const r=this._calculateBoundingBoxRect(t,e);!this._isInitialRender&&!this._growAfterOpen&&(r.height=Math.min(r.height,this._lastBoundingBoxSize.height),r.width=Math.min(r.width,this._lastBoundingBoxSize.width));const s={};if(this._hasExactPosition())s.top=s.left="0",s.bottom=s.right=s.maxHeight=s.maxWidth="",s.width=s.height="100%";else{const i=this._overlayRef.getConfig().maxHeight,o=this._overlayRef.getConfig().maxWidth;s.height=cr(r.height),s.top=cr(r.top),s.bottom=cr(r.bottom),s.width=cr(r.width),s.left=cr(r.left),s.right=cr(r.right),s.alignItems="center"===e.overlayX?"center":"end"===e.overlayX?"flex-end":"flex-start",s.justifyContent="center"===e.overlayY?"center":"bottom"===e.overlayY?"flex-end":"flex-start",i&&(s.maxHeight=cr(i)),o&&(s.maxWidth=cr(o))}this._lastBoundingBoxSize=r,Rc(this._boundingBox.style,s)}_resetBoundingBoxStyles(){Rc(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){Rc(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(t,e){const r={},s=this._hasExactPosition(),i=this._hasFlexibleDimensions,o=this._overlayRef.getConfig();if(s){const u=this._viewportRuler.getViewportScrollPosition();Rc(r,this._getExactOverlayY(e,t,u)),Rc(r,this._getExactOverlayX(e,t,u))}else r.position="static";let a="",l=this._getOffset(e,"x"),c=this._getOffset(e,"y");l&&(a+=`translateX(${l}px) `),c&&(a+=`translateY(${c}px)`),r.transform=a.trim(),o.maxHeight&&(s?r.maxHeight=cr(o.maxHeight):i&&(r.maxHeight="")),o.maxWidth&&(s?r.maxWidth=cr(o.maxWidth):i&&(r.maxWidth="")),Rc(this._pane.style,r)}_getExactOverlayY(t,e,r){let s={top:"",bottom:""},i=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,r)),"bottom"===t.overlayY?s.bottom=this._document.documentElement.clientHeight-(i.y+this._overlayRect.height)+"px":s.top=cr(i.y),s}_getExactOverlayX(t,e,r){let o,s={left:"",right:""},i=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,r)),o=this._isRtl()?"end"===t.overlayX?"left":"right":"end"===t.overlayX?"right":"left","right"===o?s.right=this._document.documentElement.clientWidth-(i.x+this._overlayRect.width)+"px":s.left=cr(i.x),s}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),r=this._scrollables.map(s=>s.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:QH(t,r),isOriginOutsideView:q1(t,r),isOverlayClipped:QH(e,r),isOverlayOutsideView:q1(e,r)}}_subtractOverflows(t,...e){return e.reduce((r,s)=>r-Math.max(s,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,r=this._viewportRuler.getViewportScrollPosition();return{top:r.top+this._viewportMargin,left:r.left+this._viewportMargin,right:r.left+t-this._viewportMargin,bottom:r.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return"x"===e?t.offsetX??this._offsetX:t.offsetY??this._offsetY}_validatePositions(){}_addPanelClasses(t){this._pane&&$v(t).forEach(e=>{""!==e&&-1===this._appliedPanelClasses.indexOf(e)&&(this._appliedPanelClasses.push(e),this._pane.classList.add(e))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(t=>{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof Cn)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,r=t.height||0;return{top:t.y,bottom:t.y+r,left:t.x,right:t.x+e,height:r,width:e}}}function Rc(n,t){for(let e in t)t.hasOwnProperty(e)&&(n[e]=t[e]);return n}function rW(n){if("number"!=typeof n&&null!=n){const[t,e]=n.split(HRe);return e&&"px"!==e?null:parseFloat(t)}return n||null}function sW(n){return{top:Math.floor(n.top),right:Math.floor(n.right),bottom:Math.floor(n.bottom),left:Math.floor(n.left),width:Math.floor(n.width),height:Math.floor(n.height)}}const iW="cdk-global-overlay-wrapper";class jRe{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._alignItems="",this._xPosition="",this._xOffset="",this._width="",this._height="",this._isDisposed=!1}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&&!e.width&&t.updateSize({width:this._width}),this._height&&!e.height&&t.updateSize({height:this._height}),t.hostElement.classList.add(iW),this._isDisposed=!1}top(t=""){return this._bottomOffset="",this._topOffset=t,this._alignItems="flex-start",this}left(t=""){return this._xOffset=t,this._xPosition="left",this}bottom(t=""){return this._topOffset="",this._bottomOffset=t,this._alignItems="flex-end",this}right(t=""){return this._xOffset=t,this._xPosition="right",this}start(t=""){return this._xOffset=t,this._xPosition="start",this}end(t=""){return this._xOffset=t,this._xPosition="end",this}width(t=""){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=""){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=""){return this.left(t),this._xPosition="center",this}centerVertically(t=""){return this.top(t),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,r=this._overlayRef.getConfig(),{width:s,height:i,maxWidth:o,maxHeight:a}=r,l=!("100%"!==s&&"100vw"!==s||o&&"100%"!==o&&"100vw"!==o),c=!("100%"!==i&&"100vh"!==i||a&&"100%"!==a&&"100vh"!==a),u=this._xPosition,d=this._xOffset,h="rtl"===this._overlayRef.getConfig().direction;let f="",p="",m="";l?m="flex-start":"center"===u?(m="center",h?p=d:f=d):h?"left"===u||"end"===u?(m="flex-end",f=d):("right"===u||"start"===u)&&(m="flex-start",p=d):"left"===u||"start"===u?(m="flex-start",f=d):("right"===u||"end"===u)&&(m="flex-end",p=d),t.position=this._cssPosition,t.marginLeft=l?"0":f,t.marginTop=c?"0":this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=l?"0":p,e.justifyContent=m,e.alignItems=c?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,r=e.style;e.classList.remove(iW),r.justifyContent=r.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position="",this._overlayRef=null,this._isDisposed=!0}}let GRe=(()=>{class n{constructor(e,r,s,i){this._viewportRuler=e,this._document=r,this._platform=s,this._overlayContainer=i}global(){return new jRe}flexibleConnectedTo(e){return new WRe(e,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return n.\u0275fac=function(e){return new(e||n)(J(j1),J(Et),J(Li),J(tW))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),qRe=0,xm=(()=>{class n{constructor(e,r,s,i,o,a,l,c,u,d,h,f){this.scrollStrategies=e,this._overlayContainer=r,this._componentFactoryResolver=s,this._positionBuilder=i,this._keyboardDispatcher=o,this._injector=a,this._ngZone=l,this._document=c,this._directionality=u,this._location=d,this._outsideClickDispatcher=h,this._animationsModuleType=f}create(e){const r=this._createHostElement(),s=this._createPaneElement(r),i=this._createPortalOutlet(s),o=new JH(e);return o.direction=o.direction||this._directionality.value,new URe(i,r,s,o,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher,"NoopAnimations"===this._animationsModuleType)}position(){return this._positionBuilder}_createPaneElement(e){const r=this._document.createElement("div");return r.id="cdk-overlay-"+qRe++,r.classList.add("cdk-overlay-pane"),e.appendChild(r),r}_createHostElement(){const e=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(e),e}_createPortalOutlet(e){return this._appRef||(this._appRef=this._injector.get(ku)),new MRe(e,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return n.\u0275fac=function(e){return new(e||n)(J(LRe),J(tW),J(cu),J(GRe),J(BRe),J(os),J(St),J(Et),J(F1),J(Kg),J(zRe),J(Va,8))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const KRe=[{originX:"start",originY:"bottom",overlayX:"start",overlayY:"top"},{originX:"start",originY:"top",overlayX:"start",overlayY:"bottom"},{originX:"end",originY:"top",overlayX:"end",overlayY:"bottom"},{originX:"end",originY:"bottom",overlayX:"end",overlayY:"top"}],oW=new me("cdk-connected-overlay-scroll-strategy");let K1=(()=>{class n{constructor(e){this.elementRef=e}}return n.\u0275fac=function(e){return new(e||n)(K(Cn))},n.\u0275dir=Ve({type:n,selectors:[["","cdk-overlay-origin",""],["","overlay-origin",""],["","cdkOverlayOrigin",""]],exportAs:["cdkOverlayOrigin"]}),n})(),aW=(()=>{class n{constructor(e,r,s,i,o){this._overlay=e,this._dir=o,this._hasBackdrop=!1,this._lockPosition=!1,this._growAfterOpen=!1,this._flexibleDimensions=!1,this._push=!1,this._backdropSubscription=He.EMPTY,this._attachSubscription=He.EMPTY,this._detachSubscription=He.EMPTY,this._positionSubscription=He.EMPTY,this.viewportMargin=0,this.open=!1,this.disableClose=!1,this.backdropClick=new Ft,this.positionChange=new Ft,this.attach=new Ft,this.detach=new Ft,this.overlayKeydown=new Ft,this.overlayOutsideClick=new Ft,this._templatePortal=new XH(r,s),this._scrollStrategyFactory=i,this.scrollStrategy=this._scrollStrategyFactory()}get offsetX(){return this._offsetX}set offsetX(e){this._offsetX=e,this._position&&this._updatePositionStrategy(this._position)}get offsetY(){return this._offsetY}set offsetY(e){this._offsetY=e,this._position&&this._updatePositionStrategy(this._position)}get hasBackdrop(){return this._hasBackdrop}set hasBackdrop(e){this._hasBackdrop=Vi(e)}get lockPosition(){return this._lockPosition}set lockPosition(e){this._lockPosition=Vi(e)}get flexibleDimensions(){return this._flexibleDimensions}set flexibleDimensions(e){this._flexibleDimensions=Vi(e)}get growAfterOpen(){return this._growAfterOpen}set growAfterOpen(e){this._growAfterOpen=Vi(e)}get push(){return this._push}set push(e){this._push=Vi(e)}get overlayRef(){return this._overlayRef}get dir(){return this._dir?this._dir.value:"ltr"}ngOnDestroy(){this._attachSubscription.unsubscribe(),this._detachSubscription.unsubscribe(),this._backdropSubscription.unsubscribe(),this._positionSubscription.unsubscribe(),this._overlayRef&&this._overlayRef.dispose()}ngOnChanges(e){this._position&&(this._updatePositionStrategy(this._position),this._overlayRef.updateSize({width:this.width,minWidth:this.minWidth,height:this.height,minHeight:this.minHeight}),e.origin&&this.open&&this._position.apply()),e.open&&(this.open?this._attachOverlay():this._detachOverlay())}_createOverlay(){(!this.positions||!this.positions.length)&&(this.positions=KRe);const e=this._overlayRef=this._overlay.create(this._buildConfig());this._attachSubscription=e.attachments().subscribe(()=>this.attach.emit()),this._detachSubscription=e.detachments().subscribe(()=>this.detach.emit()),e.keydownEvents().subscribe(r=>{this.overlayKeydown.next(r),27===r.keyCode&&!this.disableClose&&!pm(r)&&(r.preventDefault(),this._detachOverlay())}),this._overlayRef.outsidePointerEvents().subscribe(r=>{this.overlayOutsideClick.next(r)})}_buildConfig(){const e=this._position=this.positionStrategy||this._createPositionStrategy(),r=new JH({direction:this._dir,positionStrategy:e,scrollStrategy:this.scrollStrategy,hasBackdrop:this.hasBackdrop});return(this.width||0===this.width)&&(r.width=this.width),(this.height||0===this.height)&&(r.height=this.height),(this.minWidth||0===this.minWidth)&&(r.minWidth=this.minWidth),(this.minHeight||0===this.minHeight)&&(r.minHeight=this.minHeight),this.backdropClass&&(r.backdropClass=this.backdropClass),this.panelClass&&(r.panelClass=this.panelClass),r}_updatePositionStrategy(e){const r=this.positions.map(s=>({originX:s.originX,originY:s.originY,overlayX:s.overlayX,overlayY:s.overlayY,offsetX:s.offsetX||this.offsetX,offsetY:s.offsetY||this.offsetY,panelClass:s.panelClass||void 0}));return e.setOrigin(this._getFlexibleConnectedPositionStrategyOrigin()).withPositions(r).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector)}_createPositionStrategy(){const e=this._overlay.position().flexibleConnectedTo(this._getFlexibleConnectedPositionStrategyOrigin());return this._updatePositionStrategy(e),e}_getFlexibleConnectedPositionStrategyOrigin(){return this.origin instanceof K1?this.origin.elementRef:this.origin}_attachOverlay(){this._overlayRef?this._overlayRef.getConfig().hasBackdrop=this.hasBackdrop:this._createOverlay(),this._overlayRef.hasAttached()||this._overlayRef.attach(this._templatePortal),this.hasBackdrop?this._backdropSubscription=this._overlayRef.backdropClick().subscribe(e=>{this.backdropClick.emit(e)}):this._backdropSubscription.unsubscribe(),this._positionSubscription.unsubscribe(),this.positionChange.observers.length>0&&(this._positionSubscription=this._position.positionChanges.pipe(o$(()=>this.positionChange.observers.length>0)).subscribe(e=>{this.positionChange.emit(e),0===this.positionChange.observers.length&&this._positionSubscription.unsubscribe()}))}_detachOverlay(){this._overlayRef&&this._overlayRef.detach(),this._backdropSubscription.unsubscribe(),this._positionSubscription.unsubscribe()}}return n.\u0275fac=function(e){return new(e||n)(K(xm),K(Co),K(_i),K(oW),K(F1,8))},n.\u0275dir=Ve({type:n,selectors:[["","cdk-connected-overlay",""],["","connected-overlay",""],["","cdkConnectedOverlay",""]],inputs:{origin:["cdkConnectedOverlayOrigin","origin"],positions:["cdkConnectedOverlayPositions","positions"],positionStrategy:["cdkConnectedOverlayPositionStrategy","positionStrategy"],offsetX:["cdkConnectedOverlayOffsetX","offsetX"],offsetY:["cdkConnectedOverlayOffsetY","offsetY"],width:["cdkConnectedOverlayWidth","width"],height:["cdkConnectedOverlayHeight","height"],minWidth:["cdkConnectedOverlayMinWidth","minWidth"],minHeight:["cdkConnectedOverlayMinHeight","minHeight"],backdropClass:["cdkConnectedOverlayBackdropClass","backdropClass"],panelClass:["cdkConnectedOverlayPanelClass","panelClass"],viewportMargin:["cdkConnectedOverlayViewportMargin","viewportMargin"],scrollStrategy:["cdkConnectedOverlayScrollStrategy","scrollStrategy"],open:["cdkConnectedOverlayOpen","open"],disableClose:["cdkConnectedOverlayDisableClose","disableClose"],transformOriginSelector:["cdkConnectedOverlayTransformOriginOn","transformOriginSelector"],hasBackdrop:["cdkConnectedOverlayHasBackdrop","hasBackdrop"],lockPosition:["cdkConnectedOverlayLockPosition","lockPosition"],flexibleDimensions:["cdkConnectedOverlayFlexibleDimensions","flexibleDimensions"],growAfterOpen:["cdkConnectedOverlayGrowAfterOpen","growAfterOpen"],push:["cdkConnectedOverlayPush","push"]},outputs:{backdropClick:"backdropClick",positionChange:"positionChange",attach:"attach",detach:"detach",overlayKeydown:"overlayKeydown",overlayOutsideClick:"overlayOutsideClick"},exportAs:["cdkConnectedOverlay"],features:[xs]}),n})();const YRe={provide:oW,deps:[xm],useFactory:function XRe(n){return()=>n.scrollStrategies.reposition()}};let lW=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({providers:[xm,YRe],imports:[gm,FRe,KH,KH]}),n})();class cW{}class ZRe{}const Ia="*";function wm(n,t){return{type:7,name:n,definitions:t,options:{}}}function qd(n,t=null){return{type:4,styles:t,timings:n}}function uW(n,t=null){return{type:2,steps:n,options:t}}function Bi(n){return{type:6,styles:n,offset:null}}function qv(n,t,e){return{type:0,name:n,styles:t,options:e}}function Mc(n,t,e=null){return{type:1,expr:n,animation:t,options:e}}function QRe(n=null){return{type:9,options:n}}function JRe(n,t,e=null){return{type:11,selector:n,animation:t,options:e}}function dW(n){Promise.resolve().then(n)}class Cm{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._originalOnDoneFns=[],this._originalOnStartFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){dW(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this._started=!1,this._finished=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class hW{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,r=0,s=0;const i=this.players.length;0==i?dW(()=>this._onFinish()):this.players.forEach(o=>{o.onDone(()=>{++e==i&&this._onFinish()}),o.onDestroy(()=>{++r==i&&this._onDestroy()}),o.onStart(()=>{++s==i&&this._onStart()})}),this.totalTime=this.players.reduce((o,a)=>Math.max(o,a.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(r=>{const s=r.totalTime?Math.min(1,e/r.totalTime):1;r.setPosition(s)})}getPosition(){const t=this.players.reduce((e,r)=>null===e||r.totalTime>e.totalTime?r:e,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}let eMe=(()=>{class n{create(e){return typeof MutationObserver>"u"?null:new MutationObserver(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),tMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({providers:[eMe]}),n})(),lMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=Ve({type:n}),n})();const cMe=new me("MatFormField");let uMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({imports:[ys,Ru,tMe,ys]}),n})();class dMe{constructor(t=!1,e,r=!0,s){this._multiple=t,this._emitChanges=r,this.compareWith=s,this._selection=new Set,this._deselectedToEmit=[],this._selectedToEmit=[],this.changed=new Wt,e&&e.length&&(t?e.forEach(i=>this._markSelected(i)):this._markSelected(e[0]),this._selectedToEmit.length=0)}get selected(){return this._selected||(this._selected=Array.from(this._selection.values())),this._selected}select(...t){this._verifyValueAssignment(t),t.forEach(r=>this._markSelected(r));const e=this._hasQueuedChanges();return this._emitChangeEvent(),e}deselect(...t){this._verifyValueAssignment(t),t.forEach(r=>this._unmarkSelected(r));const e=this._hasQueuedChanges();return this._emitChangeEvent(),e}setSelection(...t){this._verifyValueAssignment(t);const e=this.selected,r=new Set(t);t.forEach(i=>this._markSelected(i)),e.filter(i=>!r.has(i)).forEach(i=>this._unmarkSelected(i));const s=this._hasQueuedChanges();return this._emitChangeEvent(),s}toggle(t){return this.isSelected(t)?this.deselect(t):this.select(t)}clear(t=!0){this._unmarkAll();const e=this._hasQueuedChanges();return t&&this._emitChangeEvent(),e}isSelected(t){if(this.compareWith){for(const e of this._selection)if(this.compareWith(e,t))return!0;return!1}return this._selection.has(t)}isEmpty(){return 0===this._selection.size}hasValue(){return!this.isEmpty()}sort(t){this._multiple&&this.selected&&this._selected.sort(t)}isMultipleSelection(){return this._multiple}_emitChangeEvent(){this._selected=null,(this._selectedToEmit.length||this._deselectedToEmit.length)&&(this.changed.next({source:this,added:this._selectedToEmit,removed:this._deselectedToEmit}),this._deselectedToEmit=[],this._selectedToEmit=[])}_markSelected(t){this.isSelected(t)||(this._multiple||this._unmarkAll(),this.isSelected(t)||this._selection.add(t),this._emitChanges&&this._selectedToEmit.push(t))}_unmarkSelected(t){this.isSelected(t)&&(this._selection.delete(t),this._emitChanges&&this._deselectedToEmit.push(t))}_unmarkAll(){this.isEmpty()||this._selection.forEach(t=>this._unmarkSelected(t))}_verifyValueAssignment(t){}_hasQueuedChanges(){return!(!this._deselectedToEmit.length&&!this._selectedToEmit.length)}}let fW=(()=>{class n{constructor(e,r){this._renderer=e,this._elementRef=r,this.onChange=s=>{},this.onTouched=()=>{}}setProperty(e,r){this._renderer.setProperty(this._elementRef.nativeElement,e,r)}registerOnTouched(e){this.onTouched=e}registerOnChange(e){this.onChange=e}setDisabledState(e){this.setProperty("disabled",e)}}return n.\u0275fac=function(e){return new(e||n)(K(Jo),K(Cn))},n.\u0275dir=Ve({type:n}),n})(),Fc=(()=>{class n extends fW{}return n.\u0275fac=function(){let t;return function(r){return(t||(t=Dr(n)))(r||n)}}(),n.\u0275dir=Ve({type:n,features:[bt]}),n})();const Ho=new me("NgValueAccessor"),fMe={provide:Ho,useExisting:cn(()=>Y1),multi:!0},mMe=new me("CompositionEventMode");let Y1=(()=>{class n extends fW{constructor(e,r,s){super(e,r),this._compositionMode=s,this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function pMe(){const n=Eo()?Eo().getUserAgent():"";return/android (\d+)/.test(n.toLowerCase())}())}writeValue(e){this.setProperty("value",e??"")}_handleInput(e){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(e)}_compositionStart(){this._composing=!0}_compositionEnd(e){this._composing=!1,this._compositionMode&&this.onChange(e)}}return n.\u0275fac=function(e){return new(e||n)(K(Jo),K(Cn),K(mMe,8))},n.\u0275dir=Ve({type:n,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(e,r){1&e&&Gn("input",function(i){return r._handleInput(i.target.value)})("blur",function(){return r.onTouched()})("compositionstart",function(){return r._compositionStart()})("compositionend",function(i){return r._compositionEnd(i.target.value)})},features:[gn([fMe]),bt]}),n})();function El(n){return null==n||("string"==typeof n||Array.isArray(n))&&0===n.length}function mW(n){return null!=n&&"number"==typeof n.length}const ts=new me("NgValidators"),Il=new me("NgAsyncValidators"),yMe=/^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;class bMe{static min(t){return function gW(n){return t=>{if(El(t.value)||El(n))return null;const e=parseFloat(t.value);return!isNaN(e)&&e<n?{min:{min:n,actual:t.value}}:null}}(t)}static max(t){return function yW(n){return t=>{if(El(t.value)||El(n))return null;const e=parseFloat(t.value);return!isNaN(e)&&e>n?{max:{max:n,actual:t.value}}:null}}(t)}static required(t){return function bW(n){return El(n.value)?{required:!0}:null}(t)}static requiredTrue(t){return function _W(n){return!0===n.value?null:{required:!0}}(t)}static email(t){return function vW(n){return El(n.value)||yMe.test(n.value)?null:{email:!0}}(t)}static minLength(t){return function xW(n){return t=>El(t.value)||!mW(t.value)?null:t.value.length<n?{minlength:{requiredLength:n,actualLength:t.value.length}}:null}(t)}static maxLength(t){return function wW(n){return t=>mW(t.value)&&t.value.length>n?{maxlength:{requiredLength:n,actualLength:t.value.length}}:null}(t)}static pattern(t){return function CW(n){if(!n)return Kv;let t,e;return"string"==typeof n?(e="","^"!==n.charAt(0)&&(e+="^"),e+=n,"$"!==n.charAt(n.length-1)&&(e+="$"),t=new RegExp(e)):(e=n.toString(),t=n),r=>{if(El(r.value))return null;const s=r.value;return t.test(s)?null:{pattern:{requiredPattern:e,actualValue:s}}}}(t)}static nullValidator(t){return null}static compose(t){return kW(t)}static composeAsync(t){return NW(t)}}function Kv(n){return null}function SW(n){return null!=n}function EW(n){return Fh(n)?$n(n):n}function IW(n){let t={};return n.forEach(e=>{t=null!=e?{...t,...e}:t}),0===Object.keys(t).length?null:t}function DW(n,t){return t.map(e=>e(n))}function TW(n){return n.map(t=>function _Me(n){return!n.validate}(t)?t:e=>t.validate(e))}function kW(n){if(!n)return null;const t=n.filter(SW);return 0==t.length?null:function(e){return IW(DW(e,t))}}function Z1(n){return null!=n?kW(TW(n)):null}function NW(n){if(!n)return null;const t=n.filter(SW);return 0==t.length?null:function(e){return SH(DW(e,t).map(EW)).pipe(ze(IW))}}function Q1(n){return null!=n?NW(TW(n)):null}function AW(n,t){return null===n?[t]:Array.isArray(n)?[...n,t]:[n,t]}function RW(n){return n._rawValidators}function MW(n){return n._rawAsyncValidators}function J1(n){return n?Array.isArray(n)?n:[n]:[]}function Xv(n,t){return Array.isArray(n)?n.includes(t):n===t}function FW(n,t){const e=J1(t);return J1(n).forEach(s=>{Xv(e,s)||e.push(s)}),e}function OW(n,t){return J1(t).filter(e=>!Xv(n,e))}class $W{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(t){this._rawValidators=t||[],this._composedValidatorFn=Z1(this._rawValidators)}_setAsyncValidators(t){this._rawAsyncValidators=t||[],this._composedAsyncValidatorFn=Q1(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(t){this._onDestroyCallbacks.push(t)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(t=>t()),this._onDestroyCallbacks=[]}reset(t){this.control&&this.control.reset(t)}hasError(t,e){return!!this.control&&this.control.hasError(t,e)}getError(t,e){return this.control?this.control.getError(t,e):null}}class bs extends $W{get formDirective(){return null}get path(){return null}}class Da extends $W{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}class PW{constructor(t){this._cd=t}get isTouched(){return!!this._cd?.control?.touched}get isUntouched(){return!!this._cd?.control?.untouched}get isPristine(){return!!this._cd?.control?.pristine}get isDirty(){return!!this._cd?.control?.dirty}get isValid(){return!!this._cd?.control?.valid}get isInvalid(){return!!this._cd?.control?.invalid}get isPending(){return!!this._cd?.control?.pending}get isSubmitted(){return!!this._cd?.submitted}}let LW=(()=>{class n extends PW{constructor(e){super(e)}}return n.\u0275fac=function(e){return new(e||n)(K(Da,2))},n.\u0275dir=Ve({type:n,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(e,r){2&e&&Gs("ng-untouched",r.isUntouched)("ng-touched",r.isTouched)("ng-pristine",r.isPristine)("ng-dirty",r.isDirty)("ng-valid",r.isValid)("ng-invalid",r.isInvalid)("ng-pending",r.isPending)},features:[bt]}),n})();const Sm="VALID",Zv="INVALID",Kd="PENDING",Em="DISABLED";function rk(n){return(Qv(n)?n.validators:n)||null}function sk(n,t){return(Qv(t)?t.asyncValidators:n)||null}function Qv(n){return null!=n&&!Array.isArray(n)&&"object"==typeof n}class UW{constructor(t,e){this._pendingDirty=!1,this._hasOwnPendingAsyncValidator=!1,this._pendingTouched=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._assignValidators(t),this._assignAsyncValidators(e)}get validator(){return this._composedValidatorFn}set validator(t){this._rawValidators=this._composedValidatorFn=t}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(t){this._rawAsyncValidators=this._composedAsyncValidatorFn=t}get parent(){return this._parent}get valid(){return this.status===Sm}get invalid(){return this.status===Zv}get pending(){return this.status==Kd}get disabled(){return this.status===Em}get enabled(){return this.status!==Em}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(t){this._assignValidators(t)}setAsyncValidators(t){this._assignAsyncValidators(t)}addValidators(t){this.setValidators(FW(t,this._rawValidators))}addAsyncValidators(t){this.setAsyncValidators(FW(t,this._rawAsyncValidators))}removeValidators(t){this.setValidators(OW(t,this._rawValidators))}removeAsyncValidators(t){this.setAsyncValidators(OW(t,this._rawAsyncValidators))}hasValidator(t){return Xv(this._rawValidators,t)}hasAsyncValidator(t){return Xv(this._rawAsyncValidators,t)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(t={}){this.touched=!0,this._parent&&!t.onlySelf&&this._parent.markAsTouched(t)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(t=>t.markAllAsTouched())}markAsUntouched(t={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(e=>{e.markAsUntouched({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}markAsDirty(t={}){this.pristine=!1,this._parent&&!t.onlySelf&&this._parent.markAsDirty(t)}markAsPristine(t={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(e=>{e.markAsPristine({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}markAsPending(t={}){this.status=Kd,!1!==t.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!t.onlySelf&&this._parent.markAsPending(t)}disable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=Em,this.errors=null,this._forEachChild(r=>{r.disable({...t,onlySelf:!0})}),this._updateValue(),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors({...t,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!0))}enable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=Sm,this._forEachChild(r=>{r.enable({...t,onlySelf:!0})}),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent}),this._updateAncestors({...t,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!1))}_updateAncestors(t){this._parent&&!t.onlySelf&&(this._parent.updateValueAndValidity(t),t.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(t){this._parent=t}getRawValue(){return this.value}updateValueAndValidity(t={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),(this.status===Sm||this.status===Kd)&&this._runAsyncValidator(t.emitEvent)),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!t.onlySelf&&this._parent.updateValueAndValidity(t)}_updateTreeValidity(t={emitEvent:!0}){this._forEachChild(e=>e._updateTreeValidity(t)),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?Em:Sm}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(t){if(this.asyncValidator){this.status=Kd,this._hasOwnPendingAsyncValidator=!0;const e=EW(this.asyncValidator(this));this._asyncValidationSubscription=e.subscribe(r=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(r,{emitEvent:t})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(t,e={}){this.errors=t,this._updateControlsErrors(!1!==e.emitEvent)}get(t){let e=t;return null==e||(Array.isArray(e)||(e=e.split(".")),0===e.length)?null:e.reduce((r,s)=>r&&r._find(s),this)}getError(t,e){const r=e?this.get(e):this;return r&&r.errors?r.errors[t]:null}hasError(t,e){return!!this.getError(t,e)}get root(){let t=this;for(;t._parent;)t=t._parent;return t}_updateControlsErrors(t){this.status=this._calculateStatus(),t&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(t)}_initObservables(){this.valueChanges=new Ft,this.statusChanges=new Ft}_calculateStatus(){return this._allControlsDisabled()?Em:this.errors?Zv:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(Kd)?Kd:this._anyControlsHaveStatus(Zv)?Zv:Sm}_anyControlsHaveStatus(t){return this._anyControls(e=>e.status===t)}_anyControlsDirty(){return this._anyControls(t=>t.dirty)}_anyControlsTouched(){return this._anyControls(t=>t.touched)}_updatePristine(t={}){this.pristine=!this._anyControlsDirty(),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}_updateTouched(t={}){this.touched=this._anyControlsTouched(),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}_registerOnCollectionChange(t){this._onCollectionChange=t}_setUpdateStrategy(t){Qv(t)&&null!=t.updateOn&&(this._updateOn=t.updateOn)}_parentMarkedDirty(t){return!t&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}_find(t){return null}_assignValidators(t){this._rawValidators=Array.isArray(t)?t.slice():t,this._composedValidatorFn=function DMe(n){return Array.isArray(n)?Z1(n):n||null}(this._rawValidators)}_assignAsyncValidators(t){this._rawAsyncValidators=Array.isArray(t)?t.slice():t,this._composedAsyncValidatorFn=function TMe(n){return Array.isArray(n)?Q1(n):n||null}(this._rawAsyncValidators)}}class ik extends UW{constructor(t,e,r){super(rk(e),sk(r,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}registerControl(t,e){return this.controls[t]?this.controls[t]:(this.controls[t]=e,e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange),e)}addControl(t,e,r={}){this.registerControl(t,e),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}removeControl(t,e={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],this.updateValueAndValidity({emitEvent:e.emitEvent}),this._onCollectionChange()}setControl(t,e,r={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],e&&this.registerControl(t,e),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}contains(t){return this.controls.hasOwnProperty(t)&&this.controls[t].enabled}setValue(t,e={}){(function zW(n,t,e){n._forEachChild((r,s)=>{if(void 0===e[s])throw new te(1002,"")})})(this,0,t),Object.keys(t).forEach(r=>{(function BW(n,t,e){const r=n.controls;if(!(t?Object.keys(r):r).length)throw new te(1e3,"");if(!r[e])throw new te(1001,"")})(this,!0,r),this.controls[r].setValue(t[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){null!=t&&(Object.keys(t).forEach(r=>{const s=this.controls[r];s&&s.patchValue(t[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(t={},e={}){this._forEachChild((r,s)=>{r.reset(t[s],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this._reduceChildren({},(t,e,r)=>(t[r]=e.getRawValue(),t))}_syncPendingControls(){let t=this._reduceChildren(!1,(e,r)=>!!r._syncPendingControls()||e);return t&&this.updateValueAndValidity({onlySelf:!0}),t}_forEachChild(t){Object.keys(this.controls).forEach(e=>{const r=this.controls[e];r&&t(r,e)})}_setUpControls(){this._forEachChild(t=>{t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(t){for(const[e,r]of Object.entries(this.controls))if(this.contains(e)&&t(r))return!0;return!1}_reduceValue(){return this._reduceChildren({},(e,r,s)=>((r.enabled||this.disabled)&&(e[s]=r.value),e))}_reduceChildren(t,e){let r=t;return this._forEachChild((s,i)=>{r=e(r,s,i)}),r}_allControlsDisabled(){for(const t of Object.keys(this.controls))if(this.controls[t].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_find(t){return this.controls.hasOwnProperty(t)?this.controls[t]:null}}const Xd=new me("CallSetDisabledState",{providedIn:"root",factory:()=>Jv}),Jv="always";function Im(n,t,e=Jv){ok(n,t),t.valueAccessor.writeValue(n.value),(n.disabled||"always"===e)&&t.valueAccessor.setDisabledState?.(n.disabled),function AMe(n,t){t.valueAccessor.registerOnChange(e=>{n._pendingValue=e,n._pendingChange=!0,n._pendingDirty=!0,"change"===n.updateOn&&HW(n,t)})}(n,t),function MMe(n,t){const e=(r,s)=>{t.valueAccessor.writeValue(r),s&&t.viewToModelUpdate(r)};n.registerOnChange(e),t._registerOnDestroy(()=>{n._unregisterOnChange(e)})}(n,t),function RMe(n,t){t.valueAccessor.registerOnTouched(()=>{n._pendingTouched=!0,"blur"===n.updateOn&&n._pendingChange&&HW(n,t),"submit"!==n.updateOn&&n.markAsTouched()})}(n,t),function NMe(n,t){if(t.valueAccessor.setDisabledState){const e=r=>{t.valueAccessor.setDisabledState(r)};n.registerOnDisabledChange(e),t._registerOnDestroy(()=>{n._unregisterOnDisabledChange(e)})}}(n,t)}function tx(n,t,e=!0){const r=()=>{};t.valueAccessor&&(t.valueAccessor.registerOnChange(r),t.valueAccessor.registerOnTouched(r)),rx(n,t),n&&(t._invokeOnDestroyCallbacks(),n._registerOnCollectionChange(()=>{}))}function nx(n,t){n.forEach(e=>{e.registerOnValidatorChange&&e.registerOnValidatorChange(t)})}function ok(n,t){const e=RW(n);null!==t.validator?n.setValidators(AW(e,t.validator)):"function"==typeof e&&n.setValidators([e]);const r=MW(n);null!==t.asyncValidator?n.setAsyncValidators(AW(r,t.asyncValidator)):"function"==typeof r&&n.setAsyncValidators([r]);const s=()=>n.updateValueAndValidity();nx(t._rawValidators,s),nx(t._rawAsyncValidators,s)}function rx(n,t){let e=!1;if(null!==n){if(null!==t.validator){const s=RW(n);if(Array.isArray(s)&&s.length>0){const i=s.filter(o=>o!==t.validator);i.length!==s.length&&(e=!0,n.setValidators(i))}}if(null!==t.asyncValidator){const s=MW(n);if(Array.isArray(s)&&s.length>0){const i=s.filter(o=>o!==t.asyncValidator);i.length!==s.length&&(e=!0,n.setAsyncValidators(i))}}}const r=()=>{};return nx(t._rawValidators,r),nx(t._rawAsyncValidators,r),e}function HW(n,t){n._pendingDirty&&n.markAsDirty(),n.setValue(n._pendingValue,{emitModelToViewChange:!1}),t.viewToModelUpdate(n._pendingValue),n._pendingChange=!1}function WW(n,t){ok(n,t)}function jW(n,t){n._syncPendingControls(),t.forEach(e=>{const r=e.control;"submit"===r.updateOn&&r._pendingChange&&(e.viewToModelUpdate(r._pendingValue),r._pendingChange=!1)})}const LMe={provide:bs,useExisting:cn(()=>sx)},Dm=(()=>Promise.resolve())();let sx=(()=>{class n extends bs{constructor(e,r,s){super(),this.callSetDisabledState=s,this.submitted=!1,this._directives=new Set,this.ngSubmit=new Ft,this.form=new ik({},Z1(e),Q1(r))}ngAfterViewInit(){this._setUpdateStrategy()}get formDirective(){return this}get control(){return this.form}get path(){return[]}get controls(){return this.form.controls}addControl(e){Dm.then(()=>{const r=this._findContainer(e.path);e.control=r.registerControl(e.name,e.control),Im(e.control,e,this.callSetDisabledState),e.control.updateValueAndValidity({emitEvent:!1}),this._directives.add(e)})}getControl(e){return this.form.get(e.path)}removeControl(e){Dm.then(()=>{const r=this._findContainer(e.path);r&&r.removeControl(e.name),this._directives.delete(e)})}addFormGroup(e){Dm.then(()=>{const r=this._findContainer(e.path),s=new ik({});WW(s,e),r.registerControl(e.name,s),s.updateValueAndValidity({emitEvent:!1})})}removeFormGroup(e){Dm.then(()=>{const r=this._findContainer(e.path);r&&r.removeControl(e.name)})}getFormGroup(e){return this.form.get(e.path)}updateModel(e,r){Dm.then(()=>{this.form.get(e.path).setValue(r)})}setValue(e){this.control.setValue(e)}onSubmit(e){return this.submitted=!0,jW(this.form,this._directives),this.ngSubmit.emit(e),"dialog"===e?.target?.method}onReset(){this.resetForm()}resetForm(e){this.form.reset(e),this.submitted=!1}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.form._updateOn=this.options.updateOn)}_findContainer(e){return e.pop(),e.length?this.form.get(e):this.form}}return n.\u0275fac=function(e){return new(e||n)(K(ts,10),K(Il,10),K(Xd,8))},n.\u0275dir=Ve({type:n,selectors:[["form",3,"ngNoForm","",3,"formGroup",""],["ng-form"],["","ngForm",""]],hostBindings:function(e,r){1&e&&Gn("submit",function(i){return r.onSubmit(i)})("reset",function(){return r.onReset()})},inputs:{options:["ngFormOptions","options"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[gn([LMe]),bt]}),n})();function GW(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}function qW(n){return"object"==typeof n&&null!==n&&2===Object.keys(n).length&&"value"in n&&"disabled"in n}const KW=class extends UW{constructor(t=null,e,r){super(rk(e),sk(r,e)),this.defaultValue=null,this._onChange=[],this._pendingChange=!1,this._applyFormState(t),this._setUpdateStrategy(e),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator}),Qv(e)&&(e.nonNullable||e.initialValueIsDefault)&&(this.defaultValue=qW(t)?t.value:t)}setValue(t,e={}){this.value=this._pendingValue=t,this._onChange.length&&!1!==e.emitModelToViewChange&&this._onChange.forEach(r=>r(this.value,!1!==e.emitViewToModelChange)),this.updateValueAndValidity(e)}patchValue(t,e={}){this.setValue(t,e)}reset(t=this.defaultValue,e={}){this._applyFormState(t),this.markAsPristine(e),this.markAsUntouched(e),this.setValue(this.value,e),this._pendingChange=!1}_updateValue(){}_anyControls(t){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(t){this._onChange.push(t)}_unregisterOnChange(t){GW(this._onChange,t)}registerOnDisabledChange(t){this._onDisabledChange.push(t)}_unregisterOnDisabledChange(t){GW(this._onDisabledChange,t)}_forEachChild(t){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(t){qW(t)?(this.value=this._pendingValue=t.value,t.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=t}},zMe={provide:Da,useExisting:cn(()=>uk)},ZW=(()=>Promise.resolve())();let uk=(()=>{class n extends Da{constructor(e,r,s,i,o,a){super(),this._changeDetectorRef=o,this.callSetDisabledState=a,this.control=new KW,this._registered=!1,this.update=new Ft,this._parent=e,this._setValidators(r),this._setAsyncValidators(s),this.valueAccessor=function ck(n,t){if(!t)return null;let e,r,s;return Array.isArray(t),t.forEach(i=>{i.constructor===Y1?e=i:function $Me(n){return Object.getPrototypeOf(n.constructor)===Fc}(i)?r=i:s=i}),s||r||e||null}(0,i)}ngOnChanges(e){if(this._checkForErrors(),!this._registered||"name"in e){if(this._registered&&(this._checkName(),this.formDirective)){const r=e.name.previousValue;this.formDirective.removeControl({name:r,path:this._getPath(r)})}this._setUpControl()}"isDisabled"in e&&this._updateDisabled(e),function lk(n,t){if(!n.hasOwnProperty("model"))return!1;const e=n.model;return!!e.isFirstChange()||!Object.is(t,e.currentValue)}(e,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._getPath(this.name)}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){Im(this.control,this,this.callSetDisabledState),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()}_updateValue(e){ZW.then(()=>{this.control.setValue(e,{emitViewToModelChange:!1}),this._changeDetectorRef?.markForCheck()})}_updateDisabled(e){const r=e.isDisabled.currentValue,s=0!==r&&function Au(n){return"boolean"==typeof n?n:null!=n&&"false"!==n}(r);ZW.then(()=>{s&&!this.control.disabled?this.control.disable():!s&&this.control.disabled&&this.control.enable(),this._changeDetectorRef?.markForCheck()})}_getPath(e){return this._parent?function ex(n,t){return[...t.path,n]}(e,this._parent):[e]}}return n.\u0275fac=function(e){return new(e||n)(K(bs,9),K(ts,10),K(Il,10),K(Ho,10),K(Nu,8),K(Xd,8))},n.\u0275dir=Ve({type:n,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:["disabled","isDisabled"],model:["ngModel","model"],options:["ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],features:[gn([zMe]),bt,xs]}),n})(),JW=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({}),n})();const dk=new me("NgModelWithFormControlWarning"),KMe={provide:bs,useExisting:cn(()=>ix)};let ix=(()=>{class n extends bs{constructor(e,r,s){super(),this.callSetDisabledState=s,this.submitted=!1,this._onCollectionChange=()=>this._updateDomValue(),this.directives=[],this.form=null,this.ngSubmit=new Ft,this._setValidators(e),this._setAsyncValidators(r)}ngOnChanges(e){this._checkFormPresent(),e.hasOwnProperty("form")&&(this._updateValidators(),this._updateDomValue(),this._updateRegistrations(),this._oldForm=this.form)}ngOnDestroy(){this.form&&(rx(this.form,this),this.form._onCollectionChange===this._onCollectionChange&&this.form._registerOnCollectionChange(()=>{}))}get formDirective(){return this}get control(){return this.form}get path(){return[]}addControl(e){const r=this.form.get(e.path);return Im(r,e,this.callSetDisabledState),r.updateValueAndValidity({emitEvent:!1}),this.directives.push(e),r}getControl(e){return this.form.get(e.path)}removeControl(e){tx(e.control||null,e,!1),function PMe(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}(this.directives,e)}addFormGroup(e){this._setUpFormContainer(e)}removeFormGroup(e){this._cleanUpFormContainer(e)}getFormGroup(e){return this.form.get(e.path)}addFormArray(e){this._setUpFormContainer(e)}removeFormArray(e){this._cleanUpFormContainer(e)}getFormArray(e){return this.form.get(e.path)}updateModel(e,r){this.form.get(e.path).setValue(r)}onSubmit(e){return this.submitted=!0,jW(this.form,this.directives),this.ngSubmit.emit(e),"dialog"===e?.target?.method}onReset(){this.resetForm()}resetForm(e){this.form.reset(e),this.submitted=!1}_updateDomValue(){this.directives.forEach(e=>{const r=e.control,s=this.form.get(e.path);r!==s&&(tx(r||null,e),(n=>n instanceof KW)(s)&&(Im(s,e,this.callSetDisabledState),e.control=s))}),this.form._updateTreeValidity({emitEvent:!1})}_setUpFormContainer(e){const r=this.form.get(e.path);WW(r,e),r.updateValueAndValidity({emitEvent:!1})}_cleanUpFormContainer(e){if(this.form){const r=this.form.get(e.path);r&&function FMe(n,t){return rx(n,t)}(r,e)&&r.updateValueAndValidity({emitEvent:!1})}}_updateRegistrations(){this.form._registerOnCollectionChange(this._onCollectionChange),this._oldForm&&this._oldForm._registerOnCollectionChange(()=>{})}_updateValidators(){ok(this.form,this),this._oldForm&&rx(this._oldForm,this)}_checkFormPresent(){}}return n.\u0275fac=function(e){return new(e||n)(K(ts,10),K(Il,10),K(Xd,8))},n.\u0275dir=Ve({type:n,selectors:[["","formGroup",""]],hostBindings:function(e,r){1&e&&Gn("submit",function(i){return r.onSubmit(i)})("reset",function(){return r.onReset()})},inputs:{form:["formGroup","form"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[gn([KMe]),bt,xs]}),n})(),gj=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({imports:[JW]}),n})(),hFe=(()=>{class n{static withConfig(e){return{ngModule:n,providers:[{provide:Xd,useValue:e.callSetDisabledState??Jv}]}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({imports:[gj]}),n})(),fFe=(()=>{class n{static withConfig(e){return{ngModule:n,providers:[{provide:dk,useValue:e.warnOnNgModelWithFormControl??"always"},{provide:Xd,useValue:e.callSetDisabledState??Jv}]}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({imports:[gj]}),n})();const mFe=["trigger"],gFe=["panel"];function yFe(n,t){if(1&n&&(Xt(0,"span",10),Xl(1),Nn()),2&n){const e=Yi();en(1),Ph(e.placeholder)}}function bFe(n,t){if(1&n&&(Xt(0,"span",14),Xl(1),Nn()),2&n){const e=Yi(2);en(1),Ph(e.triggerValue)}}function _Fe(n,t){1&n&&sa(0,0,["*ngSwitchCase","true"])}function vFe(n,t){1&n&&(Xt(0,"span",11),bi(1,bFe,2,1,"span",12),bi(2,_Fe,1,0,"ng-content",13),Nn()),2&n&&(tn("ngSwitch",!!Yi().customTrigger),en(2),tn("ngSwitchCase",!0))}function xFe(n,t){if(1&n){const e=kg();dh(),a0(),Xt(0,"div",15,16),Gn("@transformPanel.done",function(s){return lh(e),ch(Yi()._panelDoneAnimatingStream.next(s.toState))})("keydown",function(s){return lh(e),ch(Yi()._handleKeydown(s))}),sa(2,1),Nn()}if(2&n){const e=Yi();XM("mat-mdc-select-panel mdc-menu-surface mdc-menu-surface--open ",e._getPanelTheme(),""),tn("ngClass",e.panelClass)("@transformPanel","showing"),kn("id",e.id+"-panel")("aria-multiselectable",e.multiple)("aria-label",e.ariaLabel||null)("aria-labelledby",e._getPanelAriaLabelledby())}}const wFe=[[["mat-select-trigger"]],"*"],CFe=["mat-select-trigger","*"],SFe={transformPanelWrap:wm("transformPanelWrap",[Mc("* => void",JRe("@transformPanel",[QRe()],{optional:!0}))]),transformPanel:wm("transformPanel",[qv("void",Bi({opacity:0,transform:"scale(1, 0.8)"})),Mc("void => showing",qd("120ms cubic-bezier(0, 0, 0.2, 1)",Bi({opacity:1,transform:"scale(1, 1)"}))),Mc("* => void",qd("100ms linear",Bi({opacity:0})))])};let yj=0;const bj=new me("mat-select-scroll-strategy"),IFe=new me("MAT_SELECT_CONFIG"),DFe={provide:bj,deps:[xm],useFactory:function EFe(n){return()=>n.scrollStrategies.reposition()}},TFe=new me("MatSelectTrigger");class kFe{constructor(t,e){this.source=t,this.value=e}}const NFe=mH(qNe(pH(KNe(class{constructor(n,t,e,r,s){this._elementRef=n,this._defaultErrorStateMatcher=t,this._parentForm=e,this._parentFormGroup=r,this.ngControl=s,this.stateChanges=new Wt}}))));let AFe=(()=>{class n extends NFe{constructor(e,r,s,i,o,a,l,c,u,d,h,f,p,m){super(o,i,l,c,d),this._viewportRuler=e,this._changeDetectorRef=r,this._ngZone=s,this._dir=a,this._parentFormField=u,this._liveAnnouncer=p,this._defaultOptions=m,this._panelOpen=!1,this._compareWith=(g,y)=>g===y,this._uid="mat-select-"+yj++,this._triggerAriaLabelledBy=null,this._destroy=new Wt,this._onChange=()=>{},this._onTouched=()=>{},this._valueId="mat-select-value-"+yj++,this._panelDoneAnimatingStream=new Wt,this._overlayPanelClass=this._defaultOptions?.overlayPanelClass||"",this._focused=!1,this.controlType="mat-select",this._multiple=!1,this._disableOptionCentering=this._defaultOptions?.disableOptionCentering??!1,this.ariaLabel="",this.optionSelectionChanges=fy(()=>{const g=this.options;return g?g.changes.pipe(py(g),Xs(()=>Jd(...g.map(y=>y.onSelectionChange)))):this._ngZone.onStable.pipe(no(1),Xs(()=>this.optionSelectionChanges))}),this.openedChange=new Ft,this._openedStream=this.openedChange.pipe(Ss(g=>g),ze(()=>{})),this._closedStream=this.openedChange.pipe(Ss(g=>!g),ze(()=>{})),this.selectionChange=new Ft,this.valueChange=new Ft,this.ngControl&&(this.ngControl.valueAccessor=this),null!=m?.typeaheadDebounceInterval&&(this._typeaheadDebounceInterval=m.typeaheadDebounceInterval),this._scrollStrategyFactory=f,this._scrollStrategy=this._scrollStrategyFactory(),this.tabIndex=parseInt(h)||0,this.id=this.id}get focused(){return this._focused||this._panelOpen}get placeholder(){return this._placeholder}set placeholder(e){this._placeholder=e,this.stateChanges.next()}get required(){return this._required??this.ngControl?.control?.hasValidator(bMe.required)??!1}set required(e){this._required=Vi(e),this.stateChanges.next()}get multiple(){return this._multiple}set multiple(e){this._multiple=Vi(e)}get disableOptionCentering(){return this._disableOptionCentering}set disableOptionCentering(e){this._disableOptionCentering=Vi(e)}get compareWith(){return this._compareWith}set compareWith(e){this._compareWith=e,this._selectionModel&&this._initializeSelection()}get value(){return this._value}set value(e){this._assignValue(e)&&this._onChange(e)}get typeaheadDebounceInterval(){return this._typeaheadDebounceInterval}set typeaheadDebounceInterval(e){this._typeaheadDebounceInterval=mm(e)}get id(){return this._id}set id(e){this._id=e||this._uid,this.stateChanges.next()}ngOnInit(){this._selectionModel=new dMe(this.multiple),this.stateChanges.next(),this._panelDoneAnimatingStream.pipe(tH(),Ea(this._destroy)).subscribe(()=>this._panelDoneAnimating(this.panelOpen))}ngAfterContentInit(){this._initKeyManager(),this._selectionModel.changed.pipe(Ea(this._destroy)).subscribe(e=>{e.added.forEach(r=>r.select()),e.removed.forEach(r=>r.deselect())}),this.options.changes.pipe(py(null),Ea(this._destroy)).subscribe(()=>{this._resetOptions(),this._initializeSelection()})}ngDoCheck(){const e=this._getTriggerAriaLabelledby(),r=this.ngControl;if(e!==this._triggerAriaLabelledBy){const s=this._elementRef.nativeElement;this._triggerAriaLabelledBy=e,e?s.setAttribute("aria-labelledby",e):s.removeAttribute("aria-labelledby")}r&&(this._previousControl!==r.control&&(void 0!==this._previousControl&&null!==r.disabled&&r.disabled!==this.disabled&&(this.disabled=r.disabled),this._previousControl=r.control),this.updateErrorState())}ngOnChanges(e){(e.disabled||e.userAriaDescribedBy)&&this.stateChanges.next(),e.typeaheadDebounceInterval&&this._keyManager&&this._keyManager.withTypeAhead(this._typeaheadDebounceInterval)}ngOnDestroy(){this._keyManager?.destroy(),this._destroy.next(),this._destroy.complete(),this.stateChanges.complete()}toggle(){this.panelOpen?this.close():this.open()}open(){this._canOpen()&&(this._panelOpen=!0,this._keyManager.withHorizontalOrientation(null),this._highlightCorrectOption(),this._changeDetectorRef.markForCheck())}close(){this._panelOpen&&(this._panelOpen=!1,this._keyManager.withHorizontalOrientation(this._isRtl()?"rtl":"ltr"),this._changeDetectorRef.markForCheck(),this._onTouched())}writeValue(e){this._assignValue(e)}registerOnChange(e){this._onChange=e}registerOnTouched(e){this._onTouched=e}setDisabledState(e){this.disabled=e,this._changeDetectorRef.markForCheck(),this.stateChanges.next()}get panelOpen(){return this._panelOpen}get selected(){return this.multiple?this._selectionModel?.selected||[]:this._selectionModel?.selected[0]}get triggerValue(){if(this.empty)return"";if(this._multiple){const e=this._selectionModel.selected.map(r=>r.viewValue);return this._isRtl()&&e.reverse(),e.join(", ")}return this._selectionModel.selected[0].viewValue}_isRtl(){return!!this._dir&&"rtl"===this._dir.value}_handleKeydown(e){this.disabled||(this.panelOpen?this._handleOpenKeydown(e):this._handleClosedKeydown(e))}_handleClosedKeydown(e){const r=e.keyCode,s=40===r||38===r||37===r||39===r,i=13===r||32===r,o=this._keyManager;if(!o.isTyping()&&i&&!pm(e)||(this.multiple||e.altKey)&&s)e.preventDefault(),this.open();else if(!this.multiple){const a=this.selected;o.onKeydown(e);const l=this.selected;l&&a!==l&&this._liveAnnouncer.announce(l.viewValue,1e4)}}_handleOpenKeydown(e){const r=this._keyManager,s=e.keyCode,i=40===s||38===s,o=r.isTyping();if(i&&e.altKey)e.preventDefault(),this.close();else if(o||13!==s&&32!==s||!r.activeItem||pm(e))if(!o&&this._multiple&&65===s&&e.ctrlKey){e.preventDefault();const a=this.options.some(l=>!l.disabled&&!l.selected);this.options.forEach(l=>{l.disabled||(a?l.select():l.deselect())})}else{const a=r.activeItemIndex;r.onKeydown(e),this._multiple&&i&&e.shiftKey&&r.activeItem&&r.activeItemIndex!==a&&r.activeItem._selectViaInteraction()}else e.preventDefault(),r.activeItem._selectViaInteraction()}_onFocus(){this.disabled||(this._focused=!0,this.stateChanges.next())}_onBlur(){this._focused=!1,this._keyManager?.cancelTypeahead(),!this.disabled&&!this.panelOpen&&(this._onTouched(),this._changeDetectorRef.markForCheck(),this.stateChanges.next())}_onAttached(){this._overlayDir.positionChange.pipe(no(1)).subscribe(()=>{this._changeDetectorRef.detectChanges(),this._positioningSettled()})}_getPanelTheme(){return this._parentFormField?`mat-${this._parentFormField.color}`:""}get empty(){return!this._selectionModel||this._selectionModel.isEmpty()}_initializeSelection(){Promise.resolve().then(()=>{this.ngControl&&(this._value=this.ngControl.value),this._setSelectionByValue(this._value),this.stateChanges.next()})}_setSelectionByValue(e){if(this._selectionModel.selected.forEach(r=>r.setInactiveStyles()),this._selectionModel.clear(),this.multiple&&e)Array.isArray(e),e.forEach(r=>this._selectOptionByValue(r)),this._sortValues();else{const r=this._selectOptionByValue(e);r?this._keyManager.updateActiveItem(r):this.panelOpen||this._keyManager.updateActiveItem(-1)}this._changeDetectorRef.markForCheck()}_selectOptionByValue(e){const r=this.options.find(s=>{if(this._selectionModel.isSelected(s))return!1;try{return null!=s.value&&this._compareWith(s.value,e)}catch{return!1}});return r&&this._selectionModel.select(r),r}_assignValue(e){return!!(e!==this._value||this._multiple&&Array.isArray(e))&&(this.options&&this._setSelectionByValue(e),this._value=e,!0)}_initKeyManager(){this._keyManager=new wNe(this.options).withTypeAhead(this._typeaheadDebounceInterval).withVerticalOrientation().withHorizontalOrientation(this._isRtl()?"rtl":"ltr").withHomeAndEnd().withPageUpDown().withAllowedModifierKeys(["shiftKey"]),this._keyManager.tabOut.subscribe(()=>{this.panelOpen&&(!this.multiple&&this._keyManager.activeItem&&this._keyManager.activeItem._selectViaInteraction(),this.focus(),this.close())}),this._keyManager.change.subscribe(()=>{this._panelOpen&&this.panel?this._scrollOptionIntoView(this._keyManager.activeItemIndex||0):!this._panelOpen&&!this.multiple&&this._keyManager.activeItem&&this._keyManager.activeItem._selectViaInteraction()})}_resetOptions(){const e=Jd(this.options.changes,this._destroy);this.optionSelectionChanges.pipe(Ea(e)).subscribe(r=>{this._onSelect(r.source,r.isUserInput),r.isUserInput&&!this.multiple&&this._panelOpen&&(this.close(),this.focus())}),Jd(...this.options.map(r=>r._stateChanges)).pipe(Ea(e)).subscribe(()=>{this._changeDetectorRef.markForCheck(),this.stateChanges.next()})}_onSelect(e,r){const s=this._selectionModel.isSelected(e);null!=e.value||this._multiple?(s!==e.selected&&(e.selected?this._selectionModel.select(e):this._selectionModel.deselect(e)),r&&this._keyManager.setActiveItem(e),this.multiple&&(this._sortValues(),r&&this.focus())):(e.deselect(),this._selectionModel.clear(),null!=this.value&&this._propagateChanges(e.value)),s!==this._selectionModel.isSelected(e)&&this._propagateChanges(),this.stateChanges.next()}_sortValues(){if(this.multiple){const e=this.options.toArray();this._selectionModel.sort((r,s)=>this.sortComparator?this.sortComparator(r,s,e):e.indexOf(r)-e.indexOf(s)),this.stateChanges.next()}}_propagateChanges(e){let r=null;r=this.multiple?this.selected.map(s=>s.value):this.selected?this.selected.value:e,this._value=r,this.valueChange.emit(r),this._onChange(r),this.selectionChange.emit(this._getChangeEvent(r)),this._changeDetectorRef.markForCheck()}_highlightCorrectOption(){this._keyManager&&(this.empty?this._keyManager.setFirstItemActive():this._keyManager.setActiveItem(this._selectionModel.selected[0]))}_canOpen(){return!this._panelOpen&&!this.disabled&&this.options?.length>0}focus(e){this._elementRef.nativeElement.focus(e)}_getPanelAriaLabelledby(){if(this.ariaLabel)return null;const e=this._parentFormField?.getLabelId();return this.ariaLabelledby?(e?e+" ":"")+this.ariaLabelledby:e}_getAriaActiveDescendant(){return this.panelOpen&&this._keyManager&&this._keyManager.activeItem?this._keyManager.activeItem.id:null}_getTriggerAriaLabelledby(){if(this.ariaLabel)return null;const e=this._parentFormField?.getLabelId();let r=(e?e+" ":"")+this._valueId;return this.ariaLabelledby&&(r+=" "+this.ariaLabelledby),r}_panelDoneAnimating(e){this.openedChange.emit(e)}setDescribedByIds(e){e.length?this._elementRef.nativeElement.setAttribute("aria-describedby",e.join(" ")):this._elementRef.nativeElement.removeAttribute("aria-describedby")}onContainerClick(){this.focus(),this.open()}get shouldLabelFloat(){return this._panelOpen||!this.empty||this._focused&&!!this._placeholder}}return n.\u0275fac=function(e){return new(e||n)(K(j1),K(Nu),K(St),K(YNe),K(Cn),K(F1,8),K(sx,8),K(ix,8),K(cMe,8),K(Da,10),Jc("tabindex"),K(bj),K(FNe),K(IFe,8))},n.\u0275dir=Ve({type:n,viewQuery:function(e,r){if(1&e&&(ia(mFe,5),ia(gFe,5),ia(aW,5)),2&e){let s;qs(s=Ks())&&(r.trigger=s.first),qs(s=Ks())&&(r.panel=s.first),qs(s=Ks())&&(r._overlayDir=s.first)}},inputs:{userAriaDescribedBy:["aria-describedby","userAriaDescribedBy"],panelClass:"panelClass",placeholder:"placeholder",required:"required",multiple:"multiple",disableOptionCentering:"disableOptionCentering",compareWith:"compareWith",value:"value",ariaLabel:["aria-label","ariaLabel"],ariaLabelledby:["aria-labelledby","ariaLabelledby"],errorStateMatcher:"errorStateMatcher",typeaheadDebounceInterval:"typeaheadDebounceInterval",sortComparator:"sortComparator",id:"id"},outputs:{openedChange:"openedChange",_openedStream:"opened",_closedStream:"closed",selectionChange:"selectionChange",valueChange:"valueChange"},features:[bt,xs]}),n})(),RFe=(()=>{class n extends AFe{constructor(){super(...arguments),this._positions=[{originX:"start",originY:"bottom",overlayX:"start",overlayY:"top"},{originX:"start",originY:"top",overlayX:"start",overlayY:"bottom",panelClass:"mat-mdc-select-panel-above"}]}get shouldLabelFloat(){return this.panelOpen||!this.empty||this.focused&&!!this.placeholder}ngOnInit(){super.ngOnInit(),this._viewportRuler.change().pipe(Ea(this._destroy)).subscribe(()=>{this.panelOpen&&(this._overlayWidth=this._getOverlayWidth(),this._changeDetectorRef.detectChanges())})}ngAfterViewInit(){this._parentFormField&&(this._preferredOverlayOrigin=this._parentFormField.getConnectedOverlayOrigin())}open(){this._overlayWidth=this._getOverlayWidth(),super.open(),this.stateChanges.next()}close(){super.close(),this.stateChanges.next()}_scrollOptionIntoView(e){const r=this.options.toArray()[e];if(r){const s=this.panel.nativeElement,i=function aAe(n,t,e){if(e.length){let r=t.toArray(),s=e.toArray(),i=0;for(let o=0;o<n+1;o++)r[o].group&&r[o].group===s[i]&&i++;return i}return 0}(e,this.options,this.optionGroups),o=r._getHostElement();s.scrollTop=0===e&&1===i?0:function lAe(n,t,e,r){return n<e?n:n+t>e+r?Math.max(0,n-r+t):e}(o.offsetTop,o.offsetHeight,s.scrollTop,s.offsetHeight)}}_positioningSettled(){this._scrollOptionIntoView(this._keyManager.activeItemIndex||0)}_getChangeEvent(e){return new kFe(this,e)}_getOverlayWidth(){return(this._preferredOverlayOrigin instanceof K1?this._preferredOverlayOrigin.elementRef:this._preferredOverlayOrigin||this._elementRef).nativeElement.getBoundingClientRect().width}}return n.\u0275fac=function(){let t;return function(r){return(t||(t=Dr(n)))(r||n)}}(),n.\u0275cmp=pi({type:n,selectors:[["mat-select"]],contentQueries:function(e,r,s){if(1&e&&(Gh(s,TFe,5),Gh(s,xH,5),Gh(s,vH,5)),2&e){let i;qs(i=Ks())&&(r.customTrigger=i.first),qs(i=Ks())&&(r.options=i),qs(i=Ks())&&(r.optionGroups=i)}},hostAttrs:["role","combobox","aria-autocomplete","none","aria-haspopup","listbox",1,"mat-mdc-select"],hostVars:19,hostBindings:function(e,r){1&e&&Gn("keydown",function(i){return r._handleKeydown(i)})("focus",function(){return r._onFocus()})("blur",function(){return r._onBlur()}),2&e&&(kn("id",r.id)("tabindex",r.tabIndex)("aria-controls",r.panelOpen?r.id+"-panel":null)("aria-expanded",r.panelOpen)("aria-label",r.ariaLabel||null)("aria-required",r.required.toString())("aria-disabled",r.disabled.toString())("aria-invalid",r.errorState)("aria-activedescendant",r._getAriaActiveDescendant()),Gs("mat-mdc-select-disabled",r.disabled)("mat-mdc-select-invalid",r.errorState)("mat-mdc-select-required",r.required)("mat-mdc-select-empty",r.empty)("mat-mdc-select-multiple",r.multiple))},inputs:{disabled:"disabled",disableRipple:"disableRipple",tabIndex:"tabIndex"},exportAs:["matSelect"],features:[gn([{provide:lMe,useExisting:n},{provide:_H,useExisting:n}]),bt],ngContentSelectors:CFe,decls:11,vars:11,consts:[["cdk-overlay-origin","",1,"mat-mdc-select-trigger",3,"click"],["fallbackOverlayOrigin","cdkOverlayOrigin","trigger",""],[1,"mat-mdc-select-value",3,"ngSwitch"],["class","mat-mdc-select-placeholder mat-mdc-select-min-line",4,"ngSwitchCase"],["class","mat-mdc-select-value-text",3,"ngSwitch",4,"ngSwitchCase"],[1,"mat-mdc-select-arrow-wrapper"],[1,"mat-mdc-select-arrow"],["viewBox","0 0 24 24","width","24px","height","24px","focusable","false"],["d","M7 10l5 5 5-5z"],["cdk-connected-overlay","","cdkConnectedOverlayLockPosition","","cdkConnectedOverlayHasBackdrop","","cdkConnectedOverlayBackdropClass","cdk-overlay-transparent-backdrop",3,"cdkConnectedOverlayPanelClass","cdkConnectedOverlayScrollStrategy","cdkConnectedOverlayOrigin","cdkConnectedOverlayOpen","cdkConnectedOverlayPositions","cdkConnectedOverlayWidth","backdropClick","attach","detach"],[1,"mat-mdc-select-placeholder","mat-mdc-select-min-line"],[1,"mat-mdc-select-value-text",3,"ngSwitch"],["class","mat-mdc-select-min-line",4,"ngSwitchDefault"],[4,"ngSwitchCase"],[1,"mat-mdc-select-min-line"],["role","listbox","tabindex","-1",3,"ngClass","keydown"],["panel",""]],template:function(e,r){if(1&e&&(Cu(wFe),Xt(0,"div",0,1),Gn("click",function(){return r.toggle()}),Xt(3,"div",2),bi(4,yFe,2,1,"span",3),bi(5,vFe,3,2,"span",4),Nn(),Xt(6,"div",5)(7,"div",6),dh(),Xt(8,"svg",7),as(9,"path",8),Nn()()()(),bi(10,xFe,3,9,"ng-template",9),Gn("backdropClick",function(){return r.close()})("attach",function(){return r._onAttached()})("detach",function(){return r.close()})),2&e){const s=Rh(1);kn("aria-owns",r.panelOpen?r.id+"-panel":null),en(3),tn("ngSwitch",r.empty),kn("id",r._valueId),en(1),tn("ngSwitchCase",!0),en(1),tn("ngSwitchCase",!1),en(5),tn("cdkConnectedOverlayPanelClass",r._overlayPanelClass)("cdkConnectedOverlayScrollStrategy",r._scrollStrategy)("cdkConnectedOverlayOrigin",r._preferredOverlayOrigin||s)("cdkConnectedOverlayOpen",r.panelOpen)("cdkConnectedOverlayPositions",r._positions)("cdkConnectedOverlayWidth",r._overlayWidth)}},dependencies:[f2,sy,_2,v2,aW,K1],styles:['.mdc-menu-surface{display:none;position:absolute;box-sizing:border-box;max-width:calc(100vw - 32px);max-width:var(--mdc-menu-max-width, calc(100vw - 32px));max-height:calc(100vh - 32px);max-height:var(--mdc-menu-max-height, calc(100vh - 32px));margin:0;padding:0;transform:scale(1);transform-origin:top left;opacity:0;overflow:auto;will-change:transform,opacity;z-index:8;border-radius:4px;border-radius:var(--mdc-shape-medium, 4px);transform-origin-left:top left;transform-origin-right:top right}.mdc-menu-surface:focus{outline:none}.mdc-menu-surface--animating-open{display:inline-block;transform:scale(0.8);opacity:0}.mdc-menu-surface--open{display:inline-block;transform:scale(1);opacity:1}.mdc-menu-surface--animating-closed{display:inline-block;opacity:0}[dir=rtl] .mdc-menu-surface,.mdc-menu-surface[dir=rtl]{transform-origin-left:top right;transform-origin-right:top left}.mdc-menu-surface--anchor{position:relative;overflow:visible}.mdc-menu-surface--fixed{position:fixed}.mdc-menu-surface--fullwidth{width:100%}.mat-mdc-select{display:inline-block;width:100%;outline:none}.mat-mdc-select-trigger{display:inline-flex;align-items:center;cursor:pointer;position:relative;box-sizing:border-box;width:100%}.mat-mdc-select-disabled .mat-mdc-select-trigger{-webkit-user-select:none;user-select:none;cursor:default}.mat-mdc-select-value{width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-mdc-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-mdc-select-arrow-wrapper{height:24px;flex-shrink:0;display:inline-flex;align-items:center}.mat-form-field-appearance-fill .mat-mdc-select-arrow-wrapper{transform:translateY(-8px)}.mat-form-field-appearance-fill .mdc-text-field--no-label .mat-mdc-select-arrow-wrapper{transform:none}.mat-mdc-select-arrow{width:10px;height:5px;position:relative}.mat-mdc-select-arrow svg{fill:currentColor;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}.cdk-high-contrast-active .mat-mdc-select-arrow svg{fill:CanvasText}.mat-mdc-select-disabled .cdk-high-contrast-active .mat-mdc-select-arrow svg{fill:GrayText}.mdc-menu-surface.mat-mdc-select-panel{width:100%;max-height:275px;position:static;outline:0;margin:0;padding:8px 0;list-style-type:none}.mdc-menu-surface.mat-mdc-select-panel:focus{outline:none}.cdk-high-contrast-active .mdc-menu-surface.mat-mdc-select-panel{outline:solid 1px}.cdk-overlay-pane:not(.mat-mdc-select-panel-above) .mdc-menu-surface.mat-mdc-select-panel{border-top-left-radius:0;border-top-right-radius:0;transform-origin:top center}.mat-mdc-select-panel-above .mdc-menu-surface.mat-mdc-select-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:bottom center}.mat-mdc-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable .mat-mdc-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-mdc-select-placeholder{color:rgba(0,0,0,0);-webkit-text-fill-color:rgba(0,0,0,0);transition:none;display:block}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mat-mdc-floating-label{max-width:calc(100% - 18px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 24px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-text-field--label-floating .mdc-notched-outline__notch{max-width:calc(100% - 24px)}.mat-mdc-select-min-line:empty::before{content:" ";white-space:pre;width:1px;display:inline-block;visibility:hidden}'],encapsulation:2,data:{animation:[SFe.transformPanel]},changeDetection:0}),n})(),MFe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({providers:[DFe],imports:[Ru,lW,wH,ys,Gv,uMe,wH,ys]}),n})();const FFe=["inferenceCanvas"],OFe=["frameCapture"],$Fe=["videoElement"];function PFe(n,t){1&n&&as(0,"mat-spinner",16),2&n&&tn("diameter",40)}function LFe(n,t){if(1&n){const e=kg();Xt(0,"button",17),Gn("click",function(){return lh(e),Yi(),ch(Rh(3).click())}),Xt(1,"mat-icon"),Xl(2,"add_a_photo"),Nn()()}}function VFe(n,t){if(1&n&&(Xt(0,"mat-option",18),Xl(1),Nn()),2&n){const e=t.$implicit;tn("value",e.value),en(1),Ph(e.value)}}const BFe=function(){return{display:"none"}};class ox{constructor(){this.FONT_SIZE=12,this.FONT=this.FONT_SIZE+"px comic-sans",this.classNamesMap=new Map,this.currentClassNames=new Map,this.loadingInference=!0,this.streamLoaded=!1,this.RESOLUTION=[640,640],this.showOriginalImage=!1,this.selectedClasses=[],this.importer=new Mv,this.classNamesMap=this.importer.getClassNames(),this.selectedClasses=[...this.classNamesMap.values()],console.log(this.selectedClasses);for(let t of this.classNamesMap)console.log(t[1])}ngAfterViewInit(){this.ctxFrameCapture=this.frameCapture.nativeElement.getContext("2d"),this.ctx=this.inferenceCanvas.nativeElement.getContext("2d"),this.ctx.font=this.FONT,this.ctx.textBaseline="top";var t=new Image;t.src="assets/fab.jpg",null!=t&&(t.onload=()=>{this.importer.modelLoaded$.pipe(Xs(()=>this.importer.predict(this.frameCapture.nativeElement,this.ctxFrameCapture,this.ctx,this.video,t,!0))).subscribe(()=>{console.log("ran predict"),this.loadingInference=!1})})}selectChange(t){console.log(t),this.selectedClasses=t,this.importer.setClassNames(t)}getDetectionInterval(t){return function _te(n=0,t=$y){return n<0&&(n=0),yP(n,n,t)}(1).pipe(bP(()=>t))}inputEvent(t){console.log("inputEvent",t);let e=t.target.files[0];if(e){this.loadingInference=!0;var r=new FileReader;this.classifySubscription&&this.classifySubscription.unsubscribe(),r.readAsDataURL(e),r.onloadend=s=>{console.log(s);var i=new Image;s.target&&(i.src=s?.target?.result),i.onload=o=>{this.importer.predict(this.frameCapture.nativeElement,this.ctxFrameCapture,this.ctx,this.video,i,!0).subscribe(()=>{this.loadingInference=!1})}}}else console.log("No file selected!")}selectClasses(){}toggleDetection(t){this.classifySubscription&&(this.classifySubscription.unsubscribe(),console.log("unsubscribe old")),this.classifySubscription=this.getDetectionInterval(this.importer.predict(this.frameCapture.nativeElement,this.ctxFrameCapture,this.ctx,this.video)).subscribe()}static#e=this.\u0275fac=function(e){return new(e||ox)};static#t=this.\u0275cmp=pi({type:ox,selectors:[["app-root"]],viewQuery:function(e,r){if(1&e&&(ia(FFe,5),ia(OFe,5),ia($Fe,5)),2&e){let s;qs(s=Ks())&&(r.inferenceCanvas=s.first),qs(s=Ks())&&(r.frameCapture=s.first),qs(s=Ks())&&(r.videoElement=s.first)}},decls:18,vars:14,consts:[[2,"width","100%","height","100%"],[1,"content"],["type","file","accept","image/*",2,"display","none",3,"disabled","change"],["imageInput",""],[2,"width","100%","position","relative"],["style","position: absolute; top: 45%; \n        margin-left: auto; \n        margin-right: auto; \n        left: 0;\n        right: 0;\n        text-align: center; ",3,"diameter",4,"ngIf"],[2,"width","100%",3,"width","height"],["inferenceCanvas",""],["mat-mini-fab","","style","position: absolute; \n        margin-left: auto; \n        margin-right: auto; \n        left: 0;\n        right: 0;\n        text-align: center; \n        bottom: 5%; \n        background-color: white;",3,"click",4,"ngIf"],["mat-icon-button","",2,"position","absolute","top","5%","left","4%",3,"click"],[2,"color","white"],["multiple","","color","accent",1,"langSelect",3,"ngModel","selectionChange"],["select",""],[3,"value",4,"ngFor","ngForOf"],[2,"width","90%",3,"hidden","ngStyle","width","height"],["frameCapture",""],[2,"position","absolute","top","45%","margin-left","auto","margin-right","auto","left","0","right","0","text-align","center",3,"diameter"],["mat-mini-fab","",2,"position","absolute","margin-left","auto","margin-right","auto","left","0","right","0","text-align","center","bottom","5%","background-color","white",3,"click"],[3,"value"]],template:function(e,r){if(1&e){const s=kg();Xt(0,"div",0)(1,"div",1)(2,"input",2,3),Gn("change",function(o){return r.inputEvent(o)}),Nn(),Xt(4,"div",4),bi(5,PFe,1,1,"mat-spinner",5),as(6,"canvas",6,7),bi(8,LFe,3,0,"button",8),Xt(9,"button",9),Gn("click",function(){return lh(s),ch(Rh(13).open())}),Xt(10,"mat-icon",10),Xl(11,"sort"),Nn(),Xt(12,"mat-select",11,12),Gn("selectionChange",function(o){return r.selectChange(o.value)}),bi(14,VFe,2,2,"mat-option",13),function XF(n,t){const e=Nt();let r;const s=n+22;e.firstCreatePass?(r=function zY(n,t){if(t)for(let e=t.length-1;e>=0;e--){const r=t[e];if(n===r.name)return r}}(t,e.pipeRegistry),e.data[s]=r,r.onDestroy&&(e.destroyHooks||(e.destroyHooks=[])).push(s,r.onDestroy)):r=e.data[s];const i=r.factory||(r.factory=Vl(r.type)),o=fi(K);try{const a=Jm(!1),l=i();return Jm(a),function OK(n,t,e,r){e>=n.data.length&&(n.data[e]=null,n.blueprint[e]=null),t[e]=r}(e,oe(),s,l),l}finally{fi(o)}}(15,"keyvalue"),Nn()()(),as(16,"canvas",14,15),Nn()()}2&e&&(en(2),tn("disabled",!r.importer.isModelLoaded()||r.loadingInference),en(3),tn("ngIf",r.loadingInference),en(1),tn("width",r.RESOLUTION[0])("height",r.RESOLUTION[1]),en(2),tn("ngIf",!r.loadingInference),en(4),tn("ngModel",r.selectedClasses),en(2),tn("ngForOf",function YF(n,t,e){const r=n+22,s=oe(),i=qc(s,r);return function Wh(n,t){return n[1].data[t].pure}(s,r)?WF(s,rs(),t,i.transform,e,i):i.transform(e)}(15,11,r.classNamesMap)),en(2),tn("hidden",r.showOriginalImage)("ngStyle",function HF(n,t,e){const r=rs()+n,s=oe();return s[r]===nt?vo(s,r,e?t.call(e):t()):function Ah(n,t){return n[t]}(s,r)}(13,BFe))("width",r.RESOLUTION[0])("height",r.RESOLUTION[1]))},dependencies:[g2,kC,w2,mAe,KAe,lRe,aRe,RFe,xH,LW,uk,S2],styles:[".langSelect div.mat-mdc-select-arrow-wrapper{display:none}  .langSelect.mat-select{display:inline}  #cdk-overlay-0{width:250px!important}  #mat-select-0{display:none}  .mat-pseudo-checkbox-checked{background:blue}.mat-select-panel[_ngcontent-%COMP%]{width:2000px;background-color:red;font-size:10px}"]})}const WFe={provide:new me("mat-menu-scroll-strategy"),deps:[xm],useFactory:function HFe(n){return()=>n.scrollStrategies.reposition()}};let jFe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({providers:[WFe],imports:[Ru,P1,ys,lW,Gv,ys]}),n})();function vj(n){return new te(3e3,!1)}function IOe(){return typeof window<"u"&&typeof window.document<"u"}function yk(){return typeof process<"u"&&"[object process]"==={}.toString.call(process)}function Dl(n){switch(n.length){case 0:return new Cm;case 1:return n[0];default:return new hW(n)}}function xj(n,t,e,r,s=new Map,i=new Map){const o=[],a=[];let l=-1,c=null;if(r.forEach(u=>{const d=u.get("offset"),h=d==l,f=h&&c||new Map;u.forEach((p,m)=>{let g=m,y=p;if("offset"!==m)switch(g=t.normalizePropertyName(g,o),y){case"!":y=s.get(m);break;case Ia:y=i.get(m);break;default:y=t.normalizeStyleValue(m,g,y,o)}f.set(g,y)}),h||a.push(f),c=f,l=d}),o.length)throw function pOe(n){return new te(3502,!1)}();return a}function bk(n,t,e,r){switch(t){case"start":n.onStart(()=>r(e&&_k(e,"start",n)));break;case"done":n.onDone(()=>r(e&&_k(e,"done",n)));break;case"destroy":n.onDestroy(()=>r(e&&_k(e,"destroy",n)))}}function _k(n,t,e){const i=vk(n.element,n.triggerName,n.fromState,n.toState,t||n.phaseName,e.totalTime??n.totalTime,!!e.disabled),o=n._data;return null!=o&&(i._data=o),i}function vk(n,t,e,r,s="",i=0,o){return{element:n,triggerName:t,fromState:e,toState:r,phaseName:s,totalTime:i,disabled:!!o}}function ci(n,t,e){let r=n.get(t);return r||n.set(t,r=e),r}function wj(n){const t=n.indexOf(":");return[n.substring(1,t),n.slice(t+1)]}let xk=(n,t)=>!1,Cj=(n,t,e)=>[],Sj=null;function wk(n){const t=n.parentNode||n.host;return t===Sj?null:t}(yk()||typeof Element<"u")&&(IOe()?(Sj=(()=>document.documentElement)(),xk=(n,t)=>{for(;t;){if(t===n)return!0;t=wk(t)}return!1}):xk=(n,t)=>n.contains(t),Cj=(n,t,e)=>{if(e)return Array.from(n.querySelectorAll(t));const r=n.querySelector(t);return r?[r]:[]});let $c=null,Ej=!1;const Ij=xk,Dj=Cj;let Tj=(()=>{class n{validateStyleProperty(e){return function TOe(n){$c||($c=function kOe(){return typeof document<"u"?document.body:null}()||{},Ej=!!$c.style&&"WebkitAppearance"in $c.style);let t=!0;return $c.style&&!function DOe(n){return"ebkit"==n.substring(1,6)}(n)&&(t=n in $c.style,!t&&Ej&&(t="Webkit"+n.charAt(0).toUpperCase()+n.slice(1)in $c.style)),t}(e)}matchesElement(e,r){return!1}containsElement(e,r){return Ij(e,r)}getParentElement(e){return wk(e)}query(e,r,s){return Dj(e,r,s)}computeStyle(e,r,s){return s||""}animate(e,r,s,i,o,a=[],l){return new Cm(s,i)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=Ce({token:n,factory:n.\u0275fac}),n})(),Ck=(()=>{class n{}return n.NOOP=new Tj,n})();const Sk="ng-enter",ax="ng-leave",lx="ng-trigger",cx=".ng-trigger",Nj="ng-animating",Ek=".ng-animating";function Ta(n){if("number"==typeof n)return n;const t=n.match(/^(-?[\.\d]+)(m?s)/);return!t||t.length<2?0:Ik(parseFloat(t[1]),t[2])}function Ik(n,t){return"s"===t?1e3*n:n}function ux(n,t,e){return n.hasOwnProperty("duration")?n:function ROe(n,t,e){let s,i=0,o="";if("string"==typeof n){const a=n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===a)return t.push(vj()),{duration:0,delay:0,easing:""};s=Ik(parseFloat(a[1]),a[2]);const l=a[3];null!=l&&(i=Ik(parseFloat(l),a[4]));const c=a[5];c&&(o=c)}else s=n;if(!e){let a=!1,l=t.length;s<0&&(t.push(function GFe(){return new te(3100,!1)}()),a=!0),i<0&&(t.push(function qFe(){return new te(3101,!1)}()),a=!0),a&&t.splice(l,0,vj())}return{duration:s,delay:i,easing:o}}(n,t,e)}function Tm(n,t={}){return Object.keys(n).forEach(e=>{t[e]=n[e]}),t}function Aj(n){const t=new Map;return Object.keys(n).forEach(e=>{t.set(e,n[e])}),t}function Tl(n,t=new Map,e){if(e)for(let[r,s]of e)t.set(r,s);for(let[r,s]of n)t.set(r,s);return t}function Mj(n,t,e){return e?t+":"+e+";":""}function Fj(n){let t="";for(let e=0;e<n.style.length;e++){const r=n.style.item(e);t+=Mj(0,r,n.style.getPropertyValue(r))}for(const e in n.style)n.style.hasOwnProperty(e)&&!e.startsWith("_")&&(t+=Mj(0,$Oe(e),n.style[e]));n.setAttribute("style",t)}function Wo(n,t,e){n.style&&(t.forEach((r,s)=>{const i=Tk(s);e&&!e.has(s)&&e.set(s,n.style[i]),n.style[i]=r}),yk()&&Fj(n))}function Pc(n,t){n.style&&(t.forEach((e,r)=>{const s=Tk(r);n.style[s]=""}),yk()&&Fj(n))}function km(n){return Array.isArray(n)?1==n.length?n[0]:uW(n):n}const Dk=new RegExp("{{\\s*(.+?)\\s*}}","g");function Oj(n){let t=[];if("string"==typeof n){let e;for(;e=Dk.exec(n);)t.push(e[1]);Dk.lastIndex=0}return t}function Nm(n,t,e){const r=n.toString(),s=r.replace(Dk,(i,o)=>{let a=t[o];return null==a&&(e.push(function XFe(n){return new te(3003,!1)}()),a=""),a.toString()});return s==r?n:s}function dx(n){const t=[];let e=n.next();for(;!e.done;)t.push(e.value),e=n.next();return t}const OOe=/-+([a-z0-9])/g;function Tk(n){return n.replace(OOe,(...t)=>t[1].toUpperCase())}function $Oe(n){return n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}function ui(n,t,e){switch(t.type){case 7:return n.visitTrigger(t,e);case 0:return n.visitState(t,e);case 1:return n.visitTransition(t,e);case 2:return n.visitSequence(t,e);case 3:return n.visitGroup(t,e);case 4:return n.visitAnimate(t,e);case 5:return n.visitKeyframes(t,e);case 6:return n.visitStyle(t,e);case 8:return n.visitReference(t,e);case 9:return n.visitAnimateChild(t,e);case 10:return n.visitAnimateRef(t,e);case 11:return n.visitQuery(t,e);case 12:return n.visitStagger(t,e);default:throw function YFe(n){return new te(3004,!1)}()}}function $j(n,t){return window.getComputedStyle(n)[t]}function UOe(n,t){const e=[];return"string"==typeof n?n.split(/\s*,\s*/).forEach(r=>function HOe(n,t,e){if(":"==n[0]){const l=function WOe(n,t){switch(n){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(e,r)=>parseFloat(r)>parseFloat(e);case":decrement":return(e,r)=>parseFloat(r)<parseFloat(e);default:return t.push(function uOe(n){return new te(3016,!1)}()),"* => *"}}(n,e);if("function"==typeof l)return void t.push(l);n=l}const r=n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==r||r.length<4)return e.push(function cOe(n){return new te(3015,!1)}()),t;const s=r[1],i=r[2],o=r[3];t.push(Pj(s,o));"<"==i[0]&&!("*"==s&&"*"==o)&&t.push(Pj(o,s))}(r,e,t)):e.push(n),e}const mx=new Set(["true","1"]),gx=new Set(["false","0"]);function Pj(n,t){const e=mx.has(n)||gx.has(n),r=mx.has(t)||gx.has(t);return(s,i)=>{let o="*"==n||n==s,a="*"==t||t==i;return!o&&e&&"boolean"==typeof s&&(o=s?mx.has(n):gx.has(n)),!a&&r&&"boolean"==typeof i&&(a=i?mx.has(t):gx.has(t)),o&&a}}const jOe=new RegExp("s*:selfs*,?","g");function kk(n,t,e,r){return new GOe(n).build(t,e,r)}class GOe{constructor(t){this._driver=t}build(t,e,r){const s=new XOe(e);return this._resetContextStyleTimingState(s),ui(this,km(t),s)}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles=new Map,t.collectedStyles.set("",new Map),t.currentTime=0}visitTrigger(t,e){let r=e.queryCount=0,s=e.depCount=0;const i=[],o=[];return"@"==t.name.charAt(0)&&e.errors.push(function QFe(){return new te(3006,!1)}()),t.definitions.forEach(a=>{if(this._resetContextStyleTimingState(e),0==a.type){const l=a,c=l.name;c.toString().split(/\s*,\s*/).forEach(u=>{l.name=u,i.push(this.visitState(l,e))}),l.name=c}else if(1==a.type){const l=this.visitTransition(a,e);r+=l.queryCount,s+=l.depCount,o.push(l)}else e.errors.push(function JFe(){return new te(3007,!1)}())}),{type:7,name:t.name,states:i,transitions:o,queryCount:r,depCount:s,options:null}}visitState(t,e){const r=this.visitStyle(t.styles,e),s=t.options&&t.options.params||null;if(r.containsDynamicStyles){const i=new Set,o=s||{};r.styles.forEach(a=>{a instanceof Map&&a.forEach(l=>{Oj(l).forEach(c=>{o.hasOwnProperty(c)||i.add(c)})})}),i.size&&(dx(i.values()),e.errors.push(function eOe(n,t){return new te(3008,!1)}()))}return{type:0,name:t.name,style:r,options:s?{params:s}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const r=ui(this,km(t.animation),e);return{type:1,matchers:UOe(t.expr,e.errors),animation:r,queryCount:e.queryCount,depCount:e.depCount,options:Lc(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(r=>ui(this,r,e)),options:Lc(t.options)}}visitGroup(t,e){const r=e.currentTime;let s=0;const i=t.steps.map(o=>{e.currentTime=r;const a=ui(this,o,e);return s=Math.max(s,e.currentTime),a});return e.currentTime=s,{type:3,steps:i,options:Lc(t.options)}}visitAnimate(t,e){const r=function ZOe(n,t){if(n.hasOwnProperty("duration"))return n;if("number"==typeof n)return Nk(ux(n,t).duration,0,"");const e=n;if(e.split(/\s+/).some(i=>"{"==i.charAt(0)&&"{"==i.charAt(1))){const i=Nk(0,0,"");return i.dynamic=!0,i.strValue=e,i}const s=ux(e,t);return Nk(s.duration,s.delay,s.easing)}(t.timings,e.errors);e.currentAnimateTimings=r;let s,i=t.styles?t.styles:Bi({});if(5==i.type)s=this.visitKeyframes(i,e);else{let o=t.styles,a=!1;if(!o){a=!0;const c={};r.easing&&(c.easing=r.easing),o=Bi(c)}e.currentTime+=r.duration+r.delay;const l=this.visitStyle(o,e);l.isEmptyStep=a,s=l}return e.currentAnimateTimings=null,{type:4,timings:r,style:s,options:null}}visitStyle(t,e){const r=this._makeStyleAst(t,e);return this._validateStyleAst(r,e),r}_makeStyleAst(t,e){const r=[],s=Array.isArray(t.styles)?t.styles:[t.styles];for(let a of s)"string"==typeof a?a===Ia?r.push(a):e.errors.push(new te(3002,!1)):r.push(Aj(a));let i=!1,o=null;return r.forEach(a=>{if(a instanceof Map&&(a.has("easing")&&(o=a.get("easing"),a.delete("easing")),!i))for(let l of a.values())if(l.toString().indexOf("{{")>=0){i=!0;break}}),{type:6,styles:r,easing:o,offset:t.offset,containsDynamicStyles:i,options:null}}_validateStyleAst(t,e){const r=e.currentAnimateTimings;let s=e.currentTime,i=e.currentTime;r&&i>0&&(i-=r.duration+r.delay),t.styles.forEach(o=>{"string"!=typeof o&&o.forEach((a,l)=>{const c=e.collectedStyles.get(e.currentQuerySelector),u=c.get(l);let d=!0;u&&(i!=s&&i>=u.startTime&&s<=u.endTime&&(e.errors.push(function nOe(n,t,e,r,s){return new te(3010,!1)}()),d=!1),i=u.startTime),d&&c.set(l,{startTime:i,endTime:s}),e.options&&function FOe(n,t,e){const r=t.params||{},s=Oj(n);s.length&&s.forEach(i=>{r.hasOwnProperty(i)||e.push(function KFe(n){return new te(3001,!1)}())})}(a,e.options,e.errors)})})}visitKeyframes(t,e){const r={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push(function rOe(){return new te(3011,!1)}()),r;let i=0;const o=[];let a=!1,l=!1,c=0;const u=t.steps.map(y=>{const b=this._makeStyleAst(y,e);let _=null!=b.offset?b.offset:function YOe(n){if("string"==typeof n)return null;let t=null;if(Array.isArray(n))n.forEach(e=>{if(e instanceof Map&&e.has("offset")){const r=e;t=parseFloat(r.get("offset")),r.delete("offset")}});else if(n instanceof Map&&n.has("offset")){const e=n;t=parseFloat(e.get("offset")),e.delete("offset")}return t}(b.styles),v=0;return null!=_&&(i++,v=b.offset=_),l=l||v<0||v>1,a=a||v<c,c=v,o.push(v),b});l&&e.errors.push(function sOe(){return new te(3012,!1)}()),a&&e.errors.push(function iOe(){return new te(3200,!1)}());const d=t.steps.length;let h=0;i>0&&i<d?e.errors.push(function oOe(){return new te(3202,!1)}()):0==i&&(h=1/(d-1));const f=d-1,p=e.currentTime,m=e.currentAnimateTimings,g=m.duration;return u.forEach((y,b)=>{const _=h>0?b==f?1:h*b:o[b],v=_*g;e.currentTime=p+m.delay+v,m.duration=v,this._validateStyleAst(y,e),y.offset=_,r.styles.push(y)}),r}visitReference(t,e){return{type:8,animation:ui(this,km(t.animation),e),options:Lc(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:Lc(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:Lc(t.options)}}visitQuery(t,e){const r=e.currentQuerySelector,s=t.options||{};e.queryCount++,e.currentQuery=t;const[i,o]=function qOe(n){const t=!!n.split(/\s*,\s*/).find(e=>":self"==e);return t&&(n=n.replace(jOe,"")),n=n.replace(/@\*/g,cx).replace(/@\w+/g,e=>cx+"-"+e.slice(1)).replace(/:animating/g,Ek),[n,t]}(t.selector);e.currentQuerySelector=r.length?r+" "+i:i,ci(e.collectedStyles,e.currentQuerySelector,new Map);const a=ui(this,km(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=r,{type:11,selector:i,limit:s.limit||0,optional:!!s.optional,includeSelf:o,animation:a,originalSelector:t.selector,options:Lc(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push(function aOe(){return new te(3013,!1)}());const r="full"===t.timings?{duration:0,delay:0,easing:"full"}:ux(t.timings,e.errors,!0);return{type:12,animation:ui(this,km(t.animation),e),timings:r,options:null}}}class XOe{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles=new Map,this.options=null,this.unsupportedCSSPropertiesFound=new Set}}function Lc(n){return n?(n=Tm(n)).params&&(n.params=function KOe(n){return n?Tm(n):null}(n.params)):n={},n}function Nk(n,t,e){return{duration:n,delay:t,easing:e}}function Ak(n,t,e,r,s,i,o=null,a=!1){return{type:1,element:n,keyframes:t,preStyleProps:e,postStyleProps:r,duration:s,delay:i,totalTime:s+i,easing:o,subTimeline:a}}class yx{constructor(){this._map=new Map}get(t){return this._map.get(t)||[]}append(t,e){let r=this._map.get(t);r||this._map.set(t,r=[]),r.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const e2e=new RegExp(":enter","g"),n2e=new RegExp(":leave","g");function Rk(n,t,e,r,s,i=new Map,o=new Map,a,l,c=[]){return(new r2e).buildKeyframes(n,t,e,r,s,i,o,a,l,c)}class r2e{buildKeyframes(t,e,r,s,i,o,a,l,c,u=[]){c=c||new yx;const d=new Mk(t,e,c,s,i,u,[]);d.options=l;const h=l.delay?Ta(l.delay):0;d.currentTimeline.delayNextStep(h),d.currentTimeline.setStyles([o],null,d.errors,l),ui(this,r,d);const f=d.timelines.filter(p=>p.containsAnimation());if(f.length&&a.size){let p;for(let m=f.length-1;m>=0;m--){const g=f[m];if(g.element===e){p=g;break}}p&&!p.allowOnlyTimelineStyles()&&p.setStyles([a],null,d.errors,l)}return f.length?f.map(p=>p.buildKeyframes()):[Ak(e,[],[],[],0,h,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const r=e.subInstructions.get(e.element);if(r){const s=e.createSubContext(t.options),i=e.currentTimeline.currentTime,o=this._visitSubInstructions(r,s,s.options);i!=o&&e.transformIntoNewTimeline(o)}e.previousNode=t}visitAnimateRef(t,e){const r=e.createSubContext(t.options);r.transformIntoNewTimeline(),this._applyAnimationRefDelays([t.options,t.animation.options],e,r),this.visitReference(t.animation,r),e.transformIntoNewTimeline(r.currentTimeline.currentTime),e.previousNode=t}_applyAnimationRefDelays(t,e,r){for(const s of t){const i=s?.delay;if(i){const o="number"==typeof i?i:Ta(Nm(i,s?.params??{},e.errors));r.delayNextStep(o)}}}_visitSubInstructions(t,e,r){let i=e.currentTimeline.currentTime;const o=null!=r.duration?Ta(r.duration):null,a=null!=r.delay?Ta(r.delay):null;return 0!==o&&t.forEach(l=>{const c=e.appendInstructionToTimeline(l,o,a);i=Math.max(i,c.duration+c.delay)}),i}visitReference(t,e){e.updateOptions(t.options,!0),ui(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const r=e.subContextCount;let s=e;const i=t.options;if(i&&(i.params||i.delay)&&(s=e.createSubContext(i),s.transformIntoNewTimeline(),null!=i.delay)){6==s.previousNode.type&&(s.currentTimeline.snapshotCurrentStyles(),s.previousNode=bx);const o=Ta(i.delay);s.delayNextStep(o)}t.steps.length&&(t.steps.forEach(o=>ui(this,o,s)),s.currentTimeline.applyStylesToKeyframe(),s.subContextCount>r&&s.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const r=[];let s=e.currentTimeline.currentTime;const i=t.options&&t.options.delay?Ta(t.options.delay):0;t.steps.forEach(o=>{const a=e.createSubContext(t.options);i&&a.delayNextStep(i),ui(this,o,a),s=Math.max(s,a.currentTimeline.currentTime),r.push(a.currentTimeline)}),r.forEach(o=>e.currentTimeline.mergeTimelineCollectedStyles(o)),e.transformIntoNewTimeline(s),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const r=t.strValue;return ux(e.params?Nm(r,e.params,e.errors):r,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const r=e.currentAnimateTimings=this._visitTiming(t.timings,e),s=e.currentTimeline;r.delay&&(e.incrementTime(r.delay),s.snapshotCurrentStyles());const i=t.style;5==i.type?this.visitKeyframes(i,e):(e.incrementTime(r.duration),this.visitStyle(i,e),s.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const r=e.currentTimeline,s=e.currentAnimateTimings;!s&&r.hasCurrentStyleProperties()&&r.forwardFrame();const i=s&&s.easing||t.easing;t.isEmptyStep?r.applyEmptyStep(i):r.setStyles(t.styles,i,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const r=e.currentAnimateTimings,s=e.currentTimeline.duration,i=r.duration,a=e.createSubContext().currentTimeline;a.easing=r.easing,t.styles.forEach(l=>{a.forwardTime((l.offset||0)*i),a.setStyles(l.styles,l.easing,e.errors,e.options),a.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(a),e.transformIntoNewTimeline(s+i),e.previousNode=t}visitQuery(t,e){const r=e.currentTimeline.currentTime,s=t.options||{},i=s.delay?Ta(s.delay):0;i&&(6===e.previousNode.type||0==r&&e.currentTimeline.hasCurrentStyleProperties())&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=bx);let o=r;const a=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!s.optional,e.errors);e.currentQueryTotal=a.length;let l=null;a.forEach((c,u)=>{e.currentQueryIndex=u;const d=e.createSubContext(t.options,c);i&&d.delayNextStep(i),c===e.element&&(l=d.currentTimeline),ui(this,t.animation,d),d.currentTimeline.applyStylesToKeyframe(),o=Math.max(o,d.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(o),l&&(e.currentTimeline.mergeTimelineCollectedStyles(l),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const r=e.parentContext,s=e.currentTimeline,i=t.timings,o=Math.abs(i.duration),a=o*(e.currentQueryTotal-1);let l=o*e.currentQueryIndex;switch(i.duration<0?"reverse":i.easing){case"reverse":l=a-l;break;case"full":l=r.currentStaggerTime}const u=e.currentTimeline;l&&u.delayNextStep(l);const d=u.currentTime;ui(this,t.animation,e),e.previousNode=t,r.currentStaggerTime=s.currentTime-d+(s.startTime-r.currentTimeline.startTime)}}const bx={};class Mk{constructor(t,e,r,s,i,o,a,l){this._driver=t,this.element=e,this.subInstructions=r,this._enterClassName=s,this._leaveClassName=i,this.errors=o,this.timelines=a,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=bx,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=l||new _x(this._driver,e,0),a.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const r=t;let s=this.options;null!=r.duration&&(s.duration=Ta(r.duration)),null!=r.delay&&(s.delay=Ta(r.delay));const i=r.params;if(i){let o=s.params;o||(o=this.options.params={}),Object.keys(i).forEach(a=>{(!e||!o.hasOwnProperty(a))&&(o[a]=Nm(i[a],o,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const r=t.params={};Object.keys(e).forEach(s=>{r[s]=e[s]})}}return t}createSubContext(t=null,e,r){const s=e||this.element,i=new Mk(this._driver,s,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(s,r||0));return i.previousNode=this.previousNode,i.currentAnimateTimings=this.currentAnimateTimings,i.options=this._copyOptions(),i.updateOptions(t),i.currentQueryIndex=this.currentQueryIndex,i.currentQueryTotal=this.currentQueryTotal,i.parentContext=this,this.subContextCount++,i}transformIntoNewTimeline(t){return this.previousNode=bx,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,r){const s={duration:e??t.duration,delay:this.currentTimeline.currentTime+(r??0)+t.delay,easing:""},i=new s2e(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,s,t.stretchStartingKeyframe);return this.timelines.push(i),s}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,r,s,i,o){let a=[];if(s&&a.push(this.element),t.length>0){t=(t=t.replace(e2e,"."+this._enterClassName)).replace(n2e,"."+this._leaveClassName);let c=this._driver.query(this.element,t,1!=r);0!==r&&(c=r<0?c.slice(c.length+r,c.length):c.slice(0,r)),a.push(...c)}return!i&&0==a.length&&o.push(function lOe(n){return new te(3014,!1)}()),a}}class _x{constructor(t,e,r,s){this._driver=t,this.element=e,this.startTime=r,this._elementTimelineStylesLookup=s,this.duration=0,this._previousKeyframe=new Map,this._currentKeyframe=new Map,this._keyframes=new Map,this._styleSummary=new Map,this._localTimelineStyles=new Map,this._pendingStyles=new Map,this._backFill=new Map,this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.hasCurrentStyleProperties();default:return!0}}hasCurrentStyleProperties(){return this._currentKeyframe.size>0}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1===this._keyframes.size&&this._pendingStyles.size;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new _x(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=new Map,this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles.set(t,e),this._globalTimelineStyles.set(t,e),this._styleSummary.set(t,{time:this.currentTime,value:e})}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&this._previousKeyframe.set("easing",t);for(let[e,r]of this._globalTimelineStyles)this._backFill.set(e,r||Ia),this._currentKeyframe.set(e,Ia);this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,r,s){e&&this._previousKeyframe.set("easing",e);const i=s&&s.params||{},o=function i2e(n,t){const e=new Map;let r;return n.forEach(s=>{if("*"===s){r=r||t.keys();for(let i of r)e.set(i,Ia)}else Tl(s,e)}),e}(t,this._globalTimelineStyles);for(let[a,l]of o){const c=Nm(l,i,r);this._pendingStyles.set(a,c),this._localTimelineStyles.has(a)||this._backFill.set(a,this._globalTimelineStyles.get(a)??Ia),this._updateStyle(a,c)}}applyStylesToKeyframe(){0!=this._pendingStyles.size&&(this._pendingStyles.forEach((t,e)=>{this._currentKeyframe.set(e,t)}),this._pendingStyles.clear(),this._localTimelineStyles.forEach((t,e)=>{this._currentKeyframe.has(e)||this._currentKeyframe.set(e,t)}))}snapshotCurrentStyles(){for(let[t,e]of this._localTimelineStyles)this._pendingStyles.set(t,e),this._updateStyle(t,e)}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){t._styleSummary.forEach((e,r)=>{const s=this._styleSummary.get(r);(!s||e.time>s.time)&&this._updateStyle(r,e.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,r=1===this._keyframes.size&&0===this.duration;let s=[];this._keyframes.forEach((a,l)=>{const c=Tl(a,new Map,this._backFill);c.forEach((u,d)=>{"!"===u?t.add(d):u===Ia&&e.add(d)}),r||c.set("offset",l/this.duration),s.push(c)});const i=t.size?dx(t.values()):[],o=e.size?dx(e.values()):[];if(r){const a=s[0],l=new Map(a);a.set("offset",0),l.set("offset",1),s=[a,l]}return Ak(this.element,s,i,o,this.duration,this.startTime,this.easing,!1)}}class s2e extends _x{constructor(t,e,r,s,i,o,a=!1){super(t,e,o.delay),this.keyframes=r,this.preStyleProps=s,this.postStyleProps=i,this._stretchStartingKeyframe=a,this.timings={duration:o.duration,delay:o.delay,easing:o.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:r,easing:s}=this.timings;if(this._stretchStartingKeyframe&&e){const i=[],o=r+e,a=e/o,l=Tl(t[0]);l.set("offset",0),i.push(l);const c=Tl(t[0]);c.set("offset",Bj(a)),i.push(c);const u=t.length-1;for(let d=1;d<=u;d++){let h=Tl(t[d]);const f=h.get("offset");h.set("offset",Bj((e+f*r)/o)),i.push(h)}r=o,e=0,s="",t=i}return Ak(this.element,t,this.preStyleProps,this.postStyleProps,r,e,s,!0)}}function Bj(n,t=3){const e=Math.pow(10,t-1);return Math.round(n*e)/e}class Fk{}const o2e=new Set(["width","height","minWidth","minHeight","maxWidth","maxHeight","left","top","bottom","right","fontSize","outlineWidth","outlineOffset","paddingTop","paddingLeft","paddingBottom","paddingRight","marginTop","marginLeft","marginBottom","marginRight","borderRadius","borderWidth","borderTopWidth","borderLeftWidth","borderRightWidth","borderBottomWidth","textIndent","perspective"]);class a2e extends Fk{normalizePropertyName(t,e){return Tk(t)}normalizeStyleValue(t,e,r,s){let i="";const o=r.toString().trim();if(o2e.has(e)&&0!==r&&"0"!==r)if("number"==typeof r)i="px";else{const a=r.match(/^[+-]?[\d\.]+([a-z]*)$/);a&&0==a[1].length&&s.push(function ZFe(n,t){return new te(3005,!1)}())}return o+i}}function zj(n,t,e,r,s,i,o,a,l,c,u,d,h){return{type:0,element:n,triggerName:t,isRemovalTransition:s,fromState:e,fromStyles:i,toState:r,toStyles:o,timelines:a,queriedElements:l,preStyleProps:c,postStyleProps:u,totalTime:d,errors:h}}const Ok={};class Uj{constructor(t,e,r){this._triggerName=t,this.ast=e,this._stateStyles=r}match(t,e,r,s){return function l2e(n,t,e,r,s){return n.some(i=>i(t,e,r,s))}(this.ast.matchers,t,e,r,s)}buildStyles(t,e,r){let s=this._stateStyles.get("*");return void 0!==t&&(s=this._stateStyles.get(t?.toString())||s),s?s.buildStyles(e,r):new Map}build(t,e,r,s,i,o,a,l,c,u){const d=[],h=this.ast.options&&this.ast.options.params||Ok,p=this.buildStyles(r,a&&a.params||Ok,d),m=l&&l.params||Ok,g=this.buildStyles(s,m,d),y=new Set,b=new Map,_=new Map,v="void"===s,w={params:c2e(m,h),delay:this.ast.options?.delay},C=u?[]:Rk(t,e,this.ast.animation,i,o,p,g,w,c,d);let I=0;if(C.forEach(T=>{I=Math.max(T.duration+T.delay,I)}),d.length)return zj(e,this._triggerName,r,s,v,p,g,[],[],b,_,I,d);C.forEach(T=>{const N=T.element,P=ci(b,N,new Set);T.preStyleProps.forEach(W=>P.add(W));const z=ci(_,N,new Set);T.postStyleProps.forEach(W=>z.add(W)),N!==e&&y.add(N)});const D=dx(y.values());return zj(e,this._triggerName,r,s,v,p,g,C,D,b,_,I)}}function c2e(n,t){const e=Tm(t);for(const r in n)n.hasOwnProperty(r)&&null!=n[r]&&(e[r]=n[r]);return e}class u2e{constructor(t,e,r){this.styles=t,this.defaultParams=e,this.normalizer=r}buildStyles(t,e){const r=new Map,s=Tm(this.defaultParams);return Object.keys(t).forEach(i=>{const o=t[i];null!==o&&(s[i]=o)}),this.styles.styles.forEach(i=>{"string"!=typeof i&&i.forEach((o,a)=>{o&&(o=Nm(o,s,e));const l=this.normalizer.normalizePropertyName(a,e);o=this.normalizer.normalizeStyleValue(a,l,o,e),r.set(l,o)})}),r}}class h2e{constructor(t,e,r){this.name=t,this.ast=e,this._normalizer=r,this.transitionFactories=[],this.states=new Map,e.states.forEach(s=>{this.states.set(s.name,new u2e(s.style,s.options&&s.options.params||{},r))}),Hj(this.states,"true","1"),Hj(this.states,"false","0"),e.transitions.forEach(s=>{this.transitionFactories.push(new Uj(t,s,this.states))}),this.fallbackTransition=function f2e(n,t,e){return new Uj(n,{type:1,animation:{type:2,steps:[],options:null},matchers:[(o,a)=>!0],options:null,queryCount:0,depCount:0},t)}(t,this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,r,s){return this.transitionFactories.find(o=>o.match(t,e,r,s))||null}matchStyles(t,e,r){return this.fallbackTransition.buildStyles(t,e,r)}}function Hj(n,t,e){n.has(t)?n.has(e)||n.set(e,n.get(t)):n.has(e)&&n.set(t,n.get(e))}const p2e=new yx;class m2e{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._animations=new Map,this._playersById=new Map,this.players=[]}register(t,e){const r=[],i=kk(this._driver,e,r,[]);if(r.length)throw function mOe(n){return new te(3503,!1)}();this._animations.set(t,i)}_buildPlayer(t,e,r){const s=t.element,i=xj(0,this._normalizer,0,t.keyframes,e,r);return this._driver.animate(s,i,t.duration,t.delay,t.easing,[],!0)}create(t,e,r={}){const s=[],i=this._animations.get(t);let o;const a=new Map;if(i?(o=Rk(this._driver,e,i,Sk,ax,new Map,new Map,r,p2e,s),o.forEach(u=>{const d=ci(a,u.element,new Map);u.postStyleProps.forEach(h=>d.set(h,null))})):(s.push(function gOe(){return new te(3300,!1)}()),o=[]),s.length)throw function yOe(n){return new te(3504,!1)}();a.forEach((u,d)=>{u.forEach((h,f)=>{u.set(f,this._driver.computeStyle(d,f,Ia))})});const c=Dl(o.map(u=>{const d=a.get(u.element);return this._buildPlayer(u,new Map,d)}));return this._playersById.set(t,c),c.onDestroy(()=>this.destroy(t)),this.players.push(c),c}destroy(t){const e=this._getPlayer(t);e.destroy(),this._playersById.delete(t);const r=this.players.indexOf(e);r>=0&&this.players.splice(r,1)}_getPlayer(t){const e=this._playersById.get(t);if(!e)throw function bOe(n){return new te(3301,!1)}();return e}listen(t,e,r,s){const i=vk(e,"","","");return bk(this._getPlayer(t),r,i,s),()=>{}}command(t,e,r,s){if("register"==r)return void this.register(t,s[0]);if("create"==r)return void this.create(t,e,s[0]||{});const i=this._getPlayer(t);switch(r){case"play":i.play();break;case"pause":i.pause();break;case"reset":i.reset();break;case"restart":i.restart();break;case"finish":i.finish();break;case"init":i.init();break;case"setPosition":i.setPosition(parseFloat(s[0]));break;case"destroy":this.destroy(t)}}}const Wj="ng-animate-queued",$k="ng-animate-disabled",v2e=[],jj={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},x2e={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0},zi="__ng_removed";class Pk{constructor(t,e=""){this.namespaceId=e;const r=t&&t.hasOwnProperty("value");if(this.value=function E2e(n){return n??null}(r?t.value:t),r){const i=Tm(t);delete i.value,this.options=i}else this.options={};this.options.params||(this.options.params={})}get params(){return this.options.params}absorbOptions(t){const e=t.params;if(e){const r=this.options.params;Object.keys(e).forEach(s=>{null==r[s]&&(r[s]=e[s])})}}}const Am="void",Lk=new Pk(Am);class w2e{constructor(t,e,r){this.id=t,this.hostElement=e,this._engine=r,this.players=[],this._triggers=new Map,this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,Ui(e,this._hostClassName)}listen(t,e,r,s){if(!this._triggers.has(e))throw function _Oe(n,t){return new te(3302,!1)}();if(null==r||0==r.length)throw function vOe(n){return new te(3303,!1)}();if(!function I2e(n){return"start"==n||"done"==n}(r))throw function xOe(n,t){return new te(3400,!1)}();const i=ci(this._elementListeners,t,[]),o={name:e,phase:r,callback:s};i.push(o);const a=ci(this._engine.statesByElement,t,new Map);return a.has(e)||(Ui(t,lx),Ui(t,lx+"-"+e),a.set(e,Lk)),()=>{this._engine.afterFlush(()=>{const l=i.indexOf(o);l>=0&&i.splice(l,1),this._triggers.has(e)||a.delete(e)})}}register(t,e){return!this._triggers.has(t)&&(this._triggers.set(t,e),!0)}_getTrigger(t){const e=this._triggers.get(t);if(!e)throw function wOe(n){return new te(3401,!1)}();return e}trigger(t,e,r,s=!0){const i=this._getTrigger(e),o=new Vk(this.id,e,t);let a=this._engine.statesByElement.get(t);a||(Ui(t,lx),Ui(t,lx+"-"+e),this._engine.statesByElement.set(t,a=new Map));let l=a.get(e);const c=new Pk(r,this.id);if(!(r&&r.hasOwnProperty("value"))&&l&&c.absorbOptions(l.options),a.set(e,c),l||(l=Lk),c.value!==Am&&l.value===c.value){if(!function k2e(n,t){const e=Object.keys(n),r=Object.keys(t);if(e.length!=r.length)return!1;for(let s=0;s<e.length;s++){const i=e[s];if(!t.hasOwnProperty(i)||n[i]!==t[i])return!1}return!0}(l.params,c.params)){const m=[],g=i.matchStyles(l.value,l.params,m),y=i.matchStyles(c.value,c.params,m);m.length?this._engine.reportError(m):this._engine.afterFlush(()=>{Pc(t,g),Wo(t,y)})}return}const h=ci(this._engine.playersByElement,t,[]);h.forEach(m=>{m.namespaceId==this.id&&m.triggerName==e&&m.queued&&m.destroy()});let f=i.matchTransition(l.value,c.value,t,c.params),p=!1;if(!f){if(!s)return;f=i.fallbackTransition,p=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:f,fromState:l,toState:c,player:o,isFallbackTransition:p}),p||(Ui(t,Wj),o.onStart(()=>{Yd(t,Wj)})),o.onDone(()=>{let m=this.players.indexOf(o);m>=0&&this.players.splice(m,1);const g=this._engine.playersByElement.get(t);if(g){let y=g.indexOf(o);y>=0&&g.splice(y,1)}}),this.players.push(o),h.push(o),o}deregister(t){this._triggers.delete(t),this._engine.statesByElement.forEach(e=>e.delete(t)),this._elementListeners.forEach((e,r)=>{this._elementListeners.set(r,e.filter(s=>s.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(r=>r.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const r=this._engine.driver.query(t,cx,!0);r.forEach(s=>{if(s[zi])return;const i=this._engine.fetchNamespacesByElement(s);i.size?i.forEach(o=>o.triggerLeaveAnimation(s,e,!1,!0)):this.clearElementCache(s)}),this._engine.afterFlushAnimationsDone(()=>r.forEach(s=>this.clearElementCache(s)))}triggerLeaveAnimation(t,e,r,s){const i=this._engine.statesByElement.get(t),o=new Map;if(i){const a=[];if(i.forEach((l,c)=>{if(o.set(c,l.value),this._triggers.has(c)){const u=this.trigger(t,c,Am,s);u&&a.push(u)}}),a.length)return this._engine.markElementAsRemoved(this.id,t,!0,e,o),r&&Dl(a).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),r=this._engine.statesByElement.get(t);if(e&&r){const s=new Set;e.forEach(i=>{const o=i.name;if(s.has(o))return;s.add(o);const l=this._triggers.get(o).fallbackTransition,c=r.get(o)||Lk,u=new Pk(Am),d=new Vk(this.id,o,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:o,transition:l,fromState:c,toState:u,player:d,isFallbackTransition:!0})})}}removeNode(t,e){const r=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let s=!1;if(r.totalAnimations){const i=r.players.length?r.playersByQueriedElement.get(t):[];if(i&&i.length)s=!0;else{let o=t;for(;o=o.parentNode;)if(r.statesByElement.get(o)){s=!0;break}}}if(this.prepareLeaveAnimationListeners(t),s)r.markElementAsRemoved(this.id,t,!1,e);else{const i=t[zi];(!i||i===jj)&&(r.afterFlush(()=>this.clearElementCache(t)),r.destroyInnerAnimations(t),r._onRemovalComplete(t,e))}}insertNode(t,e){Ui(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(r=>{const s=r.player;if(s.destroyed)return;const i=r.element,o=this._elementListeners.get(i);o&&o.forEach(a=>{if(a.name==r.triggerName){const l=vk(i,r.triggerName,r.fromState.value,r.toState.value);l._data=t,bk(r.player,a.phase,l,a.callback)}}),s.markedForDestroy?this._engine.afterFlush(()=>{s.destroy()}):e.push(r)}),this._queue=[],e.sort((r,s)=>{const i=r.transition.ast.depCount,o=s.transition.ast.depCount;return 0==i||0==o?i-o:this._engine.driver.containsElement(r.element,s.element)?1:-1})}destroy(t){this.players.forEach(e=>e.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(r=>r.element===t)||e,e}}class C2e{constructor(t,e,r){this.bodyNode=t,this.driver=e,this._normalizer=r,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(s,i)=>{}}_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(r=>{r.queued&&t.push(r)})}),t}createNamespace(t,e){const r=new w2e(t,e,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,e)?this._balanceNamespaceList(r,e):(this.newHostElements.set(e,r),this.collectEnterElement(e)),this._namespaceLookup[t]=r}_balanceNamespaceList(t,e){const r=this._namespaceList,s=this.namespacesByHostElement;if(r.length-1>=0){let o=!1,a=this.driver.getParentElement(e);for(;a;){const l=s.get(a);if(l){const c=r.indexOf(l);r.splice(c+1,0,t),o=!0;break}a=this.driver.getParentElement(a)}o||r.unshift(t)}else r.push(t);return s.set(e,t),t}register(t,e){let r=this._namespaceLookup[t];return r||(r=this.createNamespace(t,e)),r}registerTrigger(t,e,r){let s=this._namespaceLookup[t];s&&s.register(e,r)&&this.totalAnimations++}destroy(t,e){if(!t)return;const r=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(r.hostElement),delete this._namespaceLookup[t];const s=this._namespaceList.indexOf(r);s>=0&&this._namespaceList.splice(s,1)}),this.afterFlushAnimationsDone(()=>r.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,r=this.statesByElement.get(t);if(r)for(let s of r.values())if(s.namespaceId){const i=this._fetchNamespace(s.namespaceId);i&&e.add(i)}return e}trigger(t,e,r,s){if(vx(e)){const i=this._fetchNamespace(t);if(i)return i.trigger(e,r,s),!0}return!1}insertNode(t,e,r,s){if(!vx(e))return;const i=e[zi];if(i&&i.setForRemoval){i.setForRemoval=!1,i.setForMove=!0;const o=this.collectedLeaveElements.indexOf(e);o>=0&&this.collectedLeaveElements.splice(o,1)}if(t){const o=this._fetchNamespace(t);o&&o.insertNode(e,r)}s&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),Ui(t,$k)):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),Yd(t,$k))}removeNode(t,e,r,s){if(vx(e)){const i=t?this._fetchNamespace(t):null;if(i?i.removeNode(e,s):this.markElementAsRemoved(t,e,!1,s),r){const o=this.namespacesByHostElement.get(e);o&&o.id!==t&&o.removeNode(e,s)}}else this._onRemovalComplete(e,s)}markElementAsRemoved(t,e,r,s,i){this.collectedLeaveElements.push(e),e[zi]={namespaceId:t,setForRemoval:s,hasAnimation:r,removedBeforeQueried:!1,previousTriggersValues:i}}listen(t,e,r,s,i){return vx(e)?this._fetchNamespace(t).listen(e,r,s,i):()=>{}}_buildInstruction(t,e,r,s,i){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,r,s,t.fromState.options,t.toState.options,e,i)}destroyInnerAnimations(t){let e=this.driver.query(t,cx,!0);e.forEach(r=>this.destroyActiveAnimationsForElement(r)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,Ek,!0),e.forEach(r=>this.finishActiveQueriedAnimationOnElement(r)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(r=>{r.queued?r.markedForDestroy=!0:r.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(r=>r.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return Dl(this.players).onDone(()=>t());t()})}processLeaveNode(t){const e=t[zi];if(e&&e.setForRemoval){if(t[zi]=jj,e.namespaceId){this.destroyInnerAnimations(t);const r=this._fetchNamespace(e.namespaceId);r&&r.clearElementCache(t)}this._onRemovalComplete(t,e.setForRemoval)}t.classList?.contains($k)&&this.markElementAsDisabled(t,!1),this.driver.query(t,".ng-animate-disabled",!0).forEach(r=>{this.markElementAsDisabled(r,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((r,s)=>this._balanceNamespaceList(r,s)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let r=0;r<this.collectedEnterElements.length;r++)Ui(this.collectedEnterElements[r],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const r=[];try{e=this._flushAnimations(r,t)}finally{for(let s=0;s<r.length;s++)r[s]()}}else for(let r=0;r<this.collectedLeaveElements.length;r++)this.processLeaveNode(this.collectedLeaveElements[r]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(r=>r()),this._flushFns=[],this._whenQuietFns.length){const r=this._whenQuietFns;this._whenQuietFns=[],e.length?Dl(e).onDone(()=>{r.forEach(s=>s())}):r.forEach(s=>s())}}reportError(t){throw function COe(n){return new te(3402,!1)}()}_flushAnimations(t,e){const r=new yx,s=[],i=new Map,o=[],a=new Map,l=new Map,c=new Map,u=new Set;this.disabledNodes.forEach($=>{u.add($);const V=this.driver.query($,".ng-animate-queued",!0);for(let L=0;L<V.length;L++)u.add(V[L])});const d=this.bodyNode,h=Array.from(this.statesByElement.keys()),f=Kj(h,this.collectedEnterElements),p=new Map;let m=0;f.forEach(($,V)=>{const L=Sk+m++;p.set(V,L),$.forEach(H=>Ui(H,L))});const g=[],y=new Set,b=new Set;for(let $=0;$<this.collectedLeaveElements.length;$++){const V=this.collectedLeaveElements[$],L=V[zi];L&&L.setForRemoval&&(g.push(V),y.add(V),L.hasAnimation?this.driver.query(V,".ng-star-inserted",!0).forEach(H=>y.add(H)):b.add(V))}const _=new Map,v=Kj(h,Array.from(y));v.forEach(($,V)=>{const L=ax+m++;_.set(V,L),$.forEach(H=>Ui(H,L))}),t.push(()=>{f.forEach(($,V)=>{const L=p.get(V);$.forEach(H=>Yd(H,L))}),v.forEach(($,V)=>{const L=_.get(V);$.forEach(H=>Yd(H,L))}),g.forEach($=>{this.processLeaveNode($)})});const w=[],C=[];for(let $=this._namespaceList.length-1;$>=0;$--)this._namespaceList[$].drainQueuedTransitions(e).forEach(L=>{const H=L.player,ne=L.element;if(w.push(H),this.collectedEnterElements.length){const _e=ne[zi];if(_e&&_e.setForMove){if(_e.previousTriggersValues&&_e.previousTriggersValues.has(L.triggerName)){const Me=_e.previousTriggersValues.get(L.triggerName),ke=this.statesByElement.get(L.element);if(ke&&ke.has(L.triggerName)){const Ze=ke.get(L.triggerName);Ze.value=Me,ke.set(L.triggerName,Ze)}}return void H.destroy()}}const ie=!d||!this.driver.containsElement(d,ne),de=_.get(ne),ue=p.get(ne),he=this._buildInstruction(L,r,ue,de,ie);if(he.errors&&he.errors.length)return void C.push(he);if(ie)return H.onStart(()=>Pc(ne,he.fromStyles)),H.onDestroy(()=>Wo(ne,he.toStyles)),void s.push(H);if(L.isFallbackTransition)return H.onStart(()=>Pc(ne,he.fromStyles)),H.onDestroy(()=>Wo(ne,he.toStyles)),void s.push(H);const ge=[];he.timelines.forEach(_e=>{_e.stretchStartingKeyframe=!0,this.disabledNodes.has(_e.element)||ge.push(_e)}),he.timelines=ge,r.append(ne,he.timelines),o.push({instruction:he,player:H,element:ne}),he.queriedElements.forEach(_e=>ci(a,_e,[]).push(H)),he.preStyleProps.forEach((_e,Me)=>{if(_e.size){let ke=l.get(Me);ke||l.set(Me,ke=new Set),_e.forEach((Ze,at)=>ke.add(at))}}),he.postStyleProps.forEach((_e,Me)=>{let ke=c.get(Me);ke||c.set(Me,ke=new Set),_e.forEach((Ze,at)=>ke.add(at))})});if(C.length){const $=[];C.forEach(V=>{$.push(function SOe(n,t){return new te(3505,!1)}())}),w.forEach(V=>V.destroy()),this.reportError($)}const I=new Map,D=new Map;o.forEach($=>{const V=$.element;r.has(V)&&(D.set(V,V),this._beforeAnimationBuild($.player.namespaceId,$.instruction,I))}),s.forEach($=>{const V=$.element;this._getPreviousPlayers(V,!1,$.namespaceId,$.triggerName,null).forEach(H=>{ci(I,V,[]).push(H),H.destroy()})});const T=g.filter($=>Yj($,l,c)),N=new Map;qj(N,this.driver,b,c,Ia).forEach($=>{Yj($,l,c)&&T.push($)});const z=new Map;f.forEach(($,V)=>{qj(z,this.driver,new Set($),l,"!")}),T.forEach($=>{const V=N.get($),L=z.get($);N.set($,new Map([...Array.from(V?.entries()??[]),...Array.from(L?.entries()??[])]))});const W=[],G=[],q={};o.forEach($=>{const{element:V,player:L,instruction:H}=$;if(r.has(V)){if(u.has(V))return L.onDestroy(()=>Wo(V,H.toStyles)),L.disabled=!0,L.overrideTotalTime(H.totalTime),void s.push(L);let ne=q;if(D.size>1){let de=V;const ue=[];for(;de=de.parentNode;){const he=D.get(de);if(he){ne=he;break}ue.push(de)}ue.forEach(he=>D.set(he,ne))}const ie=this._buildAnimation(L.namespaceId,H,I,i,z,N);if(L.setRealPlayer(ie),ne===q)W.push(L);else{const de=this.playersByElement.get(ne);de&&de.length&&(L.parentPlayer=Dl(de)),s.push(L)}}else Pc(V,H.fromStyles),L.onDestroy(()=>Wo(V,H.toStyles)),G.push(L),u.has(V)&&s.push(L)}),G.forEach($=>{const V=i.get($.element);if(V&&V.length){const L=Dl(V);$.setRealPlayer(L)}}),s.forEach($=>{$.parentPlayer?$.syncPlayerEvents($.parentPlayer):$.destroy()});for(let $=0;$<g.length;$++){const V=g[$],L=V[zi];if(Yd(V,ax),L&&L.hasAnimation)continue;let H=[];if(a.size){let ie=a.get(V);ie&&ie.length&&H.push(...ie);let de=this.driver.query(V,Ek,!0);for(let ue=0;ue<de.length;ue++){let he=a.get(de[ue]);he&&he.length&&H.push(...he)}}const ne=H.filter(ie=>!ie.destroyed);ne.length?D2e(this,V,ne):this.processLeaveNode(V)}return g.length=0,W.forEach($=>{this.players.push($),$.onDone(()=>{$.destroy();const V=this.players.indexOf($);this.players.splice(V,1)}),$.play()}),W}elementContainsData(t,e){let r=!1;const s=e[zi];return s&&s.setForRemoval&&(r=!0),this.playersByElement.has(e)&&(r=!0),this.playersByQueriedElement.has(e)&&(r=!0),this.statesByElement.has(e)&&(r=!0),this._fetchNamespace(t).elementContainsData(e)||r}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,r,s,i){let o=[];if(e){const a=this.playersByQueriedElement.get(t);a&&(o=a)}else{const a=this.playersByElement.get(t);if(a){const l=!i||i==Am;a.forEach(c=>{c.queued||!l&&c.triggerName!=s||o.push(c)})}}return(r||s)&&(o=o.filter(a=>!(r&&r!=a.namespaceId||s&&s!=a.triggerName))),o}_beforeAnimationBuild(t,e,r){const i=e.element,o=e.isRemovalTransition?void 0:t,a=e.isRemovalTransition?void 0:e.triggerName;for(const l of e.timelines){const c=l.element,u=c!==i,d=ci(r,c,[]);this._getPreviousPlayers(c,u,o,a,e.toState).forEach(f=>{const p=f.getRealPlayer();p.beforeDestroy&&p.beforeDestroy(),f.destroy(),d.push(f)})}Pc(i,e.fromStyles)}_buildAnimation(t,e,r,s,i,o){const a=e.triggerName,l=e.element,c=[],u=new Set,d=new Set,h=e.timelines.map(p=>{const m=p.element;u.add(m);const g=m[zi];if(g&&g.removedBeforeQueried)return new Cm(p.duration,p.delay);const y=m!==l,b=function T2e(n){const t=[];return Xj(n,t),t}((r.get(m)||v2e).map(I=>I.getRealPlayer())).filter(I=>!!I.element&&I.element===m),_=i.get(m),v=o.get(m),w=xj(0,this._normalizer,0,p.keyframes,_,v),C=this._buildPlayer(p,w,b);if(p.subTimeline&&s&&d.add(m),y){const I=new Vk(t,a,m);I.setRealPlayer(C),c.push(I)}return C});c.forEach(p=>{ci(this.playersByQueriedElement,p.element,[]).push(p),p.onDone(()=>function S2e(n,t,e){let r=n.get(t);if(r){if(r.length){const s=r.indexOf(e);r.splice(s,1)}0==r.length&&n.delete(t)}return r}(this.playersByQueriedElement,p.element,p))}),u.forEach(p=>Ui(p,Nj));const f=Dl(h);return f.onDestroy(()=>{u.forEach(p=>Yd(p,Nj)),Wo(l,e.toStyles)}),d.forEach(p=>{ci(s,p,[]).push(f)}),f}_buildPlayer(t,e,r){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,r):new Cm(t.duration,t.delay)}}class Vk{constructor(t,e,r){this.namespaceId=t,this.triggerName=e,this.element=r,this._player=new Cm,this._containsRealPlayer=!1,this._queuedCallbacks=new Map,this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,this._queuedCallbacks.forEach((e,r)=>{e.forEach(s=>bk(t,r,void 0,s))}),this._queuedCallbacks.clear(),this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){ci(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function vx(n){return n&&1===n.nodeType}function Gj(n,t){const e=n.style.display;return n.style.display=t??"none",e}function qj(n,t,e,r,s){const i=[];e.forEach(l=>i.push(Gj(l)));const o=[];r.forEach((l,c)=>{const u=new Map;l.forEach(d=>{const h=t.computeStyle(c,d,s);u.set(d,h),(!h||0==h.length)&&(c[zi]=x2e,o.push(c))}),n.set(c,u)});let a=0;return e.forEach(l=>Gj(l,i[a++])),o}function Kj(n,t){const e=new Map;if(n.forEach(a=>e.set(a,[])),0==t.length)return e;const s=new Set(t),i=new Map;function o(a){if(!a)return 1;let l=i.get(a);if(l)return l;const c=a.parentNode;return l=e.has(c)?c:s.has(c)?1:o(c),i.set(a,l),l}return t.forEach(a=>{const l=o(a);1!==l&&e.get(l).push(a)}),e}function Ui(n,t){n.classList?.add(t)}function Yd(n,t){n.classList?.remove(t)}function D2e(n,t,e){Dl(e).onDone(()=>n.processLeaveNode(t))}function Xj(n,t){for(let e=0;e<n.length;e++){const r=n[e];r instanceof hW?Xj(r.players,t):t.push(r)}}function Yj(n,t,e){const r=e.get(n);if(!r)return!1;let s=t.get(n);return s?r.forEach(i=>s.add(i)):t.set(n,r),e.delete(n),!0}class xx{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._triggerCache={},this.onRemovalComplete=(s,i)=>{},this._transitionEngine=new C2e(t,e,r),this._timelineEngine=new m2e(t,e,r),this._transitionEngine.onRemovalComplete=(s,i)=>this.onRemovalComplete(s,i)}registerTrigger(t,e,r,s,i){const o=t+"-"+s;let a=this._triggerCache[o];if(!a){const l=[],u=kk(this._driver,i,l,[]);if(l.length)throw function fOe(n,t){return new te(3404,!1)}();a=function d2e(n,t,e){return new h2e(n,t,e)}(s,u,this._normalizer),this._triggerCache[o]=a}this._transitionEngine.registerTrigger(e,s,a)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,r,s){this._transitionEngine.insertNode(t,e,r,s)}onRemove(t,e,r,s){this._transitionEngine.removeNode(t,e,s||!1,r)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,r,s){if("@"==r.charAt(0)){const[i,o]=wj(r);this._timelineEngine.command(i,e,o,s)}else this._transitionEngine.trigger(t,e,r,s)}listen(t,e,r,s,i){if("@"==r.charAt(0)){const[o,a]=wj(r);return this._timelineEngine.listen(o,e,a,i)}return this._transitionEngine.listen(t,e,r,s,i)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}let A2e=(()=>{class n{constructor(e,r,s){this._element=e,this._startStyles=r,this._endStyles=s,this._state=0;let i=n.initialStylesByElement.get(e);i||n.initialStylesByElement.set(e,i=new Map),this._initialStyles=i}start(){this._state<1&&(this._startStyles&&Wo(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(Wo(this._element,this._initialStyles),this._endStyles&&(Wo(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(n.initialStylesByElement.delete(this._element),this._startStyles&&(Pc(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(Pc(this._element,this._endStyles),this._endStyles=null),Wo(this._element,this._initialStyles),this._state=3)}}return n.initialStylesByElement=new WeakMap,n})();function Bk(n){let t=null;return n.forEach((e,r)=>{(function R2e(n){return"display"===n||"position"===n})(r)&&(t=t||new Map,t.set(r,e))}),t}class Zj{constructor(t,e,r,s){this.element=t,this.keyframes=e,this.options=r,this._specialStyles=s,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this._originalOnDoneFns=[],this._originalOnStartFns=[],this.time=0,this.parentPlayer=null,this.currentSnapshot=new Map,this._duration=r.duration,this._delay=r.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:new Map,this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_convertKeyframesToObject(t){const e=[];return t.forEach(r=>{e.push(Object.fromEntries(r))}),e}_triggerWebAnimation(t,e,r){return t.animate(this._convertKeyframesToObject(e),r)}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t=new Map;this.hasStarted()&&this._finalKeyframe.forEach((r,s)=>{"offset"!==s&&t.set(s,this._finished?r:$j(this.element,s))}),this.currentSnapshot=t}triggerCallback(t){const e="start"===t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class M2e{validateStyleProperty(t){return!0}validateAnimatableStyleProperty(t){return!0}matchesElement(t,e){return!1}containsElement(t,e){return Ij(t,e)}getParentElement(t){return wk(t)}query(t,e,r){return Dj(t,e,r)}computeStyle(t,e,r){return window.getComputedStyle(t)[e]}animate(t,e,r,s,i,o=[]){const l={duration:r,delay:s,fill:0==s?"both":"forwards"};i&&(l.easing=i);const c=new Map,u=o.filter(f=>f instanceof Zj);(function POe(n,t){return 0===n||0===t})(r,s)&&u.forEach(f=>{f.currentSnapshot.forEach((p,m)=>c.set(m,p))});let d=function MOe(n){return n.length?n[0]instanceof Map?n:n.map(t=>Aj(t)):[]}(e).map(f=>Tl(f));d=function LOe(n,t,e){if(e.size&&t.length){let r=t[0],s=[];if(e.forEach((i,o)=>{r.has(o)||s.push(o),r.set(o,i)}),s.length)for(let i=1;i<t.length;i++){let o=t[i];s.forEach(a=>o.set(a,$j(n,a)))}}return t}(t,d,c);const h=function N2e(n,t){let e=null,r=null;return Array.isArray(t)&&t.length?(e=Bk(t[0]),t.length>1&&(r=Bk(t[t.length-1]))):t instanceof Map&&(e=Bk(t)),e||r?new A2e(n,e,r):null}(t,d);return new Zj(t,d,l,h)}}let F2e=(()=>{class n extends cW{constructor(e,r){super(),this._nextAnimationId=0,this._renderer=e.createRenderer(r.body,{id:"0",encapsulation:Wi.None,styles:[],data:{animation:[]}})}build(e){const r=this._nextAnimationId.toString();this._nextAnimationId++;const s=Array.isArray(e)?uW(e):e;return Qj(this._renderer,null,r,"register",[s]),new O2e(r,this._renderer)}}return n.\u0275fac=function(e){return new(e||n)(J(Eh),J(Et))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac}),n})();class O2e extends ZRe{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new $2e(this._id,t,e||{},this._renderer)}}class $2e{constructor(t,e,r,s){this.id=t,this.element=e,this._renderer=s,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",r)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return Qj(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset"),this._started=!1}setPosition(t){this._command("setPosition",t)}getPosition(){return this._renderer.engine.players[+this.id]?.getPosition()??0}}function Qj(n,t,e,r,s){return n.setProperty(t,`@@${e}:${r}`,s)}const Jj="@.disabled";let P2e=(()=>{class n{constructor(e,r,s){this.delegate=e,this.engine=r,this._zone=s,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),r.onRemovalComplete=(i,o)=>{const a=o?.parentNode(i);a&&o.removeChild(a,i)}}createRenderer(e,r){const i=this.delegate.createRenderer(e,r);if(!(e&&r&&r.data&&r.data.animation)){let u=this._rendererCache.get(i);return u||(u=new eG("",i,this.engine,()=>this._rendererCache.delete(i)),this._rendererCache.set(i,u)),u}const o=r.id,a=r.id+"-"+this._currentId;this._currentId++,this.engine.register(a,e);const l=u=>{Array.isArray(u)?u.forEach(l):this.engine.registerTrigger(o,a,e,u.name,u)};return r.data.animation.forEach(l),new L2e(this,a,i,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(e,r,s){e>=0&&e<this._microtaskId?this._zone.run(()=>r(s)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(i=>{const[o,a]=i;o(a)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([r,s]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return n.\u0275fac=function(e){return new(e||n)(J(Eh),J(xx),J(St))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac}),n})();class eG{constructor(t,e,r,s){this.namespaceId=t,this.delegate=e,this.engine=r,this._onDestroy=s,this.destroyNode=this.delegate.destroyNode?i=>e.destroyNode(i):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy(),this._onDestroy?.()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,r,s=!0){this.delegate.insertBefore(t,e,r),this.engine.onInsert(this.namespaceId,e,t,s)}removeChild(t,e,r){this.engine.onRemove(this.namespaceId,e,this.delegate,r)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,r,s){this.delegate.setAttribute(t,e,r,s)}removeAttribute(t,e,r){this.delegate.removeAttribute(t,e,r)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,r,s){this.delegate.setStyle(t,e,r,s)}removeStyle(t,e,r){this.delegate.removeStyle(t,e,r)}setProperty(t,e,r){"@"==e.charAt(0)&&e==Jj?this.disableAnimations(t,!!r):this.delegate.setProperty(t,e,r)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,r){return this.delegate.listen(t,e,r)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class L2e extends eG{constructor(t,e,r,s,i){super(e,r,s,i),this.factory=t,this.namespaceId=e}setProperty(t,e,r){"@"==e.charAt(0)?"."==e.charAt(1)&&e==Jj?this.disableAnimations(t,r=void 0===r||!!r):this.engine.process(this.namespaceId,t,e.slice(1),r):this.delegate.setProperty(t,e,r)}listen(t,e,r){if("@"==e.charAt(0)){const s=function V2e(n){switch(n){case"body":return document.body;case"document":return document;case"window":return window;default:return n}}(t);let i=e.slice(1),o="";return"@"!=i.charAt(0)&&([i,o]=function B2e(n){const t=n.indexOf(".");return[n.substring(0,t),n.slice(t+1)]}(i)),this.engine.listen(this.namespaceId,s,i,o,a=>{this.factory.scheduleListenerCallback(a._data||-1,r,a)})}return this.delegate.listen(t,e,r)}}const tG=[{provide:cW,useClass:F2e},{provide:Fk,useFactory:function U2e(){return new a2e}},{provide:xx,useClass:(()=>{class n extends xx{constructor(e,r,s,i){super(e.body,r,s)}ngOnDestroy(){this.flush()}}return n.\u0275fac=function(e){return new(e||n)(J(Et),J(Ck),J(Fk),J(ku))},n.\u0275prov=Ce({token:n,factory:n.\u0275fac}),n})()},{provide:Eh,useFactory:function H2e(n,t,e){return new P2e(n,t,e)},deps:[uy,xx,St]}],zk=[{provide:Ck,useFactory:()=>new M2e},{provide:Va,useValue:"BrowserAnimations"},...tG],nG=[{provide:Ck,useClass:Tj},{provide:Va,useValue:"NoopAnimations"},...tG];let W2e=(()=>{class n{static withConfig(e){return{ngModule:n,providers:e.disableAnimations?nG:zk}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Kt({type:n}),n.\u0275inj=jt({providers:zk,imports:[K2]}),n})();class Cx{static#e=this.\u0275fac=function(e){return new(e||Cx)};static#t=this.\u0275mod=Kt({type:Cx,bootstrap:[ox]});static#n=this.\u0275inj=jt({imports:[K2,Fy,gAe,W2e,XAe,cRe,MFe,jFe,hFe,fFe]})}DQ().bootstrapModule(Cx).catch(n=>console.error(n))},658:xt=>{xt.exports=Z;var yt=null;try{yt=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Z(Q,k,ae){this.low=0|Q,this.high=0|k,this.unsigned=!!ae}function Ue(Q){return!0===(Q&&Q.__isLong__)}Object.defineProperty(Z.prototype,"__isLong__",{value:!0}),Z.isLong=Ue;var Zn={},Ke={};function mn(Q,k){var ae,je,Ct;return k?(Ct=0<=(Q>>>=0)&&Q<256)&&(je=Ke[Q])?je:(ae=Be(Q,(0|Q)<0?-1:0,!0),Ct&&(Ke[Q]=ae),ae):(Ct=-128<=(Q|=0)&&Q<128)&&(je=Zn[Q])?je:(ae=Be(Q,Q<0?-1:0,!1),Ct&&(Zn[Q]=ae),ae)}function lt(Q,k){if(isNaN(Q))return k?Qn:Lt;if(k){if(Q<0)return Qn;if(Q>=fe)return At}else{if(Q<=-Ne)return Rt;if(Q+1>=Ne)return wt}return Q<0?lt(-Q,k).neg():Be(Q%re|0,Q/re|0,k)}function Be(Q,k,ae){return new Z(Q,k,ae)}Z.fromInt=mn,Z.fromNumber=lt,Z.fromBits=Be;var rt=Math.pow;function Ie(Q,k,ae){if(0===Q.length)throw Error("empty string");if("NaN"===Q||"Infinity"===Q||"+Infinity"===Q||"-Infinity"===Q)return Lt;if("number"==typeof k?(ae=k,k=!1):k=!!k,(ae=ae||10)<2||36<ae)throw RangeError("radix");var je;if((je=Q.indexOf("-"))>0)throw Error("interior hyphen");if(0===je)return Ie(Q.substring(1),k,ae).neg();for(var Ct=lt(rt(ae,8)),ct=Lt,He=0;He<Q.length;He+=8){var On=Math.min(8,Q.length-He),Wn=parseInt(Q.substring(He,He+On),ae);if(On<8){var ur=lt(rt(ae,On));ct=ct.mul(ur).add(lt(Wn))}else ct=(ct=ct.mul(Ct)).add(lt(Wn))}return ct.unsigned=k,ct}function U(Q,k){return"number"==typeof Q?lt(Q,k):"string"==typeof Q?Ie(Q,k):Be(Q.low,Q.high,"boolean"==typeof k?k:Q.unsigned)}Z.fromString=Ie,Z.fromValue=U;var re=4294967296,fe=re*re,Ne=fe/2,Fe=mn(1<<24),Lt=mn(0);Z.ZERO=Lt;var Qn=mn(0,!0);Z.UZERO=Qn;var Hn=mn(1);Z.ONE=Hn;var hi=mn(1,!0);Z.UONE=hi;var Os=mn(-1);Z.NEG_ONE=Os;var wt=Be(-1,2147483647,!1);Z.MAX_VALUE=wt;var At=Be(-1,-1,!0);Z.MAX_UNSIGNED_VALUE=At;var Rt=Be(0,-2147483648,!1);Z.MIN_VALUE=Rt;var ce=Z.prototype;ce.toInt=function(){return this.unsigned?this.low>>>0:this.low},ce.toNumber=function(){return this.unsigned?(this.high>>>0)*re+(this.low>>>0):this.high*re+(this.low>>>0)},ce.toString=function(k){if((k=k||10)<2||36<k)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Rt)){var ae=lt(k),je=this.div(ae),Ct=je.mul(ae).sub(this);return je.toString(k)+Ct.toInt().toString(k)}return"-"+this.neg().toString(k)}for(var ct=lt(rt(k,6),this.unsigned),He=this,On="";;){var Wn=He.div(ct),qt=(He.sub(Wn.mul(ct)).toInt()>>>0).toString(k);if((He=Wn).isZero())return qt+On;for(;qt.length<6;)qt="0"+qt;On=""+qt+On}},ce.getHighBits=function(){return this.high},ce.getHighBitsUnsigned=function(){return this.high>>>0},ce.getLowBits=function(){return this.low},ce.getLowBitsUnsigned=function(){return this.low>>>0},ce.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Rt)?64:this.neg().getNumBitsAbs();for(var k=0!=this.high?this.high:this.low,ae=31;ae>0&&0==(k&1<<ae);ae--);return 0!=this.high?ae+33:ae+1},ce.isZero=function(){return 0===this.high&&0===this.low},ce.eqz=ce.isZero,ce.isNegative=function(){return!this.unsigned&&this.high<0},ce.isPositive=function(){return this.unsigned||this.high>=0},ce.isOdd=function(){return 1==(1&this.low)},ce.isEven=function(){return 0==(1&this.low)},ce.equals=function(k){return Ue(k)||(k=U(k)),(this.unsigned===k.unsigned||this.high>>>31!=1||k.high>>>31!=1)&&this.high===k.high&&this.low===k.low},ce.eq=ce.equals,ce.notEquals=function(k){return!this.eq(k)},ce.neq=ce.notEquals,ce.ne=ce.notEquals,ce.lessThan=function(k){return this.comp(k)<0},ce.lt=ce.lessThan,ce.lessThanOrEqual=function(k){return this.comp(k)<=0},ce.lte=ce.lessThanOrEqual,ce.le=ce.lessThanOrEqual,ce.greaterThan=function(k){return this.comp(k)>0},ce.gt=ce.greaterThan,ce.greaterThanOrEqual=function(k){return this.comp(k)>=0},ce.gte=ce.greaterThanOrEqual,ce.ge=ce.greaterThanOrEqual,ce.compare=function(k){if(Ue(k)||(k=U(k)),this.eq(k))return 0;var ae=this.isNegative(),je=k.isNegative();return ae&&!je?-1:!ae&&je?1:this.unsigned?k.high>>>0>this.high>>>0||k.high===this.high&&k.low>>>0>this.low>>>0?-1:1:this.sub(k).isNegative()?-1:1},ce.comp=ce.compare,ce.negate=function(){return!this.unsigned&&this.eq(Rt)?Rt:this.not().add(Hn)},ce.neg=ce.negate,ce.add=function(k){Ue(k)||(k=U(k));var qt=0,Rr=0,jn=0,Mr=0;return jn+=(Mr+=(65535&this.low)+(65535&k.low))>>>16,Rr+=(jn+=(this.low>>>16)+(k.low>>>16))>>>16,qt+=(Rr+=(65535&this.high)+(65535&k.high))>>>16,qt+=(this.high>>>16)+(k.high>>>16),Be((jn&=65535)<<16|(Mr&=65535),(qt&=65535)<<16|(Rr&=65535),this.unsigned)},ce.subtract=function(k){return Ue(k)||(k=U(k)),this.add(k.neg())},ce.sub=ce.subtract,ce.multiply=function(k){if(this.isZero())return Lt;if(Ue(k)||(k=U(k)),yt)return Be(yt.mul(this.low,this.high,k.low,k.high),yt.get_high(),this.unsigned);if(k.isZero())return Lt;if(this.eq(Rt))return k.isOdd()?Rt:Lt;if(k.eq(Rt))return this.isOdd()?Rt:Lt;if(this.isNegative())return k.isNegative()?this.neg().mul(k.neg()):this.neg().mul(k).neg();if(k.isNegative())return this.mul(k.neg()).neg();if(this.lt(Fe)&&k.lt(Fe))return lt(this.toNumber()*k.toNumber(),this.unsigned);var Ct=65535&this.high,ct=this.low>>>16,He=65535&this.low,Wn=65535&k.high,ur=k.low>>>16,qt=65535&k.low,Rr=0,jn=0,Mr=0,Bc=0;return Mr+=(Bc+=He*qt)>>>16,jn+=(Mr+=ct*qt)>>>16,Mr&=65535,jn+=(Mr+=He*ur)>>>16,Rr+=(jn+=Ct*qt)>>>16,jn&=65535,Rr+=(jn+=ct*ur)>>>16,jn&=65535,Rr+=(jn+=He*Wn)>>>16,Rr+=(this.high>>>16)*qt+Ct*ur+ct*Wn+He*(k.high>>>16),Be((Mr&=65535)<<16|(Bc&=65535),(Rr&=65535)<<16|(jn&=65535),this.unsigned)},ce.mul=ce.multiply,ce.divide=function(k){if(Ue(k)||(k=U(k)),k.isZero())throw Error("division by zero");var je,Ct,ct;if(yt)return this.unsigned||-2147483648!==this.high||-1!==k.low||-1!==k.high?Be((this.unsigned?yt.div_u:yt.div_s)(this.low,this.high,k.low,k.high),yt.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?Qn:Lt;if(this.unsigned){if(k.unsigned||(k=k.toUnsigned()),k.gt(this))return Qn;if(k.gt(this.shru(1)))return hi;ct=Qn}else{if(this.eq(Rt))return k.eq(Hn)||k.eq(Os)?Rt:k.eq(Rt)?Hn:(je=this.shr(1).div(k).shl(1)).eq(Lt)?k.isNegative()?Hn:Os:(Ct=this.sub(k.mul(je)),ct=je.add(Ct.div(k)));if(k.eq(Rt))return this.unsigned?Qn:Lt;if(this.isNegative())return k.isNegative()?this.neg().div(k.neg()):this.neg().div(k).neg();if(k.isNegative())return this.div(k.neg()).neg();ct=Lt}for(Ct=this;Ct.gte(k);){je=Math.max(1,Math.floor(Ct.toNumber()/k.toNumber()));for(var On=Math.ceil(Math.log(je)/Math.LN2),Wn=On<=48?1:rt(2,On-48),ur=lt(je),qt=ur.mul(k);qt.isNegative()||qt.gt(Ct);)qt=(ur=lt(je-=Wn,this.unsigned)).mul(k);ur.isZero()&&(ur=Hn),ct=ct.add(ur),Ct=Ct.sub(qt)}return ct},ce.div=ce.divide,ce.modulo=function(k){return Ue(k)||(k=U(k)),yt?Be((this.unsigned?yt.rem_u:yt.rem_s)(this.low,this.high,k.low,k.high),yt.get_high(),this.unsigned):this.sub(this.div(k).mul(k))},ce.mod=ce.modulo,ce.rem=ce.modulo,ce.not=function(){return Be(~this.low,~this.high,this.unsigned)},ce.and=function(k){return Ue(k)||(k=U(k)),Be(this.low&k.low,this.high&k.high,this.unsigned)},ce.or=function(k){return Ue(k)||(k=U(k)),Be(this.low|k.low,this.high|k.high,this.unsigned)},ce.xor=function(k){return Ue(k)||(k=U(k)),Be(this.low^k.low,this.high^k.high,this.unsigned)},ce.shiftLeft=function(k){return Ue(k)&&(k=k.toInt()),0==(k&=63)?this:k<32?Be(this.low<<k,this.high<<k|this.low>>>32-k,this.unsigned):Be(0,this.low<<k-32,this.unsigned)},ce.shl=ce.shiftLeft,ce.shiftRight=function(k){return Ue(k)&&(k=k.toInt()),0==(k&=63)?this:k<32?Be(this.low>>>k|this.high<<32-k,this.high>>k,this.unsigned):Be(this.high>>k-32,this.high>=0?0:-1,this.unsigned)},ce.shr=ce.shiftRight,ce.shiftRightUnsigned=function(k){if(Ue(k)&&(k=k.toInt()),0==(k&=63))return this;var ae=this.high;return k<32?Be(this.low>>>k|ae<<32-k,ae>>>k,this.unsigned):Be(32===k?ae:ae>>>k-32,0,this.unsigned)},ce.shru=ce.shiftRightUnsigned,ce.shr_u=ce.shiftRightUnsigned,ce.toSigned=function(){return this.unsigned?Be(this.low,this.high,!1):this},ce.toUnsigned=function(){return this.unsigned?this:Be(this.low,this.high,!0)},ce.toBytes=function(k){return k?this.toBytesLE():this.toBytesBE()},ce.toBytesLE=function(){var k=this.high,ae=this.low;return[255&ae,ae>>>8&255,ae>>>16&255,ae>>>24,255&k,k>>>8&255,k>>>16&255,k>>>24]},ce.toBytesBE=function(){var k=this.high,ae=this.low;return[k>>>24,k>>>16&255,k>>>8&255,255&k,ae>>>24,ae>>>16&255,ae>>>8&255,255&ae]},Z.fromBytes=function(k,ae,je){return je?Z.fromBytesLE(k,ae):Z.fromBytesBE(k,ae)},Z.fromBytesLE=function(k,ae){return new Z(k[0]|k[1]<<8|k[2]<<16|k[3]<<24,k[4]|k[5]<<8|k[6]<<16|k[7]<<24,ae)},Z.fromBytesBE=function(k,ae){return new Z(k[4]<<24|k[5]<<16|k[6]<<8|k[7],k[0]<<24|k[1]<<16|k[2]<<8|k[3],ae)}},340:(xt,yt,Z)=>{var Ue=Z(471),Zn=Z(992),Ke=Z(657),mn=Z(583),lt=Z(929),Be=Z(83),rt=Z(818);rt.alea=Ue,rt.xor128=Zn,rt.xorwow=Ke,rt.xorshift7=mn,rt.xor4096=lt,rt.tychei=Be,xt.exports=rt},471:function(xt,yt,Z){var Ue;!function(Zn,Ke,mn){function lt(U){var pe=this,be=function Ie(){var U=4022871197;return function(be){be=String(be);for(var re=0;re<be.length;re++){var fe=.02519603282416938*(U+=be.charCodeAt(re));fe-=U=fe>>>0,U=(fe*=U)>>>0,U+=4294967296*(fe-=U)}return 2.3283064365386963e-10*(U>>>0)}}();pe.next=function(){var re=2091639*pe.s0+2.3283064365386963e-10*pe.c;return pe.s0=pe.s1,pe.s1=pe.s2,pe.s2=re-(pe.c=0|re)},pe.c=1,pe.s0=be(" "),pe.s1=be(" "),pe.s2=be(" "),pe.s0-=be(U),pe.s0<0&&(pe.s0+=1),pe.s1-=be(U),pe.s1<0&&(pe.s1+=1),pe.s2-=be(U),pe.s2<0&&(pe.s2+=1),be=null}function Be(U,pe){return pe.c=U.c,pe.s0=U.s0,pe.s1=U.s1,pe.s2=U.s2,pe}function rt(U,pe){var be=new lt(U),re=pe&&pe.state,fe=be.next;return fe.int32=function(){return 4294967296*be.next()|0},fe.double=function(){return fe()+11102230246251565e-32*(2097152*fe()|0)},fe.quick=fe,re&&("object"==typeof re&&Be(re,be),fe.state=function(){return Be(be,{})}),fe}Ke&&Ke.exports?Ke.exports=rt:Z.amdD&&Z.amdO?void 0!==(Ue=function(){return rt}.call(yt,Z,yt,Ke))&&(Ke.exports=Ue):this.alea=rt}(0,xt=Z.nmd(xt))},83:function(xt,yt,Z){var Ue;!function(Zn,Ke,mn){function lt(Ie){var U=this,pe="";U.next=function(){var re=U.b,fe=U.c,Ne=U.d,Fe=U.a;return re=re<<25^re>>>7^fe,fe=fe-Ne|0,Ne=Ne<<24^Ne>>>8^Fe,Fe=Fe-re|0,U.b=re=re<<20^re>>>12^fe,U.c=fe=fe-Ne|0,U.d=Ne<<16^fe>>>16^Fe,U.a=Fe-re|0},U.a=0,U.b=0,U.c=-1640531527,U.d=1367130551,Ie===Math.floor(Ie)?(U.a=Ie/4294967296|0,U.b=0|Ie):pe+=Ie;for(var be=0;be<pe.length+20;be++)U.b^=0|pe.charCodeAt(be),U.next()}function Be(Ie,U){return U.a=Ie.a,U.b=Ie.b,U.c=Ie.c,U.d=Ie.d,U}function rt(Ie,U){var pe=new lt(Ie),be=U&&U.state,re=function(){return(pe.next()>>>0)/4294967296};return re.double=function(){do{var Fe=((pe.next()>>>11)+(pe.next()>>>0)/4294967296)/(1<<21)}while(0===Fe);return Fe},re.int32=pe.next,re.quick=re,be&&("object"==typeof be&&Be(be,pe),re.state=function(){return Be(pe,{})}),re}Ke&&Ke.exports?Ke.exports=rt:Z.amdD&&Z.amdO?void 0!==(Ue=function(){return rt}.call(yt,Z,yt,Ke))&&(Ke.exports=Ue):this.tychei=rt}(0,xt=Z.nmd(xt))},992:function(xt,yt,Z){var Ue;!function(Zn,Ke,mn){function lt(Ie){var U=this,pe="";U.x=0,U.y=0,U.z=0,U.w=0,U.next=function(){var re=U.x^U.x<<11;return U.x=U.y,U.y=U.z,U.z=U.w,U.w^=U.w>>>19^re^re>>>8},Ie===(0|Ie)?U.x=Ie:pe+=Ie;for(var be=0;be<pe.length+64;be++)U.x^=0|pe.charCodeAt(be),U.next()}function Be(Ie,U){return U.x=Ie.x,U.y=Ie.y,U.z=Ie.z,U.w=Ie.w,U}function rt(Ie,U){var pe=new lt(Ie),be=U&&U.state,re=function(){return(pe.next()>>>0)/4294967296};return re.double=function(){do{var Fe=((pe.next()>>>11)+(pe.next()>>>0)/4294967296)/(1<<21)}while(0===Fe);return Fe},re.int32=pe.next,re.quick=re,be&&("object"==typeof be&&Be(be,pe),re.state=function(){return Be(pe,{})}),re}Ke&&Ke.exports?Ke.exports=rt:Z.amdD&&Z.amdO?void 0!==(Ue=function(){return rt}.call(yt,Z,yt,Ke))&&(Ke.exports=Ue):this.xor128=rt}(0,xt=Z.nmd(xt))},929:function(xt,yt,Z){var Ue;!function(Zn,Ke,mn){function lt(Ie){var U=this;U.next=function(){var Ne,Fe,be=U.w,re=U.X,fe=U.i;return U.w=be=be+1640531527|0,Fe=re[fe+34&127],Ne=re[fe=fe+1&127],Fe^=Fe<<13,Ne^=Ne<<17,Fe=re[fe]=(Fe^=Fe>>>15)^(Ne^=Ne>>>12),U.i=fe,Fe+(be^be>>>16)|0},function pe(be,re){var fe,Ne,Fe,Lt,Qn,Hn=[],hi=128;for(re===(0|re)?(Ne=re,re=null):(re+="\0",Ne=0,hi=Math.max(hi,re.length)),Fe=0,Lt=-32;Lt<hi;++Lt)re&&(Ne^=re.charCodeAt((Lt+32)%re.length)),0===Lt&&(Qn=Ne),Ne^=Ne<<10,Ne^=Ne>>>15,Ne^=Ne<<4,Ne^=Ne>>>13,Lt>=0&&(Fe=0==(fe=Hn[127&Lt]^=Ne+(Qn=Qn+1640531527|0))?Fe+1:0);for(Fe>=128&&(Hn[127&(re&&re.length||0)]=-1),Fe=127,Lt=512;Lt>0;--Lt)Ne=Hn[Fe+34&127],fe=Hn[Fe=Fe+1&127],Ne^=Ne<<13,fe^=fe<<17,Hn[Fe]=(Ne^=Ne>>>15)^(fe^=fe>>>12);be.w=Qn,be.X=Hn,be.i=Fe}(U,Ie)}function Be(Ie,U){return U.i=Ie.i,U.w=Ie.w,U.X=Ie.X.slice(),U}function rt(Ie,U){null==Ie&&(Ie=+new Date);var pe=new lt(Ie),be=U&&U.state,re=function(){return(pe.next()>>>0)/4294967296};return re.double=function(){do{var Fe=((pe.next()>>>11)+(pe.next()>>>0)/4294967296)/(1<<21)}while(0===Fe);return Fe},re.int32=pe.next,re.quick=re,be&&(be.X&&Be(be,pe),re.state=function(){return Be(pe,{})}),re}Ke&&Ke.exports?Ke.exports=rt:Z.amdD&&Z.amdO?void 0!==(Ue=function(){return rt}.call(yt,Z,yt,Ke))&&(Ke.exports=Ue):this.xor4096=rt}(0,xt=Z.nmd(xt))},583:function(xt,yt,Z){var Ue;!function(Zn,Ke,mn){function lt(Ie){var U=this;U.next=function(){var fe,Ne,be=U.x,re=U.i;return fe=be[re],Ne=(fe^=fe>>>7)^fe<<24,Ne^=(fe=be[re+1&7])^fe>>>10,Ne^=(fe=be[re+3&7])^fe>>>3,Ne^=(fe=be[re+4&7])^fe<<7,fe=be[re+7&7],be[re]=Ne^=(fe^=fe<<13)^fe<<9,U.i=re+1&7,Ne},function pe(be,re){var fe,Fe=[];if(re===(0|re))Fe[0]=re;else for(re=""+re,fe=0;fe<re.length;++fe)Fe[7&fe]=Fe[7&fe]<<15^re.charCodeAt(fe)+Fe[fe+1&7]<<13;for(;Fe.length<8;)Fe.push(0);for(fe=0;fe<8&&0===Fe[fe];++fe);for(8==fe&&(Fe[7]=-1),be.x=Fe,be.i=0,fe=256;fe>0;--fe)be.next()}(U,Ie)}function Be(Ie,U){return U.x=Ie.x.slice(),U.i=Ie.i,U}function rt(Ie,U){null==Ie&&(Ie=+new Date);var pe=new lt(Ie),be=U&&U.state,re=function(){return(pe.next()>>>0)/4294967296};return re.double=function(){do{var Fe=((pe.next()>>>11)+(pe.next()>>>0)/4294967296)/(1<<21)}while(0===Fe);return Fe},re.int32=pe.next,re.quick=re,be&&(be.x&&Be(be,pe),re.state=function(){return Be(pe,{})}),re}Ke&&Ke.exports?Ke.exports=rt:Z.amdD&&Z.amdO?void 0!==(Ue=function(){return rt}.call(yt,Z,yt,Ke))&&(Ke.exports=Ue):this.xorshift7=rt}(0,xt=Z.nmd(xt))},657:function(xt,yt,Z){var Ue;!function(Zn,Ke,mn){function lt(Ie){var U=this,pe="";U.next=function(){var re=U.x^U.x>>>2;return U.x=U.y,U.y=U.z,U.z=U.w,U.w=U.v,(U.d=U.d+362437|0)+(U.v=U.v^U.v<<4^re^re<<1)|0},U.x=0,U.y=0,U.z=0,U.w=0,U.v=0,Ie===(0|Ie)?U.x=Ie:pe+=Ie;for(var be=0;be<pe.length+64;be++)U.x^=0|pe.charCodeAt(be),be==pe.length&&(U.d=U.x<<10^U.x>>>4),U.next()}function Be(Ie,U){return U.x=Ie.x,U.y=Ie.y,U.z=Ie.z,U.w=Ie.w,U.v=Ie.v,U.d=Ie.d,U}function rt(Ie,U){var pe=new lt(Ie),be=U&&U.state,re=function(){return(pe.next()>>>0)/4294967296};return re.double=function(){do{var Fe=((pe.next()>>>11)+(pe.next()>>>0)/4294967296)/(1<<21)}while(0===Fe);return Fe},re.int32=pe.next,re.quick=re,be&&("object"==typeof be&&Be(be,pe),re.state=function(){return Be(pe,{})}),re}Ke&&Ke.exports?Ke.exports=rt:Z.amdD&&Z.amdO?void 0!==(Ue=function(){return rt}.call(yt,Z,yt,Ke))&&(Ke.exports=Ue):this.xorwow=rt}(0,xt=Z.nmd(xt))},818:function(xt,yt,Z){var Ue;!function(Zn,Ke,mn){var fe,lt=256,U=mn.pow(lt,6),pe=mn.pow(2,52),be=2*pe;function Ne(wt,At,Rt){var ce=[],Q=Hn(Qn((At=1==At?{entropy:!0}:At||{}).entropy?[wt,Os(Ke)]:wt??function hi(){try{var wt;return fe&&(wt=fe.randomBytes)?wt=wt(lt):(wt=new Uint8Array(lt),(Zn.crypto||Zn.msCrypto).getRandomValues(wt)),Os(wt)}catch{var At=Zn.navigator,Rt=At&&At.plugins;return[+new Date,Zn,Rt,Zn.screen,Os(Ke)]}}(),3),ce),k=new Fe(ce),ae=function(){for(var je=k.g(6),Ct=U,ct=0;je<pe;)je=(je+ct)*lt,Ct*=lt,ct=k.g(1);for(;je>=be;)je/=2,Ct/=2,ct>>>=1;return(je+ct)/Ct};return ae.int32=function(){return 0|k.g(4)},ae.quick=function(){return k.g(4)/4294967296},ae.double=ae,Hn(Os(k.S),Ke),(At.pass||Rt||function(je,Ct,ct,He){return He&&(He.S&&Lt(He,k),je.state=function(){return Lt(k,{})}),ct?(mn.random=je,Ct):je})(ae,Q,"global"in At?At.global:this==mn,At.state)}function Fe(wt){var At,Rt=wt.length,ce=this,Q=0,k=ce.i=ce.j=0,ae=ce.S=[];for(Rt||(wt=[Rt++]);Q<lt;)ae[Q]=Q++;for(Q=0;Q<lt;Q++)ae[Q]=ae[k=255&k+wt[Q%Rt]+(At=ae[Q])],ae[k]=At;(ce.g=function(je){for(var Ct,ct=0,He=ce.i,On=ce.j,Wn=ce.S;je--;)Ct=Wn[He=255&He+1],ct=ct*lt+Wn[255&(Wn[He]=Wn[On=255&On+Ct])+(Wn[On]=Ct)];return ce.i=He,ce.j=On,ct})(lt)}function Lt(wt,At){return At.i=wt.i,At.j=wt.j,At.S=wt.S.slice(),At}function Qn(wt,At){var Q,Rt=[],ce=typeof wt;if(At&&"object"==ce)for(Q in wt)try{Rt.push(Qn(wt[Q],At-1))}catch{}return Rt.length?Rt:"string"==ce?wt:wt+"\0"}function Hn(wt,At){for(var ce,Rt=wt+"",Q=0;Q<Rt.length;)At[255&Q]=255&(ce^=19*At[255&Q])+Rt.charCodeAt(Q++);return Os(At)}function Os(wt){return String.fromCharCode.apply(0,wt)}if(Hn(mn.random(),Ke),xt.exports){xt.exports=Ne;try{fe=Z(42)}catch{}}else void 0!==(Ue=function(){return Ne}.call(yt,Z,yt,xt))&&(xt.exports=Ue)}(typeof self<"u"?self:this,[],Math)},410:()=>{},628:()=>{},601:()=>{},792:()=>{},977:()=>{},42:()=>{}},xt=>{xt(xt.s=819)}]);