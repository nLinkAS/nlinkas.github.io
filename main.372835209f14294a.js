(self.webpackChunkml_iframe=self.webpackChunkml_iframe||[]).push([[179],{170:(Ct,_t,Q)=>{"use strict";var Ue={};Q.r(Ue),Q.d(Ue,{browserFiles:()=>Qne,browserHTTPRequest:()=>rre,concatenateArrayBuffers:()=>Qb,copyModel:()=>Bne,decodeWeights:()=>eL,encodeWeights:()=>jE,fromMemory:()=>ire,fromMemorySync:()=>wL,getLoadHandlers:()=>Ine,getModelArtifactsForJSON:()=>KE,getModelArtifactsForJSONSync:()=>sL,getModelArtifactsInfoForJSON:()=>Sp,getSaveHandlers:()=>oL,getWeightSpecs:()=>iL,http:()=>cI,isHTTPScheme:()=>lI,listModels:()=>$ne,loadWeights:()=>Jne,moveModel:()=>Vne,registerLoadRouter:()=>Ene,registerSaveRouter:()=>Sne,removeModel:()=>Lne,weightsLoaderFactory:()=>bL,withSaveHandler:()=>ore,withSaveHandlerSync:()=>are});var Zn={};Q.r(Zn),Q.d(Zn,{assertParamsValid:()=>pI,computeFlatOffset:()=>yI,computeOutShape:()=>mI,getNormalizedAxes:()=>mre,isSliceContinous:()=>gI,maskToAxes:()=>pre,parseSliceParams:()=>t_,sliceInfo:()=>bI,startForAxis:()=>AL,startIndicesWithElidedDims:()=>TL,stopForAxis:()=>RL,stopIndicesWithElidedDims:()=>kL,stridesForAxis:()=>NL,stridesWithElidedDims:()=>EL});var Ke={};Q.r(Ke),Q.d(Ke,{conv2d:()=>FB,depthwiseConv2d:()=>Uae,matMul:()=>oD});var gn={};Q.r(gn),Q.d(gn,{collectGatherOpShapeInfo:()=>zD,computeOutShape:()=>mV,segOpComputeOptimalWindowSize:()=>pV});var lt={};Q.r(lt),Q.d(lt,{ERF_A1:()=>DD,ERF_A2:()=>TD,ERF_A3:()=>kD,ERF_A4:()=>ND,ERF_A5:()=>AD,ERF_P:()=>ID,PARALLELIZE_THRESHOLD:()=>xD,RowPartitionType:()=>Pi,SELU_SCALE:()=>A_,SELU_SCALEALPHA:()=>N_,applyActivation:()=>I_,assertAndGetBroadcastShape:()=>et,assertAxesAreInnerMostDims:()=>Ar,assertParamsConsistent:()=>vD,assignToTypedArray:()=>QB,axesAreInnerMostDims:()=>NI,calculateShapes:()=>Bp,checkEinsumDimSizes:()=>PD,checkPadOnDimRoundingMode:()=>Zr,combineLocations:()=>aB,combineRaggedTensorToTensorShapes:()=>jB,complexWithEvenIndex:()=>YB,complexWithOddIndex:()=>ZB,computeConv2DInfo:()=>wr,computeConv3DInfo:()=>sl,computeDefaultPad:()=>xI,computeDilation2DInfo:()=>Ep,computeOptimalWindowSize:()=>k_,computeOutAndReduceShapes:()=>Cr,computeOutShape:()=>$o,computePool2DInfo:()=>Ai,computePool3DInfo:()=>ya,convertConv2DDataFormat:()=>ba,decodeEinsumEquation:()=>FD,eitherStridesOrDilationsAreOne:()=>Nr,expandShapeToKeepDim:()=>Vn,exponent:()=>eV,exponents:()=>JB,fromStringArrayToUint8:()=>gV,fromUint8ToStringArray:()=>xc,getAxesPermutation:()=>Dn,getBroadcastDims:()=>cd,getComplexWithIndex:()=>RD,getEinsumComputePath:()=>$D,getEinsumPermutation:()=>OD,getFusedBiasGradient:()=>E_,getFusedDyActivation:()=>S_,getImageCenter:()=>wD,getInnerMostAxes:()=>zn,getPermuted:()=>zp,getRaggedRank:()=>qB,getReductionAxes:()=>nr,getReshaped:()=>Vp,getReshapedPermuted:()=>Up,getRowPartitionTypesHelper:()=>GB,getSliceBeginCoords:()=>CD,getSliceSize:()=>SD,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>rV,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>sV,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>iV,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>lV,getSparseReshapeInputOutputMismatchErrorMessage:()=>uV,getSparseReshapeInputOutputMultipleErrorMessage:()=>cV,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>oV,getSparseReshapeNegativeOutputDimErrorMessage:()=>aV,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>fV,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>VD,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>dV,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>hV,getUndoAxesPermutation:()=>al,isIdentityPermutation:()=>LD,log:()=>Wte,mergeRealAndImagArrays:()=>wa,prepareAndValidate:()=>ED,prepareSplitSize:()=>BD,segment_util:()=>gn,shouldFuse:()=>D_,slice_util:()=>Zn,splitRealAndImagArrays:()=>XB,tupleValuesAreOne:()=>il,upcastType:()=>Fs,validateDefaultValueShape:()=>KB,validateInput:()=>AB,validateUpdateShape:()=>NB,warn:()=>si});var Ve={};Q.r(Ve),Q.d(Ve,{json:()=>xfe});var st={};Q.r(st),Q.d(st,{json:()=>wfe});var Ie={};Q.r(Ie),Q.d(Ie,{json:()=>Cfe});var U={};Q.r(U),Q.d(U,{json:()=>Sfe});var pe={};Q.r(pe),Q.d(pe,{json:()=>Efe});var be={};Q.r(be),Q.d(be,{json:()=>Ife});var re={};Q.r(re),Q.d(re,{json:()=>Dfe});var fe={};Q.r(fe),Q.d(fe,{json:()=>Tfe});var Ne={};Q.r(Ne),Q.d(Ne,{json:()=>kfe});var Fe={};Q.r(Fe),Q.d(Fe,{json:()=>Nfe});var zt={};Q.r(zt),Q.d(zt,{json:()=>Afe});var Qn={};Q.r(Qn),Q.d(Qn,{json:()=>Rfe});var Wn={};Q.r(Wn),Q.d(Wn,{json:()=>Mfe});var _i={};Q.r(_i),Q.d(_i,{json:()=>Ffe});var Hs={};Q.r(Hs),Q.d(Hs,{json:()=>Ofe});var St={};Q.r(St),Q.d(St,{json:()=>Pfe});var Mt={};Q.r(Mt),Q.d(Mt,{json:()=>$fe});var Ft={};Q.r(Ft),Q.d(Ft,{json:()=>Lfe});var ce={};Q.r(ce),Q.d(ce,{json:()=>Bfe});var J={};Q.r(J),Q.d(J,{OP_SCOPE_SUFFIX:()=>J$,abs:()=>rr,acos:()=>OL,acosh:()=>PL,add:()=>le,addN:()=>Ire,all:()=>vI,any:()=>r_,argMax:()=>dd,argMin:()=>$L,asin:()=>LL,asinh:()=>BL,atan:()=>VL,atan2:()=>zL,atanh:()=>UL,avgPool:()=>i_,avgPool3d:()=>HL,basicLSTMCell:()=>Yre,batchNorm:()=>Ip,batchNorm2d:()=>WL,batchNorm3d:()=>jL,batchNorm4d:()=>GL,batchToSpaceND:()=>o_,bincount:()=>qL,booleanMaskAsync:()=>wae,broadcastArgs:()=>ise,broadcastTo:()=>pd,buffer:()=>ot,cast:()=>ve,ceil:()=>KL,clipByValue:()=>Os,clone:()=>ma,complex:()=>el,concat:()=>Xn,concat1d:()=>XL,concat2d:()=>YL,concat3d:()=>ZL,concat4d:()=>QL,conv1d:()=>CI,conv2d:()=>ol,conv2dTranspose:()=>EI,conv3d:()=>JL,conv3dTranspose:()=>tB,cos:()=>a_,cosh:()=>II,cosineWindow:()=>rD,cumprod:()=>l_,cumsum:()=>DI,denseBincount:()=>TI,depthToSpace:()=>nB,depthwiseConv2d:()=>Dp,diag:()=>Tse,dilation2d:()=>rB,div:()=>Pe,divNoNan:()=>sB,dot:()=>iB,dropout:()=>RB,einsum:()=>Lse,elu:()=>Tp,enclosingPowerOfTwo:()=>MB,equal:()=>lo,erf:()=>oB,euclideanNorm:()=>cB,exp:()=>oi,expandDims:()=>gs,expm1:()=>uB,eye:()=>AI,fft:()=>w_,fill:()=>md,floor:()=>Ap,floorDiv:()=>kI,fused:()=>Ke,gather:()=>Rp,gatherND:()=>Rae,greater:()=>Ps,greaterEqual:()=>cl,ifft:()=>$p,imag:()=>c_,image:()=>xa,inTopKAsync:()=>Pae,irfft:()=>YI,isFinite:()=>dB,isInf:()=>hB,isNaN:()=>fB,leakyRelu:()=>u_,less:()=>RI,lessEqual:()=>bc,linalg:()=>HB,linspace:()=>die,localResponseNormalization:()=>pB,log:()=>ai,log1p:()=>d_,logSigmoid:()=>mB,logSoftmax:()=>MI,logSumExp:()=>FI,logicalAnd:()=>Oo,logicalNot:()=>h_,logicalOr:()=>OI,logicalXor:()=>gB,losses:()=>gce,lowerBound:()=>Iie,matMul:()=>mt,max:()=>Ri,maxPool:()=>p_,maxPool3d:()=>yB,maxPoolWithArgmax:()=>Nie,maximum:()=>_a,mean:()=>Rn,meshgrid:()=>Mie,min:()=>kp,minimum:()=>Mp,mirrorPad:()=>bB,mod:()=>_B,moments:()=>m_,movingAverage:()=>Eae,mul:()=>M,multiRNNCell:()=>Bie,multinomial:()=>zie,neg:()=>_n,norm:()=>Np,notEqual:()=>yd,oneHot:()=>$I,ones:()=>li,onesLike:()=>ci,op:()=>A,outerProduct:()=>Gie,pad:()=>ul,pad1d:()=>Xie,pad2d:()=>Zie,pad3d:()=>Jie,pad4d:()=>toe,pool:()=>vB,pow:()=>ll,prelu:()=>y_,print:()=>pL,prod:()=>xB,raggedGather:()=>coe,raggedRange:()=>doe,raggedTensorToTensor:()=>foe,rand:()=>moe,randomGamma:()=>woe,randomNormal:()=>VI,randomStandardNormal:()=>Eoe,randomUniform:()=>Fp,range:()=>bd,real:()=>Op,reciprocal:()=>wB,relu:()=>Po,relu6:()=>zI,reshape:()=>F,reverse:()=>Fi,reverse1d:()=>Moe,reverse2d:()=>Ooe,reverse3d:()=>$oe,reverse4d:()=>Boe,rfft:()=>C_,round:()=>UI,rsqrt:()=>HI,scalar:()=>Be,scatterND:()=>Dae,searchSorted:()=>PI,selu:()=>WI,separableConv2d:()=>jI,setdiff1dAsync:()=>joe,sigmoid:()=>Fo,sign:()=>CB,signal:()=>mce,sin:()=>qI,sinh:()=>KI,slice:()=>Dt,slice1d:()=>__,slice2d:()=>XI,slice3d:()=>v_,slice4d:()=>Pp,softmax:()=>x_,softplus:()=>gd,spaceToBatchND:()=>g_,sparse:()=>yce,sparseToDense:()=>Nae,spectral:()=>pce,split:()=>$s,sqrt:()=>Vr,square:()=>Jt,squaredDifference:()=>ZI,squeeze:()=>_c,stack:()=>ui,step:()=>_d,stridedSlice:()=>SB,string:()=>bce,sub:()=>De,sum:()=>Ae,tan:()=>EB,tanh:()=>fd,tensor:()=>ao,tensor1d:()=>ys,tensor2d:()=>Lp,tensor3d:()=>CL,tensor4d:()=>dae,tensor5d:()=>hae,tensor6d:()=>fae,tile:()=>Mi,topk:()=>IB,transpose:()=>wt,truncatedNormal:()=>QI,unique:()=>DB,unsortedSegmentSum:()=>JI,unstack:()=>Oi,upperBound:()=>_ae,variable:()=>TB,where:()=>ms,whereAsync:()=>kB,zeros:()=>sr,zerosLike:()=>Tt});var k={};function ae(n){return"function"==typeof n}function je(n){const e=n(r=>{Error.call(r),r.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}Q.r(k),Q.d(k,{addImpl:()=>D3,bincountImpl:()=>e1,bincountReduceImpl:()=>M3,castImpl:()=>I3,ceilImpl:()=>F3,concatImpl:()=>O3,equalImpl:()=>L3,expImpl:()=>V3,expm1Impl:()=>U3,floorImpl:()=>j3,gatherNdImpl:()=>G3,gatherV2Impl:()=>q3,greaterEqualImpl:()=>X3,greaterImpl:()=>K3,lessEqualImpl:()=>Z3,lessImpl:()=>Y3,linSpaceImpl:()=>Q3,logImpl:()=>J3,maxImpl:()=>eU,maximumImpl:()=>nU,minimumImpl:()=>rU,multiplyImpl:()=>t1,negImpl:()=>iU,notEqualImpl:()=>oU,prodImpl:()=>uU,raggedGatherImpl:()=>hU,raggedRangeImpl:()=>pU,raggedTensorToTensorImpl:()=>yU,rangeImpl:()=>bU,rsqrtImpl:()=>_U,scatterImpl:()=>Rd,sigmoidImpl:()=>lme,simpleAbsImpl:()=>k3,sliceImpl:()=>R3,sparseFillEmptyRowsImpl:()=>xU,sparseReshapeImpl:()=>wU,sparseSegmentReductionImpl:()=>l1,sqrtImpl:()=>Ave,squaredDifferenceImpl:()=>CU,stridedSliceImpl:()=>SU,stringNGramsImpl:()=>EU,stringSplitImpl:()=>IU,stringToHashBucketFastImpl:()=>DU,subImpl:()=>H3,tileImpl:()=>TU,topKImpl:()=>NU,transposeImpl:()=>QT,uniqueImpl:()=>RU});const Et=je(n=>function(e){n(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((r,s)=>`${s+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function ct(n,t){if(n){const e=n.indexOf(t);0<=e&&n.splice(e,1)}}class He{constructor(t){this.initialTeardown=t,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const i of e)i.remove(this);else e.remove(this);const{initialTeardown:r}=this;if(ae(r))try{r()}catch(i){t=i instanceof Et?i.errors:[i]}const{_finalizers:s}=this;if(s){this._finalizers=null;for(const i of s)try{ur(i)}catch(o){t=t??[],o instanceof Et?t=[...t,...o.errors]:t.push(o)}}if(t)throw new Et(t)}}add(t){var e;if(t&&t!==this)if(this.closed)ur(t);else{if(t instanceof He){if(t.closed||t._hasParent(this))return;t._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(t)}}_hasParent(t){const{_parentage:e}=this;return e===t||Array.isArray(e)&&e.includes(t)}_addParent(t){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(t),e):e?[e,t]:t}_removeParent(t){const{_parentage:e}=this;e===t?this._parentage=null:Array.isArray(e)&&ct(e,t)}remove(t){const{_finalizers:e}=this;e&&ct(e,t),t instanceof He&&t._removeParent(this)}}He.EMPTY=(()=>{const n=new He;return n.closed=!0,n})();const Fn=He.EMPTY;function jn(n){return n instanceof He||n&&"closed"in n&&ae(n.remove)&&ae(n.add)&&ae(n.unsubscribe)}function ur(n){ae(n)?n():n.unsubscribe()}const Zt={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},Fr={setTimeout(n,t,...e){const{delegate:r}=Fr;return r?.setTimeout?r.setTimeout(n,t,...e):setTimeout(n,t,...e)},clearTimeout(n){const{delegate:t}=Fr;return(t?.clearTimeout||clearTimeout)(n)},delegate:void 0};function Gn(n){Fr.setTimeout(()=>{const{onUnhandledError:t}=Zt;if(!t)throw n;t(n)})}function Or(){}const Gc=Ix("C",void 0,void 0);function Ix(n,t,e){return{kind:n,value:t,error:e}}let Pl=null;function $m(n){if(Zt.useDeprecatedSynchronousErrorHandling){const t=!Pl;if(t&&(Pl={errorThrown:!1,error:null}),n(),t){const{errorThrown:e,error:r}=Pl;if(Pl=null,e)throw r}}else n()}class Dx extends He{constructor(t){super(),this.isStopped=!1,t?(this.destination=t,jn(t)&&t.add(this)):this.destination=wG}static create(t,e,r){return new rh(t,e,r)}next(t){this.isStopped?kx(function yG(n){return Ix("N",n,void 0)}(t),this):this._next(t)}error(t){this.isStopped?kx(function gG(n){return Ix("E",void 0,n)}(t),this):(this.isStopped=!0,this._error(t))}complete(){this.isStopped?kx(Gc,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(t){this.destination.next(t)}_error(t){try{this.destination.error(t)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const _G=Function.prototype.bind;function Tx(n,t){return _G.call(n,t)}class vG{constructor(t){this.partialObserver=t}next(t){const{partialObserver:e}=this;if(e.next)try{e.next(t)}catch(r){Lm(r)}}error(t){const{partialObserver:e}=this;if(e.error)try{e.error(t)}catch(r){Lm(r)}else Lm(t)}complete(){const{partialObserver:t}=this;if(t.complete)try{t.complete()}catch(e){Lm(e)}}}class rh extends Dx{constructor(t,e,r){let s;if(super(),ae(t)||!t)s={next:t??void 0,error:e??void 0,complete:r??void 0};else{let i;this&&Zt.useDeprecatedNextContext?(i=Object.create(t),i.unsubscribe=()=>this.unsubscribe(),s={next:t.next&&Tx(t.next,i),error:t.error&&Tx(t.error,i),complete:t.complete&&Tx(t.complete,i)}):s=t}this.destination=new vG(s)}}function Lm(n){Zt.useDeprecatedSynchronousErrorHandling?function bG(n){Zt.useDeprecatedSynchronousErrorHandling&&Pl&&(Pl.errorThrown=!0,Pl.error=n)}(n):Gn(n)}function kx(n,t){const{onStoppedNotification:e}=Zt;e&&Fr.setTimeout(()=>e(n,t))}const wG={closed:!0,next:Or,error:function xG(n){throw n},complete:Or},Nx="function"==typeof Symbol&&Symbol.observable||"@@observable";function Fa(n){return n}function nN(n){return 0===n.length?Fa:1===n.length?n[0]:function(e){return n.reduce((r,s)=>s(r),e)}}let Cn=(()=>{class n{constructor(e){e&&(this._subscribe=e)}lift(e){const r=new n;return r.source=this,r.operator=e,r}subscribe(e,r,s){const i=function EG(n){return n&&n instanceof Dx||function SG(n){return n&&ae(n.next)&&ae(n.error)&&ae(n.complete)}(n)&&jn(n)}(e)?e:new rh(e,r,s);return $m(()=>{const{operator:o,source:a}=this;i.add(o?o.call(i,a):a?this._subscribe(i):this._trySubscribe(i))}),i}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return new(r=rN(r))((s,i)=>{const o=new rh({next:a=>{try{e(a)}catch(l){i(l),o.unsubscribe()}},error:i,complete:s});this.subscribe(o)})}_subscribe(e){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(e)}[Nx](){return this}pipe(...e){return nN(e)(this)}toPromise(e){return new(e=rN(e))((r,s)=>{let i;this.subscribe(o=>i=o,o=>s(o),()=>r(i))})}}return n.create=t=>new n(t),n})();function rN(n){var t;return null!==(t=n??Zt.Promise)&&void 0!==t?t:Promise}const IG=je(n=>function(){n(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let kt=(()=>{class n extends Cn{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const r=new sN(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new IG}next(e){$m(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(e)}})}error(e){$m(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){$m(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:r,isStopped:s,observers:i}=this;return r||s?Fn:(this.currentObservers=null,i.push(e),new He(()=>{this.currentObservers=null,ct(i,e)}))}_checkFinalizedStatuses(e){const{hasError:r,thrownError:s,isStopped:i}=this;r?e.error(s):i&&e.complete()}asObservable(){const e=new Cn;return e.source=this,e}}return n.create=(t,e)=>new sN(t,e),n})();class sN extends kt{constructor(t,e){super(),this.destination=t,this.source=e}next(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===r||r.call(e,t)}error(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===r||r.call(e,t)}complete(){var t,e;null===(e=null===(t=this.destination)||void 0===t?void 0:t.complete)||void 0===e||e.call(t)}_subscribe(t){var e,r;return null!==(r=null===(e=this.source)||void 0===e?void 0:e.subscribe(t))&&void 0!==r?r:Fn}}function iN(n){return ae(n?.lift)}function On(n){return t=>{if(iN(t))return t.lift(function(e){try{return n(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function Sn(n,t,e,r,s){return new DG(n,t,e,r,s)}class DG extends Dx{constructor(t,e,r,s,i,o){super(t),this.onFinalize=i,this.shouldUnsubscribe=o,this._next=e?function(a){try{e(a)}catch(l){t.error(l)}}:super._next,this._error=s?function(a){try{s(a)}catch(l){t.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){t.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(t=this.onFinalize)||void 0===t||t.call(this))}}}function ze(n,t){return On((e,r)=>{let s=0;e.subscribe(Sn(r,i=>{r.next(n.call(t,i,s++))}))})}function $l(n){return this instanceof $l?(this.v=n,this):new $l(n)}function NG(n,t,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s,r=e.apply(n,t||[]),i=[];return s={},o("next"),o("throw"),o("return"),s[Symbol.asyncIterator]=function(){return this},s;function o(h){r[h]&&(s[h]=function(f){return new Promise(function(p,m){i.push([h,f,p,m])>1||a(h,f)})})}function a(h,f){try{!function l(h){h.value instanceof $l?Promise.resolve(h.value.v).then(c,u):d(i[0][2],h)}(r[h](f))}catch(p){d(i[0][3],p)}}function c(h){a("next",h)}function u(h){a("throw",h)}function d(h,f){h(f),i.shift(),i.length&&a(i[0][0],i[0][1])}}function AG(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,t=n[Symbol.asyncIterator];return t?t.call(n):(n=function lN(n){var t="function"==typeof Symbol&&Symbol.iterator,e=t&&n[t],r=0;if(e)return e.call(n);if(n&&"number"==typeof n.length)return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(n),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(i){e[i]=n[i]&&function(o){return new Promise(function(a,l){!function s(i,o,a,l){Promise.resolve(l).then(function(c){i({value:c,done:a})},o)}(a,l,(o=n[i](o)).done,o.value)})}}}const Rx=n=>n&&"number"==typeof n.length&&"function"!=typeof n;function cN(n){return ae(n?.then)}function uN(n){return ae(n[Nx])}function dN(n){return Symbol.asyncIterator&&ae(n?.[Symbol.asyncIterator])}function hN(n){return new TypeError(`You provided ${null!==n&&"object"==typeof n?"an invalid object":`'${n}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const fN=function MG(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function pN(n){return ae(n?.[fN])}function mN(n){return NG(this,arguments,function*(){const e=n.getReader();try{for(;;){const{value:r,done:s}=yield $l(e.read());if(s)return yield $l(void 0);yield yield $l(r)}}finally{e.releaseLock()}})}function gN(n){return ae(n?.getReader)}function Cs(n){if(n instanceof Cn)return n;if(null!=n){if(uN(n))return function FG(n){return new Cn(t=>{const e=n[Nx]();if(ae(e.subscribe))return e.subscribe(t);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(n);if(Rx(n))return function OG(n){return new Cn(t=>{for(let e=0;e<n.length&&!t.closed;e++)t.next(n[e]);t.complete()})}(n);if(cN(n))return function PG(n){return new Cn(t=>{n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,Gn)})}(n);if(dN(n))return yN(n);if(pN(n))return function $G(n){return new Cn(t=>{for(const e of n)if(t.next(e),t.closed)return;t.complete()})}(n);if(gN(n))return function LG(n){return yN(mN(n))}(n)}throw hN(n)}function yN(n){return new Cn(t=>{(function BG(n,t){var e,r,s,i;return function TG(n,t,e,r){return new(e||(e=Promise))(function(i,o){function a(u){try{c(r.next(u))}catch(d){o(d)}}function l(u){try{c(r.throw(u))}catch(d){o(d)}}function c(u){u.done?i(u.value):function s(i){return i instanceof e?i:new e(function(o){o(i)})}(u.value).then(a,l)}c((r=r.apply(n,t||[])).next())})}(this,void 0,void 0,function*(){try{for(e=AG(n);!(r=yield e.next()).done;)if(t.next(r.value),t.closed)return}catch(o){s={error:o}}finally{try{r&&!r.done&&(i=e.return)&&(yield i.call(e))}finally{if(s)throw s.error}}t.complete()})})(n,t).catch(e=>t.error(e))})}function Xo(n,t,e,r=0,s=!1){const i=t.schedule(function(){e(),s?n.add(this.schedule(null,r)):this.unsubscribe()},r);if(n.add(i),!s)return i}function Dr(n,t,e=1/0){return ae(t)?Dr((r,s)=>ze((i,o)=>t(r,i,s,o))(Cs(n(r,s))),e):("number"==typeof t&&(e=t),On((r,s)=>function VG(n,t,e,r,s,i,o,a){const l=[];let c=0,u=0,d=!1;const h=()=>{d&&!l.length&&!c&&t.complete()},f=m=>c<r?p(m):l.push(m),p=m=>{i&&t.next(m),c++;let g=!1;Cs(e(m,u++)).subscribe(Sn(t,y=>{s?.(y),i?f(y):t.next(y)},()=>{g=!0},void 0,()=>{if(g)try{for(c--;l.length&&c<r;){const y=l.shift();o?Xo(t,o,()=>p(y)):p(y)}h()}catch(y){t.error(y)}}))};return n.subscribe(Sn(t,f,()=>{d=!0,h()})),()=>{a?.()}}(r,s,n,e)))}function qc(n=1/0){return Dr(Fa,n)}const Yo=new Cn(n=>n.complete());function bN(n){return n&&ae(n.schedule)}function Mx(n){return n[n.length-1]}function _N(n){return ae(Mx(n))?n.pop():void 0}function sh(n){return bN(Mx(n))?n.pop():void 0}function vN(n,t=0){return On((e,r)=>{e.subscribe(Sn(r,s=>Xo(r,n,()=>r.next(s),t),()=>Xo(r,n,()=>r.complete(),t),s=>Xo(r,n,()=>r.error(s),t)))})}function xN(n,t=0){return On((e,r)=>{r.add(n.schedule(()=>e.subscribe(r),t))})}function wN(n,t){if(!n)throw new Error("Iterable cannot be null");return new Cn(e=>{Xo(e,t,()=>{const r=n[Symbol.asyncIterator]();Xo(e,t,()=>{r.next().then(s=>{s.done?e.complete():e.next(s.value)})},0,!0)})})}function Pn(n,t){return t?function KG(n,t){if(null!=n){if(uN(n))return function HG(n,t){return Cs(n).pipe(xN(t),vN(t))}(n,t);if(Rx(n))return function jG(n,t){return new Cn(e=>{let r=0;return t.schedule(function(){r===n.length?e.complete():(e.next(n[r++]),e.closed||this.schedule())})})}(n,t);if(cN(n))return function WG(n,t){return Cs(n).pipe(xN(t),vN(t))}(n,t);if(dN(n))return wN(n,t);if(pN(n))return function GG(n,t){return new Cn(e=>{let r;return Xo(e,t,()=>{r=n[fN](),Xo(e,t,()=>{let s,i;try{({value:s,done:i}=r.next())}catch(o){return void e.error(o)}i?e.complete():e.next(s)},0,!0)}),()=>ae(r?.return)&&r.return()})}(n,t);if(gN(n))return function qG(n,t){return wN(mN(n),t)}(n,t)}throw hN(n)}(n,t):Cs(n)}function ih(...n){const t=sh(n),e=function UG(n,t){return"number"==typeof Mx(n)?n.pop():t}(n,1/0),r=n;return r.length?1===r.length?Cs(r[0]):qc(e)(Pn(r,t)):Yo}function CN(n={}){const{connector:t=(()=>new kt),resetOnError:e=!0,resetOnComplete:r=!0,resetOnRefCountZero:s=!0}=n;return i=>{let o,a,l,c=0,u=!1,d=!1;const h=()=>{a?.unsubscribe(),a=void 0},f=()=>{h(),o=l=void 0,u=d=!1},p=()=>{const m=o;f(),m?.unsubscribe()};return On((m,g)=>{c++,!d&&!u&&h();const y=l=l??t();g.add(()=>{c--,0===c&&!d&&!u&&(a=Fx(p,s))}),y.subscribe(g),!o&&c>0&&(o=new rh({next:b=>y.next(b),error:b=>{d=!0,h(),a=Fx(f,e,b),y.error(b)},complete:()=>{u=!0,h(),a=Fx(f,r),y.complete()}}),Cs(m).subscribe(o))})(i)}}function Fx(n,t,...e){if(!0===t)return void n();if(!1===t)return;const r=new rh({next:()=>{r.unsubscribe(),n()}});return t(...e).subscribe(r)}function tn(n){for(let t in n)if(n[t]===tn)return t;throw Error("Could not find renamed property on target object.")}function Ox(n,t){for(const e in t)t.hasOwnProperty(e)&&!n.hasOwnProperty(e)&&(n[e]=t[e])}function nn(n){if("string"==typeof n)return n;if(Array.isArray(n))return"["+n.map(nn).join(", ")+"]";if(null==n)return""+n;if(n.overriddenName)return`${n.overriddenName}`;if(n.name)return`${n.name}`;const t=n.toString();if(null==t)return""+t;const e=t.indexOf("\n");return-1===e?t:t.substring(0,e)}function Px(n,t){return null==n||""===n?null===t?"":t:null==t||""===t?n:n+" "+t}const XG=tn({__forward_ref__:tn});function cn(n){return n.__forward_ref__=cn,n.toString=function(){return nn(this())},n}function Ge(n){return $x(n)?n():n}function $x(n){return"function"==typeof n&&n.hasOwnProperty(XG)&&n.__forward_ref__===cn}function Lx(n){return n&&!!n.\u0275providers}const Bm="https://g.co/ng/security#xss";class te extends Error{constructor(t,e){super(function Vm(n,t){return`NG0${Math.abs(n)}${t?": "+t.trim():""}`}(t,e)),this.code=t}}function nt(n){return"string"==typeof n?n:null==n?"":String(n)}function zm(n,t){throw new te(-201,!1)}function js(n,t){null==n&&function Ht(n,t,e,r){throw new Error(`ASSERTION ERROR: ${n}`+(null==r?"":` [Expected=> ${e} ${r} ${t} <=Actual]`))}(t,n,null,"!=")}function we(n){return{token:n.token,providedIn:n.providedIn||null,factory:n.factory,value:void 0}}function Wt(n){return{providers:n.providers||[],imports:n.imports||[]}}function Um(n){return SN(n,Hm)||SN(n,IN)}function SN(n,t){return n.hasOwnProperty(t)?n[t]:null}function EN(n){return n&&(n.hasOwnProperty(Bx)||n.hasOwnProperty(s5))?n[Bx]:null}const Hm=tn({\u0275prov:tn}),Bx=tn({\u0275inj:tn}),IN=tn({ngInjectableDef:tn}),s5=tn({ngInjectorDef:tn});var qe=(()=>((qe=qe||{})[qe.Default=0]="Default",qe[qe.Host=1]="Host",qe[qe.Self=2]="Self",qe[qe.SkipSelf=4]="SkipSelf",qe[qe.Optional=8]="Optional",qe))();let Vx;function vi(n){const t=Vx;return Vx=n,t}function DN(n,t,e){const r=Um(n);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:e&qe.Optional?null:void 0!==t?t:void zm(nn(n))}const un=(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)(),oh={},zx="__NG_DI_FLAG__",Wm="ngTempTokenPath",a5=/\n/gm,TN="__source";let ah;function Kc(n){const t=ah;return ah=n,t}function c5(n,t=qe.Default){if(void 0===ah)throw new te(-203,!1);return null===ah?DN(n,void 0,t):ah.get(n,t&qe.Optional?null:void 0,t)}function Z(n,t=qe.Default){return(function i5(){return Vx}()||c5)(Ge(n),t)}function Ot(n,t=qe.Default){return Z(n,jm(t))}function jm(n){return typeof n>"u"||"number"==typeof n?n:0|(n.optional&&8)|(n.host&&1)|(n.self&&2)|(n.skipSelf&&4)}function Ux(n){const t=[];for(let e=0;e<n.length;e++){const r=Ge(n[e]);if(Array.isArray(r)){if(0===r.length)throw new te(900,!1);let s,i=qe.Default;for(let o=0;o<r.length;o++){const a=r[o],l=u5(a);"number"==typeof l?-1===l?s=a.token:i|=l:s=a}t.push(Z(s,i))}else t.push(Z(r))}return t}function lh(n,t){return n[zx]=t,n.prototype[zx]=t,n}function u5(n){return n[zx]}function Oa(n){return{toString:n}.toString()}var Gi=(()=>((Gi=Gi||{})[Gi.OnPush=0]="OnPush",Gi[Gi.Default=1]="Default",Gi))(),qi=(()=>{return(n=qi||(qi={}))[n.Emulated=0]="Emulated",n[n.None=2]="None",n[n.ShadowDom=3]="ShadowDom",qi;var n})();const Qo={},Bt=[],Gm=tn({\u0275cmp:tn}),Hx=tn({\u0275dir:tn}),Wx=tn({\u0275pipe:tn}),NN=tn({\u0275mod:tn}),Jo=tn({\u0275fac:tn}),ch=tn({__NG_ELEMENT_ID__:tn});let f5=0;function is(n){return Oa(()=>{const e=!0===n.standalone,r={},s={type:n.type,providersResolver:null,decls:n.decls,vars:n.vars,factory:null,template:n.template||null,consts:n.consts||null,ngContentSelectors:n.ngContentSelectors,hostBindings:n.hostBindings||null,hostVars:n.hostVars||0,hostAttrs:n.hostAttrs||null,contentQueries:n.contentQueries||null,declaredInputs:r,inputs:null,outputs:null,exportAs:n.exportAs||null,onPush:n.changeDetection===Gi.OnPush,directiveDefs:null,pipeDefs:null,standalone:e,dependencies:e&&n.dependencies||null,getStandaloneInjector:null,selectors:n.selectors||Bt,viewQuery:n.viewQuery||null,features:n.features||null,data:n.data||{},encapsulation:n.encapsulation||qi.Emulated,id:"c"+f5++,styles:n.styles||Bt,_:null,setInput:null,schemas:n.schemas||null,tView:null,findHostDirectiveDefs:null,hostDirectives:null},i=n.dependencies,o=n.features;return s.inputs=MN(n.inputs,r),s.outputs=MN(n.outputs),o&&o.forEach(a=>a(s)),s.directiveDefs=i?()=>("function"==typeof i?i():i).map(AN).filter(RN):null,s.pipeDefs=i?()=>("function"==typeof i?i():i).map(os).filter(RN):null,s})}function AN(n){return jt(n)||Hr(n)}function RN(n){return null!==n}function Xt(n){return Oa(()=>({type:n.type,bootstrap:n.bootstrap||Bt,declarations:n.declarations||Bt,imports:n.imports||Bt,exports:n.exports||Bt,transitiveCompileScopes:null,schemas:n.schemas||null,id:n.id||null}))}function MN(n,t){if(null==n)return Qo;const e={};for(const r in n)if(n.hasOwnProperty(r)){let s=n[r],i=s;Array.isArray(s)&&(i=s[1],s=s[0]),e[s]=r,t&&(t[s]=i)}return e}const $e=is;function Ss(n){return{type:n.type,name:n.name,factory:null,pure:!1!==n.pure,standalone:!0===n.standalone,onDestroy:n.type.prototype.ngOnDestroy||null}}function jt(n){return n[Gm]||null}function Hr(n){return n[Hx]||null}function os(n){return n[Wx]||null}function Gs(n,t){const e=n[NN]||null;if(!e&&!0===t)throw new Error(`Type ${nn(n)} does not have '\u0275mod' property.`);return e}function Es(n){return Array.isArray(n)&&"object"==typeof n[1]}function Xi(n){return Array.isArray(n)&&!0===n[1]}function qx(n){return 0!=(4&n.flags)}function Ym(n){return n.componentOffset>-1}function Zm(n){return 1==(1&n.flags)}function Yi(n){return null!==n.template}function _5(n){return 0!=(256&n[2])}function Ul(n,t){return n.hasOwnProperty(Jo)?n[Jo]:null}class w5{constructor(t,e,r){this.previousValue=t,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}}function Is(){return PN}function PN(n){return n.type.prototype.ngOnChanges&&(n.setInput=S5),C5}function C5(){const n=LN(this),t=n?.current;if(t){const e=n.previous;if(e===Qo)n.previous=t;else for(let r in t)e[r]=t[r];n.current=null,this.ngOnChanges(t)}}function S5(n,t,e,r){const s=this.declaredInputs[e],i=LN(n)||function E5(n,t){return n[$N]=t}(n,{previous:Qo,current:null}),o=i.current||(i.current={}),a=i.previous,l=a[s];o[s]=new w5(l&&l.currentValue,t,a===Qo),n[r]=t}Is.ngInherit=!0;const $N="__ngSimpleChanges__";function LN(n){return n[$N]||null}function dr(n){for(;Array.isArray(n);)n=n[0];return n}function Qm(n,t){return dr(t[n])}function Ks(n,t){return dr(t[n.index])}function Qx(n,t){return n.data[t]}function Jc(n,t){return n[t]}function Xs(n,t){const e=t[n];return Es(e)?e:e[0]}function Jm(n){return 64==(64&n[2])}function Pa(n,t){return null==t?null:n[t]}function BN(n){n[18]=0}function Jx(n,t){n[5]+=t;let e=n,r=n[3];for(;null!==r&&(1===t&&1===e[5]||-1===t&&0===e[5]);)r[5]+=t,e=r,r=r[3]}const Je={lFrame:XN(null),bindingsEnabled:!0};function zN(){return Je.bindingsEnabled}function oe(){return Je.lFrame.lView}function At(){return Je.lFrame.tView}function eu(n){return Je.lFrame.contextLView=n,n[8]}function tu(n){return Je.lFrame.contextLView=null,n}function Pr(){let n=UN();for(;null!==n&&64===n.type;)n=n.parent;return n}function UN(){return Je.lFrame.currentTNode}function bo(n,t){const e=Je.lFrame;e.currentTNode=n,e.isParent=t}function e0(){return Je.lFrame.isParent}function t0(){Je.lFrame.isParent=!1}function as(){const n=Je.lFrame;let t=n.bindingRootIndex;return-1===t&&(t=n.bindingRootIndex=n.tView.bindingStartIndex),t}function nu(){return Je.lFrame.bindingIndex++}function ta(n){const t=Je.lFrame,e=t.bindingIndex;return t.bindingIndex=t.bindingIndex+n,e}function V5(n,t){const e=Je.lFrame;e.bindingIndex=e.bindingRootIndex=n,n0(t)}function n0(n){Je.lFrame.currentDirectiveIndex=n}function r0(n){const t=Je.lFrame.currentDirectiveIndex;return-1===t?null:n[t]}function GN(){return Je.lFrame.currentQueryIndex}function s0(n){Je.lFrame.currentQueryIndex=n}function U5(n){const t=n[1];return 2===t.type?t.declTNode:1===t.type?n[6]:null}function qN(n,t,e){if(e&qe.SkipSelf){let s=t,i=n;for(;!(s=s.parent,null!==s||e&qe.Host||(s=U5(i),null===s||(i=i[15],10&s.type))););if(null===s)return!1;t=s,n=i}const r=Je.lFrame=KN();return r.currentTNode=t,r.lView=n,!0}function o0(n){const t=KN(),e=n[1];Je.lFrame=t,t.currentTNode=e.firstChild,t.lView=n,t.tView=e,t.contextLView=n,t.bindingIndex=e.bindingStartIndex,t.inI18n=!1}function KN(){const n=Je.lFrame,t=null===n?null:n.child;return null===t?XN(n):t}function XN(n){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:n,child:null,inI18n:!1};return null!==n&&(n.child=t),t}function YN(){const n=Je.lFrame;return Je.lFrame=n.parent,n.currentTNode=null,n.lView=null,n}const ZN=YN;function a0(){const n=YN();n.isParent=!0,n.tView=null,n.selectedIndex=-1,n.contextLView=null,n.elementDepthCount=0,n.currentDirectiveIndex=-1,n.currentNamespace=null,n.bindingRootIndex=-1,n.bindingIndex=-1,n.currentQueryIndex=0}function ls(){return Je.lFrame.selectedIndex}function Hl(n){Je.lFrame.selectedIndex=n}function kn(){const n=Je.lFrame;return Qx(n.tView,n.selectedIndex)}function mh(){Je.lFrame.currentNamespace="svg"}function l0(){!function G5(){Je.lFrame.currentNamespace=null}()}function eg(n,t){for(let e=t.directiveStart,r=t.directiveEnd;e<r;e++){const i=n.data[e].type.prototype,{ngAfterContentInit:o,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:c,ngOnDestroy:u}=i;o&&(n.contentHooks||(n.contentHooks=[])).push(-e,o),a&&((n.contentHooks||(n.contentHooks=[])).push(e,a),(n.contentCheckHooks||(n.contentCheckHooks=[])).push(e,a)),l&&(n.viewHooks||(n.viewHooks=[])).push(-e,l),c&&((n.viewHooks||(n.viewHooks=[])).push(e,c),(n.viewCheckHooks||(n.viewCheckHooks=[])).push(e,c)),null!=u&&(n.destroyHooks||(n.destroyHooks=[])).push(e,u)}}function tg(n,t,e){QN(n,t,3,e)}function ng(n,t,e,r){(3&n[2])===e&&QN(n,t,e,r)}function c0(n,t){let e=n[2];(3&e)===t&&(e&=2047,e+=1,n[2]=e)}function QN(n,t,e,r){const i=r??-1,o=t.length-1;let a=0;for(let l=void 0!==r?65535&n[18]:0;l<o;l++)if("number"==typeof t[l+1]){if(a=t[l],null!=r&&a>=r)break}else t[l]<0&&(n[18]+=65536),(a<i||-1==i)&&(X5(n,e,t,l),n[18]=(4294901760&n[18])+l+2),l++}function X5(n,t,e,r){const s=e[r]<0,i=e[r+1],a=n[s?-e[r]:e[r]];if(s){if(n[2]>>11<n[18]>>16&&(3&n[2])===t){n[2]+=2048;try{i.call(a)}finally{}}}else try{i.call(a)}finally{}}class gh{constructor(t,e,r){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}}function d0(n,t,e){let r=0;for(;r<e.length;){const s=e[r];if("number"==typeof s){if(0!==s)break;r++;const i=e[r++],o=e[r++],a=e[r++];n.setAttribute(t,o,a,i)}else{const i=s,o=e[++r];eA(i)?n.setProperty(t,i,o):n.setAttribute(t,i,o),r++}}return r}function JN(n){return 3===n||4===n||6===n}function eA(n){return 64===n.charCodeAt(0)}function bh(n,t){if(null!==t&&0!==t.length)if(null===n||0===n.length)n=t.slice();else{let e=-1;for(let r=0;r<t.length;r++){const s=t[r];"number"==typeof s?e=s:0===e||tA(n,e,s,null,-1===e||2===e?t[++r]:null)}}return n}function tA(n,t,e,r,s){let i=0,o=n.length;if(-1===t)o=-1;else for(;i<n.length;){const a=n[i++];if("number"==typeof a){if(a===t){o=-1;break}if(a>t){o=i-1;break}}}for(;i<n.length;){const a=n[i];if("number"==typeof a)break;if(a===e){if(null===r)return void(null!==s&&(n[i+1]=s));if(r===n[i+1])return void(n[i+2]=s)}i++,null!==r&&i++,null!==s&&i++}-1!==o&&(n.splice(o,0,t),i=o+1),n.splice(i++,0,e),null!==r&&n.splice(i++,0,r),null!==s&&n.splice(i++,0,s)}function nA(n){return-1!==n}function ru(n){return 32767&n}function su(n,t){let e=function eq(n){return n>>16}(n),r=t;for(;e>0;)r=r[15],e--;return r}let h0=!0;function rg(n){const t=h0;return h0=n,t}let tq=0;const _o={};function sg(n,t){const e=p0(n,t);if(-1!==e)return e;const r=t[1];r.firstCreatePass&&(n.injectorIndex=t.length,f0(r.data,n),f0(t,null),f0(r.blueprint,null));const s=ig(n,t),i=n.injectorIndex;if(nA(s)){const o=ru(s),a=su(s,t),l=a[1].data;for(let c=0;c<8;c++)t[i+c]=a[o+c]|l[o+c]}return t[i+8]=s,i}function f0(n,t){n.push(0,0,0,0,0,0,0,0,t)}function p0(n,t){return-1===n.injectorIndex||n.parent&&n.parent.injectorIndex===n.injectorIndex||null===t[n.injectorIndex+8]?-1:n.injectorIndex}function ig(n,t){if(n.parent&&-1!==n.parent.injectorIndex)return n.parent.injectorIndex;let e=0,r=null,s=t;for(;null!==s;){if(r=dA(s),null===r)return-1;if(e++,s=s[15],-1!==r.injectorIndex)return r.injectorIndex|e<<16}return-1}function m0(n,t,e){!function nq(n,t,e){let r;"string"==typeof e?r=e.charCodeAt(0)||0:e.hasOwnProperty(ch)&&(r=e[ch]),null==r&&(r=e[ch]=tq++);const s=255&r;t.data[n+(s>>5)]|=1<<s}(n,t,e)}function iA(n,t,e){if(e&qe.Optional||void 0!==n)return n;zm()}function oA(n,t,e,r){if(e&qe.Optional&&void 0===r&&(r=null),0==(e&(qe.Self|qe.Host))){const s=n[9],i=vi(void 0);try{return s?s.get(t,r,e&qe.Optional):DN(t,r,e&qe.Optional)}finally{vi(i)}}return iA(r,0,e)}function aA(n,t,e,r=qe.Default,s){if(null!==n){if(1024&t[2]){const o=function aq(n,t,e,r,s){let i=n,o=t;for(;null!==i&&null!==o&&1024&o[2]&&!(256&o[2]);){const a=lA(i,o,e,r|qe.Self,_o);if(a!==_o)return a;let l=i.parent;if(!l){const c=o[21];if(c){const u=c.get(e,_o,r);if(u!==_o)return u}l=dA(o),o=o[15]}i=l}return s}(n,t,e,r,_o);if(o!==_o)return o}const i=lA(n,t,e,r,_o);if(i!==_o)return i}return oA(t,e,r,s)}function lA(n,t,e,r,s){const i=function iq(n){if("string"==typeof n)return n.charCodeAt(0)||0;const t=n.hasOwnProperty(ch)?n[ch]:void 0;return"number"==typeof t?t>=0?255&t:oq:t}(e);if("function"==typeof i){if(!qN(t,n,r))return r&qe.Host?iA(s,0,r):oA(t,e,r,s);try{const o=i(r);if(null!=o||r&qe.Optional)return o;zm()}finally{ZN()}}else if("number"==typeof i){let o=null,a=p0(n,t),l=-1,c=r&qe.Host?t[16][6]:null;for((-1===a||r&qe.SkipSelf)&&(l=-1===a?ig(n,t):t[a+8],-1!==l&&uA(r,!1)?(o=t[1],a=ru(l),t=su(l,t)):a=-1);-1!==a;){const u=t[1];if(cA(i,a,u.data)){const d=sq(a,t,e,o,r,c);if(d!==_o)return d}l=t[a+8],-1!==l&&uA(r,t[1].data[a+8]===c)&&cA(i,a,t)?(o=u,a=ru(l),t=su(l,t)):a=-1}}return s}function sq(n,t,e,r,s,i){const o=t[1],a=o.data[n+8],u=og(a,o,e,null==r?Ym(a)&&h0:r!=o&&0!=(3&a.type),s&qe.Host&&i===a);return null!==u?iu(t,o,u,a):_o}function og(n,t,e,r,s){const i=n.providerIndexes,o=t.data,a=1048575&i,l=n.directiveStart,u=i>>20,h=s?a+u:n.directiveEnd;for(let f=r?a:a+u;f<h;f++){const p=o[f];if(f<l&&e===p||f>=l&&p.type===e)return f}if(s){const f=o[l];if(f&&Yi(f)&&f.type===e)return l}return null}function iu(n,t,e,r){let s=n[e];const i=t.data;if(function Y5(n){return n instanceof gh}(s)){const o=s;o.resolving&&function YG(n,t){const e=t?`. Dependency path: ${t.join(" > ")} > ${n}`:"";throw new te(-200,`Circular dependency in DI detected for ${n}${e}`)}(function Ut(n){return"function"==typeof n?n.name||n.toString():"object"==typeof n&&null!=n&&"function"==typeof n.type?n.type.name||n.type.toString():nt(n)}(i[e]));const a=rg(o.canSeeViewProviders);o.resolving=!0;const l=o.injectImpl?vi(o.injectImpl):null;qN(n,r,qe.Default);try{s=n[e]=o.factory(void 0,i,n,r),t.firstCreatePass&&e>=r.directiveStart&&function K5(n,t,e){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:i}=t.type.prototype;if(r){const o=PN(t);(e.preOrderHooks||(e.preOrderHooks=[])).push(n,o),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n,o)}s&&(e.preOrderHooks||(e.preOrderHooks=[])).push(0-n,s),i&&((e.preOrderHooks||(e.preOrderHooks=[])).push(n,i),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n,i))}(e,i[e],t)}finally{null!==l&&vi(l),rg(a),o.resolving=!1,ZN()}}return s}function cA(n,t,e){return!!(e[t+(n>>5)]&1<<n)}function uA(n,t){return!(n&qe.Self||n&qe.Host&&t)}class ou{constructor(t,e){this._tNode=t,this._lView=e}get(t,e,r){return aA(this._tNode,this._lView,t,jm(r),e)}}function oq(){return new ou(Pr(),oe())}function hr(n){return Oa(()=>{const t=n.prototype.constructor,e=t[Jo]||g0(t),r=Object.prototype;let s=Object.getPrototypeOf(n.prototype).constructor;for(;s&&s!==r;){const i=s[Jo]||g0(s);if(i&&i!==e)return i;s=Object.getPrototypeOf(s)}return i=>new i})}function g0(n){return $x(n)?()=>{const t=g0(Ge(n));return t&&t()}:Ul(n)}function dA(n){const t=n[1],e=t.type;return 2===e?t.declTNode:1===e?n[6]:null}function au(n){return function rq(n,t){if("class"===t)return n.classes;if("style"===t)return n.styles;const e=n.attrs;if(e){const r=e.length;let s=0;for(;s<r;){const i=e[s];if(JN(i))break;if(0===i)s+=2;else if("number"==typeof i)for(s++;s<r&&"string"==typeof e[s];)s++;else{if(i===t)return e[s+1];s+=2}}}return null}(Pr(),n)}const cu="__parameters__";function du(n,t,e){return Oa(()=>{const r=function y0(n){return function(...e){if(n){const r=n(...e);for(const s in r)this[s]=r[s]}}}(t);function s(...i){if(this instanceof s)return r.apply(this,i),this;const o=new s(...i);return a.annotation=o,a;function a(l,c,u){const d=l.hasOwnProperty(cu)?l[cu]:Object.defineProperty(l,cu,{value:[]})[cu];for(;d.length<=u;)d.push(null);return(d[u]=d[u]||[]).push(o),l}}return e&&(s.prototype=Object.create(e.prototype)),s.prototype.ngMetadataName=n,s.annotationCls=s,s})}class me{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=we({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}function Ys(n,t){void 0===t&&(t=n);for(let e=0;e<n.length;e++){let r=n[e];Array.isArray(r)?(t===n&&(t=n.slice(0,e)),Ys(r,t)):t!==n&&t.push(r)}return t}function Wl(n,t){n.forEach(e=>Array.isArray(e)?Wl(e,t):t(e))}function fA(n,t,e){t>=n.length?n.push(e):n.splice(t,0,e)}function ag(n,t){return t>=n.length-1?n.pop():n.splice(t,1)[0]}function xh(n,t){const e=[];for(let r=0;r<n;r++)e.push(t);return e}function Zs(n,t,e){let r=hu(n,t);return r>=0?n[1|r]=e:(r=~r,function dq(n,t,e,r){let s=n.length;if(s==t)n.push(e,r);else if(1===s)n.push(r,n[0]),n[0]=e;else{for(s--,n.push(n[s-1],n[s]);s>t;)n[s]=n[s-2],s--;n[t]=e,n[t+1]=r}}(n,r,t,e)),r}function _0(n,t){const e=hu(n,t);if(e>=0)return n[1|e]}function hu(n,t){return function gA(n,t,e){let r=0,s=n.length>>e;for(;s!==r;){const i=r+(s-r>>1),o=n[i<<e];if(t===o)return i<<e;o>t?s=i:r=i+1}return~(s<<e)}(n,t,1)}const La=lh(du("Optional"),8),fu=lh(du("SkipSelf"),4);var Ds=(()=>((Ds=Ds||{})[Ds.Important=1]="Important",Ds[Ds.DashCase=2]="DashCase",Ds))();const E0=new Map;let Mq=0;const D0="__ngContext__";function Gr(n,t){Es(t)?(n[D0]=t[20],function Oq(n){E0.set(n[20],n)}(t)):n[D0]=t}function k0(n,t){return undefined(n,t)}function Eh(n){const t=n[3];return Xi(t)?t[3]:t}function N0(n){return $A(n[13])}function A0(n){return $A(n[4])}function $A(n){for(;null!==n&&!Xi(n);)n=n[4];return n}function mu(n,t,e,r,s){if(null!=r){let i,o=!1;Xi(r)?i=r:Es(r)&&(o=!0,r=r[0]);const a=dr(r);0===n&&null!==e?null==s?HA(t,e,a):jl(t,e,a,s||null,!0):1===n&&null!==e?jl(t,e,a,s||null,!0):2===n?function L0(n,t,e){const r=dg(n,t);r&&function n8(n,t,e,r){n.removeChild(t,e,r)}(n,r,t,e)}(t,a,o):3===n&&t.destroyNode(a),null!=i&&function i8(n,t,e,r,s){const i=e[7];i!==dr(e)&&mu(t,n,r,i,s);for(let a=10;a<e.length;a++){const l=e[a];Ih(l[1],l,n,t,r,i)}}(t,n,i,e,s)}}function M0(n,t,e){return n.createElement(t,e)}function BA(n,t){const e=n[9],r=e.indexOf(t),s=t[3];512&t[2]&&(t[2]&=-513,Jx(s,-1)),e.splice(r,1)}function F0(n,t){if(n.length<=10)return;const e=10+t,r=n[e];if(r){const s=r[17];null!==s&&s!==n&&BA(s,r),t>0&&(n[e-1][4]=r[4]);const i=ag(n,10+t);!function Kq(n,t){Ih(n,t,t[11],2,null,null),t[0]=null,t[6]=null}(r[1],r);const o=i[19];null!==o&&o.detachView(i[1]),r[3]=null,r[4]=null,r[2]&=-65}return r}function VA(n,t){if(!(128&t[2])){const e=t[11];e.destroyNode&&Ih(n,t,e,3,null,null),function Zq(n){let t=n[13];if(!t)return O0(n[1],n);for(;t;){let e=null;if(Es(t))e=t[13];else{const r=t[10];r&&(e=r)}if(!e){for(;t&&!t[4]&&t!==n;)Es(t)&&O0(t[1],t),t=t[3];null===t&&(t=n),Es(t)&&O0(t[1],t),e=t&&t[4]}t=e}}(t)}}function O0(n,t){if(!(128&t[2])){t[2]&=-65,t[2]|=128,function t8(n,t){let e;if(null!=n&&null!=(e=n.destroyHooks))for(let r=0;r<e.length;r+=2){const s=t[e[r]];if(!(s instanceof gh)){const i=e[r+1];if(Array.isArray(i))for(let o=0;o<i.length;o+=2){const a=s[i[o]],l=i[o+1];try{l.call(a)}finally{}}else try{i.call(s)}finally{}}}}(n,t),function e8(n,t){const e=n.cleanup,r=t[7];let s=-1;if(null!==e)for(let i=0;i<e.length-1;i+=2)if("string"==typeof e[i]){const o=e[i+3];o>=0?r[s=o]():r[s=-o].unsubscribe(),i+=2}else{const o=r[s=e[i+1]];e[i].call(o)}if(null!==r){for(let i=s+1;i<r.length;i++)(0,r[i])();t[7]=null}}(n,t),1===t[1].type&&t[11].destroy();const e=t[17];if(null!==e&&Xi(t[3])){e!==t[3]&&BA(e,t);const r=t[19];null!==r&&r.detachView(n)}!function Pq(n){E0.delete(n[20])}(t)}}function zA(n,t,e){return function UA(n,t,e){let r=t;for(;null!==r&&40&r.type;)r=(t=r).parent;if(null===r)return e[0];{const{componentOffset:s}=r;if(s>-1){const{encapsulation:i}=n.data[r.directiveStart+s];if(i===qi.None||i===qi.Emulated)return null}return Ks(r,e)}}(n,t.parent,e)}function jl(n,t,e,r,s){n.insertBefore(t,e,r,s)}function HA(n,t,e){n.appendChild(t,e)}function WA(n,t,e,r,s){null!==r?jl(n,t,e,r,s):HA(n,t,e)}function dg(n,t){return n.parentNode(t)}function jA(n,t,e){return qA(n,t,e)}let pg,z0,qA=function GA(n,t,e){return 40&n.type?Ks(n,e):null};function hg(n,t,e,r){const s=zA(n,r,t),i=t[11],a=jA(r.parent||t[6],r,t);if(null!=s)if(Array.isArray(e))for(let l=0;l<e.length;l++)WA(i,s,e[l],a,!1);else WA(i,s,e,a,!1)}function fg(n,t){if(null!==t){const e=t.type;if(3&e)return Ks(t,n);if(4&e)return $0(-1,n[t.index]);if(8&e){const r=t.child;if(null!==r)return fg(n,r);{const s=n[t.index];return Xi(s)?$0(-1,s):dr(s)}}if(32&e)return k0(t,n)()||dr(n[t.index]);{const r=XA(n,t);return null!==r?Array.isArray(r)?r[0]:fg(Eh(n[16]),r):fg(n,t.next)}}return null}function XA(n,t){return null!==t?n[16][6].projection[t.projection]:null}function $0(n,t){const e=10+n+1;if(e<t.length){const r=t[e],s=r[1].firstChild;if(null!==s)return fg(r,s)}return t[7]}function B0(n,t,e,r,s,i,o){for(;null!=e;){const a=r[e.index],l=e.type;if(o&&0===t&&(a&&Gr(dr(a),r),e.flags|=2),32!=(32&e.flags))if(8&l)B0(n,t,e.child,r,s,i,!1),mu(t,n,s,a,i);else if(32&l){const c=k0(e,r);let u;for(;u=c();)mu(t,n,s,u,i);mu(t,n,s,a,i)}else 16&l?YA(n,t,r,e,s,i):mu(t,n,s,a,i);e=o?e.projectionNext:e.next}}function Ih(n,t,e,r,s,i){B0(e,r,n.firstChild,t,s,i,!1)}function YA(n,t,e,r,s,i){const o=e[16],l=o[6].projection[r.projection];if(Array.isArray(l))for(let c=0;c<l.length;c++)mu(t,n,s,l[c],i);else B0(n,t,l,o[3],s,i,!0)}function ZA(n,t,e){""===e?n.removeAttribute(t,"class"):n.setAttribute(t,"class",e)}function QA(n,t,e){const{mergedAttrs:r,classes:s,styles:i}=e;null!==r&&d0(n,t,r),null!==s&&ZA(n,t,s),null!==i&&function a8(n,t,e){n.setAttribute(t,"style",e)}(n,t,i)}function Gl(n){return function V0(){if(void 0===pg&&(pg=null,un.trustedTypes))try{pg=un.trustedTypes.createPolicy("angular",{createHTML:n=>n,createScript:n=>n,createScriptURL:n=>n})}catch{}return pg}()?.createHTML(n)||n}class ql{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Bm})`}}class h8 extends ql{getTypeName(){return"HTML"}}class f8 extends ql{getTypeName(){return"Style"}}class p8 extends ql{getTypeName(){return"Script"}}class m8 extends ql{getTypeName(){return"URL"}}class g8 extends ql{getTypeName(){return"ResourceURL"}}function Qs(n){return n instanceof ql?n.changingThisBreaksApplicationSecurity:n}function vo(n,t){const e=function y8(n){return n instanceof ql&&n.getTypeName()||null}(n);if(null!=e&&e!==t){if("ResourceURL"===e&&"URL"===t)return!0;throw new Error(`Required a safe ${t}, got a ${e} (see ${Bm})`)}return e===t}class C8{constructor(t){this.inertDocumentHelper=t}getInertBodyElement(t){t="<body><remove></remove>"+t;try{const e=(new window.DOMParser).parseFromString(Gl(t),"text/html").body;return null===e?this.inertDocumentHelper.getInertBodyElement(t):(e.removeChild(e.firstChild),e)}catch{return null}}}class S8{constructor(t){if(this.defaultDoc=t,this.inertDocument=this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"),null==this.inertDocument.body){const e=this.inertDocument.createElement("html");this.inertDocument.appendChild(e);const r=this.inertDocument.createElement("body");e.appendChild(r)}}getInertBodyElement(t){const e=this.inertDocument.createElement("template");if("content"in e)return e.innerHTML=Gl(t),e;const r=this.inertDocument.createElement("body");return r.innerHTML=Gl(t),this.defaultDoc.documentMode&&this.stripCustomNsAttrs(r),r}stripCustomNsAttrs(t){const e=t.attributes;for(let s=e.length-1;0<s;s--){const o=e.item(s).name;("xmlns:ns1"===o||0===o.indexOf("ns1:"))&&t.removeAttribute(o)}let r=t.firstChild;for(;r;)r.nodeType===Node.ELEMENT_NODE&&this.stripCustomNsAttrs(r),r=r.nextSibling}}const I8=/^(?:(?:https?|mailto|data|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi;function gg(n){return(n=String(n)).match(I8)?n:"unsafe:"+n}function na(n){const t={};for(const e of n.split(","))t[e]=!0;return t}function Dh(...n){const t={};for(const e of n)for(const r in e)e.hasOwnProperty(r)&&(t[r]=!0);return t}const sR=na("area,br,col,hr,img,wbr"),iR=na("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),oR=na("rp,rt"),H0=Dh(sR,Dh(iR,na("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),Dh(oR,na("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),Dh(oR,iR)),W0=na("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),aR=Dh(W0,na("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),na("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),D8=na("script,style,template");class T8{constructor(){this.sanitizedSomething=!1,this.buf=[]}sanitizeChildren(t){let e=t.firstChild,r=!0;for(;e;)if(e.nodeType===Node.ELEMENT_NODE?r=this.startElement(e):e.nodeType===Node.TEXT_NODE?this.chars(e.nodeValue):this.sanitizedSomething=!0,r&&e.firstChild)e=e.firstChild;else for(;e;){e.nodeType===Node.ELEMENT_NODE&&this.endElement(e);let s=this.checkClobberedElement(e,e.nextSibling);if(s){e=s;break}e=this.checkClobberedElement(e,e.parentNode)}return this.buf.join("")}startElement(t){const e=t.nodeName.toLowerCase();if(!H0.hasOwnProperty(e))return this.sanitizedSomething=!0,!D8.hasOwnProperty(e);this.buf.push("<"),this.buf.push(e);const r=t.attributes;for(let s=0;s<r.length;s++){const i=r.item(s),o=i.name,a=o.toLowerCase();if(!aR.hasOwnProperty(a)){this.sanitizedSomething=!0;continue}let l=i.value;W0[a]&&(l=gg(l)),this.buf.push(" ",o,'="',lR(l),'"')}return this.buf.push(">"),!0}endElement(t){const e=t.nodeName.toLowerCase();H0.hasOwnProperty(e)&&!sR.hasOwnProperty(e)&&(this.buf.push("</"),this.buf.push(e),this.buf.push(">"))}chars(t){this.buf.push(lR(t))}checkClobberedElement(t,e){if(e&&(t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_CONTAINED_BY)===Node.DOCUMENT_POSITION_CONTAINED_BY)throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`);return e}}const k8=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,N8=/([^\#-~ |!])/g;function lR(n){return n.replace(/&/g,"&amp;").replace(k8,function(t){return"&#"+(1024*(t.charCodeAt(0)-55296)+(t.charCodeAt(1)-56320)+65536)+";"}).replace(N8,function(t){return"&#"+t.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}let yg;function cR(n,t){let e=null;try{yg=yg||function rR(n){const t=new S8(n);return function E8(){try{return!!(new window.DOMParser).parseFromString(Gl(""),"text/html")}catch{return!1}}()?new C8(t):t}(n);let r=t?String(t):"";e=yg.getInertBodyElement(r);let s=5,i=r;do{if(0===s)throw new Error("Failed to sanitize html because the input is unstable");s--,r=i,i=e.innerHTML,e=yg.getInertBodyElement(r)}while(r!==i);return Gl((new T8).sanitizeChildren(j0(e)||e))}finally{if(e){const r=j0(e)||e;for(;r.firstChild;)r.removeChild(r.firstChild)}}}function j0(n){return"content"in n&&function A8(n){return n.nodeType===Node.ELEMENT_NODE&&"TEMPLATE"===n.nodeName}(n)?n.content:null}var Vt=(()=>((Vt=Vt||{})[Vt.NONE=0]="NONE",Vt[Vt.HTML=1]="HTML",Vt[Vt.STYLE=2]="STYLE",Vt[Vt.SCRIPT=3]="SCRIPT",Vt[Vt.URL=4]="URL",Vt[Vt.RESOURCE_URL=5]="RESOURCE_URL",Vt))();const bg=new me("ENVIRONMENT_INITIALIZER"),fR=new me("INJECTOR",-1),pR=new me("INJECTOR_DEF_TYPES");class mR{get(t,e=oh){if(e===oh){const r=new Error(`NullInjectorError: No provider for ${nn(t)}!`);throw r.name="NullInjectorError",r}return e}}function L8(...n){return{\u0275providers:gR(0,n),\u0275fromNgModule:!0}}function gR(n,...t){const e=[],r=new Set;let s;return Wl(t,i=>{const o=i;G0(o,e,[],r)&&(s||(s=[]),s.push(o))}),void 0!==s&&yR(s,e),e}function yR(n,t){for(let e=0;e<n.length;e++){const{providers:s}=n[e];q0(s,i=>{t.push(i)})}}function G0(n,t,e,r){if(!(n=Ge(n)))return!1;let s=null,i=EN(n);const o=!i&&jt(n);if(i||o){if(o&&!o.standalone)return!1;s=n}else{const l=n.ngModule;if(i=EN(l),!i)return!1;s=l}const a=r.has(s);if(o){if(a)return!1;if(r.add(s),o.dependencies){const l="function"==typeof o.dependencies?o.dependencies():o.dependencies;for(const c of l)G0(c,t,e,r)}}else{if(!i)return!1;{if(null!=i.imports&&!a){let c;r.add(s);try{Wl(i.imports,u=>{G0(u,t,e,r)&&(c||(c=[]),c.push(u))})}finally{}void 0!==c&&yR(c,t)}if(!a){const c=Ul(s)||(()=>new s);t.push({provide:s,useFactory:c,deps:Bt},{provide:pR,useValue:s,multi:!0},{provide:bg,useValue:()=>Z(s),multi:!0})}const l=i.providers;null==l||a||q0(l,u=>{t.push(u)})}}return s!==n&&void 0!==n.providers}function q0(n,t){for(let e of n)Lx(e)&&(e=e.\u0275providers),Array.isArray(e)?q0(e,t):t(e)}const B8=tn({provide:String,useValue:tn});function K0(n){return null!==n&&"object"==typeof n&&B8 in n}function Kl(n){return"function"==typeof n}const X0=new me("Set Injector scope."),_g={},z8={};let Y0;function vg(){return void 0===Y0&&(Y0=new mR),Y0}class Ba{}class vR extends Ba{constructor(t,e,r,s){super(),this.parent=e,this.source=r,this.scopes=s,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,Q0(t,o=>this.processProvider(o)),this.records.set(fR,gu(void 0,this)),s.has("environment")&&this.records.set(Ba,gu(void 0,this));const i=this.records.get(X0);null!=i&&"string"==typeof i.value&&this.scopes.add(i.value),this.injectorDefTypes=new Set(this.get(pR.multi,Bt,qe.Self))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const t of this._ngOnDestroyHooks)t.ngOnDestroy();for(const t of this._onDestroyHooks)t()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),this._onDestroyHooks.length=0}}onDestroy(t){this._onDestroyHooks.push(t)}runInContext(t){this.assertNotDestroyed();const e=Kc(this),r=vi(void 0);try{return t()}finally{Kc(e),vi(r)}}get(t,e=oh,r=qe.Default){this.assertNotDestroyed(),r=jm(r);const s=Kc(this),i=vi(void 0);try{if(!(r&qe.SkipSelf)){let a=this.records.get(t);if(void 0===a){const l=function G8(n){return"function"==typeof n||"object"==typeof n&&n instanceof me}(t)&&Um(t);a=l&&this.injectableDefInScope(l)?gu(Z0(t),_g):null,this.records.set(t,a)}if(null!=a)return this.hydrate(t,a)}return(r&qe.Self?vg():this.parent).get(t,e=r&qe.Optional&&e===oh?null:e)}catch(o){if("NullInjectorError"===o.name){if((o[Wm]=o[Wm]||[]).unshift(nn(t)),s)throw o;return function d5(n,t,e,r){const s=n[Wm];throw t[TN]&&s.unshift(t[TN]),n.message=function h5(n,t,e,r=null){n=n&&"\n"===n.charAt(0)&&"\u0275"==n.charAt(1)?n.slice(2):n;let s=nn(t);if(Array.isArray(t))s=t.map(nn).join(" -> ");else if("object"==typeof t){let i=[];for(let o in t)if(t.hasOwnProperty(o)){let a=t[o];i.push(o+":"+("string"==typeof a?JSON.stringify(a):nn(a)))}s=`{${i.join(", ")}}`}return`${e}${r?"("+r+")":""}[${s}]: ${n.replace(a5,"\n  ")}`}("\n"+n.message,s,e,r),n.ngTokenPath=s,n[Wm]=null,n}(o,t,"R3InjectorError",this.source)}throw o}finally{vi(i),Kc(s)}}resolveInjectorInitializers(){const t=Kc(this),e=vi(void 0);try{const r=this.get(bg.multi,Bt,qe.Self);for(const s of r)s()}finally{Kc(t),vi(e)}}toString(){const t=[],e=this.records;for(const r of e.keys())t.push(nn(r));return`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new te(205,!1)}processProvider(t){let e=Kl(t=Ge(t))?t:Ge(t&&t.provide);const r=function H8(n){return K0(n)?gu(void 0,n.useValue):gu(xR(n),_g)}(t);if(Kl(t)||!0!==t.multi)this.records.get(e);else{let s=this.records.get(e);s||(s=gu(void 0,_g,!0),s.factory=()=>Ux(s.multi),this.records.set(e,s)),e=t,s.multi.push(t)}this.records.set(e,r)}hydrate(t,e){return e.value===_g&&(e.value=z8,e.value=e.factory()),"object"==typeof e.value&&e.value&&function j8(n){return null!==n&&"object"==typeof n&&"function"==typeof n.ngOnDestroy}(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}injectableDefInScope(t){if(!t.providedIn)return!1;const e=Ge(t.providedIn);return"string"==typeof e?"any"===e||this.scopes.has(e):this.injectorDefTypes.has(e)}}function Z0(n){const t=Um(n),e=null!==t?t.factory:Ul(n);if(null!==e)return e;if(n instanceof me)throw new te(204,!1);if(n instanceof Function)return function U8(n){const t=n.length;if(t>0)throw xh(t,"?"),new te(204,!1);const e=function n5(n){const t=n&&(n[Hm]||n[IN]);if(t){const e=function r5(n){if(n.hasOwnProperty("name"))return n.name;const t=(""+n).match(/^function\s*([^\s(]+)/);return null===t?"":t[1]}(n);return console.warn(`DEPRECATED: DI is instantiating a token "${e}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${e}" class.`),t}return null}(n);return null!==e?()=>e.factory(n):()=>new n}(n);throw new te(204,!1)}function xR(n,t,e){let r;if(Kl(n)){const s=Ge(n);return Ul(s)||Z0(s)}if(K0(n))r=()=>Ge(n.useValue);else if(function _R(n){return!(!n||!n.useFactory)}(n))r=()=>n.useFactory(...Ux(n.deps||[]));else if(function bR(n){return!(!n||!n.useExisting)}(n))r=()=>Z(Ge(n.useExisting));else{const s=Ge(n&&(n.useClass||n.provide));if(!function W8(n){return!!n.deps}(n))return Ul(s)||Z0(s);r=()=>new s(...Ux(n.deps))}return r}function gu(n,t,e=!1){return{factory:n,value:t,multi:e?[]:void 0}}function Q0(n,t){for(const e of n)Array.isArray(e)?Q0(e,t):e&&Lx(e)?Q0(e.\u0275providers,t):t(e)}class q8{}class wR{}class X8{resolveComponentFactory(t){throw function K8(n){const t=Error(`No component factory found for ${nn(n)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=n,t}(t)}}let Xl=(()=>{class n{}return n.NULL=new X8,n})();function Y8(){return yu(Pr(),oe())}function yu(n,t){return new hn(Ks(n,t))}let hn=(()=>{class n{constructor(e){this.nativeElement=e}}return n.__NG_ELEMENT_ID__=Y8,n})();function Z8(n){return n instanceof hn?n.nativeElement:n}class kh{}let ra=(()=>{class n{}return n.__NG_ELEMENT_ID__=()=>function Q8(){const n=oe(),e=Xs(Pr().index,n);return(Es(e)?e:n)[11]}(),n})(),J8=(()=>{class n{}return n.\u0275prov=we({token:n,providedIn:"root",factory:()=>null}),n})();class Yl{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const e6=new Yl("15.0.1"),J0={};function tw(n){return n.ngOriginalError}class sa{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t);this._console.error("ERROR",t),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(t){let e=t&&tw(t);for(;e&&tw(e);)e=tw(e);return e||null}}function ia(n){return n instanceof Function?n():n}function ER(n,t,e){let r=n.length;for(;;){const s=n.indexOf(t,e);if(-1===s)return s;if(0===s||n.charCodeAt(s-1)<=32){const i=t.length;if(s+i===r||n.charCodeAt(s+i)<=32)return s}e=s+1}}const IR="ng-template";function d6(n,t,e){let r=0;for(;r<n.length;){let s=n[r++];if(e&&"class"===s){if(s=n[r],-1!==ER(s.toLowerCase(),t,0))return!0}else if(1===s){for(;r<n.length&&"string"==typeof(s=n[r++]);)if(s.toLowerCase()===t)return!0;return!1}}return!1}function DR(n){return 4===n.type&&n.value!==IR}function h6(n,t,e){return t===(4!==n.type||e?n.value:IR)}function f6(n,t,e){let r=4;const s=n.attrs||[],i=function g6(n){for(let t=0;t<n.length;t++)if(JN(n[t]))return t;return n.length}(s);let o=!1;for(let a=0;a<t.length;a++){const l=t[a];if("number"!=typeof l){if(!o)if(4&r){if(r=2|1&r,""!==l&&!h6(n,l,e)||""===l&&1===t.length){if(Zi(r))return!1;o=!0}}else{const c=8&r?l:t[++a];if(8&r&&null!==n.attrs){if(!d6(n.attrs,c,e)){if(Zi(r))return!1;o=!0}continue}const d=p6(8&r?"class":l,s,DR(n),e);if(-1===d){if(Zi(r))return!1;o=!0;continue}if(""!==c){let h;h=d>i?"":s[d+1].toLowerCase();const f=8&r?h:null;if(f&&-1!==ER(f,c,0)||2&r&&c!==h){if(Zi(r))return!1;o=!0}}}}else{if(!o&&!Zi(r)&&!Zi(l))return!1;if(o&&Zi(l))continue;o=!1,r=l|1&r}}return Zi(r)||o}function Zi(n){return 0==(1&n)}function p6(n,t,e,r){if(null===t)return-1;let s=0;if(r||!e){let i=!1;for(;s<t.length;){const o=t[s];if(o===n)return s;if(3===o||6===o)i=!0;else{if(1===o||2===o){let a=t[++s];for(;"string"==typeof a;)a=t[++s];continue}if(4===o)break;if(0===o){s+=4;continue}}s+=i?1:2}return-1}return function y6(n,t){let e=n.indexOf(4);if(e>-1)for(e++;e<n.length;){const r=n[e];if("number"==typeof r)return-1;if(r===t)return e;e++}return-1}(t,n)}function TR(n,t,e=!1){for(let r=0;r<t.length;r++)if(f6(n,t[r],e))return!0;return!1}function b6(n,t){e:for(let e=0;e<t.length;e++){const r=t[e];if(n.length===r.length){for(let s=0;s<n.length;s++)if(n[s]!==r[s])continue e;return!0}}return!1}function kR(n,t){return n?":not("+t.trim()+")":t}function _6(n){let t=n[0],e=1,r=2,s="",i=!1;for(;e<n.length;){let o=n[e];if("string"==typeof o)if(2&r){const a=n[++e];s+="["+o+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?s+="."+o:4&r&&(s+=" "+o);else""!==s&&!Zi(o)&&(t+=kR(i,s),s=""),r=o,i=i||!Zi(r);e++}return""!==s&&(t+=kR(i,s)),t}const rt={};function Pt(n){NR(At(),oe(),ls()+n,!1)}function NR(n,t,e,r){if(!r)if(3==(3&t[2])){const i=n.preOrderCheckHooks;null!==i&&tg(t,i,e)}else{const i=n.preOrderHooks;null!==i&&ng(t,i,0,e)}Hl(e)}function FR(n,t=null,e=null,r){const s=OR(n,t,e,r);return s.resolveInjectorInitializers(),s}function OR(n,t=null,e=null,r,s=new Set){const i=[e||Bt,L8(n)];return r=r||("object"==typeof n?void 0:nn(n)),new vR(i,t||vg(),r||null,s)}let pr=(()=>{class n{static create(e,r){if(Array.isArray(e))return FR({name:""},r,e,"");{const s=e.name??"";return FR({name:s},e.parent,e.providers,s)}}}return n.THROW_IF_NOT_FOUND=oh,n.NULL=new mR,n.\u0275prov=we({token:n,providedIn:"any",factory:()=>Z(fR)}),n.__NG_ELEMENT_ID__=-1,n})();function H(n,t=qe.Default){const e=oe();return null===e?Z(n,t):aA(Pr(),e,Ge(n),t)}function Nh(){throw new Error("invalid")}function wg(n,t){return n<<17|t<<2}function Qi(n){return n>>17&32767}function ow(n){return 2|n}function oa(n){return(131068&n)>>2}function aw(n,t){return-131069&n|t<<2}function lw(n){return 1|n}function QR(n,t){const e=n.contentQueries;if(null!==e)for(let r=0;r<e.length;r+=2){const s=e[r],i=e[r+1];if(-1!==i){const o=n.data[i];s0(s),o.contentQueries(2,t[i],i)}}}function Eg(n,t,e,r,s,i,o,a,l,c,u){const d=t.blueprint.slice();return d[0]=s,d[2]=76|r,(null!==u||n&&1024&n[2])&&(d[2]|=1024),BN(d),d[3]=d[15]=n,d[8]=e,d[10]=o||n&&n[10],d[11]=a||n&&n[11],d[12]=l||n&&n[12]||null,d[9]=c||n&&n[9]||null,d[6]=i,d[20]=function Fq(){return Mq++}(),d[21]=u,d[16]=2==t.type?n[16]:d,d}function vu(n,t,e,r,s){let i=n.data[t];if(null===i)i=function gw(n,t,e,r,s){const i=UN(),o=e0(),l=n.data[t]=function tK(n,t,e,r,s,i){return{type:e,index:r,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:0,providerIndexes:0,value:s,attrs:i,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,o?i:i&&i.parent,e,t,r,s);return null===n.firstChild&&(n.firstChild=l),null!==i&&(o?null==i.child&&null!==l.parent&&(i.child=l):null===i.next&&(i.next=l)),l}(n,t,e,r,s),function B5(){return Je.lFrame.inI18n}()&&(i.flags|=32);else if(64&i.type){i.type=e,i.value=r,i.attrs=s;const o=function ph(){const n=Je.lFrame,t=n.currentTNode;return n.isParent?t:t.parent}();i.injectorIndex=null===o?-1:o.injectorIndex}return bo(i,!0),i}function Ah(n,t,e,r){if(0===e)return-1;const s=t.length;for(let i=0;i<e;i++)t.push(r),n.blueprint.push(r),n.data.push(null);return s}function yw(n,t,e){o0(t);try{const r=n.viewQuery;null!==r&&Dw(1,r,e);const s=n.template;null!==s&&JR(n,t,s,1,e),n.firstCreatePass&&(n.firstCreatePass=!1),n.staticContentQueries&&QR(n,t),n.staticViewQueries&&Dw(2,n.viewQuery,e);const i=n.components;null!==i&&function Q6(n,t){for(let e=0;e<t.length;e++)vK(n,t[e])}(t,i)}catch(r){throw n.firstCreatePass&&(n.incompleteFirstPass=!0,n.firstCreatePass=!1),r}finally{t[2]&=-5,a0()}}function Ig(n,t,e,r){const s=t[2];if(128!=(128&s)){o0(t);try{BN(t),function WN(n){return Je.lFrame.bindingIndex=n}(n.bindingStartIndex),null!==e&&JR(n,t,e,2,r);const o=3==(3&s);if(o){const c=n.preOrderCheckHooks;null!==c&&tg(t,c,null)}else{const c=n.preOrderHooks;null!==c&&ng(t,c,0,null),c0(t,0)}if(function bK(n){for(let t=N0(n);null!==t;t=A0(t)){if(!t[2])continue;const e=t[9];for(let r=0;r<e.length;r++){const s=e[r],i=s[3];0==(512&s[2])&&Jx(i,1),s[2]|=512}}}(t),function yK(n){for(let t=N0(n);null!==t;t=A0(t))for(let e=10;e<t.length;e++){const r=t[e],s=r[1];Jm(r)&&Ig(s,r,s.template,r[8])}}(t),null!==n.contentQueries&&QR(n,t),o){const c=n.contentCheckHooks;null!==c&&tg(t,c)}else{const c=n.contentHooks;null!==c&&ng(t,c,1),c0(t,1)}!function Y6(n,t){const e=n.hostBindingOpCodes;if(null!==e)try{for(let r=0;r<e.length;r++){const s=e[r];if(s<0)Hl(~s);else{const i=s,o=e[++r],a=e[++r];V5(o,i),a(2,t[i])}}}finally{Hl(-1)}}(n,t);const a=n.components;null!==a&&function Z6(n,t){for(let e=0;e<t.length;e++)_K(n,t[e])}(t,a);const l=n.viewQuery;if(null!==l&&Dw(2,l,r),o){const c=n.viewCheckHooks;null!==c&&tg(t,c)}else{const c=n.viewHooks;null!==c&&ng(t,c,2),c0(t,2)}!0===n.firstUpdatePass&&(n.firstUpdatePass=!1),t[2]&=-41,512&t[2]&&(t[2]&=-513,Jx(t[3],-1))}finally{a0()}}}function JR(n,t,e,r,s){const i=ls(),o=2&r;try{Hl(-1),o&&t.length>22&&NR(n,t,22,!1),e(r,s)}finally{Hl(i)}}function bw(n,t,e){if(qx(t)){const s=t.directiveEnd;for(let i=t.directiveStart;i<s;i++){const o=n.data[i];o.contentQueries&&o.contentQueries(1,e[i],i)}}}function _w(n,t,e){!zN()||(function aK(n,t,e,r){const s=e.directiveStart,i=e.directiveEnd;n.firstCreatePass||sg(e,t),Gr(r,t);const o=e.initialInputs;for(let a=s;a<i;a++){const l=n.data[a],c=Yi(l);c&&pK(t,e,l);const u=iu(t,n,a,e);Gr(u,t),null!==o&&mK(0,a-s,u,l,0,o),c&&(Xs(e.index,t)[8]=u)}}(n,t,e,Ks(e,t)),64==(64&e.flags)&&oM(n,t,e))}function vw(n,t,e=Ks){const r=t.localNames;if(null!==r){let s=t.index+1;for(let i=0;i<r.length;i+=2){const o=r[i+1],a=-1===o?e(t,n):n[o];n[s++]=a}}}function eM(n){const t=n.tView;return null===t||t.incompleteFirstPass?n.tView=xw(1,null,n.template,n.decls,n.vars,n.directiveDefs,n.pipeDefs,n.viewQuery,n.schemas,n.consts):t}function xw(n,t,e,r,s,i,o,a,l,c){const u=22+r,d=u+s,h=function J6(n,t){const e=[];for(let r=0;r<t;r++)e.push(r<n?null:rt);return e}(u,d),f="function"==typeof c?c():c;return h[1]={type:n,blueprint:h,template:e,queries:null,viewQuery:a,declTNode:t,data:h.slice().fill(null,u),bindingStartIndex:u,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof i?i():i,pipeRegistry:"function"==typeof o?o():o,firstChild:null,schemas:l,consts:f,incompleteFirstPass:!1}}function tM(n,t,e,r){const s=lM(t);null===e?s.push(r):(s.push(e),n.firstCreatePass&&cM(n).push(r,s.length-1))}function nM(n,t,e,r){for(let s in n)if(n.hasOwnProperty(s)){e=null===e?{}:e;const i=n[s];null===r?rM(e,t,s,i):r.hasOwnProperty(s)&&rM(e,t,r[s],i)}return e}function rM(n,t,e,r){n.hasOwnProperty(e)?n[e].push(t,r):n[e]=[t,r]}function Js(n,t,e,r,s,i,o,a){const l=Ks(t,e);let u,c=t.inputs;!a&&null!=c&&(u=c[r])?(Tw(n,e,u,r,s),Ym(t)&&sM(e,t.index)):3&t.type&&(r=function rK(n){return"class"===n?"className":"for"===n?"htmlFor":"formaction"===n?"formAction":"innerHtml"===n?"innerHTML":"readonly"===n?"readOnly":"tabindex"===n?"tabIndex":n}(r),s=null!=o?o(s,t.value||"",r):s,i.setProperty(l,r,s))}function sM(n,t){const e=Xs(t,n);16&e[2]||(e[2]|=32)}function ww(n,t,e,r){let s=!1;if(zN()){const i=null===r?null:{"":-1},o=function cK(n,t){const e=n.directiveRegistry;let r=null,s=null;if(e)for(let i=0;i<e.length;i++){const o=e[i];if(TR(t,o.selectors,!1))if(r||(r=[]),Yi(o))if(null!==o.findHostDirectiveDefs){const a=[];s=s||new Map,o.findHostDirectiveDefs(o,a,s),r.unshift(...a,o),Cw(n,t,a.length)}else r.unshift(o),Cw(n,t,0);else s=s||new Map,o.findHostDirectiveDefs?.(o,r,s),r.push(o)}return null===r?null:[r,s]}(n,e);let a,l;null===o?a=l=null:[a,l]=o,null!==a&&(s=!0,iM(n,t,e,a,i,l)),i&&function uK(n,t,e){if(t){const r=n.localNames=[];for(let s=0;s<t.length;s+=2){const i=e[t[s+1]];if(null==i)throw new te(-301,!1);r.push(t[s],i)}}}(e,r,i)}return e.mergedAttrs=bh(e.mergedAttrs,e.attrs),s}function iM(n,t,e,r,s,i){for(let c=0;c<r.length;c++)m0(sg(e,t),n,r[c].type);!function hK(n,t,e){n.flags|=1,n.directiveStart=t,n.directiveEnd=t+e,n.providerIndexes=t}(e,n.data.length,r.length);for(let c=0;c<r.length;c++){const u=r[c];u.providersResolver&&u.providersResolver(u)}let o=!1,a=!1,l=Ah(n,t,r.length,null);for(let c=0;c<r.length;c++){const u=r[c];e.mergedAttrs=bh(e.mergedAttrs,u.hostAttrs),fK(n,e,t,l,u),dK(l,u,s),null!==u.contentQueries&&(e.flags|=4),(null!==u.hostBindings||null!==u.hostAttrs||0!==u.hostVars)&&(e.flags|=64);const d=u.type.prototype;!o&&(d.ngOnChanges||d.ngOnInit||d.ngDoCheck)&&((n.preOrderHooks||(n.preOrderHooks=[])).push(e.index),o=!0),!a&&(d.ngOnChanges||d.ngDoCheck)&&((n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e.index),a=!0),l++}!function nK(n,t,e){const s=t.directiveEnd,i=n.data,o=t.attrs,a=[];let l=null,c=null;for(let u=t.directiveStart;u<s;u++){const d=i[u],h=e?e.get(d):null,p=h?h.outputs:null;l=nM(d.inputs,u,l,h?h.inputs:null),c=nM(d.outputs,u,c,p);const m=null===l||null===o||DR(t)?null:gK(l,u,o);a.push(m)}null!==l&&(l.hasOwnProperty("class")&&(t.flags|=8),l.hasOwnProperty("style")&&(t.flags|=16)),t.initialInputs=a,t.inputs=l,t.outputs=c}(n,e,i)}function oM(n,t,e){const r=e.directiveStart,s=e.directiveEnd,i=e.index,o=function z5(){return Je.lFrame.currentDirectiveIndex}();try{Hl(i);for(let a=r;a<s;a++){const l=n.data[a],c=t[a];n0(a),(null!==l.hostBindings||0!==l.hostVars||null!==l.hostAttrs)&&lK(l,c)}}finally{Hl(-1),n0(o)}}function lK(n,t){null!==n.hostBindings&&n.hostBindings(1,t)}function Cw(n,t,e){t.componentOffset=e,(n.components||(n.components=[])).push(t.index)}function dK(n,t,e){if(e){if(t.exportAs)for(let r=0;r<t.exportAs.length;r++)e[t.exportAs[r]]=n;Yi(t)&&(e[""]=n)}}function fK(n,t,e,r,s){n.data[r]=s;const i=s.factory||(s.factory=Ul(s.type)),o=new gh(i,Yi(s),H);n.blueprint[r]=o,e[r]=o,function iK(n,t,e,r,s){const i=s.hostBindings;if(i){let o=n.hostBindingOpCodes;null===o&&(o=n.hostBindingOpCodes=[]);const a=~t.index;(function oK(n){let t=n.length;for(;t>0;){const e=n[--t];if("number"==typeof e&&e<0)return e}return 0})(o)!=a&&o.push(a),o.push(e,r,i)}}(n,t,r,Ah(n,e,s.hostVars,rt),s)}function pK(n,t,e){const r=Ks(t,n),s=eM(e),i=n[10],o=Dg(n,Eg(n,s,null,e.onPush?32:16,r,t,i,i.createRenderer(r,e),null,null,null));n[t.index]=o}function xo(n,t,e,r,s,i){const o=Ks(n,t);!function Sw(n,t,e,r,s,i,o){if(null==i)n.removeAttribute(t,s,e);else{const a=null==o?nt(i):o(i,r||"",s);n.setAttribute(t,s,a,e)}}(t[11],o,i,n.value,e,r,s)}function mK(n,t,e,r,s,i){const o=i[t];if(null!==o){const a=r.setInput;for(let l=0;l<o.length;){const c=o[l++],u=o[l++],d=o[l++];null!==a?r.setInput(e,d,c,u):e[u]=d}}}function gK(n,t,e){let r=null,s=0;for(;s<e.length;){const i=e[s];if(0!==i)if(5!==i){if("number"==typeof i)break;if(n.hasOwnProperty(i)){null===r&&(r=[]);const o=n[i];for(let a=0;a<o.length;a+=2)if(o[a]===t){r.push(i,o[a+1],e[s+1]);break}}s+=2}else s+=2;else s+=4}return r}function aM(n,t,e,r){return new Array(n,!0,!1,t,null,0,r,e,null,null)}function _K(n,t){const e=Xs(t,n);if(Jm(e)){const r=e[1];48&e[2]?Ig(r,e,r.template,e[8]):e[5]>0&&Ew(e)}}function Ew(n){for(let r=N0(n);null!==r;r=A0(r))for(let s=10;s<r.length;s++){const i=r[s];if(Jm(i))if(512&i[2]){const o=i[1];Ig(o,i,o.template,i[8])}else i[5]>0&&Ew(i)}const e=n[1].components;if(null!==e)for(let r=0;r<e.length;r++){const s=Xs(e[r],n);Jm(s)&&s[5]>0&&Ew(s)}}function vK(n,t){const e=Xs(t,n),r=e[1];(function xK(n,t){for(let e=t.length;e<n.blueprint.length;e++)t.push(n.blueprint[e])})(r,e),yw(r,e,e[8])}function Dg(n,t){return n[13]?n[14][4]=t:n[13]=t,n[14]=t,t}function Iw(n){for(;n;){n[2]|=32;const t=Eh(n);if(_5(n)&&!t)return n;n=t}return null}function Tg(n,t,e,r=!0){const s=t[10];s.begin&&s.begin();try{Ig(n,t,n.template,e)}catch(o){throw r&&dM(t,o),o}finally{s.end&&s.end()}}function Dw(n,t,e){s0(0),t(n,e)}function lM(n){return n[7]||(n[7]=[])}function cM(n){return n.cleanup||(n.cleanup=[])}function uM(n,t,e){return(null===n||Yi(n))&&(e=function k5(n){for(;Array.isArray(n);){if("object"==typeof n[1])return n;n=n[0]}return null}(e[t.index])),e[11]}function dM(n,t){const e=n[9],r=e?e.get(sa,null):null;r&&r.handleError(t)}function Tw(n,t,e,r,s){for(let i=0;i<e.length;){const o=e[i++],a=e[i++],l=t[o],c=n.data[o];null!==c.setInput?c.setInput(l,s,r,a):l[a]=s}}function kg(n,t,e){let r=e?n.styles:null,s=e?n.classes:null,i=0;if(null!==t)for(let o=0;o<t.length;o++){const a=t[o];"number"==typeof a?i=a:1==i?s=Px(s,a):2==i&&(r=Px(r,a+": "+t[++o]+";"))}e?n.styles=r:n.stylesWithoutHost=r,e?n.classes=s:n.classesWithoutHost=s}function Ng(n,t,e,r,s=!1){for(;null!==e;){const i=t[e.index];if(null!==i&&r.push(dr(i)),Xi(i))for(let a=10;a<i.length;a++){const l=i[a],c=l[1].firstChild;null!==c&&Ng(l[1],l,c,r)}const o=e.type;if(8&o)Ng(n,t,e.child,r);else if(32&o){const a=k0(e,t);let l;for(;l=a();)r.push(l)}else if(16&o){const a=XA(t,e);if(Array.isArray(a))r.push(...a);else{const l=Eh(t[16]);Ng(l[1],l,a,r,!0)}}e=s?e.projectionNext:e.next}return r}class Rh{constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const t=this._lView,e=t[1];return Ng(e,t,e.firstChild,[])}get context(){return this._lView[8]}set context(t){this._lView[8]=t}get destroyed(){return 128==(128&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[3];if(Xi(t)){const e=t[8],r=e?e.indexOf(this):-1;r>-1&&(F0(t,r),ag(e,r))}this._attachedToViewContainer=!1}VA(this._lView[1],this._lView)}onDestroy(t){tM(this._lView[1],this._lView,null,t)}markForCheck(){Iw(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-65}reattach(){this._lView[2]|=64}detectChanges(){Tg(this._lView[1],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new te(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function Yq(n,t){Ih(n,t,t[11],2,null,null)}(this._lView[1],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new te(902,!1);this._appRef=t}}class wK extends Rh{constructor(t){super(t),this._view=t}detectChanges(){const t=this._view;Tg(t[1],t,t[8],!1)}checkNoChanges(){}get context(){return null}}class kw extends Xl{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=jt(t);return new Mh(e,this.ngModule)}}function hM(n){const t=[];for(let e in n)n.hasOwnProperty(e)&&t.push({propName:n[e],templateName:e});return t}class SK{constructor(t,e){this.injector=t,this.parentInjector=e}get(t,e,r){r=jm(r);const s=this.injector.get(t,J0,r);return s!==J0||e===J0?s:this.parentInjector.get(t,e,r)}}class Mh extends wR{constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=function v6(n){return n.map(_6).join(",")}(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return hM(this.componentDef.inputs)}get outputs(){return hM(this.componentDef.outputs)}create(t,e,r,s){let i=(s=s||this.ngModule)instanceof Ba?s:s?.injector;i&&null!==this.componentDef.getStandaloneInjector&&(i=this.componentDef.getStandaloneInjector(i)||i);const o=i?new SK(t,i):t,a=o.get(kh,null);if(null===a)throw new te(407,!1);const l=o.get(J8,null),c=a.createRenderer(null,this.componentDef),u=this.componentDef.selectors[0][0]||"div",d=r?function eK(n,t,e){return n.selectRootElement(t,e===qi.ShadowDom)}(c,r,this.componentDef.encapsulation):M0(c,u,function CK(n){const t=n.toLowerCase();return"svg"===t?"svg":"math"===t?"math":null}(u)),h=this.componentDef.onPush?288:272,f=xw(0,null,null,1,0,null,null,null,null,null),p=Eg(null,f,null,h,null,null,a,c,l,o,null);let m,g;o0(p);try{const y=this.componentDef;let b,_=null;y.findHostDirectiveDefs?(b=[],_=new Map,y.findHostDirectiveDefs(y,b,_),b.push(y)):b=[y];const v=function DK(n,t){const e=n[1];return n[22]=t,vu(e,22,2,"#host",null)}(p,d),w=function TK(n,t,e,r,s,i,o,a){const l=s[1];!function kK(n,t,e,r){for(const s of n)t.mergedAttrs=bh(t.mergedAttrs,s.hostAttrs);null!==t.mergedAttrs&&(kg(t,t.mergedAttrs,!0),null!==e&&QA(r,e,t))}(r,n,t,o);const c=i.createRenderer(t,e),u=Eg(s,eM(e),null,e.onPush?32:16,s[n.index],n,i,c,a||null,null,null);return l.firstCreatePass&&Cw(l,n,r.length-1),Dg(s,u),s[n.index]=u}(v,d,y,b,p,a,c);g=Qx(f,22),d&&function AK(n,t,e,r){if(r)d0(n,e,["ng-version",e6.full]);else{const{attrs:s,classes:i}=function x6(n){const t=[],e=[];let r=1,s=2;for(;r<n.length;){let i=n[r];if("string"==typeof i)2===s?""!==i&&t.push(i,n[++r]):8===s&&e.push(i);else{if(!Zi(s))break;s=i}r++}return{attrs:t,classes:e}}(t.selectors[0]);s&&d0(n,e,s),i&&i.length>0&&ZA(n,e,i.join(" "))}}(c,y,d,r),void 0!==e&&function RK(n,t,e){const r=n.projection=[];for(let s=0;s<t.length;s++){const i=e[s];r.push(null!=i?Array.from(i):null)}}(g,this.ngContentSelectors,e),m=function NK(n,t,e,r,s,i){const o=Pr(),a=s[1],l=Ks(o,s);iM(a,s,o,e,null,r);for(let u=0;u<e.length;u++)Gr(iu(s,a,o.directiveStart+u,o),s);oM(a,s,o),l&&Gr(l,s);const c=iu(s,a,o.directiveStart+o.componentOffset,o);if(n[8]=s[8]=c,null!==i)for(const u of i)u(c,t);return bw(a,o,n),c}(w,y,b,_,p,[MK]),yw(f,p,null)}finally{a0()}return new IK(this.componentType,m,yu(g,p),p,g)}}class IK extends q8{constructor(t,e,r,s,i){super(),this.location=r,this._rootLView=s,this._tNode=i,this.instance=e,this.hostView=this.changeDetectorRef=new wK(s),this.componentType=t}setInput(t,e){const r=this._tNode.inputs;let s;if(null!==r&&(s=r[t])){const i=this._rootLView;Tw(i[1],i,s,t,e),sM(i,this._tNode.index)}}get injector(){return new ou(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}function MK(){const n=Pr();eg(oe()[1],n)}function dt(n){let t=function fM(n){return Object.getPrototypeOf(n.prototype).constructor}(n.type),e=!0;const r=[n];for(;t;){let s;if(Yi(n))s=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new te(903,!1);s=t.\u0275dir}if(s){if(e){r.push(s);const o=n;o.inputs=Nw(n.inputs),o.declaredInputs=Nw(n.declaredInputs),o.outputs=Nw(n.outputs);const a=s.hostBindings;a&&$K(n,a);const l=s.viewQuery,c=s.contentQueries;if(l&&OK(n,l),c&&PK(n,c),Ox(n.inputs,s.inputs),Ox(n.declaredInputs,s.declaredInputs),Ox(n.outputs,s.outputs),Yi(s)&&s.data.animation){const u=n.data;u.animation=(u.animation||[]).concat(s.data.animation)}}const i=s.features;if(i)for(let o=0;o<i.length;o++){const a=i[o];a&&a.ngInherit&&a(n),a===dt&&(e=!1)}}t=Object.getPrototypeOf(t)}!function FK(n){let t=0,e=null;for(let r=n.length-1;r>=0;r--){const s=n[r];s.hostVars=t+=s.hostVars,s.hostAttrs=bh(s.hostAttrs,e=bh(e,s.hostAttrs))}}(r)}function Nw(n){return n===Qo?{}:n===Bt?[]:n}function OK(n,t){const e=n.viewQuery;n.viewQuery=e?(r,s)=>{t(r,s),e(r,s)}:t}function PK(n,t){const e=n.contentQueries;n.contentQueries=e?(r,s,i)=>{t(r,s,i),e(r,s,i)}:t}function $K(n,t){const e=n.hostBindings;n.hostBindings=e?(r,s)=>{t(r,s),e(r,s)}:t}let Ag=null;function Zl(){if(!Ag){const n=un.Symbol;if(n&&n.iterator)Ag=n.iterator;else{const t=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e<t.length;++e){const r=t[e];"entries"!==r&&"size"!==r&&Map.prototype[r]===Map.prototype.entries&&(Ag=r)}}}return Ag}function Fh(n){return!!Aw(n)&&(Array.isArray(n)||!(n instanceof Map)&&Zl()in n)}function Aw(n){return null!==n&&("function"==typeof n||"object"==typeof n)}function wo(n,t,e){return n[t]=e}function qr(n,t,e){return!Object.is(n[t],e)&&(n[t]=e,!0)}function yn(n,t,e,r){const s=oe();return qr(s,nu(),t)&&(At(),xo(kn(),s,n,t,e,r)),yn}function wu(n,t,e,r){return qr(n,nu(),e)?t+nt(e)+r:rt}function us(n,t,e,r,s,i,o,a){const l=oe(),c=At(),u=n+22,d=c.firstCreatePass?function qK(n,t,e,r,s,i,o,a,l){const c=t.consts,u=vu(t,n,4,o||null,Pa(c,a));ww(t,e,u,Pa(c,l)),eg(t,u);const d=u.tViews=xw(2,u,r,s,i,t.directiveRegistry,t.pipeRegistry,null,t.schemas,c);return null!==t.queries&&(t.queries.template(t,u),d.queries=t.queries.embeddedTView(u)),u}(u,c,l,t,e,r,s,i,o):c.data[u];bo(d,!1);const h=l[11].createComment("");hg(c,l,h,d),Gr(h,l),Dg(l,l[u]=aM(h,l,h,d)),Zm(d)&&_w(c,l,d),null!=o&&vw(l,d,a)}function Ph(n){return Jc(function L5(){return Je.lFrame.contextLView}(),22+n)}function Gt(n,t,e){const r=oe();return qr(r,nu(),t)&&Js(At(),kn(),r,n,t,r[11],e,!1),Gt}function Rw(n,t,e,r,s){const o=s?"class":"style";Tw(n,e,t.inputs[o],o,r)}function Lt(n,t,e,r){const s=oe(),i=At(),o=22+n,a=s[11],l=s[o]=M0(a,t,function q5(){return Je.lFrame.currentNamespace}()),c=i.firstCreatePass?function XK(n,t,e,r,s,i,o){const a=t.consts,c=vu(t,n,2,s,Pa(a,i));return ww(t,e,c,Pa(a,o)),null!==c.attrs&&kg(c,c.attrs,!1),null!==c.mergedAttrs&&kg(c,c.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,c),c}(o,i,s,0,t,e,r):i.data[o];return bo(c,!0),QA(a,l,c),32!=(32&c.flags)&&hg(i,s,l,c),0===function M5(){return Je.lFrame.elementDepthCount}()&&Gr(l,s),function F5(){Je.lFrame.elementDepthCount++}(),Zm(c)&&(_w(i,s,c),bw(i,c,s)),null!==r&&vw(s,c),Lt}function Qt(){let n=Pr();e0()?t0():(n=n.parent,bo(n,!1));const t=n;!function O5(){Je.lFrame.elementDepthCount--}();const e=At();return e.firstCreatePass&&(eg(e,n),qx(n)&&e.queries.elementEnd(n)),null!=t.classesWithoutHost&&function Q5(n){return 0!=(8&n.flags)}(t)&&Rw(e,t,oe(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function J5(n){return 0!=(16&n.flags)}(t)&&Rw(e,t,oe(),t.stylesWithoutHost,!1),Qt}function kr(n,t,e,r){return Lt(n,t,e,r),Qt(),kr}function Mw(n,t,e){const r=oe(),s=At(),i=n+22,o=s.firstCreatePass?function YK(n,t,e,r,s){const i=t.consts,o=Pa(i,r),a=vu(t,n,8,"ng-container",o);return null!==o&&kg(a,o,!0),ww(t,e,a,Pa(i,s)),null!==t.queries&&t.queries.elementStart(t,a),a}(i,s,r,t,e):s.data[i];bo(o,!0);const a=r[i]=r[11].createComment("");return hg(s,r,a,o),Gr(a,r),Zm(o)&&(_w(s,r,o),bw(s,o,r)),null!=e&&vw(r,o),Mw}function Fw(){let n=Pr();const t=At();return e0()?t0():(n=n.parent,bo(n,!1)),t.firstCreatePass&&(eg(t,n),qx(n)&&t.queries.elementEnd(n)),Fw}function $h(n,t,e){return Mw(n,t,e),Fw(),$h}function Lh(){return oe()}function Bh(n){return!!n&&"function"==typeof n.then}const Ow=function IM(n){return!!n&&"function"==typeof n.subscribe};function Ln(n,t,e,r){const s=oe(),i=At(),o=Pr();return DM(i,s,s[11],o,n,t,r),Ln}function Pw(n,t){const e=Pr(),r=oe(),s=At();return DM(s,r,uM(r0(s.data),e,r),e,n,t),Pw}function DM(n,t,e,r,s,i,o){const a=Zm(r),c=n.firstCreatePass&&cM(n),u=t[8],d=lM(t);let h=!0;if(3&r.type||o){const m=Ks(r,t),g=o?o(m):m,y=d.length,b=o?v=>o(dr(v[r.index])):r.index;let _=null;if(!o&&a&&(_=function ZK(n,t,e,r){const s=n.cleanup;if(null!=s)for(let i=0;i<s.length-1;i+=2){const o=s[i];if(o===e&&s[i+1]===r){const a=t[7],l=s[i+2];return a.length>l?a[l]:null}"string"==typeof o&&(i+=2)}return null}(n,t,s,r.index)),null!==_)(_.__ngLastListenerFn__||_).__ngNextListenerFn__=i,_.__ngLastListenerFn__=i,h=!1;else{i=kM(r,t,u,i,!1);const v=e.listen(g,s,i);d.push(i,v),c&&c.push(s,b,y,y+1)}}else i=kM(r,t,u,i,!1);const f=r.outputs;let p;if(h&&null!==f&&(p=f[s])){const m=p.length;if(m)for(let g=0;g<m;g+=2){const w=t[p[g]][p[g+1]].subscribe(i),C=d.length;d.push(i,w),c&&c.push(s,r.index,C,-(C+1))}}}function TM(n,t,e,r){try{return!1!==e(r)}catch(s){return dM(n,s),!1}}function kM(n,t,e,r,s){return function i(o){if(o===Function)return r;Iw(n.componentOffset>-1?Xs(n.index,t):t);let l=TM(t,0,r,o),c=i.__ngNextListenerFn__;for(;c;)l=TM(t,0,c,o)&&l,c=c.__ngNextListenerFn__;return s&&!1===l&&(o.preventDefault(),o.returnValue=!1),l}}function ei(n=1){return function H5(n){return(Je.lFrame.contextLView=function W5(n,t){for(;n>0;)t=t[15],n--;return t}(n,Je.lFrame.contextLView))[8]}(n)}function QK(n,t){let e=null;const r=function m6(n){const t=n.attrs;if(null!=t){const e=t.indexOf(5);if(0==(1&e))return t[e+1]}return null}(n);for(let s=0;s<t.length;s++){const i=t[s];if("*"!==i){if(null===r?TR(n,i,!0):b6(r,i))return s}else e=s}return e}function Jl(n){const t=oe()[16][6];if(!t.projection){const r=t.projection=xh(n?n.length:1,null),s=r.slice();let i=t.child;for(;null!==i;){const o=n?QK(i,n):0;null!==o&&(s[o]?s[o].projectionNext=i:r[o]=i,s[o]=i),i=i.next}}}function Si(n,t=0,e){const r=oe(),s=At(),i=vu(s,22+n,16,null,e||null);null===i.projection&&(i.projection=t),t0(),32!=(32&i.flags)&&function s8(n,t,e){YA(t[11],0,t,e,zA(n,e,t),jA(e.parent||t[6],e,t))}(s,r,i)}function BM(n,t,e,r,s){const i=n[e+1],o=null===t;let a=r?Qi(i):oa(i),l=!1;for(;0!==a&&(!1===l||o);){const u=n[a+1];tX(n[a],t)&&(l=!0,n[a+1]=r?lw(u):ow(u)),a=r?Qi(u):oa(u)}l&&(n[e+1]=r?ow(i):lw(i))}function tX(n,t){return null===n||null==t||(Array.isArray(n)?n[1]:n)===t||!(!Array.isArray(n)||"string"!=typeof t)&&hu(n,t)>=0}const mr={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function VM(n){return n.substring(mr.key,mr.keyEnd)}function zM(n,t){const e=mr.textEnd;return e===t?-1:(t=mr.keyEnd=function iX(n,t,e){for(;t<e&&n.charCodeAt(t)>32;)t++;return t}(n,mr.key=t,e),Nu(n,t,e))}function Nu(n,t,e){for(;t<e&&n.charCodeAt(t)<=32;)t++;return t}function Vh(n,t,e){return Ji(n,t,e,!1),Vh}function ds(n,t){return Ji(n,t,null,!0),ds}function So(n,t){for(let e=function rX(n){return function HM(n){mr.key=0,mr.keyEnd=0,mr.value=0,mr.valueEnd=0,mr.textEnd=n.length}(n),zM(n,Nu(n,0,mr.textEnd))}(t);e>=0;e=zM(t,e))Zs(n,VM(t),!0)}function Ji(n,t,e,r){const s=oe(),i=At(),o=ta(2);i.firstUpdatePass&&qM(i,n,o,r),t!==rt&&qr(s,o,t)&&XM(i,i.data[ls()],s,s[11],n,s[o+1]=function gX(n,t){return null==n||("string"==typeof t?n+=t:"object"==typeof n&&(n=nn(Qs(n)))),n}(t,e),r,o)}function GM(n,t){return t>=n.expandoStartIndex}function qM(n,t,e,r){const s=n.data;if(null===s[e+1]){const i=s[ls()],o=GM(n,e);ZM(i,r)&&null===t&&!o&&(t=!1),t=function uX(n,t,e,r){const s=r0(n);let i=r?t.residualClasses:t.residualStyles;if(null===s)0===(r?t.classBindings:t.styleBindings)&&(e=zh(e=Lw(null,n,t,e,r),t.attrs,r),i=null);else{const o=t.directiveStylingLast;if(-1===o||n[o]!==s)if(e=Lw(s,n,t,e,r),null===i){let l=function dX(n,t,e){const r=e?t.classBindings:t.styleBindings;if(0!==oa(r))return n[Qi(r)]}(n,t,r);void 0!==l&&Array.isArray(l)&&(l=Lw(null,n,t,l[1],r),l=zh(l,t.attrs,r),function hX(n,t,e,r){n[Qi(e?t.classBindings:t.styleBindings)]=r}(n,t,r,l))}else i=function fX(n,t,e){let r;const s=t.directiveEnd;for(let i=1+t.directiveStylingLast;i<s;i++)r=zh(r,n[i].hostAttrs,e);return zh(r,t.attrs,e)}(n,t,r)}return void 0!==i&&(r?t.residualClasses=i:t.residualStyles=i),e}(s,i,t,r),function JK(n,t,e,r,s,i){let o=i?t.classBindings:t.styleBindings,a=Qi(o),l=oa(o);n[r]=e;let u,c=!1;if(Array.isArray(e)){const d=e;u=d[1],(null===u||hu(d,u)>0)&&(c=!0)}else u=e;if(s)if(0!==l){const h=Qi(n[a+1]);n[r+1]=wg(h,a),0!==h&&(n[h+1]=aw(n[h+1],r)),n[a+1]=function V6(n,t){return 131071&n|t<<17}(n[a+1],r)}else n[r+1]=wg(a,0),0!==a&&(n[a+1]=aw(n[a+1],r)),a=r;else n[r+1]=wg(l,0),0===a?a=r:n[l+1]=aw(n[l+1],r),l=r;c&&(n[r+1]=ow(n[r+1])),BM(n,u,r,!0),BM(n,u,r,!1),function eX(n,t,e,r,s){const i=s?n.residualClasses:n.residualStyles;null!=i&&"string"==typeof t&&hu(i,t)>=0&&(e[r+1]=lw(e[r+1]))}(t,u,n,r,i),o=wg(a,l),i?t.classBindings=o:t.styleBindings=o}(s,i,t,e,o,r)}}function Lw(n,t,e,r,s){let i=null;const o=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<o&&(i=t[a],r=zh(r,i.hostAttrs,s),i!==n);)a++;return null!==n&&(e.directiveStylingLast=a),r}function zh(n,t,e){const r=e?1:2;let s=-1;if(null!==t)for(let i=0;i<t.length;i++){const o=t[i];"number"==typeof o?s=o:s===r&&(Array.isArray(n)||(n=void 0===n?[]:["",n]),Zs(n,o,!!e||t[++i]))}return void 0===n?null:n}function XM(n,t,e,r,s,i,o,a){if(!(3&t.type))return;const l=n.data,c=l[a+1];Mg(function WR(n){return 1==(1&n)}(c)?YM(l,t,e,s,oa(c),o):void 0)||(Mg(i)||function HR(n){return 2==(2&n)}(c)&&(i=YM(l,null,e,s,a,o)),function o8(n,t,e,r,s){if(t)s?n.addClass(e,r):n.removeClass(e,r);else{let i=-1===r.indexOf("-")?void 0:Ds.DashCase;null==s?n.removeStyle(e,r,i):("string"==typeof s&&s.endsWith("!important")&&(s=s.slice(0,-10),i|=Ds.Important),n.setStyle(e,r,s,i))}}(r,o,Qm(ls(),e),s,i))}function YM(n,t,e,r,s,i){const o=null===t;let a;for(;s>0;){const l=n[s],c=Array.isArray(l),u=c?l[1]:l,d=null===u;let h=e[s+1];h===rt&&(h=d?Bt:void 0);let f=d?_0(h,r):u===r?h:void 0;if(c&&!Mg(f)&&(f=_0(l,r)),Mg(f)&&(a=f,o))return a;const p=n[s+1];s=o?Qi(p):oa(p)}if(null!==t){let l=i?t.residualClasses:t.residualStyles;null!=l&&(a=_0(l,r))}return a}function Mg(n){return void 0!==n}function ZM(n,t){return 0!=(n.flags&(t?8:16))}function la(n,t=""){const e=oe(),r=At(),s=n+22,i=r.firstCreatePass?vu(r,s,1,t,null):r.data[s],o=e[s]=function R0(n,t){return n.createText(t)}(e[11],t);hg(r,e,o,i),bo(i,!1)}function Uh(n){return Au("",n,""),Uh}function Au(n,t,e){const r=oe(),s=wu(r,n,t,e);return s!==rt&&function aa(n,t,e){const r=Qm(t,n);!function LA(n,t,e){n.setValue(t,e)}(n[11],r,e)}(r,ls(),s),Au}function oF(n,t,e){!function eo(n,t,e,r){const s=At(),i=ta(2);s.firstUpdatePass&&qM(s,null,i,r);const o=oe();if(e!==rt&&qr(o,i,e)){const a=s.data[ls()];if(ZM(a,r)&&!GM(s,i)){let l=r?a.classesWithoutHost:a.stylesWithoutHost;null!==l&&(e=Px(l,e||"")),Rw(s,a,o,e,r)}else!function mX(n,t,e,r,s,i,o,a){s===rt&&(s=Bt);let l=0,c=0,u=0<s.length?s[0]:null,d=0<i.length?i[0]:null;for(;null!==u||null!==d;){const h=l<s.length?s[l+1]:void 0,f=c<i.length?i[c+1]:void 0;let m,p=null;u===d?(l+=2,c+=2,h!==f&&(p=d,m=f)):null===d||null!==u&&u<d?(l+=2,p=u):(c+=2,p=d,m=f),null!==p&&XM(n,t,e,r,p,m,o,a),u=l<s.length?s[l]:null,d=c<i.length?i[c]:null}}(s,a,o,o[11],o[i+1],o[i+1]=function pX(n,t,e){if(null==e||""===e)return Bt;const r=[],s=Qs(e);if(Array.isArray(s))for(let i=0;i<s.length;i++)n(r,s[i],!0);else if("object"==typeof s)for(const i in s)s.hasOwnProperty(i)&&n(r,i,s[i]);else"string"==typeof s&&t(r,s);return r}(n,t,e),r,i)}}(Zs,So,wu(oe(),n,t,e),!0)}function Bw(n,t,e){const r=oe();return qr(r,nu(),t)&&Js(At(),kn(),r,n,t,r[11],e,!0),Bw}function Vw(n,t,e){const r=oe();if(qr(r,nu(),t)){const i=At(),o=kn();Js(i,o,r,n,t,uM(r0(i.data),o,r),e,!0)}return Vw}const Mu="en-US";let bF=Mu;function Hw(n,t,e,r,s){if(n=Ge(n),Array.isArray(n))for(let i=0;i<n.length;i++)Hw(n[i],t,e,r,s);else{const i=At(),o=oe();let a=Kl(n)?n:Ge(n.provide),l=xR(n);const c=Pr(),u=1048575&c.providerIndexes,d=c.directiveStart,h=c.providerIndexes>>20;if(Kl(n)||!n.multi){const f=new gh(l,s,H),p=jw(a,t,s?u:u+h,d);-1===p?(m0(sg(c,o),i,a),Ww(i,n,t.length),t.push(a),c.directiveStart++,c.directiveEnd++,s&&(c.providerIndexes+=1048576),e.push(f),o.push(f)):(e[p]=f,o[p]=f)}else{const f=jw(a,t,u+h,d),p=jw(a,t,u,u+h),m=f>=0&&e[f],g=p>=0&&e[p];if(s&&!g||!s&&!m){m0(sg(c,o),i,a);const y=function MY(n,t,e,r,s){const i=new gh(n,e,H);return i.multi=[],i.index=t,i.componentProviders=0,HF(i,s,r&&!e),i}(s?RY:AY,e.length,s,r,l);!s&&g&&(e[p].providerFactory=y),Ww(i,n,t.length,0),t.push(a),c.directiveStart++,c.directiveEnd++,s&&(c.providerIndexes+=1048576),e.push(y),o.push(y)}else Ww(i,n,f>-1?f:p,HF(e[s?p:f],l,!s&&r));!s&&r&&g&&e[p].componentProviders++}}}function Ww(n,t,e,r){const s=Kl(t),i=function V8(n){return!!n.useClass}(t);if(s||i){const l=(i?Ge(t.useClass):t).prototype.ngOnDestroy;if(l){const c=n.destroyHooks||(n.destroyHooks=[]);if(!s&&t.multi){const u=c.indexOf(e);-1===u?c.push(e,[r,l]):c[u+1].push(r,l)}else c.push(e,l)}}}function HF(n,t,e){return e&&n.componentProviders++,n.multi.push(t)-1}function jw(n,t,e,r){for(let s=e;s<r;s++)if(t[s]===n)return s;return-1}function AY(n,t,e,r){return Gw(this.multi,[])}function RY(n,t,e,r){const s=this.multi;let i;if(this.providerFactory){const o=this.providerFactory.componentProviders,a=iu(e,e[1],this.providerFactory.index,r);i=a.slice(0,o),Gw(s,i);for(let l=o;l<a.length;l++)i.push(a[l])}else i=[],Gw(s,i);return i}function Gw(n,t){for(let e=0;e<n.length;e++)t.push((0,n[e])());return t}function bn(n,t=[]){return e=>{e.providersResolver=(r,s)=>function NY(n,t,e){const r=At();if(r.firstCreatePass){const s=Yi(n);Hw(e,r.data,r.blueprint,s,!0),Hw(t,r.data,r.blueprint,s,!1)}}(r,s?s(n):n,t)}}class tc{}class WF{}class jF extends tc{constructor(t,e){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new kw(this);const r=Gs(t);this._bootstrapComponents=ia(r.bootstrap),this._r3Injector=OR(t,e,[{provide:tc,useValue:this},{provide:Xl,useValue:this.componentFactoryResolver}],nn(t),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(t)}get injector(){return this._r3Injector}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class qw extends WF{constructor(t){super(),this.moduleType=t}create(t){return new jF(this.moduleType,t)}}class OY extends tc{constructor(t,e,r){super(),this.componentFactoryResolver=new kw(this),this.instance=null;const s=new vR([...t,{provide:tc,useValue:this},{provide:Xl,useValue:this.componentFactoryResolver}],e||vg(),r,new Set(["environment"]));this.injector=s,s.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(t){this.injector.onDestroy(t)}}function Lg(n,t,e=null){return new OY(n,t,e).injector}let PY=(()=>{class n{constructor(e){this._injector=e,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e.id)){const r=gR(0,e.type),s=r.length>0?Lg([r],this._injector,`Standalone[${e.type.name}]`):null;this.cachedInjectors.set(e.id,s)}return this.cachedInjectors.get(e.id)}ngOnDestroy(){try{for(const e of this.cachedInjectors.values())null!==e&&e.destroy()}finally{this.cachedInjectors.clear()}}}return n.\u0275prov=we({token:n,providedIn:"environment",factory:()=>new n(Z(Ba))}),n})();function GF(n){n.getStandaloneInjector=t=>t.get(PY).getOrCreateStandaloneInjector(n)}function eO(n,t,e,r,s,i){const o=t+e;return qr(n,o,s)?wo(n,o+1,i?r.call(i,s):r(s)):function Kh(n,t){const e=n[t];return e===rt?void 0:e}(n,o+1)}function Xw(n){return t=>{setTimeout(n,void 0,t)}}const Rt=class i7 extends kt{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,r){let s=t,i=e||(()=>null),o=r;if(t&&"object"==typeof t){const l=t;s=l.next?.bind(l),i=l.error?.bind(l),o=l.complete?.bind(l)}this.__isAsync&&(i=Xw(i),s&&(s=Xw(s)),o&&(o=Xw(o)));const a=super.subscribe({next:s,error:i,complete:o});return t instanceof He&&t.add(a),a}};function o7(){return this._results[Zl()]()}class Yh{constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=Zl(),r=Yh.prototype;r[e]||(r[e]=o7)}get changes(){return this._changes||(this._changes=new Rt)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){const r=this;r.dirty=!1;const s=Ys(t);(this._changesDetected=!function cq(n,t,e){if(n.length!==t.length)return!1;for(let r=0;r<n.length;r++){let s=n[r],i=t[r];if(e&&(s=e(s),i=e(i)),i!==s)return!1}return!0}(r._results,s,e))&&(r._results=s,r.length=s.length,r.last=s[this.length-1],r.first=s[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}let to=(()=>{class n{}return n.__NG_ELEMENT_ID__=c7,n})();const a7=to,l7=class extends a7{constructor(t,e,r){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=r}createEmbeddedView(t,e){const r=this._declarationTContainer.tViews,s=Eg(this._declarationLView,r,t,16,null,r.declTNode,null,null,null,null,e||null);s[17]=this._declarationLView[this._declarationTContainer.index];const o=this._declarationLView[19];return null!==o&&(s[19]=o.createEmbeddedView(r)),yw(r,s,t),new Rh(s)}};function c7(){return Bg(Pr(),oe())}function Bg(n,t){return 4&n.type?new l7(t,n,yu(n,t)):null}let ti=(()=>{class n{}return n.__NG_ELEMENT_ID__=u7,n})();function u7(){return cO(Pr(),oe())}const d7=ti,aO=class extends d7{constructor(t,e,r){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=r}get element(){return yu(this._hostTNode,this._hostLView)}get injector(){return new ou(this._hostTNode,this._hostLView)}get parentInjector(){const t=ig(this._hostTNode,this._hostLView);if(nA(t)){const e=su(t,this._hostLView),r=ru(t);return new ou(e[1].data[r+8],e)}return new ou(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=lO(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-10}createEmbeddedView(t,e,r){let s,i;"number"==typeof r?s=r:null!=r&&(s=r.index,i=r.injector);const o=t.createEmbeddedView(e||{},i);return this.insert(o,s),o}createComponent(t,e,r,s,i){const o=t&&!function vh(n){return"function"==typeof n}(t);let a;if(o)a=e;else{const d=e||{};a=d.index,r=d.injector,s=d.projectableNodes,i=d.environmentInjector||d.ngModuleRef}const l=o?t:new Mh(jt(t)),c=r||this.parentInjector;if(!i&&null==l.ngModule){const h=(o?c:this.parentInjector).get(Ba,null);h&&(i=h)}const u=l.create(c,s,void 0,i);return this.insert(u.hostView,a),u}insert(t,e){const r=t._lView,s=r[1];if(function R5(n){return Xi(n[3])}(r)){const u=this.indexOf(t);if(-1!==u)this.detach(u);else{const d=r[3],h=new aO(d,d[6],d[3]);h.detach(h.indexOf(t))}}const i=this._adjustIndex(e),o=this._lContainer;!function Qq(n,t,e,r){const s=10+r,i=e.length;r>0&&(e[s-1][4]=t),r<i-10?(t[4]=e[s],fA(e,10+r,t)):(e.push(t),t[4]=null),t[3]=e;const o=t[17];null!==o&&e!==o&&function Jq(n,t){const e=n[9];t[16]!==t[3][3][16]&&(n[2]=!0),null===e?n[9]=[t]:e.push(t)}(o,t);const a=t[19];null!==a&&a.insertView(n),t[2]|=64}(s,r,o,i);const a=$0(i,o),l=r[11],c=dg(l,o[7]);return null!==c&&function Xq(n,t,e,r,s,i){r[0]=s,r[6]=t,Ih(n,r,e,1,s,i)}(s,o[6],l,r,c,a),t.attachToViewContainerRef(),fA(Yw(o),i,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=lO(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),r=F0(this._lContainer,e);r&&(ag(Yw(this._lContainer),e),VA(r[1],r))}detach(t){const e=this._adjustIndex(t,-1),r=F0(this._lContainer,e);return r&&null!=ag(Yw(this._lContainer),e)?new Rh(r):null}_adjustIndex(t,e=0){return t??this.length+e}};function lO(n){return n[8]}function Yw(n){return n[8]||(n[8]=[])}function cO(n,t){let e;const r=t[n.index];if(Xi(r))e=r;else{let s;if(8&n.type)s=dr(r);else{const i=t[11];s=i.createComment("");const o=Ks(n,t);jl(i,dg(i,o),s,function r8(n,t){return n.nextSibling(t)}(i,o),!1)}t[n.index]=e=aM(r,t,s,n),Dg(t,e)}return new aO(e,n,t)}class Zw{constructor(t){this.queryList=t,this.matches=null}clone(){return new Zw(this.queryList)}setDirty(){this.queryList.setDirty()}}class Qw{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const r=null!==t.contentQueries?t.contentQueries[0]:e.length,s=[];for(let i=0;i<r;i++){const o=e.getByIndex(i);s.push(this.queries[o.indexInDeclarationView].clone())}return new Qw(s)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==pO(t,e).matches&&this.queries[e].setDirty()}}class uO{constructor(t,e,r=null){this.predicate=t,this.flags=e,this.read=r}}class Jw{constructor(t=[]){this.queries=t}elementStart(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let r=0;r<this.length;r++){const s=null!==e?e.length:0,i=this.getByIndex(r).embeddedTView(t,s);i&&(i.indexInDeclarationView=r,null!==e?e.push(i):e=[i])}return null!==e?new Jw(e):null}template(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class eC{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new eC(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let r=t.parent;for(;null!==r&&8&r.type&&r.index!==e;)r=r.parent;return e===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const r=this.metadata.predicate;if(Array.isArray(r))for(let s=0;s<r.length;s++){const i=r[s];this.matchTNodeWithReadOption(t,e,p7(e,i)),this.matchTNodeWithReadOption(t,e,og(e,t,i,!1,!1))}else r===to?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,og(e,t,r,!1,!1))}matchTNodeWithReadOption(t,e,r){if(null!==r){const s=this.metadata.read;if(null!==s)if(s===hn||s===ti||s===to&&4&e.type)this.addMatch(e.index,-2);else{const i=og(e,t,s,!1,!1);null!==i&&this.addMatch(e.index,i)}else this.addMatch(e.index,r)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function p7(n,t){const e=n.localNames;if(null!==e)for(let r=0;r<e.length;r+=2)if(e[r]===t)return e[r+1];return null}function g7(n,t,e,r){return-1===e?function m7(n,t){return 11&n.type?yu(n,t):4&n.type?Bg(n,t):null}(t,n):-2===e?function y7(n,t,e){return e===hn?yu(t,n):e===to?Bg(t,n):e===ti?cO(t,n):void 0}(n,t,r):iu(n,n[1],e,t)}function dO(n,t,e,r){const s=t[19].queries[r];if(null===s.matches){const i=n.data,o=e.matches,a=[];for(let l=0;l<o.length;l+=2){const c=o[l];a.push(c<0?null:g7(t,i[c],o[l+1],e.metadata.read))}s.matches=a}return s.matches}function tC(n,t,e,r){const s=n.queries.getByIndex(e),i=s.matches;if(null!==i){const o=dO(n,t,s,e);for(let a=0;a<i.length;a+=2){const l=i[a];if(l>0)r.push(o[a/2]);else{const c=i[a+1],u=t[-l];for(let d=10;d<u.length;d++){const h=u[d];h[17]===h[3]&&tC(h[1],h,c,r)}if(null!==u[9]){const d=u[9];for(let h=0;h<d.length;h++){const f=d[h];tC(f[1],f,c,r)}}}}}return r}function Ts(n){const t=oe(),e=At(),r=GN();s0(r+1);const s=pO(e,r);if(n.dirty&&function A5(n){return 4==(4&n[2])}(t)===(2==(2&s.metadata.flags))){if(null===s.matches)n.reset([]);else{const i=s.crossesNgTemplate?tC(e,t,r,[]):dO(e,t,s,r);n.reset(i,Z8),n.notifyOnChanges()}return!0}return!1}function Eo(n,t,e){const r=At();r.firstCreatePass&&(fO(r,new uO(n,t,e),-1),2==(2&t)&&(r.staticViewQueries=!0)),hO(r,oe(),t)}function Zh(n,t,e,r){const s=At();if(s.firstCreatePass){const i=Pr();fO(s,new uO(t,e,r),i.index),function _7(n,t){const e=n.contentQueries||(n.contentQueries=[]);t!==(e.length?e[e.length-1]:-1)&&e.push(n.queries.length-1,t)}(s,n),2==(2&e)&&(s.staticContentQueries=!0)}hO(s,oe(),e)}function ks(){return function b7(n,t){return n[19].queries[t].queryList}(oe(),GN())}function hO(n,t,e){const r=new Yh(4==(4&e));tM(n,t,r,r.destroy),null===t[19]&&(t[19]=new Qw),t[19].queries.push(new Zw(r))}function fO(n,t,e){null===n.queries&&(n.queries=new Jw),n.queries.track(new eC(t,e))}function pO(n,t){return n.queries.getByIndex(t)}function mO(n,t){return Bg(n,t)}function zg(...n){}const Ug=new me("Application Initializer");let Hg=(()=>{class n{constructor(e){this.appInits=e,this.resolve=zg,this.reject=zg,this.initialized=!1,this.done=!1,this.donePromise=new Promise((r,s)=>{this.resolve=r,this.reject=s})}runInitializers(){if(this.initialized)return;const e=[],r=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let s=0;s<this.appInits.length;s++){const i=this.appInits[s]();if(Bh(i))e.push(i);else if(Ow(i)){const o=new Promise((a,l)=>{i.subscribe({complete:a,error:l})});e.push(o)}}Promise.all(e).then(()=>{r()}).catch(s=>{this.reject(s)}),0===e.length&&r(),this.initialized=!0}}return n.\u0275fac=function(e){return new(e||n)(Z(Ug,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const Jh=new me("AppId",{providedIn:"root",factory:function FO(){return`${oC()}${oC()}${oC()}`}});function oC(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const OO=new me("Platform Initializer"),aC=new me("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),PO=new me("appBootstrapListener"),ca=new me("AnimationModuleType");let B7=(()=>{class n{log(e){console.log(e)}warn(e){console.warn(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();const Io=new me("LocaleId",{providedIn:"root",factory:()=>Ot(Io,qe.Optional|qe.SkipSelf)||function V7(){return typeof $localize<"u"&&$localize.locale||Mu}()});class U7{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}let lC=(()=>{class n{compileModuleSync(e){return new qw(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const r=this.compileModuleSync(e),i=ia(Gs(e).declarations).reduce((o,a)=>{const l=jt(a);return l&&o.push(new Mh(l)),o},[]);return new U7(r,i)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const j7=(()=>Promise.resolve(0))();function cC(n){typeof Zone>"u"?j7.then(()=>{n&&n.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",n)}class yt{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Rt(!1),this.onMicrotaskEmpty=new Rt(!1),this.onStable=new Rt(!1),this.onError=new Rt(!1),typeof Zone>"u")throw new te(908,!1);Zone.assertZonePatched();const s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!r&&e,s.shouldCoalesceRunChangeDetection=r,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function G7(){let n=un.requestAnimationFrame,t=un.cancelAnimationFrame;if(typeof Zone<"u"&&n&&t){const e=n[Zone.__symbol__("OriginalDelegate")];e&&(n=e);const r=t[Zone.__symbol__("OriginalDelegate")];r&&(t=r)}return{nativeRequestAnimationFrame:n,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function X7(n){const t=()=>{!function K7(n){n.isCheckStableRunning||-1!==n.lastRequestAnimationFrameId||(n.lastRequestAnimationFrameId=n.nativeRequestAnimationFrame.call(un,()=>{n.fakeTopEventTask||(n.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{n.lastRequestAnimationFrameId=-1,dC(n),n.isCheckStableRunning=!0,uC(n),n.isCheckStableRunning=!1},void 0,()=>{},()=>{})),n.fakeTopEventTask.invoke()}),dC(n))}(n)};n._inner=n._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,s,i,o,a)=>{try{return BO(n),e.invokeTask(s,i,o,a)}finally{(n.shouldCoalesceEventChangeDetection&&"eventTask"===i.type||n.shouldCoalesceRunChangeDetection)&&t(),VO(n)}},onInvoke:(e,r,s,i,o,a,l)=>{try{return BO(n),e.invoke(s,i,o,a,l)}finally{n.shouldCoalesceRunChangeDetection&&t(),VO(n)}},onHasTask:(e,r,s,i)=>{e.hasTask(s,i),r===s&&("microTask"==i.change?(n._hasPendingMicrotasks=i.microTask,dC(n),uC(n)):"macroTask"==i.change&&(n.hasPendingMacrotasks=i.macroTask))},onHandleError:(e,r,s,i)=>(e.handleError(s,i),n.runOutsideAngular(()=>n.onError.emit(i)),!1)})}(s)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!yt.isInAngularZone())throw new te(909,!1)}static assertNotInAngularZone(){if(yt.isInAngularZone())throw new te(909,!1)}run(t,e,r){return this._inner.run(t,e,r)}runTask(t,e,r,s){const i=this._inner,o=i.scheduleEventTask("NgZoneEvent: "+s,t,q7,zg,zg);try{return i.runTask(o,e,r)}finally{i.cancelTask(o)}}runGuarded(t,e,r){return this._inner.runGuarded(t,e,r)}runOutsideAngular(t){return this._outer.run(t)}}const q7={};function uC(n){if(0==n._nesting&&!n.hasPendingMicrotasks&&!n.isStable)try{n._nesting++,n.onMicrotaskEmpty.emit(null)}finally{if(n._nesting--,!n.hasPendingMicrotasks)try{n.runOutsideAngular(()=>n.onStable.emit(null))}finally{n.isStable=!0}}}function dC(n){n.hasPendingMicrotasks=!!(n._hasPendingMicrotasks||(n.shouldCoalesceEventChangeDetection||n.shouldCoalesceRunChangeDetection)&&-1!==n.lastRequestAnimationFrameId)}function BO(n){n._nesting++,n.isStable&&(n.isStable=!1,n.onUnstable.emit(null))}function VO(n){n._nesting--,uC(n)}class Y7{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Rt,this.onMicrotaskEmpty=new Rt,this.onStable=new Rt,this.onError=new Rt}run(t,e,r){return t.apply(e,r)}runGuarded(t,e,r){return t.apply(e,r)}runOutsideAngular(t){return t()}runTask(t,e,r,s){return t.apply(e,r)}}const zO=new me(""),Wg=new me("");let pC,hC=(()=>{class n{constructor(e,r,s){this._ngZone=e,this.registry=r,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,pC||(function Z7(n){pC=n}(s),s.addToWindow(r)),this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{yt.assertNotInAngularZone(),cC(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())cC(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(e)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,r,s){let i=-1;r&&r>0&&(i=setTimeout(()=>{this._callbacks=this._callbacks.filter(o=>o.timeoutId!==i),e(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:e,timeoutId:i,updateCb:s})}whenStable(e,r,s){if(s&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,r,s),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(e){this.registry.registerApplication(e,this)}unregisterApplication(e){this.registry.unregisterApplication(e)}findProviders(e,r,s){return[]}}return n.\u0275fac=function(e){return new(e||n)(Z(yt),Z(fC),Z(Wg))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})(),fC=(()=>{class n{constructor(){this._applications=new Map}registerApplication(e,r){this._applications.set(e,r)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,r=!0){return pC?.findTestabilityInTree(this,e,r)??null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})(),Ua=null;const UO=new me("AllowMultipleToken"),mC=new me("PlatformDestroyListeners");class HO{constructor(t,e){this.name=t,this.token=e}}function jO(n,t,e=[]){const r=`Platform: ${t}`,s=new me(r);return(i=[])=>{let o=gC();if(!o||o.injector.get(UO,!1)){const a=[...e,...i,{provide:s,useValue:!0}];n?n(a):function e9(n){if(Ua&&!Ua.get(UO,!1))throw new te(400,!1);Ua=n;const t=n.get(qO);(function WO(n){const t=n.get(OO,null);t&&t.forEach(e=>e())})(n)}(function GO(n=[],t){return pr.create({name:t,providers:[{provide:X0,useValue:"platform"},{provide:mC,useValue:new Set([()=>Ua=null])},...n]})}(a,r))}return function n9(n){const t=gC();if(!t)throw new te(401,!1);return t}()}}function gC(){return Ua?.get(qO)??null}let qO=(()=>{class n{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,r){const s=function XO(n,t){let e;return e="noop"===n?new Y7:("zone.js"===n?void 0:n)||new yt(t),e}(r?.ngZone,function KO(n){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:!(!n||!n.ngZoneEventCoalescing)||!1,shouldCoalesceRunChangeDetection:!(!n||!n.ngZoneRunCoalescing)||!1}}(r)),i=[{provide:yt,useValue:s}];return s.run(()=>{const o=pr.create({providers:i,parent:this.injector,name:e.moduleType.name}),a=e.create(o),l=a.injector.get(sa,null);if(!l)throw new te(402,!1);return s.runOutsideAngular(()=>{const c=s.onError.subscribe({next:u=>{l.handleError(u)}});a.onDestroy(()=>{jg(this._modules,a),c.unsubscribe()})}),function YO(n,t,e){try{const r=e();return Bh(r)?r.catch(s=>{throw t.runOutsideAngular(()=>n.handleError(s)),s}):r}catch(r){throw t.runOutsideAngular(()=>n.handleError(r)),r}}(l,s,()=>{const c=a.injector.get(Hg);return c.runInitializers(),c.donePromise.then(()=>(function _F(n){js(n,"Expected localeId to be defined"),"string"==typeof n&&(bF=n.toLowerCase().replace(/_/g,"-"))}(a.injector.get(Io,Mu)||Mu),this._moduleDoBootstrap(a),a))})})}bootstrapModule(e,r=[]){const s=ZO({},r);return function Q7(n,t,e){const r=new qw(e);return Promise.resolve(r)}(0,0,e).then(i=>this.bootstrapModuleFactory(i,s))}_moduleDoBootstrap(e){const r=e.injector.get(Pu);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(s=>r.bootstrap(s));else{if(!e.instance.ngDoBootstrap)throw new te(403,!1);e.instance.ngDoBootstrap(r)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new te(404,!1);this._modules.slice().forEach(r=>r.destroy()),this._destroyListeners.forEach(r=>r());const e=this._injector.get(mC,null);e&&(e.forEach(r=>r()),e.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return n.\u0275fac=function(e){return new(e||n)(Z(pr))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();function ZO(n,t){return Array.isArray(t)?t.reduce(ZO,n):{...n,...t}}let Pu=(()=>{class n{constructor(e,r,s){this._zone=e,this._injector=r,this._exceptionHandler=s,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this._destroyed=!1,this._destroyListeners=[],this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const i=new Cn(a=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{a.next(this._stable),a.complete()})}),o=new Cn(a=>{let l;this._zone.runOutsideAngular(()=>{l=this._zone.onStable.subscribe(()=>{yt.assertNotInAngularZone(),cC(()=>{!this._stable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks&&(this._stable=!0,a.next(!0))})})});const c=this._zone.onUnstable.subscribe(()=>{yt.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{a.next(!1)}))});return()=>{l.unsubscribe(),c.unsubscribe()}});this.isStable=ih(i,o.pipe(CN()))}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(e,r){const s=e instanceof wR;if(!this._injector.get(Hg).done)throw!s&&function Xc(n){const t=jt(n)||Hr(n)||os(n);return null!==t&&t.standalone}(e),new te(405,false);let o;o=s?e:this._injector.get(Xl).resolveComponentFactory(e),this.componentTypes.push(o.componentType);const a=function J7(n){return n.isBoundToModule}(o)?void 0:this._injector.get(tc),c=o.create(pr.NULL,[],r||o.selector,a),u=c.location.nativeElement,d=c.injector.get(zO,null);return d?.registerApplication(u),c.onDestroy(()=>{this.detachView(c.hostView),jg(this.components,c),d?.unregisterApplication(u)}),this._loadComponent(c),c}tick(){if(this._runningTick)throw new te(101,!1);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){const r=e;jg(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get(PO,[]).concat(this._bootstrapListeners).forEach(s=>s(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>jg(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new te(406,!1);const e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return n.\u0275fac=function(e){return new(e||n)(Z(yt),Z(Ba),Z(sa))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function jg(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}let nc=(()=>{class n{}return n.__NG_ELEMENT_ID__=s9,n})();function s9(n){return function i9(n,t,e){if(Ym(n)&&!e){const r=Xs(n.index,t);return new Rh(r,r)}return 47&n.type?new Rh(t[16],t):null}(Pr(),oe(),16==(16&n))}class n2{constructor(){}supports(t){return Fh(t)}create(t){return new d9(t)}}const u9=(n,t)=>t;class d9{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||u9}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,r=this._removalsHead,s=0,i=null;for(;e||r;){const o=!r||e&&e.currentIndex<s2(r,s,i)?e:r,a=s2(o,s,i),l=o.currentIndex;if(o===r)s--,r=r._nextRemoved;else if(e=e._next,null==o.previousIndex)s++;else{i||(i=[]);const c=a-s,u=l-s;if(c!=u){for(let h=0;h<c;h++){const f=h<i.length?i[h]:i[h]=0,p=f+h;u<=p&&p<c&&(i[h]=f+1)}i[o.previousIndex]=u-c}}a!==l&&t(o,a,l)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!Fh(t))throw new te(900,!1);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let s,i,o,e=this._itHead,r=!1;if(Array.isArray(t)){this.length=t.length;for(let a=0;a<this.length;a++)i=t[a],o=this._trackByFn(a,i),null!==e&&Object.is(e.trackById,o)?(r&&(e=this._verifyReinsertion(e,i,o,a)),Object.is(e.item,i)||this._addIdentityChange(e,i)):(e=this._mismatch(e,i,o,a),r=!0),e=e._next}else s=0,function WK(n,t){if(Array.isArray(n))for(let e=0;e<n.length;e++)t(n[e]);else{const e=n[Zl()]();let r;for(;!(r=e.next()).done;)t(r.value)}}(t,a=>{o=this._trackByFn(s,a),null!==e&&Object.is(e.trackById,o)?(r&&(e=this._verifyReinsertion(e,a,o,s)),Object.is(e.item,a)||this._addIdentityChange(e,a)):(e=this._mismatch(e,a,o,s),r=!0),e=e._next,s++}),this.length=s;return this._truncate(e),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,r,s){let i;return null===t?i=this._itTail:(i=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,i,s)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(r,s))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,i,s)):t=this._addAfter(new h9(e,r),i,s),t}_verifyReinsertion(t,e,r,s){let i=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null);return null!==i?t=this._reinsertAfter(i,t._prev,s):t.currentIndex!=s&&(t.currentIndex=s,this._addToMoves(t,s)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,r){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const s=t._prevRemoved,i=t._nextRemoved;return null===s?this._removalsHead=i:s._nextRemoved=i,null===i?this._removalsTail=s:i._prevRemoved=s,this._insertAfter(t,e,r),this._addToMoves(t,r),t}_moveAfter(t,e,r){return this._unlink(t),this._insertAfter(t,e,r),this._addToMoves(t,r),t}_addAfter(t,e,r){return this._insertAfter(t,e,r),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,r){const s=null===e?this._itHead:e._next;return t._next=s,t._prev=e,null===s?this._itTail=t:s._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new r2),this._linkedRecords.put(t),t.currentIndex=r,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,r=t._next;return null===e?this._itHead=r:e._next=r,null===r?this._itTail=e:r._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new r2),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class h9{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class f9{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let r;for(r=this._head;null!==r;r=r._nextDup)if((null===e||e<=r.currentIndex)&&Object.is(r.trackById,t))return r;return null}remove(t){const e=t._prevDup,r=t._nextDup;return null===e?this._head=r:e._nextDup=r,null===r?this._tail=e:r._prevDup=e,null===this._head}}class r2{constructor(){this.map=new Map}put(t){const e=t.trackById;let r=this.map.get(e);r||(r=new f9,this.map.set(e,r)),r.add(t)}get(t,e){const s=this.map.get(t);return s?s.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function s2(n,t,e){const r=n.previousIndex;if(null===r)return r;let s=0;return e&&r<e.length&&(s=e[r]),r+t+s}class o2{constructor(){}supports(t){return t instanceof Map||Aw(t)}create(){return new p9}}class p9{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let e;for(e=this._mapHead;null!==e;e=e._next)t(e)}forEachPreviousItem(t){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)t(e)}forEachChangedItem(t){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}diff(t){if(t){if(!(t instanceof Map||Aw(t)))throw new te(900,!1)}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(t,(r,s)=>{if(e&&e.key===s)this._maybeAddToChanges(e,r),this._appendAfter=e,e=e._next;else{const i=this._getOrCreateRecordForKey(s,r);e=this._insertBeforeOrAppend(e,i)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let r=e;null!==r;r=r._nextRemoved)r===this._mapHead&&(this._mapHead=null),this._records.delete(r.key),r._nextRemoved=r._next,r.previousValue=r.currentValue,r.currentValue=null,r._prev=null,r._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,e){if(t){const r=t._prev;return e._next=t,e._prev=r,t._prev=e,r&&(r._next=e),t===this._mapHead&&(this._mapHead=e),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(t,e){if(this._records.has(t)){const s=this._records.get(t);this._maybeAddToChanges(s,e);const i=s._prev,o=s._next;return i&&(i._next=o),o&&(o._prev=i),s._next=null,s._prev=null,s}const r=new m9(t);return this._records.set(t,r),r.currentValue=e,this._addToAdditions(r),r}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,e){Object.is(e,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=e,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,e){t instanceof Map?t.forEach(e):Object.keys(t).forEach(r=>e(t[r],r))}}class m9{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function a2(){return new Kg([new n2])}let Kg=(()=>{class n{constructor(e){this.factories=e}static create(e,r){if(null!=r){const s=r.factories.slice();e=e.concat(s)}return new n(e)}static extend(e){return{provide:n,useFactory:r=>n.create(e,r||a2()),deps:[[n,new fu,new La]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(null!=r)return r;throw new te(901,!1)}}return n.\u0275prov=we({token:n,providedIn:"root",factory:a2}),n})();function l2(){return new ef([new o2])}let ef=(()=>{class n{constructor(e){this.factories=e}static create(e,r){if(r){const s=r.factories.slice();e=e.concat(s)}return new n(e)}static extend(e){return{provide:n,useFactory:r=>n.create(e,r||l2()),deps:[[n,new fu,new La]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(r)return r;throw new te(901,!1)}}return n.\u0275prov=we({token:n,providedIn:"root",factory:l2}),n})();const b9=jO(null,"core",[]);let _9=(()=>{class n{constructor(e){}}return n.\u0275fac=function(e){return new(e||n)(Z(Pu))},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({}),n})();let Xg=null;function Do(){return Xg}class w9{}const vt=new me("DocumentToken");let xC=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:function(){return function C9(){return Z(c2)}()},providedIn:"platform"}),n})();const S9=new me("Location Initialized");let c2=(()=>{class n extends xC{constructor(e){super(),this._doc=e,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Do().getBaseHref(this._doc)}onPopState(e){const r=Do().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){const r=Do().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(e){this.location.pathname=e}pushState(e,r,s){u2()?this._history.pushState(e,r,s):this.location.hash=s}replaceState(e,r,s){u2()?this._history.replaceState(e,r,s):this.location.hash=s}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return n.\u0275fac=function(e){return new(e||n)(Z(vt))},n.\u0275prov=we({token:n,factory:function(){return function E9(){return new c2(Z(vt))}()},providedIn:"platform"}),n})();function u2(){return!!window.history.pushState}function wC(n,t){if(0==n.length)return t;if(0==t.length)return n;let e=0;return n.endsWith("/")&&e++,t.startsWith("/")&&e++,2==e?n+t.substring(1):1==e?n+t:n+"/"+t}function d2(n){const t=n.match(/#|\?|$/),e=t&&t.index||n.length;return n.slice(0,e-("/"===n[e-1]?1:0))+n.slice(e)}function da(n){return n&&"?"!==n[0]?"?"+n:n}let sc=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:function(){return Ot(f2)},providedIn:"root"}),n})();const h2=new me("appBaseHref");let f2=(()=>{class n extends sc{constructor(e,r){super(),this._platformLocation=e,this._removeListenerFns=[],this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??Ot(vt).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return wC(this._baseHref,e)}path(e=!1){const r=this._platformLocation.pathname+da(this._platformLocation.search),s=this._platformLocation.hash;return s&&e?`${r}${s}`:r}pushState(e,r,s,i){const o=this.prepareExternalUrl(s+da(i));this._platformLocation.pushState(e,r,o)}replaceState(e,r,s,i){const o=this.prepareExternalUrl(s+da(i));this._platformLocation.replaceState(e,r,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return n.\u0275fac=function(e){return new(e||n)(Z(xC),Z(h2,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),I9=(()=>{class n extends sc{constructor(e,r){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let r=this._platformLocation.hash;return null==r&&(r="#"),r.length>0?r.substring(1):r}prepareExternalUrl(e){const r=wC(this._baseHref,e);return r.length>0?"#"+r:r}pushState(e,r,s,i){let o=this.prepareExternalUrl(s+da(i));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.pushState(e,r,o)}replaceState(e,r,s,i){let o=this.prepareExternalUrl(s+da(i));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.replaceState(e,r,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return n.\u0275fac=function(e){return new(e||n)(Z(xC),Z(h2,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})(),Yg=(()=>{class n{constructor(e){this._subject=new Rt,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=e;const r=this._locationStrategy.getBaseHref();this._baseHref=d2(p2(r)),this._locationStrategy.onPopState(s=>{this._subject.emit({url:this.path(!0),pop:!0,state:s.state,type:s.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+da(r))}normalize(e){return n.stripTrailingSlash(function T9(n,t){return n&&t.startsWith(n)?t.substring(n.length):t}(this._baseHref,p2(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,r="",s=null){this._locationStrategy.pushState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+da(r)),s)}replaceState(e,r="",s=null){this._locationStrategy.replaceState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+da(r)),s)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)})),()=>{const r=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(r,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(s=>s(e,r))}subscribe(e,r,s){return this._subject.subscribe({next:e,error:r,complete:s})}}return n.normalizeQueryParams=da,n.joinWithSlash=wC,n.stripTrailingSlash=d2,n.\u0275fac=function(e){return new(e||n)(Z(sc))},n.\u0275prov=we({token:n,factory:function(){return function D9(){return new Yg(Z(sc))}()},providedIn:"root"}),n})();function p2(n){return n.replace(/\/index.html$/,"")}let C2=(()=>{class n{constructor(e,r,s,i){this._iterableDiffers=e,this._keyValueDiffers=r,this._ngEl=s,this._renderer=i,this._iterableDiffer=null,this._keyValueDiffer=null,this._initialClasses=[],this._rawClass=null}set klass(e){this._removeClasses(this._initialClasses),this._initialClasses="string"==typeof e?e.split(/\s+/):[],this._applyClasses(this._initialClasses),this._applyClasses(this._rawClass)}set ngClass(e){this._removeClasses(this._rawClass),this._applyClasses(this._initialClasses),this._iterableDiffer=null,this._keyValueDiffer=null,this._rawClass="string"==typeof e?e.split(/\s+/):e,this._rawClass&&(Fh(this._rawClass)?this._iterableDiffer=this._iterableDiffers.find(this._rawClass).create():this._keyValueDiffer=this._keyValueDiffers.find(this._rawClass).create())}ngDoCheck(){if(this._iterableDiffer){const e=this._iterableDiffer.diff(this._rawClass);e&&this._applyIterableChanges(e)}else if(this._keyValueDiffer){const e=this._keyValueDiffer.diff(this._rawClass);e&&this._applyKeyValueChanges(e)}}_applyKeyValueChanges(e){e.forEachAddedItem(r=>this._toggleClass(r.key,r.currentValue)),e.forEachChangedItem(r=>this._toggleClass(r.key,r.currentValue)),e.forEachRemovedItem(r=>{r.previousValue&&this._toggleClass(r.key,!1)})}_applyIterableChanges(e){e.forEachAddedItem(r=>{if("string"!=typeof r.item)throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${nn(r.item)}`);this._toggleClass(r.item,!0)}),e.forEachRemovedItem(r=>this._toggleClass(r.item,!1))}_applyClasses(e){e&&(Array.isArray(e)||e instanceof Set?e.forEach(r=>this._toggleClass(r,!0)):Object.keys(e).forEach(r=>this._toggleClass(r,!!e[r])))}_removeClasses(e){e&&(Array.isArray(e)||e instanceof Set?e.forEach(r=>this._toggleClass(r,!1)):Object.keys(e).forEach(r=>this._toggleClass(r,!1)))}_toggleClass(e,r){(e=e.trim())&&e.split(/\s+/g).forEach(s=>{r?this._renderer.addClass(this._ngEl.nativeElement,s):this._renderer.removeClass(this._ngEl.nativeElement,s)})}}return n.\u0275fac=function(e){return new(e||n)(H(Kg),H(ef),H(hn),H(ra))},n.\u0275dir=$e({type:n,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"},standalone:!0}),n})();class fZ{constructor(t,e,r,s){this.$implicit=t,this.ngForOf=e,this.index=r,this.count=s}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let I2=(()=>{class n{constructor(e,r,s){this._viewContainer=e,this._template=r,this._differs=s,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const e=this._ngForOf;!this._differ&&e&&(this._differ=this._differs.find(e).create(this.ngForTrackBy))}if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const r=this._viewContainer;e.forEachOperation((s,i,o)=>{if(null==s.previousIndex)r.createEmbeddedView(this._template,new fZ(s.item,this._ngForOf,-1,-1),null===o?void 0:o);else if(null==o)r.remove(null===i?void 0:i);else if(null!==i){const a=r.get(i);r.move(a,o),D2(a,s)}});for(let s=0,i=r.length;s<i;s++){const a=r.get(s).context;a.index=s,a.count=i,a.ngForOf=this._ngForOf}e.forEachIdentityChange(s=>{D2(r.get(s.currentIndex),s)})}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(H(ti),H(to),H(Kg))},n.\u0275dir=$e({type:n,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"},standalone:!0}),n})();function D2(n,t){n.context.$implicit=t.item}let oy=(()=>{class n{constructor(e,r){this._viewContainer=e,this._context=new mZ,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=r}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){T2("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){T2("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(H(ti),H(to))},n.\u0275dir=$e({type:n,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0}),n})();class mZ{constructor(){this.$implicit=null,this.ngIf=null}}function T2(n,t){if(t&&!t.createEmbeddedView)throw new Error(`${n} must be a TemplateRef, but received '${nn(t)}'.`)}class RC{constructor(t,e){this._viewContainerRef=t,this._templateRef=e,this._created=!1}create(){this._created=!0,this._viewContainerRef.createEmbeddedView(this._templateRef)}destroy(){this._created=!1,this._viewContainerRef.clear()}enforceState(t){t&&!this._created?this.create():!t&&this._created&&this.destroy()}}let ay=(()=>{class n{constructor(){this._defaultUsed=!1,this._caseCount=0,this._lastCaseCheckIndex=0,this._lastCasesMatched=!1}set ngSwitch(e){this._ngSwitch=e,0===this._caseCount&&this._updateDefaultCases(!0)}_addCase(){return this._caseCount++}_addDefault(e){this._defaultViews||(this._defaultViews=[]),this._defaultViews.push(e)}_matchCase(e){const r=e==this._ngSwitch;return this._lastCasesMatched=this._lastCasesMatched||r,this._lastCaseCheckIndex++,this._lastCaseCheckIndex===this._caseCount&&(this._updateDefaultCases(!this._lastCasesMatched),this._lastCaseCheckIndex=0,this._lastCasesMatched=!1),r}_updateDefaultCases(e){if(this._defaultViews&&e!==this._defaultUsed){this._defaultUsed=e;for(let r=0;r<this._defaultViews.length;r++)this._defaultViews[r].enforceState(e)}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=$e({type:n,selectors:[["","ngSwitch",""]],inputs:{ngSwitch:"ngSwitch"},standalone:!0}),n})(),k2=(()=>{class n{constructor(e,r,s){this.ngSwitch=s,s._addCase(),this._view=new RC(e,r)}ngDoCheck(){this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))}}return n.\u0275fac=function(e){return new(e||n)(H(ti),H(to),H(ay,9))},n.\u0275dir=$e({type:n,selectors:[["","ngSwitchCase",""]],inputs:{ngSwitchCase:"ngSwitchCase"},standalone:!0}),n})(),N2=(()=>{class n{constructor(e,r,s){s._addDefault(new RC(e,r))}}return n.\u0275fac=function(e){return new(e||n)(H(ti),H(to),H(ay,9))},n.\u0275dir=$e({type:n,selectors:[["","ngSwitchDefault",""]],standalone:!0}),n})(),R2=(()=>{class n{constructor(e,r,s){this._ngEl=e,this._differs=r,this._renderer=s,this._ngStyle=null,this._differ=null}set ngStyle(e){this._ngStyle=e,!this._differ&&e&&(this._differ=this._differs.find(e).create())}ngDoCheck(){if(this._differ){const e=this._differ.diff(this._ngStyle);e&&this._applyChanges(e)}}_setStyle(e,r){const[s,i]=e.split("."),o=-1===s.indexOf("-")?void 0:Ds.DashCase;null!=r?this._renderer.setStyle(this._ngEl.nativeElement,s,i?`${r}${i}`:r,o):this._renderer.removeStyle(this._ngEl.nativeElement,s,o)}_applyChanges(e){e.forEachRemovedItem(r=>this._setStyle(r.key,null)),e.forEachAddedItem(r=>this._setStyle(r.key,r.currentValue)),e.forEachChangedItem(r=>this._setStyle(r.key,r.currentValue))}}return n.\u0275fac=function(e){return new(e||n)(H(hn),H(ef),H(ra))},n.\u0275dir=$e({type:n,selectors:[["","ngStyle",""]],inputs:{ngStyle:"ngStyle"},standalone:!0}),n})(),M2=(()=>{class n{constructor(e){this._viewContainerRef=e,this._viewRef=null,this.ngTemplateOutletContext=null,this.ngTemplateOutlet=null,this.ngTemplateOutletInjector=null}ngOnChanges(e){if(e.ngTemplateOutlet||e.ngTemplateOutletInjector){const r=this._viewContainerRef;if(this._viewRef&&r.remove(r.indexOf(this._viewRef)),this.ngTemplateOutlet){const{ngTemplateOutlet:s,ngTemplateOutletContext:i,ngTemplateOutletInjector:o}=this;this._viewRef=r.createEmbeddedView(s,i,o?{injector:o}:void 0)}else this._viewRef=null}else this._viewRef&&e.ngTemplateOutletContext&&this.ngTemplateOutletContext&&(this._viewRef.context=this.ngTemplateOutletContext)}}return n.\u0275fac=function(e){return new(e||n)(H(ti))},n.\u0275dir=$e({type:n,selectors:[["","ngTemplateOutlet",""]],inputs:{ngTemplateOutletContext:"ngTemplateOutletContext",ngTemplateOutlet:"ngTemplateOutlet",ngTemplateOutletInjector:"ngTemplateOutletInjector"},standalone:!0,features:[Is]}),n})(),F2=(()=>{class n{constructor(e){this.differs=e,this.keyValues=[],this.compareFn=O2}transform(e,r=O2){if(!e||!(e instanceof Map)&&"object"!=typeof e)return null;this.differ||(this.differ=this.differs.find(e).create());const s=this.differ.diff(e),i=r!==this.compareFn;return s&&(this.keyValues=[],s.forEachItem(o=>{this.keyValues.push(function FZ(n,t){return{key:n,value:t}}(o.key,o.currentValue))})),(s||i)&&(this.keyValues.sort(r),this.compareFn=r),this.keyValues}}return n.\u0275fac=function(e){return new(e||n)(H(ef,16))},n.\u0275pipe=Ss({name:"keyvalue",type:n,pure:!1,standalone:!0}),n})();function O2(n,t){const e=n.key,r=t.key;if(e===r)return 0;if(void 0===e)return 1;if(void 0===r)return-1;if(null===e)return 1;if(null===r)return-1;if("string"==typeof e&&"string"==typeof r)return e<r?-1:1;if("number"==typeof e&&"number"==typeof r)return e-r;if("boolean"==typeof e&&"boolean"==typeof r)return e<r?-1:1;const s=String(e),i=String(r);return s==i?0:s<i?-1:1}let ic=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({}),n})();const P2="browser";let HZ=(()=>{class n{}return n.\u0275prov=we({token:n,providedIn:"root",factory:()=>new WZ(Z(vt),window)}),n})();class WZ{constructor(t,e){this.document=t,this.window=e,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(t){this.supportsScrolling()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){if(!this.supportsScrolling())return;const e=function jZ(n,t){const e=n.getElementById(t)||n.getElementsByName(t)[0];if(e)return e;if("function"==typeof n.createTreeWalker&&n.body&&(n.body.createShadowRoot||n.body.attachShadow)){const r=n.createTreeWalker(n.body,NodeFilter.SHOW_ELEMENT);let s=r.currentNode;for(;s;){const i=s.shadowRoot;if(i){const o=i.getElementById(t)||i.querySelector(`[name="${t}"]`);if(o)return o}s=r.nextNode()}}return null}(this.document,t);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),r=e.left+this.window.pageXOffset,s=e.top+this.window.pageYOffset,i=this.offset();this.window.scrollTo(r-i[0],s-i[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const t=$2(this.window.history)||$2(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&&!t.set)}catch{return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch{return!1}}}function $2(n){return Object.getOwnPropertyDescriptor(n,"scrollRestoration")}class _Q extends w9{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class $C extends _Q{static makeCurrent(){!function x9(n){Xg||(Xg=n)}(new $C)}onAndCancel(t,e,r){return t.addEventListener(e,r,!1),()=>{t.removeEventListener(e,r,!1)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){t.parentNode&&t.parentNode.removeChild(t)}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getBaseHref(t){const e=function vQ(){return af=af||document.querySelector("base"),af?af.getAttribute("href"):null}();return null==e?null:function xQ(n){cy=cy||document.createElement("a"),cy.setAttribute("href",n);const t=cy.pathname;return"/"===t.charAt(0)?t:`/${t}`}(e)}resetBaseElement(){af=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return function dZ(n,t){t=encodeURIComponent(t);for(const e of n.split(";")){const r=e.indexOf("="),[s,i]=-1==r?[e,""]:[e.slice(0,r),e.slice(r+1)];if(s.trim()===t)return decodeURIComponent(i)}return null}(document.cookie,t)}}let cy,af=null;const H2=new me("TRANSITION_ID"),CQ=[{provide:Ug,useFactory:function wQ(n,t,e){return()=>{e.get(Hg).donePromise.then(()=>{const r=Do(),s=t.querySelectorAll(`style[ng-transition="${n}"]`);for(let i=0;i<s.length;i++)r.remove(s[i])})}},deps:[H2,vt,pr],multi:!0}];let EQ=(()=>{class n{build(){return new XMLHttpRequest}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();const uy=new me("EventManagerPlugins");let dy=(()=>{class n{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(s=>s.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,r,s){return this._findPluginFor(r).addEventListener(e,r,s)}addGlobalEventListener(e,r,s){return this._findPluginFor(r).addGlobalEventListener(e,r,s)}getZone(){return this._zone}_findPluginFor(e){const r=this._eventNameToPlugin.get(e);if(r)return r;const s=this._plugins;for(let i=0;i<s.length;i++){const o=s[i];if(o.supports(e))return this._eventNameToPlugin.set(e,o),o}throw new Error(`No event manager plugin found for event ${e}`)}}return n.\u0275fac=function(e){return new(e||n)(Z(uy),Z(yt))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();class W2{constructor(t){this._doc=t}addGlobalEventListener(t,e,r){const s=Do().getGlobalEventTarget(this._doc,t);if(!s)throw new Error(`Unsupported event target ${s} for event ${e}`);return this.addEventListener(s,e,r)}}let j2=(()=>{class n{constructor(){this._stylesSet=new Set}addStyles(e){const r=new Set;e.forEach(s=>{this._stylesSet.has(s)||(this._stylesSet.add(s),r.add(s))}),this.onStylesAdded(r)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})(),lf=(()=>{class n extends j2{constructor(e){super(),this._doc=e,this._hostNodes=new Map,this._hostNodes.set(e.head,[])}_addStylesToHost(e,r,s){e.forEach(i=>{const o=this._doc.createElement("style");o.textContent=i,s.push(r.appendChild(o))})}addHost(e){const r=[];this._addStylesToHost(this._stylesSet,e,r),this._hostNodes.set(e,r)}removeHost(e){const r=this._hostNodes.get(e);r&&r.forEach(G2),this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach((r,s)=>{this._addStylesToHost(e,s,r)})}ngOnDestroy(){this._hostNodes.forEach(e=>e.forEach(G2))}}return n.\u0275fac=function(e){return new(e||n)(Z(vt))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();function G2(n){Do().remove(n)}const LC={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},BC=/%COMP%/g;function hy(n,t,e){for(let r=0;r<t.length;r++){let s=t[r];Array.isArray(s)?hy(n,s,e):(s=s.replace(BC,n),e.push(s))}return e}function X2(n){return t=>{if("__ngUnwrap__"===t)return n;!1===n(t)&&(t.preventDefault(),t.returnValue=!1)}}let fy=(()=>{class n{constructor(e,r,s){this.eventManager=e,this.sharedStylesHost=r,this.appId=s,this.rendererByCompId=new Map,this.defaultRenderer=new VC(e)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;switch(r.encapsulation){case qi.Emulated:{let s=this.rendererByCompId.get(r.id);return s||(s=new AQ(this.eventManager,this.sharedStylesHost,r,this.appId),this.rendererByCompId.set(r.id,s)),s.applyToHost(e),s}case 1:case qi.ShadowDom:return new RQ(this.eventManager,this.sharedStylesHost,e,r);default:if(!this.rendererByCompId.has(r.id)){const s=hy(r.id,r.styles,[]);this.sharedStylesHost.addStyles(s),this.rendererByCompId.set(r.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return n.\u0275fac=function(e){return new(e||n)(Z(dy),Z(lf),Z(Jh))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();class VC{constructor(t){this.eventManager=t,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(t,e){return e?document.createElementNS(LC[e]||e,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,e){(Z2(t)?t.content:t).appendChild(e)}insertBefore(t,e,r){t&&(Z2(t)?t.content:t).insertBefore(e,r)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let r="string"==typeof t?document.querySelector(t):t;if(!r)throw new Error(`The selector "${t}" did not match any elements`);return e||(r.textContent=""),r}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,r,s){if(s){e=s+":"+e;const i=LC[s];i?t.setAttributeNS(i,e,r):t.setAttribute(e,r)}else t.setAttribute(e,r)}removeAttribute(t,e,r){if(r){const s=LC[r];s?t.removeAttributeNS(s,e):t.removeAttribute(`${r}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,r,s){s&(Ds.DashCase|Ds.Important)?t.style.setProperty(e,r,s&Ds.Important?"important":""):t.style[e]=r}removeStyle(t,e,r){r&Ds.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,r){t[e]=r}setValue(t,e){t.nodeValue=e}listen(t,e,r){return"string"==typeof t?this.eventManager.addGlobalEventListener(t,e,X2(r)):this.eventManager.addEventListener(t,e,X2(r))}}function Z2(n){return"TEMPLATE"===n.tagName&&void 0!==n.content}class AQ extends VC{constructor(t,e,r,s){super(t),this.component=r;const i=hy(s+"-"+r.id,r.styles,[]);e.addStyles(i),this.contentAttr=function TQ(n){return"_ngcontent-%COMP%".replace(BC,n)}(s+"-"+r.id),this.hostAttr=function kQ(n){return"_nghost-%COMP%".replace(BC,n)}(s+"-"+r.id)}applyToHost(t){super.setAttribute(t,this.hostAttr,"")}createElement(t,e){const r=super.createElement(t,e);return super.setAttribute(r,this.contentAttr,""),r}}class RQ extends VC{constructor(t,e,r,s){super(t),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const i=hy(s.id,s.styles,[]);for(let o=0;o<i.length;o++){const a=document.createElement("style");a.textContent=i[o],this.shadowRoot.appendChild(a)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,r){return super.insertBefore(this.nodeOrShadowRoot(t),e,r)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}}let MQ=(()=>{class n extends W2{constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,s){return e.addEventListener(r,s,!1),()=>this.removeEventListener(e,r,s)}removeEventListener(e,r,s){return e.removeEventListener(r,s)}}return n.\u0275fac=function(e){return new(e||n)(Z(vt))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();const Q2=["alt","control","meta","shift"],FQ={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},OQ={alt:n=>n.altKey,control:n=>n.ctrlKey,meta:n=>n.metaKey,shift:n=>n.shiftKey};let PQ=(()=>{class n extends W2{constructor(e){super(e)}supports(e){return null!=n.parseEventName(e)}addEventListener(e,r,s){const i=n.parseEventName(r),o=n.eventCallback(i.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Do().onAndCancel(e,i.domEventName,o))}static parseEventName(e){const r=e.toLowerCase().split("."),s=r.shift();if(0===r.length||"keydown"!==s&&"keyup"!==s)return null;const i=n._normalizeKey(r.pop());let o="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),o="code."),Q2.forEach(c=>{const u=r.indexOf(c);u>-1&&(r.splice(u,1),o+=c+".")}),o+=i,0!=r.length||0===i.length)return null;const l={};return l.domEventName=s,l.fullKey=o,l}static matchEventFullKeyCode(e,r){let s=FQ[e.key]||e.key,i="";return r.indexOf("code.")>-1&&(s=e.code,i="code."),!(null==s||!s)&&(s=s.toLowerCase()," "===s?s="space":"."===s&&(s="dot"),Q2.forEach(o=>{o!==s&&(0,OQ[o])(e)&&(i+=o+".")}),i+=s,i===r)}static eventCallback(e,r,s){return i=>{n.matchEventFullKeyCode(i,e)&&s.runGuarded(()=>r(i))}}static _normalizeKey(e){return"esc"===e?"escape":e}}return n.\u0275fac=function(e){return new(e||n)(Z(vt))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();const VQ=jO(b9,"browser",[{provide:aC,useValue:P2},{provide:OO,useValue:function $Q(){$C.makeCurrent()},multi:!0},{provide:vt,useFactory:function BQ(){return function d8(n){z0=n}(document),document},deps:[]}]),tP=new me(""),nP=[{provide:Wg,useClass:class SQ{addToWindow(t){un.getAngularTestability=(r,s=!0)=>{const i=t.findTestabilityInTree(r,s);if(null==i)throw new Error("Could not find testability for element.");return i},un.getAllAngularTestabilities=()=>t.getAllTestabilities(),un.getAllAngularRootElements=()=>t.getAllRootElements(),un.frameworkStabilizers||(un.frameworkStabilizers=[]),un.frameworkStabilizers.push(r=>{const s=un.getAllAngularTestabilities();let i=s.length,o=!1;const a=function(l){o=o||l,i--,0==i&&r(o)};s.forEach(function(l){l.whenStable(a)})})}findTestabilityInTree(t,e,r){return null==e?null:t.getTestability(e)??(r?Do().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null)}},deps:[]},{provide:zO,useClass:hC,deps:[yt,fC,Wg]},{provide:hC,useClass:hC,deps:[yt,fC,Wg]}],rP=[{provide:X0,useValue:"root"},{provide:sa,useFactory:function LQ(){return new sa},deps:[]},{provide:uy,useClass:MQ,multi:!0,deps:[vt,yt,aC]},{provide:uy,useClass:PQ,multi:!0,deps:[vt]},{provide:fy,useClass:fy,deps:[dy,lf,Jh]},{provide:kh,useExisting:fy},{provide:j2,useExisting:lf},{provide:lf,useClass:lf,deps:[vt]},{provide:dy,useClass:dy,deps:[uy,yt]},{provide:class GZ{},useClass:EQ,deps:[]},[]];let sP=(()=>{class n{constructor(e){}static withServerTransition(e){return{ngModule:n,providers:[{provide:Jh,useValue:e.appId},{provide:H2,useExisting:Jh},CQ]}}}return n.\u0275fac=function(e){return new(e||n)(Z(tP,12))},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({providers:[...rP,...nP],imports:[ic,_9]}),n})(),iP=(()=>{class n{constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}}return n.\u0275fac=function(e){return new(e||n)(Z(vt))},n.\u0275prov=we({token:n,factory:function(e){let r=null;return r=e?new e:function UQ(){return new iP(Z(vt))}(),r},providedIn:"root"}),n})();typeof window<"u"&&window;let HC=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:function(e){let r=null;return r=e?new(e||n):Z(lP),r},providedIn:"root"}),n})(),lP=(()=>{class n extends HC{constructor(e){super(),this._doc=e}sanitize(e,r){if(null==r)return null;switch(e){case Vt.NONE:return r;case Vt.HTML:return vo(r,"HTML")?Qs(r):cR(this._doc,String(r)).toString();case Vt.STYLE:return vo(r,"Style")?Qs(r):r;case Vt.SCRIPT:if(vo(r,"Script"))return Qs(r);throw new Error("unsafe value used in a script context");case Vt.URL:return vo(r,"URL")?Qs(r):gg(String(r));case Vt.RESOURCE_URL:if(vo(r,"ResourceURL"))return Qs(r);throw new Error(`unsafe value used in a resource URL context (see ${Bm})`);default:throw new Error(`Unexpected SecurityContext ${e} (see ${Bm})`)}}bypassSecurityTrustHtml(e){return function b8(n){return new h8(n)}(e)}bypassSecurityTrustStyle(e){return function _8(n){return new f8(n)}(e)}bypassSecurityTrustScript(e){return function v8(n){return new p8(n)}(e)}bypassSecurityTrustUrl(e){return function x8(n){return new m8(n)}(e)}bypassSecurityTrustResourceUrl(e){return function w8(n){return new g8(n)}(e)}}return n.\u0275fac=function(e){return new(e||n)(Z(vt))},n.\u0275prov=we({token:n,factory:function(e){let r=null;return r=e?new e:function XQ(n){return new lP(n.get(vt))}(Z(pr)),r},providedIn:"root"}),n})();function Oe(...n){return Pn(n,sh(n))}class Di extends kt{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return!e.closed&&t.next(this._value),e}getValue(){const{hasError:t,thrownError:e,_value:r}=this;if(t)throw e;return this._throwIfClosed(),r}next(t){super.next(this._value=t)}}const py=je(n=>function(){n(this),this.name="EmptyError",this.message="no elements in sequence"}),{isArray:YQ}=Array,{getPrototypeOf:ZQ,prototype:QQ,keys:JQ}=Object;function cP(n){if(1===n.length){const t=n[0];if(YQ(t))return{args:t,keys:null};if(function eJ(n){return n&&"object"==typeof n&&ZQ(n)===QQ}(t)){const e=JQ(t);return{args:e.map(r=>t[r]),keys:e}}}return{args:n,keys:null}}const{isArray:tJ}=Array;function WC(n){return ze(t=>function nJ(n,t){return tJ(t)?n(...t):n(t)}(n,t))}function uP(n,t){return n.reduce((e,r,s)=>(e[r]=t[s],e),{})}function jC(...n){const t=sh(n),e=_N(n),{args:r,keys:s}=cP(n);if(0===r.length)return Pn([],t);const i=new Cn(function rJ(n,t,e=Fa){return r=>{dP(t,()=>{const{length:s}=n,i=new Array(s);let o=s,a=s;for(let l=0;l<s;l++)dP(t,()=>{const c=Pn(n[l],t);let u=!1;c.subscribe(Sn(r,d=>{i[l]=d,u||(u=!0,a--),a||r.next(e(i.slice()))},()=>{--o||r.complete()}))},r)},r)}}(r,t,s?o=>uP(s,o):Fa));return e?i.pipe(WC(e)):i}function dP(n,t,e){n?Xo(e,n,t):t()}function my(...n){return function sJ(){return qc(1)}()(Pn(n,sh(n)))}function gy(n){return new Cn(t=>{Cs(n()).subscribe(t)})}function Lu(n,t){const e=ae(n)?n:()=>n,r=s=>s.error(e());return new Cn(t?s=>t.schedule(r,0,s):r)}function GC(){return On((n,t)=>{let e=null;n._refCount++;const r=Sn(t,void 0,void 0,void 0,()=>{if(!n||n._refCount<=0||0<--n._refCount)return void(e=null);const s=n._connection,i=e;e=null,s&&(!i||s===i)&&s.unsubscribe(),t.unsubscribe()});n.subscribe(r),r.closed||(e=n.connect())})}class hP extends Cn{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,iN(t)&&(this.lift=t.lift)}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return(!t||t.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:t}=this;this._subject=this._connection=null,t?.unsubscribe()}connect(){let t=this._connection;if(!t){t=this._connection=new He;const e=this.getSubject();t.add(this.source.subscribe(Sn(e,void 0,()=>{this._teardown(),e.complete()},r=>{this._teardown(),e.error(r)},()=>this._teardown()))),t.closed&&(this._connection=null,t=He.EMPTY)}return t}refCount(){return GC()(this)}}function ni(n,t){return On((e,r)=>{let s=null,i=0,o=!1;const a=()=>o&&!s&&r.complete();e.subscribe(Sn(r,l=>{s?.unsubscribe();let c=0;const u=i++;Cs(n(l,u)).subscribe(s=Sn(r,d=>r.next(t?t(l,d,u,c++):d),()=>{s=null,a()}))},()=>{o=!0,a()}))})}function $r(n){return n<=0?()=>Yo:On((t,e)=>{let r=0;t.subscribe(Sn(e,s=>{++r<=n&&(e.next(s),n<=r&&e.complete())}))})}function yy(...n){const t=sh(n);return On((e,r)=>{(t?my(n,e,t):my(n,e)).subscribe(r)})}function As(n,t){return On((e,r)=>{let s=0;e.subscribe(Sn(r,i=>n.call(t,i,s++)&&r.next(i)))})}function by(n){return On((t,e)=>{let r=!1;t.subscribe(Sn(e,s=>{r=!0,e.next(s)},()=>{r||e.next(n),e.complete()}))})}function fP(n=iJ){return On((t,e)=>{let r=!1;t.subscribe(Sn(e,s=>{r=!0,e.next(s)},()=>r?e.complete():e.error(n())))})}function iJ(){return new py}function Wa(n,t){const e=arguments.length>=2;return r=>r.pipe(n?As((s,i)=>n(s,i,r)):Fa,$r(1),e?by(t):fP(()=>new py))}function ja(n,t){return ae(t)?Dr(n,t,1):Dr(n,1)}function tr(n,t,e){const r=ae(n)||t||e?{next:n,error:t,complete:e}:n;return r?On((s,i)=>{var o;null===(o=r.subscribe)||void 0===o||o.call(r);let a=!0;s.subscribe(Sn(i,l=>{var c;null===(c=r.next)||void 0===c||c.call(r,l),i.next(l)},()=>{var l;a=!1,null===(l=r.complete)||void 0===l||l.call(r),i.complete()},l=>{var c;a=!1,null===(c=r.error)||void 0===c||c.call(r,l),i.error(l)},()=>{var l,c;a&&(null===(l=r.unsubscribe)||void 0===l||l.call(r)),null===(c=r.finalize)||void 0===c||c.call(r)}))}):Fa}function To(n){return On((t,e)=>{let i,r=null,s=!1;r=t.subscribe(Sn(e,void 0,void 0,o=>{i=Cs(n(o,To(n)(t))),r?(r.unsubscribe(),r=null,i.subscribe(e)):s=!0})),s&&(r.unsubscribe(),r=null,i.subscribe(e))})}function oJ(n,t,e,r,s){return(i,o)=>{let a=e,l=t,c=0;i.subscribe(Sn(o,u=>{const d=c++;l=a?n(l,u,d):(a=!0,u),r&&o.next(l)},s&&(()=>{a&&o.next(l),o.complete()})))}}function pP(n,t){return On(oJ(n,t,arguments.length>=2,!0))}function qC(n){return n<=0?()=>Yo:On((t,e)=>{let r=[];t.subscribe(Sn(e,s=>{r.push(s),n<r.length&&r.shift()},()=>{for(const s of r)e.next(s);e.complete()},void 0,()=>{r=null}))})}function mP(n,t){const e=arguments.length>=2;return r=>r.pipe(n?As((s,i)=>n(s,i,r)):Fa,qC(1),e?by(t):fP(()=>new py))}function gP(n,t=!1){return On((e,r)=>{let s=0;e.subscribe(Sn(r,i=>{const o=n(i,s++);(o||t)&&r.next(i),!o&&r.complete()}))})}function _y(n){return On((t,e)=>{try{t.subscribe(e)}finally{e.add(n)}})}const pt="primary",cf=Symbol("RouteTitle");class lJ{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function Bu(n){return new lJ(n)}function cJ(n,t,e){const r=e.path.split("/");if(r.length>n.length||"full"===e.pathMatch&&(t.hasChildren()||r.length<n.length))return null;const s={};for(let i=0;i<r.length;i++){const o=r[i],a=n[i];if(o.startsWith(":"))s[o.substring(1)]=a;else if(o!==a.path)return null}return{consumed:n.slice(0,r.length),posParams:s}}function ko(n,t){const e=n?Object.keys(n):void 0,r=t?Object.keys(t):void 0;if(!e||!r||e.length!=r.length)return!1;let s;for(let i=0;i<e.length;i++)if(s=e[i],!yP(n[s],t[s]))return!1;return!0}function yP(n,t){if(Array.isArray(n)&&Array.isArray(t)){if(n.length!==t.length)return!1;const e=[...n].sort(),r=[...t].sort();return e.every((s,i)=>r[i]===s)}return n===t}function bP(n){return Array.prototype.concat.apply([],n)}function _P(n){return n.length>0?n[n.length-1]:null}function Lr(n,t){for(const e in n)n.hasOwnProperty(e)&&t(n[e],e)}function Ga(n){return Ow(n)?n:Bh(n)?Pn(Promise.resolve(n)):Oe(n)}const vy=!1,dJ={exact:function wP(n,t,e){if(!ac(n.segments,t.segments)||!xy(n.segments,t.segments,e)||n.numberOfChildren!==t.numberOfChildren)return!1;for(const r in t.children)if(!n.children[r]||!wP(n.children[r],t.children[r],e))return!1;return!0},subset:CP},vP={exact:function hJ(n,t){return ko(n,t)},subset:function fJ(n,t){return Object.keys(t).length<=Object.keys(n).length&&Object.keys(t).every(e=>yP(n[e],t[e]))},ignored:()=>!0};function xP(n,t,e){return dJ[e.paths](n.root,t.root,e.matrixParams)&&vP[e.queryParams](n.queryParams,t.queryParams)&&!("exact"===e.fragment&&n.fragment!==t.fragment)}function CP(n,t,e){return SP(n,t,t.segments,e)}function SP(n,t,e,r){if(n.segments.length>e.length){const s=n.segments.slice(0,e.length);return!(!ac(s,e)||t.hasChildren()||!xy(s,e,r))}if(n.segments.length===e.length){if(!ac(n.segments,e)||!xy(n.segments,e,r))return!1;for(const s in t.children)if(!n.children[s]||!CP(n.children[s],t.children[s],r))return!1;return!0}{const s=e.slice(0,n.segments.length),i=e.slice(n.segments.length);return!!(ac(n.segments,s)&&xy(n.segments,s,r)&&n.children[pt])&&SP(n.children[pt],t,i,r)}}function xy(n,t,e){return t.every((r,s)=>vP[e](n[s].parameters,r.parameters))}class oc{constructor(t=new bt([],{}),e={},r=null){this.root=t,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Bu(this.queryParams)),this._queryParamMap}toString(){return gJ.serialize(this)}}class bt{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Lr(e,(r,s)=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return wy(this)}}class uf{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=Bu(this.parameters)),this._parameterMap}toString(){return TP(this)}}function ac(n,t){return n.length===t.length&&n.every((e,r)=>e.path===t[r].path)}let EP=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:function(){return new KC},providedIn:"root"}),n})();class KC{parse(t){const e=new EJ(t);return new oc(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){const e=`/${df(t.root,!0)}`,r=function _J(n){const t=Object.keys(n).map(e=>{const r=n[e];return Array.isArray(r)?r.map(s=>`${Cy(e)}=${Cy(s)}`).join("&"):`${Cy(e)}=${Cy(r)}`}).filter(e=>!!e);return t.length?`?${t.join("&")}`:""}(t.queryParams);return`${e}${r}${"string"==typeof t.fragment?`#${function yJ(n){return encodeURI(n)}(t.fragment)}`:""}`}}const gJ=new KC;function wy(n){return n.segments.map(t=>TP(t)).join("/")}function df(n,t){if(!n.hasChildren())return wy(n);if(t){const e=n.children[pt]?df(n.children[pt],!1):"",r=[];return Lr(n.children,(s,i)=>{i!==pt&&r.push(`${i}:${df(s,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}{const e=function mJ(n,t){let e=[];return Lr(n.children,(r,s)=>{s===pt&&(e=e.concat(t(r,s)))}),Lr(n.children,(r,s)=>{s!==pt&&(e=e.concat(t(r,s)))}),e}(n,(r,s)=>s===pt?[df(n.children[pt],!1)]:[`${s}:${df(r,!1)}`]);return 1===Object.keys(n.children).length&&null!=n.children[pt]?`${wy(n)}/${e[0]}`:`${wy(n)}/(${e.join("//")})`}}function IP(n){return encodeURIComponent(n).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Cy(n){return IP(n).replace(/%3B/gi,";")}function XC(n){return IP(n).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Sy(n){return decodeURIComponent(n)}function DP(n){return Sy(n.replace(/\+/g,"%20"))}function TP(n){return`${XC(n.path)}${function bJ(n){return Object.keys(n).map(t=>`;${XC(t)}=${XC(n[t])}`).join("")}(n.parameters)}`}const vJ=/^[^\/()?;=#]+/;function Ey(n){const t=n.match(vJ);return t?t[0]:""}const xJ=/^[^=?&#]+/,CJ=/^[^&#]+/;class EJ{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new bt([],{}):new bt([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(r[pt]=new bt(t,e)),r}parseSegment(){const t=Ey(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new te(4009,vy);return this.capture(t),new uf(Sy(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=Ey(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const s=Ey(this.remaining);s&&(r=s,this.capture(r))}t[Sy(e)]=Sy(r)}parseQueryParam(t){const e=function wJ(n){const t=n.match(xJ);return t?t[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const o=function SJ(n){const t=n.match(CJ);return t?t[0]:""}(this.remaining);o&&(r=o,this.capture(r))}const s=DP(e),i=DP(r);if(t.hasOwnProperty(s)){let o=t[s];Array.isArray(o)||(o=[o],t[s]=o),o.push(i)}else t[s]=i}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=Ey(this.remaining),s=this.remaining[r.length];if("/"!==s&&")"!==s&&";"!==s)throw new te(4010,vy);let i;r.indexOf(":")>-1?(i=r.slice(0,r.indexOf(":")),this.capture(i),this.capture(":")):t&&(i=pt);const o=this.parseChildren();e[i]=1===Object.keys(o).length?o[pt]:new bt([],o),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new te(4011,vy)}}function YC(n){return n.segments.length>0?new bt([],{[pt]:n}):n}function Iy(n){const t={};for(const r of Object.keys(n.children)){const i=Iy(n.children[r]);(i.segments.length>0||i.hasChildren())&&(t[r]=i)}return function IJ(n){if(1===n.numberOfChildren&&n.children[pt]){const t=n.children[pt];return new bt(n.segments.concat(t.segments),t.children)}return n}(new bt(n.segments,t))}function lc(n){return n instanceof oc}function kJ(n,t,e,r,s){if(0===e.length)return Vu(t.root,t.root,t.root,r,s);const i=function AP(n){if("string"==typeof n[0]&&1===n.length&&"/"===n[0])return new NP(!0,0,n);let t=0,e=!1;const r=n.reduce((s,i,o)=>{if("object"==typeof i&&null!=i){if(i.outlets){const a={};return Lr(i.outlets,(l,c)=>{a[c]="string"==typeof l?l.split("/"):l}),[...s,{outlets:a}]}if(i.segmentPath)return[...s,i.segmentPath]}return"string"!=typeof i?[...s,i]:0===o?(i.split("/").forEach((a,l)=>{0==l&&"."===a||(0==l&&""===a?e=!0:".."===a?t++:""!=a&&s.push(a))}),s):[...s,i]},[]);return new NP(e,t,r)}(e);return i.toRoot()?Vu(t.root,t.root,new bt([],{}),r,s):function o(l){const c=function AJ(n,t,e,r){if(n.isAbsolute)return new zu(t.root,!0,0);if(-1===r)return new zu(e,e===t.root,0);return function RP(n,t,e){let r=n,s=t,i=e;for(;i>s;){if(i-=s,r=r.parent,!r)throw new te(4005,!1);s=r.segments.length}return new zu(r,!1,s-i)}(e,r+(hf(n.commands[0])?0:1),n.numberOfDoubleDots)}(i,t,n.snapshot?._urlSegment,l),u=c.processChildren?pf(c.segmentGroup,c.index,i.commands):QC(c.segmentGroup,c.index,i.commands);return Vu(t.root,c.segmentGroup,u,r,s)}(n.snapshot?._lastPathIndex)}function hf(n){return"object"==typeof n&&null!=n&&!n.outlets&&!n.segmentPath}function ff(n){return"object"==typeof n&&null!=n&&n.outlets}function Vu(n,t,e,r,s){let o,i={};r&&Lr(r,(l,c)=>{i[c]=Array.isArray(l)?l.map(u=>`${u}`):`${l}`}),o=n===t?e:kP(n,t,e);const a=YC(Iy(o));return new oc(a,i,s)}function kP(n,t,e){const r={};return Lr(n.children,(s,i)=>{r[i]=s===t?e:kP(s,t,e)}),new bt(n.segments,r)}class NP{constructor(t,e,r){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=r,t&&r.length>0&&hf(r[0]))throw new te(4003,!1);const s=r.find(ff);if(s&&s!==_P(r))throw new te(4004,!1)}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class zu{constructor(t,e,r){this.segmentGroup=t,this.processChildren=e,this.index=r}}function QC(n,t,e){if(n||(n=new bt([],{})),0===n.segments.length&&n.hasChildren())return pf(n,t,e);const r=function MJ(n,t,e){let r=0,s=t;const i={match:!1,pathIndex:0,commandIndex:0};for(;s<n.segments.length;){if(r>=e.length)return i;const o=n.segments[s],a=e[r];if(ff(a))break;const l=`${a}`,c=r<e.length-1?e[r+1]:null;if(s>0&&void 0===l)break;if(l&&c&&"object"==typeof c&&void 0===c.outlets){if(!FP(l,c,o))return i;r+=2}else{if(!FP(l,{},o))return i;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(n,t,e),s=e.slice(r.commandIndex);if(r.match&&r.pathIndex<n.segments.length){const i=new bt(n.segments.slice(0,r.pathIndex),{});return i.children[pt]=new bt(n.segments.slice(r.pathIndex),n.children),pf(i,0,s)}return r.match&&0===s.length?new bt(n.segments,{}):r.match&&!n.hasChildren()?JC(n,t,e):r.match?pf(n,0,s):JC(n,t,e)}function pf(n,t,e){if(0===e.length)return new bt(n.segments,{});{const r=function RJ(n){return ff(n[0])?n[0].outlets:{[pt]:n}}(e),s={};return Lr(r,(i,o)=>{"string"==typeof i&&(i=[i]),null!==i&&(s[o]=QC(n.children[o],t,i))}),Lr(n.children,(i,o)=>{void 0===r[o]&&(s[o]=i)}),new bt(n.segments,s)}}function JC(n,t,e){const r=n.segments.slice(0,t);let s=0;for(;s<e.length;){const i=e[s];if(ff(i)){const l=FJ(i.outlets);return new bt(r,l)}if(0===s&&hf(e[0])){r.push(new uf(n.segments[t].path,MP(e[0]))),s++;continue}const o=ff(i)?i.outlets[pt]:`${i}`,a=s<e.length-1?e[s+1]:null;o&&a&&hf(a)?(r.push(new uf(o,MP(a))),s+=2):(r.push(new uf(o,{})),s++)}return new bt(r,{})}function FJ(n){const t={};return Lr(n,(e,r)=>{"string"==typeof e&&(e=[e]),null!==e&&(t[r]=JC(new bt([],{}),0,e))}),t}function MP(n){const t={};return Lr(n,(e,r)=>t[r]=`${e}`),t}function FP(n,t,e){return n==e.path&&ko(t,e.parameters)}class fa{constructor(t,e){this.id=t,this.url=e}}class eS extends fa{constructor(t,e,r="imperative",s=null){super(t,e),this.type=0,this.navigationTrigger=r,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class cc extends fa{constructor(t,e,r){super(t,e),this.urlAfterRedirects=r,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Dy extends fa{constructor(t,e,r,s){super(t,e),this.reason=r,this.code=s,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class OP extends fa{constructor(t,e,r,s){super(t,e),this.error=r,this.target=s,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class OJ extends fa{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class PJ extends fa{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class $J extends fa{constructor(t,e,r,s,i){super(t,e),this.urlAfterRedirects=r,this.state=s,this.shouldActivate=i,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class LJ extends fa{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class BJ extends fa{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class VJ{constructor(t){this.route=t,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class zJ{constructor(t){this.route=t,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class UJ{constructor(t){this.snapshot=t,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class HJ{constructor(t){this.snapshot=t,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class WJ{constructor(t){this.snapshot=t,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class jJ{constructor(t){this.snapshot=t,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class PP{constructor(t,e,r){this.routerEvent=t,this.position=e,this.anchor=r,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class $P{constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=tS(t,this._root);return e?e.children.map(r=>r.value):[]}firstChild(t){const e=tS(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=nS(t,this._root);return e.length<2?[]:e[e.length-2].children.map(s=>s.value).filter(s=>s!==t)}pathFromRoot(t){return nS(t,this._root).map(e=>e.value)}}function tS(n,t){if(n===t.value)return t;for(const e of t.children){const r=tS(n,e);if(r)return r}return null}function nS(n,t){if(n===t.value)return[t];for(const e of t.children){const r=nS(n,e);if(r.length)return r.unshift(t),r}return[]}class pa{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function Uu(n){const t={};return n&&n.children.forEach(e=>t[e.value.outlet]=e),t}class LP extends $P{constructor(t,e){super(t),this.snapshot=e,rS(this,t)}toString(){return this.snapshot.toString()}}function BP(n,t){const e=function qJ(n,t){const o=new Ty([],{},{},"",{},pt,t,null,n.root,-1,{});return new zP("",new pa(o,[]))}(n,t),r=new Di([new uf("",{})]),s=new Di({}),i=new Di({}),o=new Di({}),a=new Di(""),l=new Hu(r,s,o,a,i,pt,t,e.root);return l.snapshot=e.root,new LP(new pa(l,[]),e)}class Hu{constructor(t,e,r,s,i,o,a,l){this.url=t,this.params=e,this.queryParams=r,this.fragment=s,this.data=i,this.outlet=o,this.component=a,this.title=this.data?.pipe(ze(c=>c[cf]))??Oe(void 0),this._futureSnapshot=l}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(ze(t=>Bu(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(ze(t=>Bu(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function VP(n,t="emptyOnly"){const e=n.pathFromRoot;let r=0;if("always"!==t)for(r=e.length-1;r>=1;){const s=e[r],i=e[r-1];if(s.routeConfig&&""===s.routeConfig.path)r--;else{if(i.component)break;r--}}return function KJ(n){return n.reduce((t,e)=>({params:{...t.params,...e.params},data:{...t.data,...e.data},resolve:{...e.data,...t.resolve,...e.routeConfig?.data,...e._resolvedData}}),{params:{},data:{},resolve:{}})}(e.slice(r))}class Ty{constructor(t,e,r,s,i,o,a,l,c,u,d){this.url=t,this.params=e,this.queryParams=r,this.fragment=s,this.data=i,this.outlet=o,this.component=a,this.routeConfig=l,this._urlSegment=c,this._lastPathIndex=u,this._resolve=d}get title(){return this.data?.[cf]}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=Bu(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Bu(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class zP extends $P{constructor(t,e){super(e),this.url=t,rS(this,e)}toString(){return UP(this._root)}}function rS(n,t){t.value._routerState=n,t.children.forEach(e=>rS(n,e))}function UP(n){const t=n.children.length>0?` { ${n.children.map(UP).join(", ")} } `:"";return`${n.value}${t}`}function sS(n){if(n.snapshot){const t=n.snapshot,e=n._futureSnapshot;n.snapshot=e,ko(t.queryParams,e.queryParams)||n.queryParams.next(e.queryParams),t.fragment!==e.fragment&&n.fragment.next(e.fragment),ko(t.params,e.params)||n.params.next(e.params),function uJ(n,t){if(n.length!==t.length)return!1;for(let e=0;e<n.length;++e)if(!ko(n[e],t[e]))return!1;return!0}(t.url,e.url)||n.url.next(e.url),ko(t.data,e.data)||n.data.next(e.data)}else n.snapshot=n._futureSnapshot,n.data.next(n._futureSnapshot.data)}function iS(n,t){const e=ko(n.params,t.params)&&function pJ(n,t){return ac(n,t)&&n.every((e,r)=>ko(e.parameters,t[r].parameters))}(n.url,t.url);return e&&!(!n.parent!=!t.parent)&&(!n.parent||iS(n.parent,t.parent))}function mf(n,t,e){if(e&&n.shouldReuseRoute(t.value,e.value.snapshot)){const r=e.value;r._futureSnapshot=t.value;const s=function YJ(n,t,e){return t.children.map(r=>{for(const s of e.children)if(n.shouldReuseRoute(r.value,s.value.snapshot))return mf(n,r,s);return mf(n,r)})}(n,t,e);return new pa(r,s)}{if(n.shouldAttach(t.value)){const i=n.retrieve(t.value);if(null!==i){const o=i.route;return o.value._futureSnapshot=t.value,o.children=t.children.map(a=>mf(n,a)),o}}const r=function ZJ(n){return new Hu(new Di(n.url),new Di(n.params),new Di(n.queryParams),new Di(n.fragment),new Di(n.data),n.outlet,n.component,n)}(t.value),s=t.children.map(i=>mf(n,i));return new pa(r,s)}}const oS="ngNavigationCancelingError";function HP(n,t){const{redirectTo:e,navigationBehaviorOptions:r}=lc(t)?{redirectTo:t,navigationBehaviorOptions:void 0}:t,s=WP(!1,0,t);return s.url=e,s.navigationBehaviorOptions=r,s}function WP(n,t,e){const r=new Error("NavigationCancelingError: "+(n||""));return r[oS]=!0,r.cancellationCode=t,e&&(r.url=e),r}function jP(n){return GP(n)&&lc(n.url)}function GP(n){return n&&n[oS]}class QJ{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.injector=null,this.children=new gf,this.attachRef=null}}let gf=(()=>{class n{constructor(){this.contexts=new Map}onChildOutletCreated(e,r){const s=this.getOrCreateContext(e);s.outlet=r,this.contexts.set(e,s)}onChildOutletDestroyed(e){const r=this.getContext(e);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let r=this.getContext(e);return r||(r=new QJ,this.contexts.set(e,r)),r}getContext(e){return this.contexts.get(e)||null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const ky=!1;let qP=(()=>{class n{constructor(){this.activated=null,this._activatedRoute=null,this.name=pt,this.activateEvents=new Rt,this.deactivateEvents=new Rt,this.attachEvents=new Rt,this.detachEvents=new Rt,this.parentContexts=Ot(gf),this.location=Ot(ti),this.changeDetector=Ot(nc),this.environmentInjector=Ot(Ba)}ngOnChanges(e){if(e.name){const{firstChange:r,previousValue:s}=e.name;if(r)return;this.isTrackedInParentContexts(s)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(s)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new te(4012,ky);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new te(4012,ky);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new te(4012,ky);this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new te(4013,ky);this._activatedRoute=e;const s=this.location,o=e.snapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,l=new JJ(e,a,s.injector);if(r&&function eee(n){return!!n.resolveComponentFactory}(r)){const c=r.resolveComponentFactory(o);this.activated=s.createComponent(c,s.length,l)}else this.activated=s.createComponent(o,{index:s.length,injector:l,environmentInjector:r??this.environmentInjector});this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=$e({type:n,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[Is]}),n})();class JJ{constructor(t,e,r){this.route=t,this.childContexts=e,this.parent=r}get(t,e){return t===Hu?this.route:t===gf?this.childContexts:this.parent.get(t,e)}}let aS=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=is({type:n,selectors:[["ng-component"]],standalone:!0,features:[GF],decls:1,vars:0,template:function(e,r){1&e&&kr(0,"router-outlet")},dependencies:[qP],encapsulation:2}),n})();function KP(n,t){return n.providers&&!n._injector&&(n._injector=Lg(n.providers,t,`Route: ${n.path}`)),n._injector??t}function cS(n){const t=n.children&&n.children.map(cS),e=t?{...n,children:t}:{...n};return!e.component&&!e.loadComponent&&(t||e.loadChildren)&&e.outlet&&e.outlet!==pt&&(e.component=aS),e}function Ti(n){return n.outlet||pt}function XP(n,t){const e=n.filter(r=>Ti(r)===t);return e.push(...n.filter(r=>Ti(r)!==t)),e}function yf(n){if(!n)return null;if(n.routeConfig?._injector)return n.routeConfig._injector;for(let t=n.parent;t;t=t.parent){const e=t.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}class iee{constructor(t,e,r,s){this.routeReuseStrategy=t,this.futureState=e,this.currState=r,this.forwardEvent=s}activate(t){const e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,t),sS(this.futureState.root),this.activateChildRoutes(e,r,t)}deactivateChildRoutes(t,e,r){const s=Uu(e);t.children.forEach(i=>{const o=i.value.outlet;this.deactivateRoutes(i,s[o],r),delete s[o]}),Lr(s,(i,o)=>{this.deactivateRouteAndItsChildren(i,r)})}deactivateRoutes(t,e,r){const s=t.value,i=e?e.value:null;if(s===i)if(s.component){const o=r.getContext(s.outlet);o&&this.deactivateChildRoutes(t,e,o.children)}else this.deactivateChildRoutes(t,e,r);else i&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(t,e){t.value.component&&this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const r=e.getContext(t.value.outlet),s=r&&t.value.component?r.children:e,i=Uu(t);for(const o of Object.keys(i))this.deactivateRouteAndItsChildren(i[o],s);if(r&&r.outlet){const o=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:o,route:t,contexts:a})}}deactivateRouteAndOutlet(t,e){const r=e.getContext(t.value.outlet),s=r&&t.value.component?r.children:e,i=Uu(t);for(const o of Object.keys(i))this.deactivateRouteAndItsChildren(i[o],s);r&&r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated(),r.attachRef=null,r.resolver=null,r.route=null)}activateChildRoutes(t,e,r){const s=Uu(e);t.children.forEach(i=>{this.activateRoutes(i,s[i.value.outlet],r),this.forwardEvent(new jJ(i.value.snapshot))}),t.children.length&&this.forwardEvent(new HJ(t.value.snapshot))}activateRoutes(t,e,r){const s=t.value,i=e?e.value:null;if(sS(s),s===i)if(s.component){const o=r.getOrCreateContext(s.outlet);this.activateChildRoutes(t,e,o.children)}else this.activateChildRoutes(t,e,r);else if(s.component){const o=r.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const a=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),o.children.onOutletReAttached(a.contexts),o.attachRef=a.componentRef,o.route=a.route.value,o.outlet&&o.outlet.attach(a.componentRef,a.route.value),sS(a.route.value),this.activateChildRoutes(t,null,o.children)}else{const a=yf(s.snapshot),l=a?.get(Xl)??null;o.attachRef=null,o.route=s,o.resolver=l,o.injector=a,o.outlet&&o.outlet.activateWith(s,o.injector),this.activateChildRoutes(t,null,o.children)}}else this.activateChildRoutes(t,null,r)}}class YP{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class Ny{constructor(t,e){this.component=t,this.route=e}}function oee(n,t,e){const r=n._root;return bf(r,t?t._root:null,e,[r.value])}function Wu(n,t){const e=Symbol(),r=t.get(n,e);return r===e?"function"!=typeof n||function t5(n){return null!==Um(n)}(n)?t.get(n):n:r}function bf(n,t,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const i=Uu(t);return n.children.forEach(o=>{(function lee(n,t,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const i=n.value,o=t?t.value:null,a=e?e.getContext(n.value.outlet):null;if(o&&i.routeConfig===o.routeConfig){const l=function cee(n,t,e){if("function"==typeof e)return e(n,t);switch(e){case"pathParamsChange":return!ac(n.url,t.url);case"pathParamsOrQueryParamsChange":return!ac(n.url,t.url)||!ko(n.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!iS(n,t)||!ko(n.queryParams,t.queryParams);default:return!iS(n,t)}}(o,i,i.routeConfig.runGuardsAndResolvers);l?s.canActivateChecks.push(new YP(r)):(i.data=o.data,i._resolvedData=o._resolvedData),bf(n,t,i.component?a?a.children:null:e,r,s),l&&a&&a.outlet&&a.outlet.isActivated&&s.canDeactivateChecks.push(new Ny(a.outlet.component,o))}else o&&_f(t,a,s),s.canActivateChecks.push(new YP(r)),bf(n,null,i.component?a?a.children:null:e,r,s)})(o,i[o.value.outlet],e,r.concat([o.value]),s),delete i[o.value.outlet]}),Lr(i,(o,a)=>_f(o,e.getContext(a),s)),s}function _f(n,t,e){const r=Uu(n),s=n.value;Lr(r,(i,o)=>{_f(i,s.component?t?t.children.getContext(o):null:t,e)}),e.canDeactivateChecks.push(new Ny(s.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,s))}function vf(n){return"function"==typeof n}function uS(n){return n instanceof py||"EmptyError"===n?.name}const Ay=Symbol("INITIAL_VALUE");function ju(){return ni(n=>jC(n.map(t=>t.pipe($r(1),yy(Ay)))).pipe(ze(t=>{for(const e of t)if(!0!==e){if(e===Ay)return Ay;if(!1===e||e instanceof oc)return e}return!0}),As(t=>t!==Ay),$r(1)))}function ZP(n){return function CG(...n){return nN(n)}(tr(t=>{if(lc(t))throw HP(0,t)}),ze(t=>!0===t))}const dS={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function QP(n,t,e,r,s){const i=hS(n,t,e);return i.matched?function Iee(n,t,e,r){const s=t.canMatch;return s&&0!==s.length?Oe(s.map(o=>{const a=Wu(o,n);return Ga(function mee(n){return n&&vf(n.canMatch)}(a)?a.canMatch(t,e):n.runInContext(()=>a(t,e)))})).pipe(ju(),ZP()):Oe(!0)}(r=KP(t,r),t,e).pipe(ze(o=>!0===o?i:{...dS})):Oe(i)}function hS(n,t,e){if(""===t.path)return"full"===t.pathMatch&&(n.hasChildren()||e.length>0)?{...dS}:{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const s=(t.matcher||cJ)(e,n,t);if(!s)return{...dS};const i={};Lr(s.posParams,(a,l)=>{i[l]=a.path});const o=s.consumed.length>0?{...i,...s.consumed[s.consumed.length-1].parameters}:i;return{matched:!0,consumedSegments:s.consumed,remainingSegments:e.slice(s.consumed.length),parameters:o,positionalParamSegments:s.posParams??{}}}function Ry(n,t,e,r){if(e.length>0&&function kee(n,t,e){return e.some(r=>My(n,t,r)&&Ti(r)!==pt)}(n,e,r)){const i=new bt(t,function Tee(n,t,e,r){const s={};s[pt]=r,r._sourceSegment=n,r._segmentIndexShift=t.length;for(const i of e)if(""===i.path&&Ti(i)!==pt){const o=new bt([],{});o._sourceSegment=n,o._segmentIndexShift=t.length,s[Ti(i)]=o}return s}(n,t,r,new bt(e,n.children)));return i._sourceSegment=n,i._segmentIndexShift=t.length,{segmentGroup:i,slicedSegments:[]}}if(0===e.length&&function Nee(n,t,e){return e.some(r=>My(n,t,r))}(n,e,r)){const i=new bt(n.segments,function Dee(n,t,e,r,s){const i={};for(const o of r)if(My(n,e,o)&&!s[Ti(o)]){const a=new bt([],{});a._sourceSegment=n,a._segmentIndexShift=t.length,i[Ti(o)]=a}return{...s,...i}}(n,t,e,r,n.children));return i._sourceSegment=n,i._segmentIndexShift=t.length,{segmentGroup:i,slicedSegments:e}}const s=new bt(n.segments,n.children);return s._sourceSegment=n,s._segmentIndexShift=t.length,{segmentGroup:s,slicedSegments:e}}function My(n,t,e){return(!(n.hasChildren()||t.length>0)||"full"!==e.pathMatch)&&""===e.path}function JP(n,t,e,r){return!!(Ti(n)===r||r!==pt&&My(t,e,n))&&("**"===n.path||hS(t,n,e).matched)}function e$(n,t,e){return 0===t.length&&!n.children[e]}const Fy=!1;class Oy{constructor(t){this.segmentGroup=t||null}}class t${constructor(t){this.urlTree=t}}function xf(n){return Lu(new Oy(n))}function n$(n){return Lu(new t$(n))}class Fee{constructor(t,e,r,s,i){this.injector=t,this.configLoader=e,this.urlSerializer=r,this.urlTree=s,this.config=i,this.allowRedirects=!0}apply(){const t=Ry(this.urlTree.root,[],[],this.config).segmentGroup,e=new bt(t.segments,t.children);return this.expandSegmentGroup(this.injector,this.config,e,pt).pipe(ze(i=>this.createUrlTree(Iy(i),this.urlTree.queryParams,this.urlTree.fragment))).pipe(To(i=>{if(i instanceof t$)return this.allowRedirects=!1,this.match(i.urlTree);throw i instanceof Oy?this.noMatchError(i):i}))}match(t){return this.expandSegmentGroup(this.injector,this.config,t.root,pt).pipe(ze(s=>this.createUrlTree(Iy(s),t.queryParams,t.fragment))).pipe(To(s=>{throw s instanceof Oy?this.noMatchError(s):s}))}noMatchError(t){return new te(4002,Fy)}createUrlTree(t,e,r){const s=YC(t);return new oc(s,e,r)}expandSegmentGroup(t,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.expandChildren(t,e,r).pipe(ze(i=>new bt([],i))):this.expandSegment(t,r,e,r.segments,s,!0)}expandChildren(t,e,r){const s=[];for(const i of Object.keys(r.children))"primary"===i?s.unshift(i):s.push(i);return Pn(s).pipe(ja(i=>{const o=r.children[i],a=XP(e,i);return this.expandSegmentGroup(t,a,o,i).pipe(ze(l=>({segment:l,outlet:i})))}),pP((i,o)=>(i[o.outlet]=o.segment,i),{}),mP())}expandSegment(t,e,r,s,i,o){return Pn(r).pipe(ja(a=>this.expandSegmentAgainstRoute(t,e,r,a,s,i,o).pipe(To(c=>{if(c instanceof Oy)return Oe(null);throw c}))),Wa(a=>!!a),To((a,l)=>{if(uS(a))return e$(e,s,i)?Oe(new bt([],{})):xf(e);throw a}))}expandSegmentAgainstRoute(t,e,r,s,i,o,a){return JP(s,e,i,o)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(t,e,s,i,o):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o):xf(e):xf(e)}expandSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,r,s,o):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,r,s){const i=this.applyRedirectCommands([],r.redirectTo,{});return r.redirectTo.startsWith("/")?n$(i):this.lineralizeSegments(r,i).pipe(Dr(o=>{const a=new bt(o,{});return this.expandSegment(t,a,e,o,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o){const{matched:a,consumedSegments:l,remainingSegments:c,positionalParamSegments:u}=hS(e,s,i);if(!a)return xf(e);const d=this.applyRedirectCommands(l,s.redirectTo,u);return s.redirectTo.startsWith("/")?n$(d):this.lineralizeSegments(s,d).pipe(Dr(h=>this.expandSegment(t,e,r,h.concat(c),o,!1)))}matchSegmentAgainstRoute(t,e,r,s,i){return"**"===r.path?(t=KP(r,t),r.loadChildren?(r._loadedRoutes?Oe({routes:r._loadedRoutes,injector:r._loadedInjector}):this.configLoader.loadChildren(t,r)).pipe(ze(a=>(r._loadedRoutes=a.routes,r._loadedInjector=a.injector,new bt(s,{})))):Oe(new bt(s,{}))):QP(e,r,s,t).pipe(ni(({matched:o,consumedSegments:a,remainingSegments:l})=>o?this.getChildConfig(t=r._injector??t,r,s).pipe(Dr(u=>{const d=u.injector??t,h=u.routes,{segmentGroup:f,slicedSegments:p}=Ry(e,a,l,h),m=new bt(f.segments,f.children);if(0===p.length&&m.hasChildren())return this.expandChildren(d,h,m).pipe(ze(_=>new bt(a,_)));if(0===h.length&&0===p.length)return Oe(new bt(a,{}));const g=Ti(r)===i;return this.expandSegment(d,m,h,p,g?pt:i,!0).pipe(ze(b=>new bt(a.concat(b.segments),b.children)))})):xf(e)))}getChildConfig(t,e,r){return e.children?Oe({routes:e.children,injector:t}):e.loadChildren?void 0!==e._loadedRoutes?Oe({routes:e._loadedRoutes,injector:e._loadedInjector}):function Eee(n,t,e,r){const s=t.canLoad;return void 0===s||0===s.length?Oe(!0):Oe(s.map(o=>{const a=Wu(o,n);return Ga(function dee(n){return n&&vf(n.canLoad)}(a)?a.canLoad(t,e):n.runInContext(()=>a(t,e)))})).pipe(ju(),ZP())}(t,e,r).pipe(Dr(s=>s?this.configLoader.loadChildren(t,e).pipe(tr(i=>{e._loadedRoutes=i.routes,e._loadedInjector=i.injector})):function Ree(n){return Lu(WP(Fy,3))}())):Oe({routes:[],injector:t})}lineralizeSegments(t,e){let r=[],s=e.root;for(;;){if(r=r.concat(s.segments),0===s.numberOfChildren)return Oe(r);if(s.numberOfChildren>1||!s.children[pt])return Lu(new te(4e3,Fy));s=s.children[pt]}}applyRedirectCommands(t,e,r){return this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),t,r)}applyRedirectCreateUrlTree(t,e,r,s){const i=this.createSegmentGroup(t,e.root,r,s);return new oc(i,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const r={};return Lr(t,(s,i)=>{if("string"==typeof s&&s.startsWith(":")){const a=s.substring(1);r[i]=e[a]}else r[i]=s}),r}createSegmentGroup(t,e,r,s){const i=this.createSegments(t,e.segments,r,s);let o={};return Lr(e.children,(a,l)=>{o[l]=this.createSegmentGroup(t,a,r,s)}),new bt(i,o)}createSegments(t,e,r,s){return e.map(i=>i.path.startsWith(":")?this.findPosParam(t,i,s):this.findOrReturn(i,r))}findPosParam(t,e,r){const s=r[e.path.substring(1)];if(!s)throw new te(4001,Fy);return s}findOrReturn(t,e){let r=0;for(const s of e){if(s.path===t.path)return e.splice(r),s;r++}return t}}class Pee{}class Bee{constructor(t,e,r,s,i,o,a){this.injector=t,this.rootComponentType=e,this.config=r,this.urlTree=s,this.url=i,this.paramsInheritanceStrategy=o,this.urlSerializer=a}recognize(){const t=Ry(this.urlTree.root,[],[],this.config.filter(e=>void 0===e.redirectTo)).segmentGroup;return this.processSegmentGroup(this.injector,this.config,t,pt).pipe(ze(e=>{if(null===e)return null;const r=new Ty([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},pt,this.rootComponentType,null,this.urlTree.root,-1,{}),s=new pa(r,e),i=new zP(this.url,s);return this.inheritParamsAndData(i._root),i}))}inheritParamsAndData(t){const e=t.value,r=VP(e,this.paramsInheritanceStrategy);e.params=Object.freeze(r.params),e.data=Object.freeze(r.data),t.children.forEach(s=>this.inheritParamsAndData(s))}processSegmentGroup(t,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.processChildren(t,e,r):this.processSegment(t,e,r,r.segments,s)}processChildren(t,e,r){return Pn(Object.keys(r.children)).pipe(ja(s=>{const i=r.children[s],o=XP(e,s);return this.processSegmentGroup(t,o,i,s)}),pP((s,i)=>s&&i?(s.push(...i),s):null),gP(s=>null!==s),by(null),mP(),ze(s=>{if(null===s)return null;const i=s$(s);return function Vee(n){n.sort((t,e)=>t.value.outlet===pt?-1:e.value.outlet===pt?1:t.value.outlet.localeCompare(e.value.outlet))}(i),i}))}processSegment(t,e,r,s,i){return Pn(e).pipe(ja(o=>this.processSegmentAgainstRoute(o._injector??t,o,r,s,i)),Wa(o=>!!o),To(o=>{if(uS(o))return e$(r,s,i)?Oe([]):Oe(null);throw o}))}processSegmentAgainstRoute(t,e,r,s,i){if(e.redirectTo||!JP(e,r,s,i))return Oe(null);let o;if("**"===e.path){const a=s.length>0?_P(s).parameters:{},l=o$(r)+s.length;o=Oe({snapshot:new Ty(s,a,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,a$(e),Ti(e),e.component??e._loadedComponent??null,e,i$(r),l,l$(e)),consumedSegments:[],remainingSegments:[]})}else o=QP(r,e,s,t).pipe(ze(({matched:a,consumedSegments:l,remainingSegments:c,parameters:u})=>{if(!a)return null;const d=o$(r)+l.length;return{snapshot:new Ty(l,u,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,a$(e),Ti(e),e.component??e._loadedComponent??null,e,i$(r),d,l$(e)),consumedSegments:l,remainingSegments:c}}));return o.pipe(ni(a=>{if(null===a)return Oe(null);const{snapshot:l,consumedSegments:c,remainingSegments:u}=a;t=e._injector??t;const d=e._loadedInjector??t,h=function zee(n){return n.children?n.children:n.loadChildren?n._loadedRoutes:[]}(e),{segmentGroup:f,slicedSegments:p}=Ry(r,c,u,h.filter(g=>void 0===g.redirectTo));if(0===p.length&&f.hasChildren())return this.processChildren(d,h,f).pipe(ze(g=>null===g?null:[new pa(l,g)]));if(0===h.length&&0===p.length)return Oe([new pa(l,[])]);const m=Ti(e)===i;return this.processSegment(d,h,f,p,m?pt:i).pipe(ze(g=>null===g?null:[new pa(l,g)]))}))}}function Uee(n){const t=n.value.routeConfig;return t&&""===t.path&&void 0===t.redirectTo}function s$(n){const t=[],e=new Set;for(const r of n){if(!Uee(r)){t.push(r);continue}const s=t.find(i=>r.value.routeConfig===i.value.routeConfig);void 0!==s?(s.children.push(...r.children),e.add(s)):t.push(r)}for(const r of e){const s=s$(r.children);t.push(new pa(r.value,s))}return t.filter(r=>!e.has(r))}function i$(n){let t=n;for(;t._sourceSegment;)t=t._sourceSegment;return t}function o$(n){let t=n,e=t._segmentIndexShift??0;for(;t._sourceSegment;)t=t._sourceSegment,e+=t._segmentIndexShift??0;return e-1}function a$(n){return n.data||{}}function l$(n){return n.resolve||{}}function c$(n){return"string"==typeof n.title||null===n.title}function fS(n){return ni(t=>{const e=n(t);return e?Pn(e).pipe(ze(()=>t)):Oe(t)})}class Yee{constructor(t){this.router=t,this.currentNavigation=null}setupNavigations(t){const e=this.router.events;return t.pipe(As(r=>0!==r.id),ze(r=>({...r,extractedUrl:this.router.urlHandlingStrategy.extract(r.rawUrl)})),ni(r=>{let s=!1,i=!1;return Oe(r).pipe(tr(o=>{this.currentNavigation={id:o.id,initialUrl:o.rawUrl,extractedUrl:o.extractedUrl,trigger:o.source,extras:o.extras,previousNavigation:this.router.lastSuccessfulNavigation?{...this.router.lastSuccessfulNavigation,previousNavigation:null}:null}}),ni(o=>{const a=this.router.browserUrlTree.toString(),l=!this.router.navigated||o.extractedUrl.toString()!==a||a!==this.router.currentUrlTree.toString();if(("reload"===this.router.onSameUrlNavigation||l)&&this.router.urlHandlingStrategy.shouldProcessUrl(o.rawUrl))return d$(o.source)&&(this.router.browserUrlTree=o.extractedUrl),Oe(o).pipe(ni(u=>{const d=this.router.transitions.getValue();return e.next(new eS(u.id,this.router.serializeUrl(u.extractedUrl),u.source,u.restoredState)),d!==this.router.transitions.getValue()?Yo:Promise.resolve(u)}),function Oee(n,t,e,r){return ni(s=>function Mee(n,t,e,r,s){return new Fee(n,t,e,r,s).apply()}(n,t,e,s.extractedUrl,r).pipe(ze(i=>({...s,urlAfterRedirects:i}))))}(this.router.ngModule.injector,this.router.configLoader,this.router.urlSerializer,this.router.config),tr(u=>{this.currentNavigation={...this.currentNavigation,finalUrl:u.urlAfterRedirects},r.urlAfterRedirects=u.urlAfterRedirects}),function Wee(n,t,e,r,s){return Dr(i=>function Lee(n,t,e,r,s,i,o="emptyOnly"){return new Bee(n,t,e,r,s,o,i).recognize().pipe(ni(a=>null===a?function $ee(n){return new Cn(t=>t.error(n))}(new Pee):Oe(a)))}(n,t,e,i.urlAfterRedirects,r.serialize(i.urlAfterRedirects),r,s).pipe(ze(o=>({...i,targetSnapshot:o}))))}(this.router.ngModule.injector,this.router.rootComponentType,this.router.config,this.router.urlSerializer,this.router.paramsInheritanceStrategy),tr(u=>{if(r.targetSnapshot=u.targetSnapshot,"eager"===this.router.urlUpdateStrategy){if(!u.extras.skipLocationChange){const h=this.router.urlHandlingStrategy.merge(u.urlAfterRedirects,u.rawUrl);this.router.setBrowserUrl(h,u)}this.router.browserUrlTree=u.urlAfterRedirects}const d=new OJ(u.id,this.router.serializeUrl(u.extractedUrl),this.router.serializeUrl(u.urlAfterRedirects),u.targetSnapshot);e.next(d)}));if(l&&this.router.rawUrlTree&&this.router.urlHandlingStrategy.shouldProcessUrl(this.router.rawUrlTree)){const{id:d,extractedUrl:h,source:f,restoredState:p,extras:m}=o,g=new eS(d,this.router.serializeUrl(h),f,p);e.next(g);const y=BP(h,this.router.rootComponentType).snapshot;return Oe(r={...o,targetSnapshot:y,urlAfterRedirects:h,extras:{...m,skipLocationChange:!1,replaceUrl:!1}})}return this.router.rawUrlTree=o.rawUrl,o.resolve(null),Yo}),tr(o=>{const a=new PJ(o.id,this.router.serializeUrl(o.extractedUrl),this.router.serializeUrl(o.urlAfterRedirects),o.targetSnapshot);this.router.triggerEvent(a)}),ze(o=>r={...o,guards:oee(o.targetSnapshot,o.currentSnapshot,this.router.rootContexts)}),function yee(n,t){return Dr(e=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:i,canDeactivateChecks:o}}=e;return 0===o.length&&0===i.length?Oe({...e,guardsResult:!0}):function bee(n,t,e,r){return Pn(n).pipe(Dr(s=>function See(n,t,e,r,s){const i=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return i&&0!==i.length?Oe(i.map(a=>{const l=yf(t)??s,c=Wu(a,l);return Ga(function pee(n){return n&&vf(n.canDeactivate)}(c)?c.canDeactivate(n,t,e,r):l.runInContext(()=>c(n,t,e,r))).pipe(Wa())})).pipe(ju()):Oe(!0)}(s.component,s.route,e,t,r)),Wa(s=>!0!==s,!0))}(o,r,s,n).pipe(Dr(a=>a&&function uee(n){return"boolean"==typeof n}(a)?function _ee(n,t,e,r){return Pn(t).pipe(ja(s=>my(function xee(n,t){return null!==n&&t&&t(new UJ(n)),Oe(!0)}(s.route.parent,r),function vee(n,t){return null!==n&&t&&t(new WJ(n)),Oe(!0)}(s.route,r),function Cee(n,t,e){const r=t[t.length-1],i=t.slice(0,t.length-1).reverse().map(o=>function aee(n){const t=n.routeConfig?n.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:n,guards:t}:null}(o)).filter(o=>null!==o).map(o=>gy(()=>Oe(o.guards.map(l=>{const c=yf(o.node)??e,u=Wu(l,c);return Ga(function fee(n){return n&&vf(n.canActivateChild)}(u)?u.canActivateChild(r,n):c.runInContext(()=>u(r,n))).pipe(Wa())})).pipe(ju())));return Oe(i).pipe(ju())}(n,s.path,e),function wee(n,t,e){const r=t.routeConfig?t.routeConfig.canActivate:null;if(!r||0===r.length)return Oe(!0);const s=r.map(i=>gy(()=>{const o=yf(t)??e,a=Wu(i,o);return Ga(function hee(n){return n&&vf(n.canActivate)}(a)?a.canActivate(t,n):o.runInContext(()=>a(t,n))).pipe(Wa())}));return Oe(s).pipe(ju())}(n,s.route,e))),Wa(s=>!0!==s,!0))}(r,i,n,t):Oe(a)),ze(a=>({...e,guardsResult:a})))})}(this.router.ngModule.injector,o=>this.router.triggerEvent(o)),tr(o=>{if(r.guardsResult=o.guardsResult,lc(o.guardsResult))throw HP(0,o.guardsResult);const a=new $J(o.id,this.router.serializeUrl(o.extractedUrl),this.router.serializeUrl(o.urlAfterRedirects),o.targetSnapshot,!!o.guardsResult);this.router.triggerEvent(a)}),As(o=>!!o.guardsResult||(this.router.restoreHistory(o),this.router.cancelNavigationTransition(o,"",3),!1)),fS(o=>{if(o.guards.canActivateChecks.length)return Oe(o).pipe(tr(a=>{const l=new LJ(a.id,this.router.serializeUrl(a.extractedUrl),this.router.serializeUrl(a.urlAfterRedirects),a.targetSnapshot);this.router.triggerEvent(l)}),ni(a=>{let l=!1;return Oe(a).pipe(function jee(n,t){return Dr(e=>{const{targetSnapshot:r,guards:{canActivateChecks:s}}=e;if(!s.length)return Oe(e);let i=0;return Pn(s).pipe(ja(o=>function Gee(n,t,e,r){const s=n.routeConfig,i=n._resolve;return void 0!==s?.title&&!c$(s)&&(i[cf]=s.title),function qee(n,t,e,r){const s=function Kee(n){return[...Object.keys(n),...Object.getOwnPropertySymbols(n)]}(n);if(0===s.length)return Oe({});const i={};return Pn(s).pipe(Dr(o=>function Xee(n,t,e,r){const s=yf(t)??r,i=Wu(n,s);return Ga(i.resolve?i.resolve(t,e):s.runInContext(()=>i(t,e)))}(n[o],t,e,r).pipe(Wa(),tr(a=>{i[o]=a}))),qC(1),function aJ(n){return ze(()=>n)}(i),To(o=>uS(o)?Yo:Lu(o)))}(i,n,t,r).pipe(ze(o=>(n._resolvedData=o,n.data=VP(n,e).resolve,s&&c$(s)&&(n.data[cf]=s.title),null)))}(o.route,r,n,t)),tr(()=>i++),qC(1),Dr(o=>i===s.length?Oe(e):Yo))})}(this.router.paramsInheritanceStrategy,this.router.ngModule.injector),tr({next:()=>l=!0,complete:()=>{l||(this.router.restoreHistory(a),this.router.cancelNavigationTransition(a,"",2))}}))}),tr(a=>{const l=new BJ(a.id,this.router.serializeUrl(a.extractedUrl),this.router.serializeUrl(a.urlAfterRedirects),a.targetSnapshot);this.router.triggerEvent(l)}))}),fS(o=>{const a=l=>{const c=[];l.routeConfig?.loadComponent&&!l.routeConfig._loadedComponent&&c.push(this.router.configLoader.loadComponent(l.routeConfig).pipe(tr(u=>{l.component=u}),ze(()=>{})));for(const u of l.children)c.push(...a(u));return c};return jC(a(o.targetSnapshot.root)).pipe(by(),$r(1))}),fS(()=>this.router.afterPreactivation()),ze(o=>{const a=function XJ(n,t,e){const r=mf(n,t._root,e?e._root:void 0);return new LP(r,t)}(this.router.routeReuseStrategy,o.targetSnapshot,o.currentRouterState);return r={...o,targetRouterState:a}}),tr(o=>{this.router.currentUrlTree=o.urlAfterRedirects,this.router.rawUrlTree=this.router.urlHandlingStrategy.merge(o.urlAfterRedirects,o.rawUrl),this.router.routerState=o.targetRouterState,"deferred"===this.router.urlUpdateStrategy&&(o.extras.skipLocationChange||this.router.setBrowserUrl(this.router.rawUrlTree,o),this.router.browserUrlTree=o.urlAfterRedirects)}),((n,t,e)=>ze(r=>(new iee(t,r.targetRouterState,r.currentRouterState,e).activate(n),r)))(this.router.rootContexts,this.router.routeReuseStrategy,o=>this.router.triggerEvent(o)),tr({next(){s=!0},complete(){s=!0}}),_y(()=>{s||i||this.router.cancelNavigationTransition(r,"",1),this.currentNavigation?.id===r.id&&(this.currentNavigation=null)}),To(o=>{if(i=!0,GP(o)){jP(o)||(this.router.navigated=!0,this.router.restoreHistory(r,!0));const a=new Dy(r.id,this.router.serializeUrl(r.extractedUrl),o.message,o.cancellationCode);if(e.next(a),jP(o)){const l=this.router.urlHandlingStrategy.merge(o.url,this.router.rawUrlTree),c={skipLocationChange:r.extras.skipLocationChange,replaceUrl:"eager"===this.router.urlUpdateStrategy||d$(r.source)};this.router.scheduleNavigation(l,"imperative",null,c,{resolve:r.resolve,reject:r.reject,promise:r.promise})}else r.resolve(!1)}else{this.router.restoreHistory(r,!0);const a=new OP(r.id,this.router.serializeUrl(r.extractedUrl),o,r.targetSnapshot??void 0);e.next(a);try{r.resolve(this.router.errorHandler(o))}catch(l){r.reject(l)}}return Yo}))}))}}function d$(n){return"imperative"!==n}let h$=(()=>{class n{buildTitle(e){let r,s=e.root;for(;void 0!==s;)r=this.getResolvedTitleForRoute(s)??r,s=s.children.find(i=>i.outlet===pt);return r}getResolvedTitleForRoute(e){return e.data[cf]}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:function(){return Ot(Zee)},providedIn:"root"}),n})(),Zee=(()=>{class n extends h${constructor(e){super(),this.title=e}updateTitle(e){const r=this.buildTitle(e);void 0!==r&&this.title.setTitle(r)}}return n.\u0275fac=function(e){return new(e||n)(Z(iP))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Qee=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:function(){return Ot(ete)},providedIn:"root"}),n})();class Jee{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}let ete=(()=>{class n extends Jee{}return n.\u0275fac=function(){let t;return function(r){return(t||(t=hr(n)))(r||n)}}(),n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const Py=new me("",{providedIn:"root",factory:()=>({})}),Gu=new me("ROUTES");let pS=(()=>{class n{constructor(e,r){this.injector=e,this.compiler=r,this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap}loadComponent(e){if(this.componentLoaders.get(e))return this.componentLoaders.get(e);if(e._loadedComponent)return Oe(e._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(e);const r=Ga(e.loadComponent()).pipe(ze(p$),tr(i=>{this.onLoadEndListener&&this.onLoadEndListener(e),e._loadedComponent=i}),_y(()=>{this.componentLoaders.delete(e)})),s=new hP(r,()=>new kt).pipe(GC());return this.componentLoaders.set(e,s),s}loadChildren(e,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return Oe({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);const i=this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(ze(a=>{this.onLoadEndListener&&this.onLoadEndListener(r);let l,c,u=!1;Array.isArray(a)?c=a:(l=a.create(e).injector,c=bP(l.get(Gu,[],qe.Self|qe.Optional)));return{routes:c.map(cS),injector:l}}),_y(()=>{this.childrenLoaders.delete(r)})),o=new hP(i,()=>new kt).pipe(GC());return this.childrenLoaders.set(r,o),o}loadModuleFactoryOrRoutes(e){return Ga(e()).pipe(ze(p$),Dr(s=>s instanceof WF||Array.isArray(s)?Oe(s):Pn(this.compiler.compileModuleAsync(s))))}}return n.\u0275fac=function(e){return new(e||n)(Z(pr),Z(lC))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function p$(n){return function rte(n){return n&&"object"==typeof n&&"default"in n}(n)?n.default:n}let ste=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:function(){return Ot(ite)},providedIn:"root"}),n})(),ite=(()=>{class n{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,r){return e}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function ote(n){throw n}function ate(n,t,e){return t.parse("/")}const lte={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},cte={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};function g$(){const n=Ot(EP),t=Ot(gf),e=Ot(Yg),r=Ot(pr),s=Ot(lC),i=Ot(Gu,{optional:!0})??[],o=Ot(Py,{optional:!0})??{},a=new Kr(null,n,t,e,r,s,bP(i));return function ute(n,t){n.errorHandler&&(t.errorHandler=n.errorHandler),n.malformedUriErrorHandler&&(t.malformedUriErrorHandler=n.malformedUriErrorHandler),n.onSameUrlNavigation&&(t.onSameUrlNavigation=n.onSameUrlNavigation),n.paramsInheritanceStrategy&&(t.paramsInheritanceStrategy=n.paramsInheritanceStrategy),n.urlUpdateStrategy&&(t.urlUpdateStrategy=n.urlUpdateStrategy),n.canceledNavigationResolution&&(t.canceledNavigationResolution=n.canceledNavigationResolution)}(o,a),a}let Kr=(()=>{class n{constructor(e,r,s,i,o,a,l){this.rootComponentType=e,this.urlSerializer=r,this.rootContexts=s,this.location=i,this.config=l,this.lastSuccessfulNavigation=null,this.disposed=!1,this.navigationId=0,this.currentPageId=0,this.isNgZoneEnabled=!1,this.events=new kt,this.errorHandler=ote,this.malformedUriErrorHandler=ate,this.navigated=!1,this.lastSuccessfulId=-1,this.afterPreactivation=()=>Oe(void 0),this.urlHandlingStrategy=Ot(ste),this.routeReuseStrategy=Ot(Qee),this.titleStrategy=Ot(h$),this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.canceledNavigationResolution="replace",this.navigationTransitions=new Yee(this),this.configLoader=o.get(pS),this.configLoader.onLoadEndListener=h=>this.triggerEvent(new zJ(h)),this.configLoader.onLoadStartListener=h=>this.triggerEvent(new VJ(h)),this.ngModule=o.get(tc),this.console=o.get(B7);const d=o.get(yt);this.isNgZoneEnabled=d instanceof yt&&yt.isInAngularZone(),this.resetConfig(l),this.currentUrlTree=new oc,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=BP(this.currentUrlTree,this.rootComponentType),this.transitions=new Di({id:0,targetPageId:0,currentUrlTree:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.navigationTransitions.setupNavigations(this.transitions),this.processNavigations()}get browserPageId(){return this.location.getState()?.\u0275routerPageId}resetRootComponentType(e){this.rootComponentType=e,this.routerState.root.component=this.rootComponentType}setTransition(e){this.transitions.next({...this.transitions.value,...e})}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const r="popstate"===e.type?"popstate":"hashchange";"popstate"===r&&setTimeout(()=>{const s={replaceUrl:!0},i=e.state?.navigationId?e.state:null;if(e.state){const a={...e.state};delete a.navigationId,delete a.\u0275routerPageId,0!==Object.keys(a).length&&(s.state=a)}const o=this.parseUrl(e.url);this.scheduleNavigation(o,r,i,s)},0)}))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}triggerEvent(e){this.events.next(e)}resetConfig(e){this.config=e.map(cS),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,r={}){const{relativeTo:s,queryParams:i,fragment:o,queryParamsHandling:a,preserveFragment:l}=r,c=s||this.routerState.root,u=l?this.currentUrlTree.fragment:o;let d=null;switch(a){case"merge":d={...this.currentUrlTree.queryParams,...i};break;case"preserve":d=this.currentUrlTree.queryParams;break;default:d=i||null}return null!==d&&(d=this.removeEmptyProps(d)),kJ(c,this.currentUrlTree,e,d,u??null)}navigateByUrl(e,r={skipLocationChange:!1}){const s=lc(e)?e:this.parseUrl(e),i=this.urlHandlingStrategy.merge(s,this.rawUrlTree);return this.scheduleNavigation(i,"imperative",null,r)}navigate(e,r={skipLocationChange:!1}){return function dte(n){for(let t=0;t<n.length;t++){if(null==n[t])throw new te(4008,!1)}}(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let r;try{r=this.urlSerializer.parse(e)}catch(s){r=this.malformedUriErrorHandler(s,this.urlSerializer,e)}return r}isActive(e,r){let s;if(s=!0===r?{...lte}:!1===r?{...cte}:r,lc(e))return xP(this.currentUrlTree,e,s);const i=this.parseUrl(e);return xP(this.currentUrlTree,i,s)}removeEmptyProps(e){return Object.keys(e).reduce((r,s)=>{const i=e[s];return null!=i&&(r[s]=i),r},{})}processNavigations(){this.navigations.subscribe(e=>{this.navigated=!0,this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId,this.events.next(new cc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.getCurrentNavigation(),this.titleStrategy?.updateTitle(this.routerState.snapshot),e.resolve(!0)},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)})}scheduleNavigation(e,r,s,i,o){if(this.disposed)return Promise.resolve(!1);let a,l,c;o?(a=o.resolve,l=o.reject,c=o.promise):c=new Promise((h,f)=>{a=h,l=f});const u=++this.navigationId;let d;return"computed"===this.canceledNavigationResolution?(0===this.currentPageId&&(s=this.location.getState()),d=s&&s.\u0275routerPageId?s.\u0275routerPageId:i.replaceUrl||i.skipLocationChange?this.browserPageId??0:(this.browserPageId??0)+1):d=0,this.setTransition({id:u,targetPageId:d,source:r,restoredState:s,currentUrlTree:this.currentUrlTree,rawUrl:e,extras:i,resolve:a,reject:l,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(h=>Promise.reject(h))}setBrowserUrl(e,r){const s=this.urlSerializer.serialize(e),i={...r.extras.state,...this.generateNgRouterState(r.id,r.targetPageId)};this.location.isCurrentPathEqualTo(s)||r.extras.replaceUrl?this.location.replaceState(s,"",i):this.location.go(s,"",i)}restoreHistory(e,r=!1){if("computed"===this.canceledNavigationResolution){const s=this.currentPageId-e.targetPageId;"popstate"!==e.source&&"eager"!==this.urlUpdateStrategy&&this.currentUrlTree!==this.getCurrentNavigation()?.finalUrl||0===s?this.currentUrlTree===this.getCurrentNavigation()?.finalUrl&&0===s&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree()):this.location.historyGo(s)}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}cancelNavigationTransition(e,r,s){const i=new Dy(e.id,this.serializeUrl(e.extractedUrl),r,s);this.triggerEvent(i),e.resolve(!1)}generateNgRouterState(e,r){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}}return n.\u0275fac=function(e){Nh()},n.\u0275prov=we({token:n,factory:function(){return g$()},providedIn:"root"}),n})();class y${}let pte=(()=>{class n{constructor(e,r,s,i,o){this.router=e,this.injector=s,this.preloadingStrategy=i,this.loader=o}setUpPreloading(){this.subscription=this.router.events.pipe(As(e=>e instanceof cc),ja(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,r){const s=[];for(const i of r){i.providers&&!i._injector&&(i._injector=Lg(i.providers,e,`Route: ${i.path}`));const o=i._injector??e,a=i._loadedInjector??o;i.loadChildren&&!i._loadedRoutes&&void 0===i.canLoad||i.loadComponent&&!i._loadedComponent?s.push(this.preloadConfig(o,i)):(i.children||i._loadedRoutes)&&s.push(this.processRoutes(a,i.children??i._loadedRoutes))}return Pn(s).pipe(qc())}preloadConfig(e,r){return this.preloadingStrategy.preload(r,()=>{let s;s=r.loadChildren&&void 0===r.canLoad?this.loader.loadChildren(e,r):Oe(null);const i=s.pipe(Dr(o=>null===o?Oe(void 0):(r._loadedRoutes=o.routes,r._loadedInjector=o.injector,this.processRoutes(o.injector??e,o.routes))));return r.loadComponent&&!r._loadedComponent?Pn([i,this.loader.loadComponent(r)]).pipe(qc()):i})}}return n.\u0275fac=function(e){return new(e||n)(Z(Kr),Z(lC),Z(Ba),Z(y$),Z(pS))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const gS=new me("");let b$=(()=>{class n{constructor(e,r,s,i={}){this.router=e,this.viewportScroller=r,this.zone=s,this.options=i,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},i.scrollPositionRestoration=i.scrollPositionRestoration||"disabled",i.anchorScrolling=i.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(e=>{e instanceof eS?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof cc&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.router.parseUrl(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(e=>{e instanceof PP&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,r){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.router.triggerEvent(new PP(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))})},0)})}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return n.\u0275fac=function(e){Nh()},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();function Ku(n,t){return{\u0275kind:n,\u0275providers:t}}function v$(){const n=Ot(pr);return t=>{const e=n.get(Pu);if(t!==e.components[0])return;const r=n.get(Kr),s=n.get(x$);1===n.get(bS)&&r.initialNavigation(),n.get(w$,null,qe.Optional)?.setUpPreloading(),n.get(gS,null,qe.Optional)?.init(),r.resetRootComponentType(e.componentTypes[0]),s.closed||(s.next(),s.unsubscribe())}}const x$=new me("",{factory:()=>new kt}),bS=new me("",{providedIn:"root",factory:()=>1});const w$=new me("");function _te(n){return Ku(0,[{provide:w$,useExisting:pte},{provide:y$,useExisting:n}])}const C$=new me("ROUTER_FORROOT_GUARD"),vte=[Yg,{provide:EP,useClass:KC},{provide:Kr,useFactory:g$},gf,{provide:Hu,useFactory:function _$(n){return n.routerState.root},deps:[Kr]},pS,[]];function xte(){return new HO("Router",Kr)}let S$=(()=>{class n{constructor(e){}static forRoot(e,r){return{ngModule:n,providers:[vte,[],{provide:Gu,multi:!0,useValue:e},{provide:C$,useFactory:Ete,deps:[[Kr,new La,new fu]]},{provide:Py,useValue:r||{}},r?.useHash?{provide:sc,useClass:I9}:{provide:sc,useClass:f2},{provide:gS,useFactory:()=>{const n=Ot(Kr),t=Ot(HZ),e=Ot(yt),r=Ot(Py);return r.scrollOffset&&t.setOffset(r.scrollOffset),new b$(n,t,e,r)}},r?.preloadingStrategy?_te(r.preloadingStrategy).\u0275providers:[],{provide:HO,multi:!0,useFactory:xte},r?.initialNavigation?Ite(r):[],[{provide:E$,useFactory:v$},{provide:PO,multi:!0,useExisting:E$}]]}}static forChild(e){return{ngModule:n,providers:[{provide:Gu,multi:!0,useValue:e}]}}}return n.\u0275fac=function(e){return new(e||n)(Z(C$,8))},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({imports:[aS]}),n})();function Ete(n){return"guarded"}function Ite(n){return["disabled"===n.initialNavigation?Ku(3,[{provide:Ug,multi:!0,useFactory:()=>{const t=Ot(Kr);return()=>{t.setUpLocationChangeListener()}}},{provide:bS,useValue:2}]).\u0275providers:[],"enabledBlocking"===n.initialNavigation?Ku(2,[{provide:bS,useValue:0},{provide:Ug,multi:!0,deps:[pr],useFactory:t=>{const e=t.get(S9,Promise.resolve());return()=>e.then(()=>new Promise(s=>{const i=t.get(Kr),o=t.get(x$);(function r(s){t.get(Kr).events.pipe(As(o=>o instanceof cc||o instanceof Dy||o instanceof OP),ze(o=>o instanceof cc||o instanceof Dy&&(0===o.code||1===o.code)&&null),As(o=>null!==o),$r(1)).subscribe(()=>{s()})})(()=>{s(!0)}),i.afterPreactivation=()=>(s(!0),o.closed?Oe(void 0):o),i.initialNavigation()}))}}]).\u0275providers:[]]}const E$=new me(""),Tte=[];class $y{static#e=this.\u0275fac=function(e){return new(e||$y)};static#t=this.\u0275mod=Xt({type:$y});static#n=this.\u0275inj=Wt({imports:[S$.forRoot(Tte),S$]})}function I$(n,t,e,r,s,i,o){try{var a=n[i](o),l=a.value}catch(c){return void e(c)}a.done?t(l):Promise.resolve(l).then(r,s)}function ee(n){return function(){var t=this,e=arguments;return new Promise(function(r,s){var i=n.apply(t,e);function o(l){I$(i,r,s,o,a,"next",l)}function a(l){I$(i,r,s,o,a,"throw",l)}o(void 0)})}}class D${constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class _S{refCount(t){return Rs("refCount")}incRef(t){return Rs("incRef")}timerAvailable(){return!0}time(t){return Rs("time")}read(t){return Rs("read")}readSync(t){return Rs("readSync")}readToGPU(t,e){return Rs("readToGPU")}numDataIds(){return Rs("numDataIds")}disposeData(t,e){return Rs("disposeData")}write(t,e,r){return Rs("write")}move(t,e,r,s,i){return Rs("move")}createTensorFromTexture(t,e,r){return Rs("createTensorFromTexture")}memory(){return Rs("memory")}floatPrecision(){return Rs("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Rs("dispose")}}function Rs(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function T$(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,qa(n,t,e)}function uc(n,t,e){return Math.max(n,Math.min(t,e))}function vS(n){return n%2==0?n:n+1}function qa(n,t,e){const r=n[t];n[t]=n[e],n[e]=r}function S(n,t){if(!n)throw new Error("string"==typeof t?t:t())}function Ms(n,t,e=""){S(It(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function Xu(n){S(null!=n,()=>"The input to the tensor constructor must be a non-null value.")}function Yu(n,t=[],e=!1){if(null==t&&(t=[]),Array.isArray(n)||No(n)&&!e)for(let r=0;r<n.length;++r)Yu(n[r],t,e);else t.push(n);return t}function X(n){if(0===n.length)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function It(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function Zu(n){return n%1==0}function xS(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function Qu(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function k$(n,t=(s=>0),e,r){return new Promise((s,i)=>{let o=0;const a=()=>{if(n())return void s();o++;const l=t(o);null!=e&&o>=e?i():null!=r?r(a,l):setTimeout(a,l)};a()})}function N$(n,t){let e=1,r=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)e*=n[i];else if(-1===n[i]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(-1===r){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(0===e)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const s=n.slice();return s[r]=t/e,s}function ft(n,t){const e=t.length;return S((n=null==n?t.map((r,s)=>s):[].concat(n)).every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),S(n.every(r=>Zu(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?e+r:r)}function Ka(n,t){const e=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||s?null:ft(t,n).sort();let o=0;for(let a=0;a<n.length;++a){if(null!=i){if(i[o]===a&&1!==n[a])throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(null==i[o]||i[o]>a)&&1===n[a]&&(e.push(n[a]),r.push(a)),i[o]<=a&&o++}1!==n[a]&&(e.push(n[a]),r.push(a))}return{newShape:e,keptDims:r}}function br(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);e=new Uint8Array(t)}return e}function Kn(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else if("bool"===n)e=new Uint8Array(t);else{if("string"!==n)throw new Error(`Unknown data type ${n}`);e=new Array(t)}return e}function A$(n,t){return!("complex64"===t||"float32"===t&&"complex64"!==n||"int32"===t&&"float32"!==n&&"complex64"!==n||"bool"===t&&"bool"===n)}function No(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function wS(n){if("float32"===n||"int32"===n)return 4;if("complex64"===n)return 8;if("bool"===n)return 1;throw new Error(`Unknown dtype ${n}`)}function Cf(n){return"string"==typeof n||n instanceof String}function CS(n){return"number"==typeof n}function Sf(n){return Array.isArray(n)?Sf(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":CS(n)?"float32":Cf(n)?"string":function Ote(n){return"boolean"==typeof n}(n)?"bool":"float32"}function SS(n){return!!(n&&n.constructor&&n.call&&n.apply)}function ES(n,t){for(let e=t;e<n;++e)if(n%e==0)return e;return n}function Le(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let r=t-3;r>=0;--r)e[r]=e[r+1]*n[r+1];return e}function R$(n,t,e,r=!1){const s=new Array;if(1===t.length){const i=t[0]*(r?2:1);for(let o=0;o<i;o++)s[o]=e[n+o]}else{const i=t[0],o=t.slice(1),a=o.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<i;l++)s[l]=R$(n+l*a,o,e,r)}return s}function ki(n,t,e=!1){if(0===n.length)return t[0];const r=n.reduce((s,i)=>s*i)*(e?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return R$(0,n,t,e)}function IS(n,t){const e=Br(n,t);for(let r=0;r<e.length;r++)e[r]=1;return e}function Br(n,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t)return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function M$(n,t){const e=n.reduce((r,s)=>r*s,1);if(null==t||"float32"===t)return ki(n,new Float32Array(e));if("int32"===t)return ki(n,new Int32Array(e));if("bool"===t)return ki(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function ri(n){n.forEach(t=>{S(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Ao(n,t,e){if(0===t)return 0;if(1===t)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=e[s]*n[s];return r}function Ju(n,t,e){if(0===t)return[];if(1===t)return[n];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/e[s]),n-=r[s]*e[s];return r[r.length-1]=n,r}function ed(n){return n&&n.then&&"function"==typeof n.then}const F$="tfjsflags";class Pte{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=$te,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},null!=this.urlFlags[t]){const s=this.urlFlags[t];G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}getAsync(t){var e=this;return ee(function*(){return t in e.flags||(e.flags[t]=yield e.evaluateFlag(t)),e.flags[t]})()}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(ed(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);F$ in t&&t[F$].split(",").forEach(r=>{const[s,i]=r.split(":");this.urlFlags[s]=function Bte(n,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${n}.`)}(s,i)})}}function $te(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(function Lte(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}(t,r[0],r[1]),r.join("="))),t}function G(){return O$}let DS,O$=null;function P$(){if(null==DS){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");n=self}DS=n}return DS}function TS(n,t){const e=function zte(){const n=P$();return null==n._tfGlobals&&(n._tfGlobals=new Map),n._tfGlobals}();if(e.has(n))return e.get(n);{const r=t();return e.set(n,r),e.get(n)}}const Ly="Abs",Ef="Acos",If="Acosh",td="Add",By="AddN",Vy="ArgMax",zy="ArgMin",Df="Asin",Tf="Asinh",kf="Atan",Nf="Atanh",Af="Atan2",Uy="AvgPool",AS="AvgPoolGrad",Hy="AvgPool3D",RS="AvgPool3DGrad",Wy="BatchMatMul",jy="BatchToSpaceND",MS="Bincount",FS="BroadcastArgs",Rf="Cast",Mf="Ceil",Ff="ClipByValue",OS="Complex",Gy="ComplexAbs",qy="Concat",Ky="Conv2D",PS="Conv2DBackpropFilter",Xy="Conv2DBackpropInput",Yy="Conv3D",$S="Conv3DBackpropFilterV2",LS="Conv3DBackpropInputV2",Of="Cos",Pf="Cosh",BS="Cumprod",Zy="Cumsum",VS="CropAndResize",zS="DenseBincount",US="DepthToSpace",Qy="DepthwiseConv2dNative",HS="DepthwiseConv2dNativeBackpropFilter",WS="DepthwiseConv2dNativeBackpropInput",jS="Diag",Jy="Dilation2D",GS="Dilation2DBackpropInput",qS="Dilation2DBackpropFilter",$f="RealDiv",KS="Einsum",Lf="Elu",XS="EluGrad",Bf="Erf",eb="Equal",Vf="Exp",tb="ExpandDims",zf="Expm1",ZS="Fill",QS="FlipLeftRight",Uf="Floor",Hf="FloorDiv",nb="FusedBatchNorm",rb="GatherV2",JS="GatherNd",sb="Greater",Wf="GreaterEqual",jf="Identity",eE="IFFT",tE="Imag",Gf="IsFinite",qf="IsInf",Kf="IsNan",ib="LeakyRelu",ob="Less",ab="LessEqual",nE="LinSpace",Xf="Log",Yf="Log1p",lb="LogicalAnd",cb="LogicalNot",ub="LogicalOr",db="LRN",rE="LRNGrad",hb="Max",Zf="Maximum",fb="MaxPool",sE="MaxPoolGrad",pb="MaxPool3D",iE="MaxPool3DGrad",oE="MaxPoolWithArgmax",mb="Mean",gb="Min",Qf="Minimum",yb="MirrorPad",Jf="Mod",aE="Multinomial",ep="Multiply",bb="Neg",_b="NotEqual",lE="NonMaxSuppressionV3",cE="NonMaxSuppressionV4",uE="NonMaxSuppressionV5",vb="OnesLike",xb="OneHot",wb="Pack",Cb="PadV2",tp="Pow",Sb="Prelu",Eb="Prod",dE="RaggedGather",hE="RaggedRange",fE="RaggedTensorToTensor",pE="Range",mE="Real",np="Reciprocal",rp="Relu",Ib="Reshape",Db="ResizeNearestNeighbor",gE="ResizeNearestNeighborGrad",Tb="ResizeBilinear",yE="ResizeBilinearGrad",sp="Relu6",kb="Reverse",ip="Round",op="Rsqrt",bE="ScatterNd",_E="SearchSorted",Nb="Select",ap="Selu",Ab="Slice",lp="Sin",cp="Sinh",up="Sign",dp="Sigmoid",hp="Softplus",fp="Sqrt",Rb="Sum",Mb="SpaceToBatchND",Fb="SplitV",Ob="Softmax",vE="SparseFillEmptyRows",xE="SparseReshape",wE="SparseSegmentMean",CE="SparseSegmentSum",SE="SparseToDense",pp="SquaredDifference",EE="Square",IE="StridedSlice",DE="StringNGrams",TE="StringSplit",kE="StringToHashBucketFast",mp="Sub",gp="Tan",yp="Tanh",bp="Tile",NE="TopK",AE="Transform",nd="Transpose",RE="Unique",Pb="Unpack",$b="UnsortedSegmentSum",Lb="ZerosLike",_p="Step",ME="FromPixels",FE="RotateWithOffset",Bb="_FusedMatMul",Vb="FusedConv2D",zb="FusedDepthwiseConv2D";function si(...n){G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(...n)}function Wte(...n){G().getBool("IS_TEST")||G().getBool("PROD")||console.log(...n)}const rd=TS("kernelRegistry",()=>new Map),vp=TS("gradRegistry",()=>new Map);function OE(n,t){const e=LE(n,t);return rd.get(e)}function $$(n){return vp.get(n)}function PE(n){const t=rd.entries(),e=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[i,o]=s,[a]=i.split("_");a===n&&e.push(o)}return e}function $E(n){const{kernelName:t,backendName:e}=n,r=LE(t,e);rd.has(r)&&si(`The kernel '${t}' for backend '${e}' is already registered`),rd.set(r,n)}function jte(n){const{kernelName:t}=n;vp.has(t)&&G().getBool("DEBUG")&&si(`Overriding the gradient for '${t}'`),vp.set(t,n)}function LE(n,t){return`${t}_${n}`}var L$=Q(658);const dc=Q.n(L$)()||L$;function Ub(n){return dc.fromString(n,!0,16)}const B$=Ub("c3a5c85c97cb3127"),hc=Ub("b492b66fbe98f273"),Xr=Ub("9ae16a3b2f90404f");function BE(n){return n.xor(n.shru(47))}function V$(n,t,e){const r=n.slice(t,t+e);return dc.fromBytes(Array.from(r),!0,!0)}function rn(n,t){return V$(n,t,8)}function z$(n,t){return V$(n,t,4)}function _r(n,t){return 0===t?n:n.shru(t).or(n.shl(64-t))}function Xa(n,t,e=Ub("9ddfea08eb382d69")){let r=n.xor(t).mul(e);r=r.xor(r.shru(47));let s=t.xor(r).mul(e);return s=s.xor(s.shru(47)),s=s.mul(e),s}function Hb(n,t,e,r){return function qte(n,t,e,r,s,i){s=s.add(n),i=_r(i.add(s).add(r),21);const o=s;return s=(s=s.add(t)).add(e),i=i.add(_r(s,44)),[s.add(r),i.add(o)]}(rn(n,t),rn(n,t+8),rn(n,t+16),rn(n,t+24),e,r)}function Zte(n,t=n.length){const e=dc.fromNumber(81,!0);if(t<=32)return t<=16?function Kte(n,t=n.length){if(t>=8){const e=Xr.add(2*t),r=rn(n,0).add(Xr),s=rn(n,t-8);return Xa(_r(s,37).mul(e).add(r),_r(r,25).add(s).mul(e),e)}if(t>=4){const e=Xr.add(2*t);return Xa(z$(n,0).shl(3).add(t),z$(n,t-4),e)}if(t>0){const o=t+(n[t-1]<<2);return BE(Xr.mul(n[0]+(n[t>>1]<<8)).xor(B$.mul(o))).mul(Xr)}return Xr}(n,t):function Xte(n,t=n.length){const e=Xr.add(2*t),r=rn(n,0).mul(hc),s=rn(n,8),i=rn(n,t-8).mul(e),o=rn(n,t-16).mul(Xr);return Xa(_r(r.add(s),43).add(_r(i,30)).add(o),r.add(_r(s.add(Xr),18)).add(i),e)}(n,t);if(t<=64)return function Yte(n,t=n.length){const e=Xr.add(2*t),r=rn(n,0).mul(Xr),s=rn(n,8),i=rn(n,t-8).mul(e),o=rn(n,t-16).mul(Xr),a=_r(r.add(s),43).add(_r(i,30)).add(o),l=Xa(a,r.add(_r(s.add(Xr),18)).add(i),e),c=rn(n,16).mul(e),u=rn(n,24),d=a.add(rn(n,t-32)).mul(e),h=l.add(rn(n,t-24)).mul(e);return Xa(_r(c.add(u),43).add(_r(d,30)).add(h),c.add(_r(u.add(r),18)).add(d),e)}(n,t);let r=e,s=e.mul(hc).add(113),i=BE(s.mul(Xr).add(113)).mul(Xr),o=[dc.UZERO,dc.UZERO],a=[dc.UZERO,dc.UZERO];r=r.mul(Xr).add(rn(n,0));let l=0;const c=64*(t-1>>6),u=c+(t-1&63)-63;do{r=_r(r.add(s).add(o[0]).add(rn(n,l+8)),37).mul(hc),s=_r(s.add(o[1]).add(rn(n,l+48)),42).mul(hc),r=r.xor(a[1]),s=s.add(o[0]).add(rn(n,l+40)),i=_r(i.add(a[0]),33).mul(hc),o=Hb(n,l,o[1].mul(hc),r.add(a[0])),a=Hb(n,l+32,i.add(a[1]),s.add(rn(n,l+16))),[i,r]=[r,i],l+=64}while(l!==c);const d=hc.add(i.and(255).shl(1));return l=u,a[0]=a[0].add(t-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),r=_r(r.add(s).add(o[0]).add(rn(n,l+8)),37).mul(d),s=_r(s.add(o[1]).add(rn(n,l+48)),42).mul(d),r=r.xor(a[1].mul(9)),s=s.add(o[0].mul(9).add(rn(n,l+40))),i=_r(i.add(a[0]),33).mul(d),o=Hb(n,l,o[1].mul(d),r.add(a[0])),a=Hb(n,l+32,i.add(a[1]),s.add(rn(n,l+16))),[i,r]=[r,i],Xa(Xa(o[0],a[0],d).add(BE(s).mul(B$)).add(i),Xa(o[1],a[1],d).add(r),d)}function Ya(n,t){return"string"===t?Za(n):fc([n],t)}function fc(n,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Yu(n)),G().getBool("DEBUG")&&function Rte(n,t){for(let e=0;e<n.length;e++){const r=n[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(n,t),function Qte(n,t){return n instanceof Float32Array&&"float32"===t||n instanceof Int32Array&&"int32"===t||n instanceof Uint8Array&&"bool"===t}(n,t))return n;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t){const e=new Uint8Array(n.length);for(let r=0;r<e.length;++r)0!==Math.round(n[r])&&(e[r]=1);return e}throw new Error(`Unknown data type ${t}`)}function ps(){return G().platform.now()}function Za(n,t="utf-8"){return t=t||"utf-8",G().platform.encode(n,t)}function Qa(n,t="utf-8"){return t=t||"utf-8",G().platform.decode(n,t)}class Jte{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new tne)}profileKernel(t,e,r){let s;const i=()=>{s=r()};let o;const a=ps();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of s)c.dataSync();o=Promise.resolve({kernelMs:ps()-a})}if(G().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const u=s[c];u.data().then(d=>{ene(d,u.dtype,t)})}return{kernelName:t,outputs:s,inputs:e,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>null!=c.getExtraProfileInfo?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:r,timeMs:s,inputs:i,extraInfo:o}=t;r.forEach(a=>{Promise.all([a.data(),s,o]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],i,l[2])})})}}function ene(n,t,e){if("float32"!==t)return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${e}'`),!0}return!1}class tne{logKernelProfile(t,e,r,s,i,o){const a="number"==typeof s?Qu(`${s}ms`,9):s.error,l=Qu(t,25),c=e.rank,u=e.size,d=Qu(e.shape.toString(),14);let h="";for(const f in i){const p=i[f];if(null!=p){const m=p.shape||e.shape,g=m.length;h+=`${f}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}\t%c${a}\t%c${c}D ${d}\t%c${u}\t%c${h}\t%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function sne(n,t,e,r){const s=Le(t),i=function ine(n,t,e,r){const s=X(t),i=r[r.length-1],o=new Array(i).fill(0),a=t.length,l="complex64"===e?Cp(n):n;if(a>1)for(let c=0;c<s/i;c++){const u=c*i;for(let d=0;d<i;d++)o[d]=Math.max(o[d],wp(l[u+d],0,e).length)}return o}(n,t,e,s),o=t.length,a=Wb(n,t,e,s,i),l=["Tensor"];return r&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join("\n")),l.join("\n")}function wp(n,t,e){let r;return r=Array.isArray(n)?`${parseFloat(n[0].toFixed(7))} + ${parseFloat(n[1].toFixed(7))}j`:Cf(n)?`'${n}'`:"bool"===e?H$(n):parseFloat(n.toFixed(7)).toString(),Qu(r,t)}function H$(n){return 0===n?"false":"true"}function Wb(n,t,e,r,s,i=!0){const o="complex64"===e?2:1,a=t[0],l=t.length;if(0===l)return"complex64"===e?[wp(Cp(n)[0],0,e)]:"bool"===e?[H$(n[0])]:[n[0].toString()];if(1===l){if(a>20){let y=Array.from(n.slice(0,3*o)),b=Array.from(n.slice((a-3)*o,a*o));return"complex64"===e&&(y=Cp(y),b=Cp(b)),["["+y.map((_,v)=>wp(_,s[v],e)).join(", ")+", ..., "+b.map((_,v)=>wp(_,s[a-3+v],e)).join(", ")+"]"]}return["["+("complex64"===e?Cp(n):Array.from(n)).map((g,y)=>wp(g,s[y],e)).join(", ")+"]"]}const c=t.slice(1),u=r.slice(1),d=r[0]*o,h=[];if(a>20){for(let m=0;m<3;m++){const g=m*d;h.push(...Wb(n.slice(g,g+d),c,e,u,s,!1))}h.push("...");for(let m=a-3;m<a;m++){const g=m*d;h.push(...Wb(n.slice(g,g+d),c,e,u,s,m===a-1))}}else for(let m=0;m<a;m++){const g=m*d;h.push(...Wb(n.slice(g,g+d),c,e,u,s,m===a-1))}const f=2===l?",":"";h[0]="["+h[0]+f;for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+f;let p=",\n";for(let m=2;m<l;m++)p+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(i?"":p),h}function Cp(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class vr{constructor(t,e,r){if(this.dtype=e,this.shape=t.slice(),this.size=X(t),null!=r){const s=r.length;S(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Kn(e,this.size),this.strides=Le(t)}set(t,...e){0===e.length&&(e=[0]),S(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const r=this.locToIndex(e);this.values[r]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const s of t){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return oo().makeTensor(this.values,this.shape,this.dtype)}}let oo=null,sd=null,W$=null;class pn{constructor(t,e,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=X(t),this.strides=Le(t),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var t=this;return ee(function*(){const e=yield t.data();return sd.buffer(t.shape,t.dtype,e)})()}bufferSync(){return sd.buffer(this.shape,this.dtype,this.dataSync())}array(){var t=this;return ee(function*(){const e=yield t.data();return ki(t.shape,e,"complex64"===t.dtype)})()}arraySync(){return ki(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var t=this;return ee(function*(){t.throwIfDisposed();const e=oo().read(t.dataId);if("string"===t.dtype){const r=yield e;try{return r.map(s=>Qa(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataToGPU(t){return this.throwIfDisposed(),oo().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=oo().readSync(this.dataId);if("string"===this.dtype)try{return t.map(e=>Qa(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){var t=this;return ee(function*(){t.throwIfDisposed();const e=yield oo().read(t.dataId);return"string"===t.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(oo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return sd.print(this,t)}clone(){return this.throwIfDisposed(),sd.clone(this)}toString(t=!1){return sne(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),sd.cast(this,t)}variable(t=!0,e,r){return this.throwIfDisposed(),oo().makeVariable(this,t,e,r)}}function Y(){return TS("Tensor",()=>pn)}Object.defineProperty(pn,Symbol.hasInstance,{value:n=>!!n&&null!=n.data&&null!=n.dataSync&&null!=n.throwIfDisposed}),Y();class jb extends pn{constructor(t,e,r,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=e,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!It(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);oo().disposeTensor(this),this.dataId=t.dataId,oo().incRef(this,null)}dispose(){oo().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(jb,Symbol.hasInstance,{value:n=>n instanceof pn&&null!=n.assign&&n.assign instanceof Function});var Gb=(()=>{return(n=Gb||(Gb={})).float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64",Gb;var n})(),qb=(()=>{return(n=qb||(qb={})).float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64",qb;var n})(),Kb=(()=>{return(n=Kb||(Kb={})).float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64",Kb;var n})(),Xb=(()=>{return(n=Xb||(Xb={})).float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64",Xb;var n})();const cne={float32:Kb,int32:Gb,bool:qb,complex64:Xb};function Fs(n,t){if("string"===n||"string"===t){if("string"===n&&"string"===t)return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return cne[n][t]}function zE(n){return Fs(n,"int32")}function An(n,t){if(n.dtype===t.dtype)return[n,t];const e=Fs(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function j$(n){const t=[];return G$(n,t,new Set),t}function G$(n,t,e){if(null==n)return;if(n instanceof pn)return void t.push(n);if(!function dne(n){return Array.isArray(n)||"object"==typeof n}(n))return;const r=n;for(const s in r){const i=r[s];e.has(i)||(e.add(i),G$(i,t,e))}}function UE(n){return null!=n.kernelName}class q${constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}let hne=(()=>{class n{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new q$}ready(){var e=this;return ee(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const r=e.getSortedBackends();for(let s=0;s<r.length;s++){const i=r[s];if(yield e.initializeBackend(i).success)return void(yield e.setBackend(i))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:r}=this.initializeBackend(e);if(r)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,s=1){return e in this.registryFactory?(si(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:s},!0)}setBackend(e){var r=this;return ee(function*(){if(null==r.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(r.backendName=e,null==r.registry[e]){r.backendInstance=null;const{success:s,asyncInit:i}=r.initializeBackend(e);if(!(i?yield s:s))return!1}return r.backendInstance=r.registry[e],r.setupRegisteredKernels(),r.profiler=new Jte(r.backendInstance),!0})()}setupRegisteredKernels(){PE(this.backendName).forEach(r=>{null!=r.setupFunc&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){PE(e).forEach(s=>{null!=s.disposeFunc&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const r=this.registryFactory[e];if(null==r)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=r.factory();if(!s||s instanceof _S||"function"!=typeof s.then)return this.registry[e]=s,{success:!0,asyncInit:!1};{const i=++this.pendingBackendInitId,o=s.then(a=>!(i<this.pendingBackendInitId||(this.registry[e]=a,this.pendingBackendInit=null,0))).catch(a=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,si(`Initialization of backend ${e} failed`),si(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}}catch(s){return si(`Initialization of backend ${e} failed`),si(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let r=0;r<e.length;r++){const s=e[r],{success:i,asyncInit:o}=this.initializeBackend(s);if(o||i)return{name:s,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){const s=this.state.tensorInfo.get(r),i=s.backend,o=this.readSync(r),a=i.refCount(r);i.disposeData(r,!0),s.backend=e,e.move(r,o,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let i,s=null;if(null==r){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");r=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof r)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(i),()=>(i=r(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,r,s){e();try{const i=s();return r(),i}catch(i){throw r(),i}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(e){const r=R.runKernel(jf,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[r],a=>({x:()=>R.runKernel(Rf,{x:a},{dtype:"float32"})}),[],{}),r}runKernel(e,r,s){if(null==OE(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,s){const i=this.backend.numDataIds();let o=0;s.forEach(c=>{o+="complex64"===c.dtype?3:1});const l=i-r-o-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let r,s=[];const i=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;let l,c;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const u=UE(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(UE(e)){const{kernelName:m,inputs:g,attrs:y}=e,b=OE(m,this.backendName);S(null!=b,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),l=()=>{const _=this.backend.numDataIds();c=b.kernelFunc({inputs:g,attrs:y,backend:this.backend});const v=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,_,v);const w=v.map(C=>null!=C.rank?C:this.makeTensorFromTensorInfo(C));if(i){const C=this.getTensorsForGradient(m,g,w);s=this.saveTensorsForBackwardMode(C)}return w}}else{const{forwardFunc:m}=e,g=y=>{!i||(s=y.map(b=>this.keep(this.clone(b))))};l=()=>{const y=this.backend.numDataIds();c=this.tidy(()=>m(this.backend,g));const b=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,y,b),b}}const{inputs:d,attrs:h}=e,f=UE(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(u,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),r=p.outputs):r=l()}),i&&this.addTapeNode(u,d,r,f,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(m=>null!=d[m]?d[m].shape:null),outputShapes:r.map(m=>m.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(c)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,r,s){const i=$$(e);if(null!=i){const o=i.inputsToSave||[],a=i.outputsToSave||[];let l;i.saveAllInputs?(S(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(r).map(u=>r[u])):l=o.map(u=>r[u]);const c=s.filter((u,d)=>a[d]);return l.concat(c)}return[]}makeTensor(e,r,s,i){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");i=i||this.backend;let o=e;"string"===(s=s||"float32")&&Cf(e[0])&&(o=e.map(c=>Za(c)));const a=i.write(o,r,s),l=new pn(r,s,a,this.nextTensorId());if(this.trackTensor(l,i),"string"===s){const c=this.state.tensorInfo.get(a),u=function Fte(n){if(null==n)return 0;let t=0;return n.forEach(e=>t+=e.length),t}(o);this.state.numBytes+=u-c.bytes,c.bytes=u}return l}makeTensorFromDataId(e,r,s,i){return this.makeTensorFromTensorInfo({dataId:e,shape:r,dtype:s=s||"float32"},i)}makeTensorFromTensorInfo(e,r){const{dataId:s,shape:i,dtype:o}=e,a=new pn(i,o,s,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(e,r=!0,s,i){s=s||this.nextVariableId().toString(),null!=i&&i!==e.dtype&&(e=e.cast(i));const o=new jb(e,r,s,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,r){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let s=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(s=e.size*wS(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof jb||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const s=e.size*wS(e.dtype);this.state.numBytes-=s}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var r=this;return ee(function*(){r.state.profiling=!0;const s=r.state.numBytes,i=r.state.numTensors;r.state.activeProfile.kernels=[],r.state.activeProfile.result=yield e(),r.state.profiling=!1,r.state.activeProfile.peakBytes=Math.max(...r.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),r.state.activeProfile.newBytes=r.state.numBytes-s,r.state.activeProfile.newTensors=r.state.numTensors-i;for(const o of r.state.activeProfile.kernels)o.kernelTimeMs=yield o.kernelTimeMs,o.extraInfo=yield o.extraInfo;return r.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,r,s,i,o,a){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:s,saved:o},c=$$(e);null!=c&&(i=c.gradFunc),null!=i&&(l.gradient=u=>(u=u.map((d,h)=>{if(null==d){const f=s[h],p=Br(f.size,f.dtype);return this.makeTensor(p,f.shape,f.dtype)}return d}),i(u.length>1?u:u[0],o,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){const r=j$(e),s=new Set(r.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const a=this.state.activeScope.track[o];!a.kept&&!s.has(a.id)&&a.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(o=>{!o.kept&&o.scopeId===i.id&&this.track(o)})}gradients(e,r,s,i=!1){if(S(r.length>0,()=>"gradients() received an empty list of xs."),null!=s&&"float32"!==s.dtype)throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));S(o instanceof pn,()=>"The result y returned by f() must be a tensor.");const a=function nne(n,t,e){const r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const d in u){const h=u[d];let f=!1;for(let p=0;p<t.length;p++)if(r[h.id]){c.outputs.forEach(m=>r[m.id]=!0),f=!0,s[c.id]=!0;break}if(f)break}}const i={};i[e.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let d=0;d<c.outputs.length;d++)if(i[c.outputs[d].id]){for(const h in u)i[u[h].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(s[c.id]&&o[c.id]){const u={};for(const h in c.inputs){const f=c.inputs[h];r[f.id]&&(u[h]=f)}const d=Object.assign({},c);d.inputs=u,d.outputs=c.outputs,a.push(d)}}return a}(this.state.activeTape,r,o);if(!i&&0===a.length&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[o.id]=s??function fne(n){const t=IS(X(n),"float32");return R.makeTensor(t,n,"float32")}(o.shape),function rne(n,t,e,r){for(let s=t.length-1;s>=0;s--){const i=t[s],o=[];if(i.outputs.forEach(l=>{const c=n[l.id];o.push(null!=c?c:null)}),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=e(()=>a[l]());if("float32"!==c.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=i.inputs[l];if(!It(c.shape,u.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(null==n[u.id])n[u.id]=c;else{const d=n[u.id];n[u.id]=r(d,c),d.dispose()}}}}(l,a,u=>this.tidy(u),pne);const c=r.map(u=>l[u.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(u=>{for(const d of u.saved)d.dispose()}),this.state.activeTape=null),{value:o,grads:c}})}customGrad(e){return S(SS(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{let s;S(r.every(l=>l instanceof pn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const i={};return r.forEach((l,c)=>{i[c]=l}),this.runKernelFunc({forwardFunc:(l,c)=>(s=e(...r,c),S(s.value instanceof pn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),S(SS(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),backwardsFunc:(l,c)=>{const u=s.gradFunc(l,c),d=Array.isArray(u)?u:[u];S(d.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),S(d.every(f=>f instanceof pn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return d.forEach((f,p)=>{h[p]=()=>f}),h},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,r){return this.state.tensorInfo.get(e).backend.readToGPU(e,r)}time(e){var r=this;return ee(function*(){const s=ps(),i=yield r.backend.time(e);return i.wallMs=ps()-s,i})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new q$;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();function K$(){const n=P$();if(null==n._tfengine){const t=new Pte(n);n._tfengine=new hne(t)}return function Vte(n){O$=n}(n._tfengine.ENV),function one(n){oo=n}(()=>n._tfengine),n._tfengine}const R=K$();function pne(n,t){return R.runKernel(td,{a:n,b:t})}function X$(n){if(n||function mne(){return typeof navigator<"u"&&null!=navigator}()){if(n||(n=navigator),"ReactNative"===n.product)return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Y$(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}const ii=G();function Ja(n,t){let e=n;if(No(n))return"string"===t?[]:[n.length];if("object"==typeof n&&"texture"in n)return[n.height,n.width*(n.channels||"RGBA").length];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(e)||No(e)&&"string"!==t;)r.push(e.length),e=e[0];return Array.isArray(n)&&G().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Z$(n,r,[]),r}function Z$(n,t,e){if(e=e||[],!Array.isArray(n)&&!No(n))return void S(0===t.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);S(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),S(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const r=t.slice(1);for(let s=0;s<n.length;++s)Z$(n[s],r,e.concat(s))}function Q$(n,t,e,r){if("string_or_numeric"!==n){if(null==n)throw new Error("Expected dtype cannot be null.");if("numeric"!==n&&n!==t||"numeric"===n&&"string"===t)throw new Error(`Argument '${e}' passed to '${r}' must be ${n} tensor, but got ${t} tensor`)}}function E(n,t,e,r="numeric"){if(n instanceof pn)return Q$(r,n.dtype,t,e),n;let s=Sf(n);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Q$(r,s,t,e),null==n||!No(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==n?"null":n.constructor.name}'`);const i=Ja(n,s);!No(n)&&!Array.isArray(n)&&(n=[n]);const a="string"!==s?fc(n,s):Yu(n,[],!0);return R.makeTensor(a,i,s)}function Yb(n,t,e,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>E(i,`${t}[${o}]`,e,r))}ii.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),ii.registerFlag("IS_BROWSER",()=>Y$()),ii.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),ii.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),ii.registerFlag("PROD",()=>!1),ii.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ii.getBool("DEBUG")),ii.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),ii.registerFlag("IS_TEST",()=>!1),ii.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),ii.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),ii.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),ii.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const J$="__op";function A(n){const t=Object.keys(n);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const r=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+=J$;const s=(...i)=>{R.startScope(e);try{const o=r(...i);return ed(o)&&console.error("Cannot return a Promise inside of tidy."),R.endScope(o),o}catch(o){throw R.endScope(null),o}};return Object.defineProperty(s,"name",{value:e,configurable:!0}),s}const el=A({complex_:function gne(n,t){const e=E(n,"real","complex"),r=E(t,"imag","complex");return Ms(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`),R.runKernel(OS,{real:e,imag:r})}});function tl(n,t,e,r){if(null==r&&(r=Sf(n)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if("object"==typeof n&&"texture"in n){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from texture only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return n.channels=n.channels||"RGBA",R.backend.createTensorFromTexture(n,t||e,r)}if(!No(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){ri(t);const s=X(t),i=X(e);S(s===i,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${i}`);for(let o=0;o<e.length;++o){const a=e[o],l=o!==e.length-1||a!==X(t.slice(o));S(e[o]===t[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!No(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n="string"!==r?fc(n,r):Yu(n,[],!0),R.makeTensor(n,t,r)}function ao(n,t,e){return tl(n,t,Ja(n,e),e)}const WE={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};function jE(n,t){return GE.apply(this,arguments)}function GE(){return GE=ee(function*(n,t){const e=[],r=[],s=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<s.length;++o){const a=s[o],l=Array.isArray(n)?n[o].tensor:n[a];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const u=new Promise(function(){var d=ee(function*(h){const f=yield l.bytes(),p=f.reduce((y,b)=>y+b.length,0)+4*f.length,m=new Uint8Array(p);let g=0;for(let y=0;y<f.length;y++){const b=f[y],_=new Uint8Array(new Uint32Array([b.length]).buffer);m.set(_,g),g+=4,m.set(b,g),g+=b.length}h(m)});return function(h){return d.apply(this,arguments)}}());r.push(u)}else r.push(l.data());null!=t&&(c.group=t),e.push(c)}return{data:yne(yield Promise.all(r)),specs:e}}),GE.apply(this,arguments)}function eL(n,t){const e={};let r,s=0;for(const i of t){const o=i.name,a=i.dtype,l=i.shape,c=X(l);let u;if("quantization"in i){const d=i.quantization;if("uint8"===d.dtype||"uint16"===d.dtype){if(!("min"in d)||!("scale"in d))throw new Error(`Weight ${i.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==d.dtype)throw new Error(`Weight ${i.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${i.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${a}.`)}const h=WE[d.dtype],f=n.slice(s,s+c*h),p="uint8"===d.dtype?new Uint8Array(f):new Uint16Array(f);if("float32"===a)if("uint8"===d.dtype||"uint16"===d.dtype){u=new Float32Array(p.length);for(let m=0;m<p.length;m++)u[m]=p[m]*d.scale+d.min}else{if("float16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);void 0===r&&(r=Cne()),u=r(p)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${o}': ${a}`);if("uint8"!==d.dtype&&"uint16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);u=new Int32Array(p.length);for(let m=0;m<p.length;m++)u[m]=Math.round(p[m]*d.scale+d.min)}s+=c*h}else if("string"===a){const d=X(i.shape);u=[];for(let h=0;h<d;h++){const f=new Uint32Array(n.slice(s,s+4))[0];s+=4;const p=new Uint8Array(n.slice(s,s+f));u.push(p),s+=f}}else{const d=WE[a],h=n.slice(s,s+c*d);if("float32"===a)u=new Float32Array(h);else if("int32"===a)u=new Int32Array(h);else if("bool"===a)u=new Uint8Array(h);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${o}': ${a}`);{u=new Float32Array(h);const f=new Float32Array(u.length/2),p=new Float32Array(u.length/2);for(let y=0;y<f.length;y++)f[y]=u[2*y],p[y]=u[2*y+1];const m=ao(f,l,"float32"),g=ao(p,l,"float32");e[o]=el(m,g),m.dispose(),g.dispose()}}s+=c*d}"complex64"!==a&&(e[o]=ao(u,l,a))}return e}function yne(n){if(null===n)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(i=>{if(t+=i.byteLength,e.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const r=new Uint8Array(t);let s=0;return e.forEach(i=>{r.set(new Uint8Array(i.buffer),s),s+=i.byteLength}),r.buffer}const qE=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function tL(n){return qE?Buffer.byteLength(n):new Blob([n]).size}function Qb(n){if(1===n.length)return n[0];let t=0;n.forEach(s=>{t+=s.byteLength});const e=new Uint8Array(t);let r=0;return n.forEach(s=>{e.set(new Uint8Array(s),r),r+=s.byteLength}),e.buffer}function nL(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const e=n.split("/");return e[e.length-1]}function rL(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return null!=n.signature&&(e.signature=n.signature),null!=n.userDefinedMetadata&&(e.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(e.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(e.initializerSignature=n.initializerSignature),null!=n.trainingConfig&&(e.trainingConfig=n.trainingConfig),e}function sL(n,t,e){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(null!=n.trainingConfig&&(r.trainingConfig=n.trainingConfig),null!=n.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=e}return null!=n.signature&&(r.signature=n.signature),null!=n.userDefinedMetadata&&(r.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(r.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(r.initializerSignature=n.initializerSignature),r}function KE(n,t){return XE.apply(this,arguments)}function XE(){return(XE=ee(function*(n,t){let e,r;return null!=n.weightsManifest&&([e,r]=yield t(n.weightsManifest)),sL(n,e,r)})).apply(this,arguments)}function Sp(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==n.modelTopology?0:tL(JSON.stringify(n.modelTopology)),weightSpecsBytes:null==n.weightSpecs?0:tL(JSON.stringify(n.weightSpecs)),weightDataBytes:null==n.weightData?0:n.weightData.byteLength}}function iL(n){const t=[];for(const e of n)t.push(...e.weights);return t}function Cne(){const n=function vne(){const n=e=>{let r=e<<13,s=0;for(;0==(8388608&r);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function xne(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}(),e=function wne(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}();return r=>{const s=new ArrayBuffer(4*r.length),i=new Uint32Array(s);for(let o=0;o<r.length;o++){const a=r[o];i[o]=n[e[a>>10]+(1023&a)]+t[a>>10]}return new Float32Array(s)}}class In{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==In.instance&&(In.instance=new In),In.instance}static registerSaveRouter(t){In.getInstance().saveRouters.push(t)}static registerLoadRouter(t){In.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return In.getHandlers(t,"save")}static getLoadHandlers(t,e){return In.getHandlers(t,"load",e)}static getHandlers(t,e,r){const s=[];return("load"===e?In.getInstance().loadRouters:In.getInstance().saveRouters).forEach(o=>{const a=o(t,r);null!==a&&s.push(a)}),s}}const Sne=n=>In.registerSaveRouter(n),Ene=n=>In.registerLoadRouter(n),oL=n=>In.getSaveHandlers(n),Ine=(n,t)=>In.getLoadHandlers(n,t),Jb="tensorflowjs",pc="models_store",nl="model_info_store";function QE(){if(!G().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function JE(n){const t=n.result;t.createObjectStore(pc,{keyPath:"modelPath"}),t.createObjectStore(nl,{keyPath:"modelPath"})}let id=(()=>{class n{constructor(e){if(this.indexedDB=QE(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var r=this;return ee(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return r.databaseAction(r.modelPath,e)})()}load(){var e=this;return ee(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,r){return new Promise((s,i)=>{const o=this.indexedDB.open(Jb,1);o.onupgradeneeded=()=>JE(o),o.onsuccess=()=>{const a=o.result;if(null==r){const l=a.transaction(pc,"readonly"),u=l.objectStore(pc).get(this.modelPath);u.onsuccess=()=>{if(null==u.result)return a.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(u.result.modelArtifacts)},u.onerror=d=>(a.close(),i(u.error)),l.oncomplete=()=>a.close()}else{const l=Sp(r),c=a.transaction(nl,"readwrite");let u=c.objectStore(nl);const d=u.put({modelPath:this.modelPath,modelArtifactsInfo:l});let h;d.onsuccess=()=>{h=a.transaction(pc,"readwrite");const p=h.objectStore(pc).put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l});p.onsuccess=()=>s({modelArtifactsInfo:l}),p.onerror=m=>{u=c.objectStore(nl);const g=u.delete(this.modelPath);g.onsuccess=()=>(a.close(),i(p.error)),g.onerror=y=>(a.close(),i(p.error))}},d.onerror=f=>(a.close(),i(d.error)),c.oncomplete=()=>{null==h?a.close():h.oncomplete=()=>a.close()}}},o.onerror=a=>i(o.error)})}}return n.URL_SCHEME="indexeddb://",n})();const aL=n=>G().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(id.URL_SCHEME)?function Dne(n){return new id(n)}(n.slice(id.URL_SCHEME.length)):null;In.registerSaveRouter(aL),In.registerLoadRouter(aL);class kne{constructor(){this.indexedDB=QE()}listModels(){var t=this;return ee(function*(){return new Promise((e,r)=>{const s=t.indexedDB.open(Jb,1);s.onupgradeneeded=()=>JE(s),s.onsuccess=()=>{const i=s.result,o=i.transaction(nl,"readonly"),l=o.objectStore(nl).getAll();l.onsuccess=()=>{const c={};for(const u of l.result)c[u.modelPath]=u.modelArtifactsInfo;e(c)},l.onerror=c=>(i.close(),r(l.error)),o.oncomplete=()=>i.close()},s.onerror=i=>r(s.error)})})()}removeModel(t){var e=this;return ee(function*(){return t=function Tne(n){return n.startsWith(id.URL_SCHEME)?n.slice(id.URL_SCHEME.length):n}(t),new Promise((r,s)=>{const i=e.indexedDB.open(Jb,1);i.onupgradeneeded=()=>JE(i),i.onsuccess=()=>{const o=i.result,a=o.transaction(nl,"readwrite"),l=a.objectStore(nl),c=l.get(t);let u;c.onsuccess=()=>{if(null==c.result)return o.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const d=l.delete(t),h=()=>{u=o.transaction(pc,"readwrite");const p=u.objectStore(pc).delete(t);p.onsuccess=()=>r(c.result.modelArtifactsInfo),p.onerror=m=>s(c.error)};d.onsuccess=h,d.onerror=f=>(h(),o.close(),s(c.error))}},c.onerror=d=>(o.close(),s(c.error)),a.oncomplete=()=>{null==u?o.close():u.oncomplete=()=>o.close()}},i.onerror=o=>s(i.error)})})()}}const Ro="/",mc="tensorflowjs_models",lL="info",Nne="model_topology",Ane="weight_specs",Rne="weight_data",Mne="model_metadata";function cL(n){return{info:[mc,n,lL].join(Ro),topology:[mc,n,Nne].join(Ro),weightSpecs:[mc,n,Ane].join(Ro),weightData:[mc,n,Rne].join(Ro),modelMetadata:[mc,n,Mne].join(Ro)}}function uL(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function dL(n){const t=n.split(Ro);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Ro)}let od=(()=>{class n{constructor(e){if(!G().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=cL(this.modelPath)}save(e){var r=this;return ee(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(e.modelTopology),i=JSON.stringify(e.weightSpecs),o=Sp(e);try{return r.LS.setItem(r.keys.info,JSON.stringify(o)),r.LS.setItem(r.keys.topology,s),r.LS.setItem(r.keys.weightSpecs,i),r.LS.setItem(r.keys.weightData,function bne(n){if(qE)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let r=0,s=t.length;r<s;r++)e+=String.fromCharCode(t[r]);return btoa(e)}(e.weightData)),r.LS.setItem(r.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0})),{modelArtifactsInfo:o}}catch{throw uL(r.keys),new Error(`Failed to save model '${r.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}})()}load(){var e=this;return ee(function*(){const r=JSON.parse(e.LS.getItem(e.keys.info));if(null==r)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==r.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const s={},i=JSON.parse(e.LS.getItem(e.keys.topology));if(null==i)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);s.modelTopology=i;const o=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==o)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);s.weightSpecs=o;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const c=JSON.parse(a);s.format=c.format,s.generatedBy=c.generatedBy,s.convertedBy=c.convertedBy,null!=c.signature&&(s.signature=c.signature),null!=c.userDefinedMetadata&&(s.userDefinedMetadata=c.userDefinedMetadata),null!=c.modelInitializer&&(s.modelInitializer=c.modelInitializer),null!=c.initializerSignature&&(s.initializerSignature=c.initializerSignature),null!=c.trainingConfig&&(s.trainingConfig=c.trainingConfig)}const l=e.LS.getItem(e.keys.weightData);if(null==l)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return s.weightData=function _ne(n){if(qE){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let r=0;r<t.length;++r)e.set([t.charCodeAt(r)],r);return e.buffer}(l),s})()}}return n.URL_SCHEME="localstorage://",n})();const hL=n=>G().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(od.URL_SCHEME)?function One(n){return new od(n)}(n.slice(od.URL_SCHEME.length)):null;In.registerSaveRouter(hL),In.registerLoadRouter(hL);class Pne{constructor(){S(G().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),S(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var t=this;return ee(function*(){const e={},r=mc+Ro,s=Ro+lL;for(let i=0;i<t.LS.length;++i){const o=t.LS.key(i);o.startsWith(r)&&o.endsWith(s)&&(e[dL(o)]=JSON.parse(t.LS.getItem(o)))}return e})()}removeModel(t){var e=this;return ee(function*(){const r=cL(t=function Fne(n){return n.startsWith(od.URL_SCHEME)?n.slice(od.URL_SCHEME.length):n}(t));if(null==e.LS.getItem(r.info))throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(e.LS.getItem(r.info));return uL(r),s})()}}const ad="://";class Yr{constructor(){this.managers={}}static getInstance(){return null==Yr.instance&&(Yr.instance=new Yr),Yr.instance}static registerManager(t,e){S(null!=t,()=>"scheme must not be undefined or null."),t.endsWith(ad)&&(t=t.slice(0,t.indexOf(ad))),S(t.length>0,()=>"scheme must not be an empty string.");const r=Yr.getInstance();S(null==r.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=e}static getManager(t){const e=Yr.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(Yr.getInstance().managers)}}function e_(n){if(-1===n.indexOf(ad))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Yr.getSchemes().join(",")}`);return{scheme:n.split(ad)[0],path:n.split(ad)[1]}}function fL(n,t){return eI.apply(this,arguments)}function eI(){return(eI=ee(function*(n,t,e=!1){S(n!==t,()=>`Old path and new path are the same: '${n}'`);const r=In.getLoadHandlers(n);S(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),S(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const s=r[0],i=In.getSaveHandlers(t);S(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),S(i.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);const o=i[0],a=e_(n).scheme,l=e_(n).path,c=a===e_(n).scheme,u=yield s.load();e&&c&&(yield Yr.getManager(a).removeModel(l));const d=yield o.save(u);return e&&!c&&(yield Yr.getManager(a).removeModel(l)),d.modelArtifactsInfo})).apply(this,arguments)}function $ne(){return tI.apply(this,arguments)}function tI(){return(tI=ee(function*(){const n=Yr.getSchemes(),t={};for(const e of n){const r=yield Yr.getManager(e).listModels();for(const s in r)t[e+ad+s]=r[s]}return t})).apply(this,arguments)}function Lne(n){return nI.apply(this,arguments)}function nI(){return(nI=ee(function*(n){const t=e_(n);return Yr.getManager(t.scheme).removeModel(t.path)})).apply(this,arguments)}function Bne(n,t){return rI.apply(this,arguments)}function rI(){return(rI=ee(function*(n,t){return fL(n,t,!1)})).apply(this,arguments)}function Vne(n,t){return sI.apply(this,arguments)}function sI(){return(sI=ee(function*(n,t){return fL(n,t,!0)})).apply(this,arguments)}class zne{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){typeof window>"u"||!G().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(t,e):(this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{r.source===window&&r.data.name===this.messageName&&(r.stopPropagation(),(0,this.functionRefs[r.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}}if(G().get("IS_BROWSER")){G().setPlatform("browser",new zne);try{Yr.registerManager(od.URL_SCHEME,new Pne)}catch{}try{Yr.registerManager(id.URL_SCHEME,new kne)}catch{}}let ld;function ot(n,t="float32",e){return t=t||"float32",ri(n),new vr(n,t,e)}G().get("IS_NODE")&&!G().get("IS_BROWSER")&&G().setPlatform("node",new class Hne{constructor(){this.util=Q(628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=G().global.fetch?G().global.fetch(t,e):(null==ld&&(ld=Q(410)),ld(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const ve=A({cast_:function Wne(n,t){const e=E(n,"x","cast");if(!function Mte(n){return"bool"===n||"complex64"===n||"float32"===n||"int32"===n||"string"===n}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==e.dtype||"string"!==t&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return R.runKernel(Rf,{x:e},{dtype:t})}}),ma=A({clone_:function jne(n){const e={x:E(n,"x","clone","string_or_numeric")};return R.runKernel(jf,e)}});function pL(n,t=!1){console.log(n.toString(t))}function mL(n){return new Promise(t=>setTimeout(t)).then(n)}K$(),function ane(n){sd=n}({buffer:ot,cast:ve,clone:ma,print:pL});let iI=(()=>{class n{constructor(e){if(!G().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(n.URL_SCHEME)&&(e=e.slice(n.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var r=this;return ee(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const s=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const o=rL(e,[{paths:["./"+r.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),l=r.modelJsonAnchor??document.createElement("a");if(l.download=r.modelJsonFileName,l.href=a,yield mL(()=>l.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const c=r.weightDataAnchor??document.createElement("a");c.download=r.weightDataFileName,c.href=s,yield mL(()=>c.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Sp(e)}}})()}}return n.URL_SCHEME="downloads://",n})();class Xne{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}load(){var t=this;return ee(function*(){return new Promise((e,r)=>{const s=new FileReader;s.onload=i=>{const o=JSON.parse(i.target.result),a=o.modelTopology;if(null==a)return void r(new Error(`modelTopology field is missing from file ${t.jsonFile.name}`));if(null==o.weightsManifest)return void r(new Error(`weightManifest field is missing from file ${t.jsonFile.name}`));if(0===t.weightsFiles.length)return void e({modelTopology:a});const c=KE(o,u=>t.loadWeights(u));e(c)},s.onerror=i=>r(`Failed to read model topology and weights manifest JSON from file '${t.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(t.jsonFile)})})()}loadWeights(t){const e=[],r=[];for(const o of t)e.push(...o.weights),r.push(...o.paths);const s=this.checkManifestAndWeightFiles(t),i=r.map(o=>this.loadWeightsFile(o,s[o]));return Promise.all(i).then(o=>[e,Qb(o)])}loadWeightsFile(t,e){return new Promise((r,s)=>{const i=new FileReader;i.onload=o=>{r(o.target.result)},i.onerror=o=>s(`Failed to weights data from file of path '${t}'.`),i.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],r=this.weightsFiles.map(i=>nL(i.name)),s={};for(const i of t)i.paths.forEach(o=>{const a=nL(o);if(-1!==e.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),-1===r.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);s[o]=this.weightsFiles[r.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}function Qne(n){return new Xne(n)}function gL(n,t,e,r){(function o(l){S(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(n),function a(l,c){S(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),S(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),S(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}(e=e??0,r=r??1);let s=0;return Promise.all(n.map(l=>(l.then(c=>{const u=e+ ++s/n.length*(r-e);return t(u),c}),l)))}function yL(n,t){return oI.apply(this,arguments)}function oI(){return(oI=ee(function*(n,t){null==t&&(t={});const e=t.fetchFunc??G().platform.fetch,r=n.map(d=>e(d,t.requestInit,{isBinary:!0})),a=(null==t.onProgress?yield Promise.all(r):yield gL(r,t.onProgress,0,.5)).map(d=>d.arrayBuffer());return null==t.onProgress?yield Promise.all(a):yield gL(a,t.onProgress,.5,1)})).apply(this,arguments)}function Jne(n){return aI.apply(this,arguments)}function aI(){return(aI=ee(function*(n,t="",e,r){return bL(o=>yL(o,{requestInit:r}))(n,t,e)})).apply(this,arguments)}function bL(n){return function(){var t=ee(function*(e,r="",s){const i=e.map(()=>!1),o={},a=null!=s?s.map(()=>!1):[],l=[];if(e.forEach((p,m)=>{let g=0;p.weights.forEach(y=>{const _=WE["quantization"in y?y.quantization.dtype:y.dtype]*X(y.shape),v=()=>{i[m]=!0,null==o[m]&&(o[m]=[]),o[m].push({manifestEntry:y,groupOffset:g,sizeBytes:_})};null!=s?s.forEach((w,C)=>{w===y.name&&(v(),a[C]=!0)}):v(),l.push(y.name),g+=_})}),!a.every(p=>p)){const p=s.filter((m,g)=>!a[g]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. \nManifest JSON has weights with names: ${l.join(", ")}.`)}const c=i.reduce((p,m,g)=>(m&&p.push(g),p),[]),u=[];c.forEach(p=>{e[p].paths.forEach(m=>{const g=r+(r.endsWith("/")?"":"/")+m;u.push(g)})});const d=yield n(u),h={};let f=0;return c.forEach(p=>{const m=e[p].paths.length;let g=0;for(let w=0;w<m;w++)g+=d[f+w].byteLength;const y=new ArrayBuffer(g),b=new Uint8Array(y);let _=0;for(let w=0;w<m;w++){const C=new Uint8Array(d[f+w]);b.set(C,_),_+=C.byteLength}o[p].forEach(w=>{const I=eL(y.slice(w.groupOffset,w.groupOffset+w.sizeBytes),[w.manifestEntry]);for(const D in I)h[D]=I[D]}),f+=m}),h});return function(e){return t.apply(this,arguments)}}()}In.registerSaveRouter(n=>G().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(iI.URL_SCHEME)?function Zne(n="model"){return new iI(n)}(n.slice(iI.URL_SCHEME.length)):null);let _L=(()=>{class n{constructor(e,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.onProgress=r.onProgress,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?(S("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=G().platform.fetch,S(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&S(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{}}save(e){var r=this;return ee(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const s=Object.assign({method:r.DEFAULT_METHOD},r.requestInit);s.body=new FormData;const o=rL(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);s.body.append("model.json",new Blob([JSON.stringify(o)],{type:"application/json"}),"model.json"),null!=e.weightData&&s.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=yield r.fetch(r.path,s);if(a.ok)return{modelArtifactsInfo:Sp(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})()}load(){var e=this;return ee(function*(){const r=yield e.fetch(e.path,e.requestInit);if(!r.ok)throw new Error(`Request to ${e.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let s;try{s=yield r.json()}catch{let l=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?l+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":l+=" Please make sure the server is serving valid JSON for this request.",new Error(l)}if(null==s.modelTopology&&null==s.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return KE(s,a=>e.loadWeights(a))})()}loadWeights(e){var r=this;return ee(function*(){const s=Array.isArray(r.path)?r.path[1]:r.path,[i,o]=function nre(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?");return[n.substring(0,t)+"/",e>t?n.substring(e):""]}(s),a=r.weightPathPrefix||i,l=iL(e),c=[],u=[];for(const h of e)for(const f of h.paths)null!=r.weightUrlConverter?u.push(r.weightUrlConverter(f)):c.push(a+f+o);return r.weightUrlConverter&&c.push(...yield Promise.all(u)),[l,Qb(yield yL(c,{requestInit:r.requestInit,fetchFunc:r.fetch,onProgress:r.onProgress}))]})()}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();function lI(n){return null!=n.match(_L.URL_SCHEME_REGEX)}const vL=(n,t)=>{if(typeof fetch>"u"&&(null==t||null==t.fetchFunc))return null;{let e=!0;if(e=Array.isArray(n)?n.every(r=>lI(r)):lI(n),e)return cI(n,t)}return null};function cI(n,t){return new _L(n,t)}function rre(n,t){return cI(n,t)}In.registerSaveRouter(vL),In.registerLoadRouter(vL);class uI{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class xL{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class sre{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function ire(n,t,e,r){const s=arguments;return new sre(wL(...s))}function wL(n,t,e,r){return 1===arguments.length?null!=n.modelTopology||null!=n.weightSpecs?new uI(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new uI({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new uI({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:r}))}function ore(n){return new xL(n)}function are(n){return new xL(n)}function cd(n,t){const e=n.length,r=[];for(let s=0;s<e;s++){const i=e-1-s,o=n[i]||1;(t[t.length-1-s]||1)>1&&1===o&&r.unshift(i)}return r}function nr(n,t){const e=[];for(let r=0;r<t.length;r++){const s=n[n.length-r-1],i=t.length-r-1,o=t[i];(null==s||1===s&&o>1)&&e.unshift(i)}return e}function et(n,t){const e=[],r=Math.max(n.length,t.length);for(let s=0;s<r;s++){let i=n[n.length-s-1];null==i&&(i=1);let o=t[t.length-s-1];if(null==o&&(o=1),1===i)e.unshift(o);else if(1===o)e.unshift(i);else{if(i!==o)throw Error(`Operands could not be broadcast together with shapes ${n} and ${t}.`);e.unshift(i)}}return e}function CL(n,t,e){if(Xu(n),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Ja(n,e);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return tl(n,t,r,e)}let gc;const hre=A({fromPixels_:function SL(n,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==n)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,r=!1,s=!1,i=!1,o=!1,a=!1;if(n.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)i=!0;else if(null!=n.getContext)o=!0;else{if(!(typeof ImageBitmap<"u"&&n instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);a=!0}if(null!=OE(ME,R.backendName))return R.runKernel(ME,{pixels:n},{numChannels:t});const[c,u]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let d,h;if(o)d=n.getContext("2d").getImageData(0,0,c,u).data;else if(r||e)d=n.data;else if(i||s||a){if(null==gc)if(typeof document>"u"){if(!(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u"))throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");gc=new OffscreenCanvas(1,1).getContext("2d")}else gc=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});gc.canvas.width=c,gc.canvas.height=u,gc.drawImage(n,0,0,c,u),d=gc.getImageData(0,0,c,u).data}if(4===t)h=new Int32Array(d);else{const p=c*u;h=new Int32Array(p*t);for(let m=0;m<p;m++)for(let g=0;g<t;++g)h[m*t+g]=d[4*m+g]}return CL(h,[u,c,t],"int32")}});function pI(n,t,e){const r=n.shape.length;S(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),S(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)S(t[s]+e[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+e[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function pre(n){const t=[];let e=0;for(;n>0;)1&n&&t.push(e),n/=2,e++;return t}function mI(n,t,e){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((t[s]-n[s])/e[s]);return r}function EL(n,t,e,r){const s=[...n];for(let i=s.length;i<r.length;i++)s.push(1);for(let i=0;i<e;i++)0===i?s[t]=1:(s.splice(t,0,1),s.pop());return s}function IL(n,t,e){return e<=n?e:e-(t-1)}function DL(n,t){const e=[];for(let r=0;r<n;r++)e.push(t+r);return e}function mre(n,t,e,r,s,i,o,a,l){const c=n.length;let u=new Array(c),d=new Array(c),h=new Array(c);if(t.length&&e>0){const f=t[0],p=e+1;u=TL(o,f,p,r,n),d=kL(a,f,p,s,n),h=EL(i,f,p,n)}else for(let f=0;f<c;f++)u[f]=AL(o,r,i,n,f,l),d[f]=RL(a,s,i,n,f,l),h[f]=NL(i,f,l);return{begin:u,end:d,strides:h}}function TL(n,t,e,r,s){const i=[...s],o=DL(e,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=IL(t,e,a);let c=r[l];n&1<<l&&(c=0),i[a]=c}return i}function kL(n,t,e,r,s){const i=[...s],o=DL(e,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=IL(t,e,a);let c=r[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),i[a]=c}for(let a=0;a<i.length;a++){const l=s[a];i[a]<0&&(i[a]+=l),i[a]=uc(0,i[a],s[a])}return i}function NL(n,t,e){let r=n[t];return(e&1<<t||null==r)&&(r=1),r}function AL(n,t,e,r,s,i){let o=t[s];(n&1<<s||i&1<<s||null==o)&&(o=(e[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=uc(0,o,l-1),o}function RL(n,t,e,r,s,i){let o=t[s];const a=e[s]||1;(n&1<<s||i&1<<s||null==o)&&(o=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=a>0?uc(0,o,l):uc(-1,o,l-1),o}function gI(n,t,e){let r=e.length;for(let s=0;s<e.length;s++)if(e[s]>1){r=s;break}for(let s=r+1;s<e.length;s++)if(t[s]>0||e[s]!==n[s])return!1;return!0}function yI(n,t){let e=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)e+=n[r]*t[r];return e}function t_(n,t,e){let r;const s=n.shape.length;let i;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach(o=>{S(-1!==o,()=>"slice() does not support negative begin indexing.")}),i=null==e?new Array(s).fill(-1):"number"==typeof e?[e,...new Array(s-1).fill(-1)]:e.length<s?e.concat(new Array(s-e.length).fill(-1)):e,i=i.map((o,a)=>o>=0?o:(S(-1===o,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,i]}function bI(n,t,e,r,s,i,o,a,l){let c;if(null==r?(c=new Array(t.length),c.fill(1)):c=r,null!=o&&0!=(o&o-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const d={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:c.slice(),beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let _=0;_<d.dims;_++)u&&0!=(1<<_&a)&&d.numAddAxisAfterEllipsis++,1<<_&o&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function gre(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=null!=n.begin,t.endValid=null!=n.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(t.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<s;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&n.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=n.begin&&(t.begin[e]=n.begin[r]),null!=n.end&&(t.end[e]=n.end[r]),t.strides[e]=n.strides[r],n.beginMask&1<<r&&(t.beginMask|=1<<e),n.endMask&1<<r&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[e]=r,e++}}(d,h);let f=!0,p=!0,m=!0;const g=[],y=[];for(let _=0;_<n.length;++_){if(0===h.strides[_])throw Error(`strides[${_}] must be non-zero`);const v=!!(h.shrinkAxisMask&1<<_),w=n[_];if(-1===w){g.push(v?1:-1);continue}const C=[h.beginMask&1<<_,h.endMask&1<<_],I=[h.strides[_]>0?0:-1,h.strides[_]>0?w:w-1];if(v&&h.strides[_]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[_];const D=!!(h.beginMask&1<<_&&h.endMask&1<<_);if(h.beginValid&&h.endValid){if(v){const z=h.begin[_]<0?w+h.begin[_]:h.begin[_];if(h.begin[_]=z,h.end[_]=h.begin[_]+1,z<0||z>=w)throw Error(`slice index ${h.begin[_]} of dimension ${_} out of bounds.`)}else h.begin[_]=ML(h.begin[_],0,h.strides[_],w,C,I),h.end[_]=ML(h.end[_],1,h.strides[_],w,C,I);const $=1===h.strides[_]&&0===h.begin[_]&&h.end[_]===w;f=f&&$,p=p&&(0===_&&1===h.strides[_]||$)}else f=f&&1===h.strides[_]&&D,p=p&&(0===_&&1===h.strides[_]||D);let T,N=!1;if(h.beginValid&&h.endValid?(T=h.end[_]-h.begin[_],N=!0):v?(T=1,N=!0):D&&w>=0&&(T=h.strides[_]<0?-w:w,N=!0),N){let $;$=0===T||T<0!=h.strides[_]<0?0:Math.trunc(T/h.strides[_])+(T%h.strides[_]!=0?1:0),g.push($)}else g.push(-1)}for(let _=0;_<h.finalShapeGatherIndices.length;++_){const v=h.finalShapeGatherIndices[_];v>=0?y.push(g[v]):-2===v&&y.push(1)}return{finalShapeSparse:y.filter((_,v)=>-2!==h.finalShapeGatherIndices[v]),finalShape:y,isIdentity:f,sliceDim0:p,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function ML(n,t,e,r,s,i){if(s[t])return e>0?i[t]:i[t+1&1];{const o=n<0?r+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}class ud{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class Ni{constructor(){this.classNameMap={}}static getMap(){return null==Ni.instance&&(Ni.instance=new Ni),Ni.instance}static register(t){Ni.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function se(n){S(null!=n.className,()=>"Class being registered does not have the static className property defined."),S("string"==typeof n.className,()=>"className is required to be a string, but got type "+typeof n.className),S(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Ni.register(n)}function Mo(){return R}function _I(){return R.memory()}function V(n,t){return R.tidy(n,t)}function Qe(n){j$(n).forEach(e=>e.dispose())}function xr(n){return R.keep(n)}function FL(n,t,e=1){return R.registerBackend(n,t,e)}function ga(n){return R.customGrad(n)}function Be(n,t){if((No(n)&&"string"!==t||Array.isArray(n))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&No(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return tl(n,[],[],t)}!function lne(n){W$=n}(function bre(n){G().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});class rl extends ud{minimize(t,e=!1,r){const{value:s,grads:i}=this.computeGradients(t,r);if(null!=r){const o=r.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return Qe(i),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function vre(n,t){S(SS(n),()=>"The f passed in variableGrads(f) must be a function"),S(null==t||Array.isArray(t)&&t.every(c=>c instanceof jb),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=t;if(!e){t=[];for(const c in R.registeredVariables)t.push(R.registeredVariables[c])}const r=e?t.filter(c=>!c.trainable):null,s=t.length;S((t=t.filter(c=>c.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:o,grads:a}=R.gradients(n,t,null,!0);S(a.some(c=>null!=c),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),S(0===o.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return t.forEach((c,u)=>{null!=a[u]&&(l[c.name]=a[u])}),r?.forEach(c=>l[c.name]=null),{value:o,grads:l}}(t,e)}dispose(){null!=this.iterations_&&Qe(this.iterations_)}saveIterations(){var t=this;return ee(function*(){return null==t.iterations_&&(t.iterations_=0),{name:"iter",tensor:Be(t.iterations_,"int32")}})()}getWeights(){return ee(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(t){var e=this;return ee(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(t){var e=this;return ee(function*(){return e.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})()}}Object.defineProperty(rl,Symbol.hasInstance,{value:n=>null!=n.minimize&&null!=n.computeGradients&&null!=n.applyGradients});const rr=A({abs_:function xre(n){const t=E(n,"x","abs");return R.runKernel("complex64"===t.dtype?Gy:Ly,{x:t})}}),OL=A({acos_:function wre(n){const e={x:E(n,"x","acos")};return R.runKernel(Ef,e)}}),PL=A({acosh_:function Cre(n){const e={x:E(n,"x","acosh")};return R.runKernel(If,e)}}),le=A({add_:function Sre(n,t){let e=E(n,"a","add"),r=E(t,"b","add");return[e,r]=An(e,r),R.runKernel(td,{a:e,b:r})}}),Ire=A({addN_:function Ere(n){S(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),S(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const t=n.map((s,i)=>E(s,`tensors${i}`,"addN")),e=t[0];return t.forEach(s=>{if(s.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(s=>{if(!It(s.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),R.runKernel(By,t)}}),vI=A({all_:function Dre(n,t=null,e=!1){const s={x:E(n,"x","all","bool")};return R.runKernel("All",s,{axis:t,keepDims:e})}}),r_=A({any_:function Tre(n,t=null,e=!1){const s={x:E(n,"x","any","bool")};return R.runKernel("Any",s,{axis:t,keepDims:e})}}),dd=A({argMax_:function kre(n,t=0){const r={x:E(n,"x","argMax")};return R.runKernel(Vy,r,{axis:t})}}),$L=A({argMin_:function Nre(n,t=0){const r={x:E(n,"x","argMin")};return R.runKernel(zy,r,{axis:t})}}),LL=A({asin_:function Are(n){const e={x:E(n,"x","asin")};return R.runKernel(Df,e)}}),BL=A({asinh_:function Rre(n){const e={x:E(n,"x","asinh")};return R.runKernel(Tf,e)}}),VL=A({atan_:function Mre(n){const e={x:E(n,"x","atan")};return R.runKernel(kf,e)}}),zL=A({atan2_:function Fre(n,t){let e=E(n,"a","atan2"),r=E(t,"b","atan2");return[e,r]=An(e,r),R.runKernel(Af,{a:e,b:r})}}),UL=A({atanh_:function Ore(n){const e={x:E(n,"x","atanh")};return R.runKernel(Nf,e)}});function Ep(n,t,e,r,s="NHWC",i){return wr(n,[...t,n[3]],e,i,r,null,null,ba(s))}function Ai(n,t,e,r,s,i,o="channelsLast"){const[a,l]=s_(t);let c;if("channelsLast"===o)c=[a,l,n[3],n[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);c=[a,l,n[1],n[1]]}return wr(n,c,e,r,s,i,!1,o)}function ya(n,t,e,r,s,i,o="NDHWC"){const[a,l,c]=wI(t);let u,d;if("NDHWC"===o)d="channelsLast",u=[a,l,c,n[4],n[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);d="channelsFirst",u=[a,l,c,n[1],n[1]]}return sl(n,u,e,r,s,!1,d,i)}function wr(n,t,e,r,s,i,o=!1,a="channelsLast"){let[l,c,u,d]=[-1,-1,-1,-1];if("channelsLast"===a)[l,c,u,d]=n;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,c,u]=n}const[h,f,,p]=t,[m,g]=s_(e),[y,b]=s_(r),_=hd(h,y),v=hd(f,b),{padInfo:w,outHeight:C,outWidth:I}=function Lre(n,t,e,r,s,i,o,a,l){let c,u,d;if("number"==typeof n){c={top:n,bottom:n,left:n,right:n,type:0===n?"VALID":"NUMBER"};const f=function Pre(n,t,e,r,s){null==r&&(r=xI(n,t,e));const o=n[1];return[yc((n[0]-t+2*r)/e+1,s),yc((o-t+2*r)/e+1,s)]}([t,e],i,r,n,a);u=f[0],d=f[1]}else if("same"===n){u=Math.ceil(t/r),d=Math.ceil(e/s);const h=Math.max(0,(u-1)*r+i-t),f=Math.max(0,(d-1)*s+o-e),p=Math.floor(h/2),m=h-p,g=Math.floor(f/2);c={top:p,bottom:m,left:g,right:f-g,type:"SAME"}}else if("valid"===n)c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-i+1)/r),d=Math.ceil((e-o+1)/s);else{if("object"!=typeof n)throw Error(`Unknown padding parameter: ${n}`);{const h="channelsLast"===l?n[1][0]:n[2][0],f="channelsLast"===l?n[1][1]:n[2][1],p="channelsLast"===l?n[2][0]:n[3][0],m="channelsLast"===l?n[2][1]:n[3][1];c={top:h,bottom:f,left:p,right:m,type:0===h&&0===f&&0===p&&0===m?"VALID":"EXPLICIT"},u=yc((t-i+h+f)/r+1,a),d=yc((e-o+p+m)/s+1,a)}}return{padInfo:c,outHeight:u,outWidth:d}}(s,c,u,m,g,_,v,i,a),D=o?p*d:p;let T;return"channelsFirst"===a?T=[l,D,C,I]:"channelsLast"===a&&(T=[l,C,I,D]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:d,outHeight:C,outWidth:I,outChannels:D,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:f,effectiveFilterHeight:_,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:n,outShape:T,filterShape:t}}function sl(n,t,e,r,s,i=!1,o="channelsLast",a){let[l,c,u,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,c,u,d,h]=n;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,c,u,d]=n}const[f,p,m,,g]=t,[y,b,_]=wI(e),[v,w,C]=wI(r),I=hd(f,v),D=hd(p,w),T=hd(m,C),{padInfo:N,outDepth:$,outHeight:z,outWidth:j}=function Bre(n,t,e,r,s,i,o,a,l,c,u){let d,h,f,p;if("number"==typeof n){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:0===n?"VALID":"NUMBER"};const g=function $re(n,t,e,r,s,i){null==s&&(s=xI(n,t,r));const a=n[1],l=n[2];return[yc((n[0]-t+2*s)/r+1,i),yc((a-t+2*s)/r+1,i),yc((l-t+2*s)/r+1,i),e]}([t,e,r,1],a,1,s,n,u);h=g[0],f=g[1],p=g[2]}else if("same"===n){h=Math.ceil(t/s),f=Math.ceil(e/i),p=Math.ceil(r/o);const m=(h-1)*s+a-t,g=(f-1)*i+l-e,y=(p-1)*o+c-r,b=Math.floor(m/2),_=m-b,v=Math.floor(g/2),w=g-v,C=Math.floor(y/2);d={top:v,bottom:w,left:C,right:y-C,front:b,back:_,type:"SAME"}}else{if("valid"!==n)throw Error(`Unknown padding parameter: ${n}`);d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},h=Math.ceil((t-a+1)/s),f=Math.ceil((e-l+1)/i),p=Math.ceil((r-c+1)/o)}return{padInfo:d,outDepth:h,outHeight:f,outWidth:p}}(s,c,u,d,y,b,_,I,D,T,a),q=i?g*h:g;let K;return"channelsFirst"===o?K=[l,q,$,z,j]:"channelsLast"===o&&(K=[l,$,z,j,q]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:d,inChannels:h,outDepth:$,outHeight:z,outWidth:j,outChannels:q,padInfo:N,strideDepth:y,strideHeight:b,strideWidth:_,filterDepth:f,filterHeight:p,filterWidth:m,effectiveFilterDepth:I,effectiveFilterHeight:D,effectiveFilterWidth:T,dilationDepth:v,dilationHeight:w,dilationWidth:C,inShape:n,outShape:K,filterShape:t}}function xI(n,t,e,r=1){const s=hd(t,r);return Math.floor((n[0]*(e-1)-e+s)/2)}function s_(n){return"number"==typeof n?[n,n,n]:2===n.length?[n[0],n[1],1]:n}function wI(n){return"number"==typeof n?[n,n,n]:n}function hd(n,t){return t<=1?n:n+(n-1)*(t-1)}function yc(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function il(n){const[t,e,r]=s_(n);return 1===t&&1===e&&1===r}function Nr(n,t){return il(n)||il(t)}function ba(n){if("NHWC"===n)return"channelsLast";if("NCHW"===n)return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Zr(n,t,e){if(null!=e){if("string"==typeof t)throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if("number"==typeof t)S(Zu(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);t.forEach(r=>{r.forEach(s=>{S(Zu(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${s}.`)})})}}}const F=A({reshape_:function Vre(n,t){const r={x:E(n,"x","reshape","string_or_numeric")};return R.runKernel(Ib,r,{shape:t})}}),i_=A({avgPool_:function zre(n,t,e,r,s){const i=E(n,"x","avgPool","float32");S(Nr(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let a=i,l=!1;3===i.rank&&(l=!0,a=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Zr("avgPool",r,s);let d=R.runKernel(Uy,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return d=ve(d,i.dtype),l?F(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),HL=A({avgPool3d_:function Ure(n,t,e,r,s,i="NDHWC"){const o=E(n,"x","avgPool3d","float32");let a=o,l=!1;4===o.rank&&(l=!0,a=F(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===i,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Zr("avgPool3d",r,s);let d=R.runKernel(Hy,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:i});return d=ve(d,a.dtype),l?F(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Xn=A({concat_:function Hre(n,t=0){S(n.length>=1,()=>"Pass at least one tensor to concat");const e=Yb(n,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(i=>{if("complex64"!==i.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${i.dtype}. `)}),1===e.length?ma(e[0]):R.runKernel(qy,e,{axis:t})}}),mt=A({matMul_:function Wre(n,t,e=!1,r=!1){let s=E(n,"a","matMul"),i=E(t,"b","matMul");return[s,i]=An(s,i),R.runKernel(Wy,{a:s,b:i},{transposeA:e,transposeB:r})}}),M=A({mul_:function jre(n,t){let e=E(n,"a","mul"),r=E(t,"b","mul");return[e,r]=An(e,r),R.runKernel(ep,{a:e,b:r})}}),Fo=A({sigmoid_:function Gre(n){const e={x:E(n,"x","sigmoid","float32")};return R.runKernel(dp,e)}}),Dt=A({slice_:function qre(n,t,e){const r=E(n,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return R.runKernel(Ab,{x:r},{begin:t,size:e})}}),fd=A({tanh_:function Kre(n){const e={x:E(n,"x","tanh","float32")};return R.runKernel(yp,e)}}),Yre=A({basicLSTMCell_:function Xre(n,t,e,r,s,i){const o=E(n,"forgetBias","basicLSTMCell"),a=E(t,"lstmKernel","basicLSTMCell"),l=E(e,"lstmBias","basicLSTMCell"),c=E(r,"data","basicLSTMCell"),u=E(s,"c","basicLSTMCell"),d=E(i,"h","basicLSTMCell"),h=Xn([c,d],1),f=mt(h,a),p=le(f,l),g=p.shape[1]/4,y=[p.shape[0],g],b=Dt(p,[0,0],y),_=Dt(p,[0,g],y),v=Dt(p,[0,2*g],y),w=Dt(p,[0,3*g],y),C=le(M(Fo(b),fd(_)),M(u,Fo(le(o,v))));return[C,M(fd(C),Fo(w))]}}),o_=A({batchToSpaceND_:function Zre(n,t,e){const r=E(n,"x","batchToSpaceND"),s=t.reduce((a,l)=>a*l);return S(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),S(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),S(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`),R.runKernel(jy,{x:r},{blockShape:t,crops:e})}});function Qre(n){let t;return t=0===n.rank||1===n.rank?F(n,[1,1,1,n.size]):2===n.rank?F(n,[1,1,n.shape[0],n.shape[1]]):3===n.rank?F(n,[1,n.shape[0],n.shape[1],n.shape[2]]):n,t}const Ip=A({batchNorm_:function Jre(n,t,e,r,s,i){null==i&&(i=.001);const o=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let c,u;null!=s&&(c=E(s,"scale","batchNorm")),null!=r&&(u=E(r,"offset","batchNorm")),S(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:Qre(o),scale:c,offset:u,mean:a,variance:l},p=R.runKernel(nb,h,{varianceEpsilon:i});return F(p,o.shape)}}),WL=A({batchNorm2d_:function ese(n,t,e,r,s,i){const o=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let c,u;return null!=s&&(c=E(s,"scale","batchNorm")),null!=r&&(u=E(r,"offset","batchNorm")),S(2===o.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),S(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),S(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=c&&S(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),null!=u&&S(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),Ip(o,a,l,u,c,i)}}),jL=A({batchNorm3d_:function tse(n,t,e,r,s,i){const o=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let c,u;return null!=s&&(c=E(s,"scale","batchNorm")),null!=r&&(u=E(r,"offset","batchNorm")),S(3===o.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),S(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),S(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=c&&S(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),null!=u&&S(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),Ip(o,a,l,u,c,i)}}),GL=A({batchNorm4d_:function nse(n,t,e,r,s,i){const o=E(n,"x","batchNorm"),a=E(t,"mean","batchNorm"),l=E(e,"variance","batchNorm");let c,u;return null!=s&&(c=E(s,"scale","batchNorm")),null!=r&&(u=E(r,"offset","batchNorm")),S(4===o.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),S(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),S(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=c&&S(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),null!=u&&S(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),Ip(o,a,l,u,c,i)}}),qL=A({bincount_:function rse(n,t,e){const r=E(n,"x","bincount"),s=E(t,"weights","bincount");return S("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),S(e>=0,()=>`size must be non-negative, but got ${e}.`),S(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),R.runKernel(MS,{x:r,weights:s},{size:e})}}),ise=A({broadcastArgs_:function sse(n,t){const e=E(n,"s0","broadcastArgs","int32"),r=E(t,"s1","broadcastArgs","int32");if(1!==e.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);return R.runKernel(FS,{s0:e,s1:r})}}),pd=A({broadcastTo_:function ose(n,t){let e=E(n,"broadcastTo","x");const r=e.shape;if(ri(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const c=e.shape.slice();for(;c.length<t.length;)c.unshift(1);e=F(e,c)}const s=e.shape,i=Array.from(t);for(let c=t.length-1;c>=0;c--)if(s[c]===t[c])i[c]=1;else if(1!==e.shape[c])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);return 0===i.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length?ma(e):R.runKernel(bp,{x:e},{reps:i})}}),KL=A({ceil_:function ase(n){const e={x:E(n,"x","ceil","float32")};return R.runKernel(Mf,e)}});function md(n,t,e){return ri(n),R.runKernel(ZS,{},{shape:n,value:t,dtype:e})}const Os=A({clipByValue_:function lse(n,t,e){const r=E(n,"x","clipByValue");return S(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e?md(r.shape,t,r.dtype):R.runKernel(Ff,{x:r},{clipValueMin:t,clipValueMax:e})}}),XL=A({concat1d_:function cse(n){return Xn(n,0)}}),YL=A({concat2d_:function use(n,t){return Xn(n,t)}}),ZL=A({concat3d_:function dse(n,t){return Xn(n,t)}}),QL=A({concat4d_:function hse(n,t){return Xn(n,t)}}),ol=A({conv2d_:function fse(n,t,e,r,s="NHWC",i=[1,1],o){const a=E(n,"x","conv2d","float32"),l=E(t,"filter","conv2d","float32");let c=a,u=!1;3===a.rank&&(u=!0,c=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===c.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),S(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Zr("conv2d",r,o);const d="NHWC"===s?c.shape[3]:c.shape[1];S(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),S(Nr(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const p=R.runKernel(Ky,{x:c,filter:l},{strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o});return u?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),CI=A({conv1d_:function pse(n,t,e,r,s="NWC",i=1,o){const a=E(n,"x","conv1d"),l=E(t,"filter","conv1d");let c=a,u=!1;2===a.rank&&(u=!0,c=F(a,[1,a.shape[0],a.shape[1]])),S(3===c.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),S(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Zr("conv1d",r,o),S(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),S(Nr(e,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${i}'`),S("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=F(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=F(c,[c.shape[0],1,c.shape[1],c.shape[2]]),g=ol(h,d,[1,e],r,"NHWC",[1,i],o);return F(g,u?[g.shape[2],g.shape[3]]:[g.shape[0],g.shape[2],g.shape[3]])}}),SI=A({conv2DBackpropInput_:function mse(n,t,e,r,s,i="NHWC",o){S(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let a=n,l=t,c=!1;3===t.rank&&(c=!0,l=F(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,n[0],n[1],n[2]]),S(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),S(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),S(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const u="NHWC"===i?a[3]:a[1],d="NHWC"===i?l.shape[3]:l.shape[1];S(u===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[2]}.`),S(d===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`),Zr("conv2dDerInput",s,o);const p=R.runKernel(Xy,{dy:l,filter:e},{strides:r,pad:s,dataFormat:i,dimRoundingMode:o,inputShape:a});return c?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),EI=A({conv2dTranspose_:function gse(n,t,e,r,s,i){const o=E(n,"x","conv2dTranspose"),a=E(t,"filter","conv2dTranspose");return SI(e,o,a,r,s,"NHWC",i)}}),JL=A({conv3d_:function yse(n,t,e,r,s="NDHWC",i=[1,1,1]){const o=E(n,"x","conv3d"),a=E(t,"filter","conv3d");let l=o,c=!1;4===o.rank&&(c=!0,l=F(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),S(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),S(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),S(Nr(e,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),S("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const h=R.runKernel(Yy,{x:l,filter:a},{strides:e,pad:r,dataFormat:s,dilations:i});return c?F(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),eB=A({conv3DBackpropInput_:function bse(n,t,e,r,s){S(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let i=n,o=t,a=!1;4===t.rank&&(a=!0,o=F(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const l=i[4],c=o.shape[4];S(5===i.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),S(5===o.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),S(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),S(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),S(c===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${e.shape[4]}.`);const h=R.runKernel(LS,{dy:o,filter:e},{pad:s,strides:r,inputShape:i});return a?F(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),tB=A({conv3dTranspose_:function _se(n,t,e,r,s){const i=E(n,"x","conv3dTranspose"),o=E(t,"filter","conv3dTranspose");return eB(e,i,o,r,s)}}),a_=A({cos_:function vse(n){const e={x:E(n,"x","cos","float32")};return R.runKernel(Of,e)}}),II=A({cosh_:function xse(n){const e={x:E(n,"x","cosh","float32")};return R.runKernel(Pf,e)}}),l_=A({cumprod_:function wse(n,t=0,e=!1,r=!1){const i={x:E(n,"x","cumprod")};return R.runKernel(BS,i,{axis:t,exclusive:e,reverse:r})}}),DI=A({cumsum_:function Cse(n,t=0,e=!1,r=!1){const i={x:E(n,"x","cumsum")};return R.runKernel(Zy,i,{axis:t,exclusive:e,reverse:r})}}),TI=A({denseBincount_:function Sse(n,t,e,r=!1){const s=E(n,"x","denseBincount"),i=E(t,"weights","denseBincount");return S("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),S(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),S(e>=0,()=>`size must be non-negative, but got ${e}.`),S(i.size===s.size||0===i.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${i.shape}.`),R.runKernel(zS,{x:s,weights:i},{size:e,binaryOutput:r})}}),nB=A({depthToSpace_:function Ese(n,t,e="NHWC"){const r=E(n,"x","depthToSpace","float32"),s="NHWC"===e?r.shape[1]:r.shape[2],i="NHWC"===e?r.shape[2]:r.shape[3],o="NHWC"===e?r.shape[3]:r.shape[1];return S(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),S(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),S(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${t} for depthToSpace with input shape\n        ${r.shape}`),S(o%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${r.shape}`),R.runKernel(US,{x:r},{blockSize:t,dataFormat:e})}}),Dp=A({depthwiseConv2d_:function Ise(n,t,e,r,s="NHWC",i=[1,1],o){const a=E(n,"x","depthwiseConv2d","float32"),l=E(t,"filter","depthwiseConv2d","float32");let c=a,u=!1;3===a.rank&&(u=!0,c=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===c.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),S(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d="NHWC"===s?c.shape[3]:c.shape[1];S(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),Zr("depthwiseConv2d",r,o);const p=R.runKernel(Qy,{x:c,filter:l},{strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o});return u?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),Tse=A({diag_:function Dse(n){const e={x:E(n,"x","diag")};return R.runKernel(jS,e)}}),rB=A({dilation2d_:function kse(n,t,e,r,s=[1,1],i="NHWC"){const o=E(n,"x","dilation2d"),a=E(t,"filter","dilation2d");S(3===o.rank||4===o.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),S(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),S("NHWC"===i,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,c=!1;3===o.rank&&(l=F(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0);const h=R.runKernel(Jy,{x:l,filter:a},{strides:e,pad:r,dilations:s});return c?F(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),kI=A({floorDiv_:function Nse(n,t){let e=E(n,"a","floorDiv"),r=E(t,"b","floorDiv");return[e,r]=An(e,r),R.runKernel(Hf,{a:e,b:r})}}),Pe=A({div_:function Ase(n,t){let e=E(n,"a","div"),r=E(t,"b","div");return[e,r]=An(e,r),"int32"===e.dtype&&"int32"===r.dtype?kI(e,r):R.runKernel($f,{a:e,b:r},{})}}),lo=A({equal_:function Rse(n,t){let e=E(n,"a","equal","string_or_numeric"),r=E(t,"b","equal","string_or_numeric");return[e,r]=An(e,r),et(e.shape,r.shape),R.runKernel(eb,{a:e,b:r})}}),ms=A({where_:function Mse(n,t,e){const r=E(t,"a","where"),s=E(e,"b","where"),i=E(n,"condition","where","bool"),o=et(et(i.shape,r.shape),s.shape),a=pd(i,o),l=pd(r,o),c=pd(s,o);return R.runKernel(Nb,{condition:a,t:l,e:c})}}),Tt=A({zerosLike_:function Fse(n){const e={x:E(n,"x","zerosLike")};return R.runKernel(Lb,e)}}),sB=A({divNoNan_:function Ose(n,t){let e=E(n,"a","div"),r=E(t,"b","div");[e,r]=An(e,r);const s=Pe(e,r),i=Tt(s),o=lo(r,i);return ms(o,i,s)}}),iB=A({dot_:function Pse(n,t){const e=E(n,"t1","dot"),r=E(t,"t2","dot");S(!(1!==e.rank&&2!==e.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);const s=1===e.rank?e.size:e.shape[1],i=1===r.rank?r.size:r.shape[0];if(S(s===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${i}.`),1===e.rank&&1===r.rank){const o=F(e,[1,-1]),a=F(r,[-1,1]),l=mt(o,a);return F(l,[])}if(1===e.rank&&2===r.rank){const o=F(e,[1,-1]),a=F(r,[r.shape[0],r.shape[1]]),l=mt(o,a);return F(l,[l.size])}if(2===e.rank&&1===r.rank){const o=F(r,[-1,1]),a=mt(e,o);return F(a,[a.size])}{const o=F(r,[r.shape[0],r.shape[1]]);return mt(e,o)}}}),Lse=A({einsum_:function $se(n,...t){const e=t.map((s,i)=>E(s,`tensors${i}`,"einsum"));return R.runKernel(KS,e,{equation:n})}}),Tp=A({elu_:function Bse(n){const e={x:E(n,"x","elu","float32")};return R.runKernel(Lf,e)}}),oB=A({erf_:function Vse(n){let t=E(n,"x","erf");return S("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=ve(t,"float32")),R.runKernel(Bf,{x:t})}});function NI(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function aB(n,t,e){const r=n.length+t.length,s=[];let i=0,o=0;for(let a=0;a<r;a++)-1===e.indexOf(a)?s.push(n[i++]):s.push(t[o++]);return s}function Cr(n,t){const e=[],r=n.length;for(let i=0;i<r;i++)-1===t.indexOf(i)&&e.push(n[i]);return[e,t.map(i=>n[i])]}function Vn(n,t){return aB(n,t.map(r=>1),t)}function Ar(n,t,e){S(NI(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function Dn(n,t){if(NI(n,t))return null;const e=[];for(let r=0;r<t;++r)-1===n.indexOf(r)&&e.push(r);return n.forEach(r=>e.push(r)),e}function al(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function zn(n,t){const e=[];for(let r=t-n;r<t;++r)e.push(r);return e}const Ri=A({max_:function zse(n,t=null,e=!1){const s={x:E(n,"x","max")};return R.runKernel(hb,s,{reductionIndices:t,keepDims:e})}}),kp=A({min_:function Use(n,t=null,e=!1){const s={x:E(n,"x","min")};return R.runKernel(gb,s,{axis:t,keepDims:e})}}),ll=A({pow_:function Hse(n,t){let e=E(n,"base","pow"),r=E(t,"exp","pow");return[e,r]=An(e,r),R.runKernel(tp,{a:e,b:r})}}),Vr=A({sqrt_:function Wse(n){const e={x:E(n,"x","sqrt","float32")};return R.runKernel(fp,e)}}),Jt=A({square_:function jse(n){const t=E(n,"x","square");return R.runKernel("Square",{x:t},{})}}),Ae=A({sum_:function Gse(n,t=null,e=!1){let r=E(n,"x","sum");return"bool"===r.dtype&&(r=ve(r,"int32")),R.runKernel(Rb,{x:r},{axis:t,keepDims:e})}});function lB(n,t,e=null){if(0===n.rank)return rr(n);if(1!==n.rank&&null===e)return lB(F(n,[-1]),t,e);if(1===n.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===t)return Ae(rr(n),e);if(t===1/0)return Ri(rr(n),e);if(t===-1/0)return kp(rr(n),e);if("euclidean"===t||2===t)return Vr(Ae(ll(rr(n),Be(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&2===e.length){if(1===t)return Ri(Ae(rr(n),e[0]),e[1]-1);if(t===1/0)return Ri(Ae(rr(n),e[1]),e[0]);if(t===-1/0)return kp(Ae(rr(n),e[1]),e[0]);if("fro"===t||"euclidean"===t)return Vr(Ae(Jt(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const Np=A({norm_:function qse(n,t="euclidean",e=null,r=!1){const s=lB(n=E(n,"x","norm"),t,e);let i=s.shape;if(r){const o=ft(e,n.shape);i=Vn(s.shape,o)}return F(s,i)}}),cB=A({euclideanNorm_:function Kse(n,t=null,e=!1){return Np(n,"euclidean",t,e)}}),oi=A({exp_:function Xse(n){const e={x:E(n,"x","exp")};return R.runKernel(Vf,e)}}),gs=A({expandDims_:function Yse(n,t=0){const e=E(n,"x","expandDims","string_or_numeric");return S(t<=e.rank,()=>"Axis must be <= rank of the tensor"),R.runKernel(tb,{input:e},{dim:t})}}),uB=A({expm1_:function Zse(n){const e={x:E(n,"x","expm1")};return R.runKernel(zf,e)}}),Mi=A({tile_:function Qse(n,t){const e=E(n,"x","tile","string_or_numeric");return S(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`),R.runKernel(bp,{x:e},{reps:t})}}),AI=A({eye_:function Jse(n,t,e,r="float32"){null==t&&(t=n);const s=ot([n,t],r),i=n<=t?n:t;for(let a=0;a<i;++a)s.set(1,a,a);const o=F(s.toTensor(),[n,t]);if(null==e)return o;if(1===e.length)return Mi(gs(o,0),[e[0],1,1]);if(2===e.length)return Mi(gs(gs(o,0),0),[e[0],e[1],1,1]);if(3===e.length)return Mi(gs(gs(gs(o,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}}),Ap=A({floor_:function eie(n){const e={x:E(n,"x","floor","float32")};return R.runKernel(Uf,e)}}),Rp=A({gather_:function tie(n,t,e=0,r=0){const s=E(n,"x","gather"),i=E(t,"indices","gather","int32");return R.runKernel(rb,{x:s,indices:i},{axis:e,batchDims:r})}}),Ps=A({greater_:function nie(n,t){let e=E(n,"a","greater","string_or_numeric"),r=E(t,"b","greater","string_or_numeric");return[e,r]=An(e,r),et(e.shape,r.shape),R.runKernel(sb,{a:e,b:r})}}),cl=A({greaterEqual_:function rie(n,t){let e=E(n,"a","greaterEqual","string_or_numeric"),r=E(t,"b","greaterEqual","string_or_numeric");return[e,r]=An(e,r),et(e.shape,r.shape),R.runKernel(Wf,{a:e,b:r})}}),c_=A({imag_:function sie(n){const e={input:E(n,"input","imag")};return R.runKernel(tE,e)}}),dB=A({isFinite_:function iie(n){const e={x:E(n,"x","isFinite")};return R.runKernel(Gf,e)}}),hB=A({isInf_:function oie(n){const e={x:E(n,"x","isInf")};return R.runKernel(qf,e)}}),fB=A({isNaN_:function aie(n){const e={x:E(n,"x","isNaN")};return R.runKernel(Kf,e)}}),u_=A({leakyRelu_:function lie(n,t=.2){const r={x:E(n,"x","leakyRelu")};return R.runKernel(ib,r,{alpha:t})}}),RI=A({less_:function cie(n,t){let e=E(n,"a","less","string_or_numeric"),r=E(t,"b","less","string_or_numeric");return[e,r]=An(e,r),et(e.shape,r.shape),R.runKernel(ob,{a:e,b:r})}}),bc=A({lessEqual_:function uie(n,t){let e=E(n,"a","lessEqual","string_or_numeric"),r=E(t,"b","lessEqual","string_or_numeric");return[e,r]=An(e,r),et(e.shape,r.shape),R.runKernel(ab,{a:e,b:r})}});function die(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");return R.runKernel(nE,{},{start:n,stop:t,num:e})}const pB=A({localResponseNormalization_:function hie(n,t=5,e=1,r=1,s=.5){const i=E(n,"x","localResponseNormalization");S(4===i.rank||3===i.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`),S(Zu(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=i,a=!1;3===i.rank&&(a=!0,o=F(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const u=R.runKernel(db,{x:o},{depthRadius:t,bias:e,alpha:r,beta:s});return a?F(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),ai=A({log_:function fie(n){const e={x:E(n,"x","log","float32")};return R.runKernel(Xf,e)}}),d_=A({log1p_:function pie(n){const e={x:E(n,"x","log1p")};return R.runKernel(Yf,e)}}),_n=A({neg_:function mie(n){const e={x:E(n,"x","neg")};return R.runKernel(bb,e)}}),gd=A({softplus_:function gie(n){const e={x:E(n,"x","softplus")};return R.runKernel(hp,e)}}),mB=A({logSigmoid_:function yie(n){const t=E(n,"x","logSigmoid");return ga(r=>({value:_n(gd(_n(r))),gradFunc:o=>M(o,Fo(_n(r)))}))(t)}}),De=A({sub_:function bie(n,t){let e=E(n,"a","sub"),r=E(t,"b","sub");return[e,r]=An(e,r),R.runKernel(mp,{a:e,b:r})}}),MI=A({logSoftmax_:function _ie(n,t=-1){const e=E(n,"logits","logSoftmax");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return ga((s,i)=>{const a=Ri(s,t,!0),l=De(s,a),c=De(ve(l,"float32"),ai(Ae(oi(l),t,!0)));return i([c]),{value:c,gradFunc:(d,h)=>{const[f]=h,m=oi(f);return De(d,M(Ae(d,t,!0),m))}}})(e)}}),FI=A({logSumExp_:function vie(n,t=null,e=!1){const r=E(n,"x","logSumExp"),s=ft(t,r.shape),i=Ri(r,s,!0),o=De(r,i),a=oi(o),l=Ae(a,s),c=ai(l),u=le(F(i,c.shape),c);if(e){const d=Vn(u.shape,s);return F(u,d)}return u}}),Oo=A({logicalAnd_:function xie(n,t){const e=E(n,"a","logicalAnd","bool"),r=E(t,"b","logicalAnd","bool");return et(e.shape,r.shape),R.runKernel(lb,{a:e,b:r})}}),h_=A({logicalNot_:function wie(n){const e={x:E(n,"x","logicalNot","bool")};return R.runKernel(cb,e)}}),OI=A({logicalOr_:function Cie(n,t){const e=E(n,"a","logicalOr","bool"),r=E(t,"b","logicalOr","bool");return et(e.shape,r.shape),R.runKernel(ub,{a:e,b:r})}}),gB=A({logicalXor_:function Sie(n,t){const e=E(n,"a","logicalXor","bool"),r=E(t,"b","logicalXor","bool");return et(e.shape,r.shape),Oo(OI(n,t),h_(Oo(n,t)))}}),f_=2147483648,PI=A({searchSorted_:function Eie(n,t,e="left"){const r=E(n,"sortedSequence","searchSorted"),s=E(t,"values","searchSorted"),o=s.shape[s.shape.length-1],a=F(r,[-1,r.shape[r.shape.length-1]]),l=F(s,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(X(l.shape)>=f_)throw new Error(`values tensor size must less than ${f_}`);if(a.shape[1]>=f_)throw new Error(`trailing dim_size must less than ${f_} for int32 output type, was ${a.shape[1]}`);return R.runKernel(_E,{sortedSequence:a,values:l},{side:e})}});function Iie(n,t){return PI(n,t,"left")}const p_=A({maxPool_:function Die(n,t,e,r,s){const i=E(n,"x","maxPool");let a=i,l=!1;3===i.rank&&(l=!0,a=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),S(Nr(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),Zr("maxPool",r,s);const d=R.runKernel(fb,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return l?F(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),yB=A({maxPool3d_:function Tie(n,t=[1,1,1],e,r,s,i="NDHWC"){const o=E(n,"x","maxPool3d");let a=o,l=!1;4===o.rank&&(l=!0,a=F(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===i,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Zr("maxPool3d",r,s);const d=R.runKernel(pb,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:i});return l?F(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Nie=A({maxPoolWithArgmax_:function kie(n,t,e,r,s=!1){const o={x:E(n,"x","maxPoolWithArgmax")},l=R.runKernel(oE,o,{filterSize:t,strides:e,pad:r,includeBatchInIndex:s});return{result:l[0],indexes:l[1]}}}),_a=A({maximum_:function Aie(n,t){let e=E(n,"a","maximum"),r=E(t,"b","maximum");return[e,r]=An(e,r),"bool"===e.dtype&&(e=ve(e,"int32"),r=ve(r,"int32")),et(e.shape,r.shape),R.runKernel(Zf,{a:e,b:r})}}),Rn=A({mean_:function Rie(n,t=null,e=!1){const s={x:E(n,"x","mean")};return R.runKernel(mb,s,{axis:t,keepDims:e})}});function sr(n,t="float32"){if(ri(n),"complex64"===t){const r=sr(n,"float32"),s=sr(n,"float32");return el(r,s)}const e=Br(X(n),t);return R.makeTensor(e,n,t)}function li(n,t="float32"){if(ri(n),"complex64"===t){const r=li(n,"float32"),s=sr(n,"float32");return el(r,s)}const e=IS(X(n),t);return R.makeTensor(e,n,t)}function Mie(n,t,{indexing:e="xy"}={}){if("xy"!==e&&"ij"!==e)throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(void 0===n)return[];let r=E(n,"x","meshgrid",n instanceof pn?n.dtype:"float32");if(void 0===t)return[r];let s=E(t,"y","meshgrid",t instanceof pn?t.dtype:"float32");const i=X(r.shape),o=X(s.shape);return"xy"===e?(r=F(r,[1,-1]),s=F(s,[-1,1]),[mt(li([o,1],r.dtype),r),mt(s,li([1,i],s.dtype))]):(r=F(r,[-1,1]),s=F(s,[1,-1]),[mt(r,li([1,o],r.dtype)),mt(li([i,1],s.dtype),s)])}const Mp=A({minimum_:function Fie(n,t){let e=E(n,"a","minimum"),r=E(t,"b","minimum");return[e,r]=An(e,r),"bool"===e.dtype&&(e=ve(e,"int32"),r=ve(r,"int32")),et(e.shape,r.shape),R.runKernel(Qf,{a:e,b:r})}}),bB=A({mirrorPad_:function Oie(n,t,e){S("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const r=E(n,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");S(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s="reflect"===e?1:0;for(let a=0;a<r.rank;a++)S(2===t[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),S(t[a][0]>=0&&t[a][0]<=r.shape[a]-s&&t[a][1]>=0&&t[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);return R.runKernel(yb,{x:r},{paddings:t,mode:e})}}),_B=A({mod_:function Pie(n,t){let e=E(n,"a","mod"),r=E(t,"b","mod");return[e,r]=An(e,r),R.runKernel(Jf,{a:e,b:r})}}),m_=A({moments_:function $ie(n,t=null,e=!1){const r=ft(t,(n=E(n,"x","moments")).shape),s=Rn(n,r,e);let i=s.shape;e||(i=Vn(s.shape,r));const o=Jt(De(ve(n,"float32"),F(s,i)));return{mean:s,variance:Rn(o,r,e)}}}),Bie=A({multiRNNCell_:function Lie(n,t,e,r){const s=E(t,"data","multiRNNCell"),i=Yb(e,"c","multiRNNCell"),o=Yb(r,"h","multiRNNCell");let a=s;const l=[];for(let d=0;d<n.length;d++){const h=n[d](a,i[d],o[d]);l.push(h[0]),l.push(h[1]),a=h[1]}const c=[],u=[];for(let d=0;d<l.length;d+=2)c.push(l[d]),u.push(l[d+1]);return[c,u]}}),zie=A({multinomial_:function Vie(n,t,e,r=!1){const s=E(n,"logits","multinomial"),i=s.size,o=s.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);e=e||Math.random();const l={logits:1===o?F(s,[1,-1]):s},u=R.runKernel(aE,l,{numSamples:t,seed:e,normalized:r});return 1===o?F(u,[u.size]):u}}),yd=A({notEqual_:function Uie(n,t){let e=E(n,"a","notEqual","string_or_numeric"),r=E(t,"b","notEqual","string_or_numeric");return[e,r]=An(e,r),et(e.shape,r.shape),R.runKernel(_b,{a:e,b:r})}}),$I=A({oneHot_:function Hie(n,t,e=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:E(n,"indices","oneHot","int32")};return R.runKernel(xb,o,{dtype:s,depth:t,onValue:e,offValue:r})}}),ci=A({onesLike_:function Wie(n){const e={x:E(n,"x","onesLike")};return R.runKernel(vb,e)}}),Gie=A({outerProduct_:function jie(n,t){const e=E(n,"v1","outerProduct"),r=E(t,"v2","outerProduct");S(1===e.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${r.rank}.`);const s=F(e,[-1,1]),i=F(r,[1,-1]);return mt(s,i)}}),ul=A({pad_:function qie(n,t,e=0){const r=E(n,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return R.runKernel(Cb,{x:r},{paddings:t,constantValue:e})}}),Xie=A({pad1d_:function Kie(n,t,e=0){return S(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),ul(n,[t],e)}}),Zie=A({pad2d_:function Yie(n,t,e=0){return S(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),ul(n,t,e)}}),Jie=A({pad3d_:function Qie(n,t,e=0){return S(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),ul(n,t,e)}}),toe=A({pad4d_:function eoe(n,t,e=0){return S(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),ul(n,t,e)}}),g_=A({spaceToBatchND_:function noe(n,t,e){const r=E(n,"x","spaceToBatchND");return S(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),S(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),S(r.shape.reduce((o,a,l)=>l>0&&l<=t.length?o&&(a+e[l-1][0]+e[l-1][1])%t[l-1]==0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`),R.runKernel(Mb,{x:r},{blockShape:t,paddings:e})}}),vB=A({pool_:function roe(n,t,e,r,s,i,o){null==s&&(s=[1,1]),null==i&&(i=1),0===r&&(r="valid");const a=E(n,"x","maxPool");let l=a,c=!1;3===a.rank&&(c=!0,l=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(Nr(i,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${s}'`);const u=Ai(l.shape,t,i,s,r),d=[u.dilationHeight,u.dilationWidth];let h;h="same"===r?function ioe(n,t){const r=n.map((o,a)=>o+(o-1)*(t[a]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),i=r.map((o,a)=>o-s[a]);return r.map((o,a)=>[s[a],i[a]])}([u.filterHeight,u.filterWidth],d):[[0,0],[0,0]];const f=1===d[0]&&1===d[1],[p,m]=function soe(n,t,e){const r=e.map(u=>u[0]),s=e.map(u=>u[1]),i=n.concat(r,s),o=t.map((u,d)=>(u-i[d]%u)%u),a=s.map((u,d)=>u+o[d]),l=t.map((u,d)=>[r[d],a[d]]),c=t.map((u,d)=>[0,o[d]]);return[l,c]}([u.inHeight,u.inWidth],d,h),g=f?r:"valid",y=f?l:g_(l,d,p),_=("avg"===e?()=>i_(y,t,i,g,o):()=>p_(y,t,i,g,o))(),v=f?_:o_(_,d,m);return c?F(v,[v.shape[1],v.shape[2],v.shape[3]]):v}}),y_=A({prelu_:function ooe(n,t){const e=E(n,"x","prelu"),r=E(t,"alpha","prelu");return R.runKernel(Sb,{x:e,alpha:r})}}),xB=A({prod_:function aoe(n,t=null,e=!1){let r=E(n,"x","prod");return"bool"===r.dtype&&(r=ve(r,"int32")),R.runKernel(Eb,{x:r},{axis:t,keepDims:e})}}),coe=A({raggedGather_:function loe(n,t,e,r){const s=n.map((u,d)=>E(u,`tensors${d}`,"raggedGather","int32")),i=E(t,"paramsDenseValues","raggedGather"),o=E(e,"indices","raggedGather","int32"),c=R.runKernel(dE,{paramsNestedSplits:s,paramsDenseValues:i,indices:o},{outputRaggedRank:r});return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}}),doe=A({raggedRange_:function uoe(n,t,e){const r=E(n,"starts","raggedRange"),s=E(t,"limits","raggedRange",r.dtype),i=E(e,"deltas","raggedRange",r.dtype),a=R.runKernel(hE,{starts:r,limits:s,deltas:i});return{rtNestedSplits:a[0],rtDenseValues:a[1]}}}),foe=A({raggedTensorToTensor_:function hoe(n,t,e,r,s){const i=E(n,"shape","raggedTensorToTensor","int32"),o=E(t,"values","raggedTensorToTensor"),a=E(e,"defaultValue","raggedTensorToTensor",o.dtype),l=r.map((d,h)=>E(d,`tensors${h}`,"raggedTensorToTensor","int32"));return R.runKernel(fE,{shape:i,values:o,defaultValue:a,rowPartitionTensors:l},{rowPartitionTypes:s})}}),moe=A({rand_:function poe(n,t,e){ri(n);const r=X(n);let s=null;if(null==e||"float32"===e)s=new Float32Array(r);else if("int32"===e)s=new Int32Array(r);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);s=new Uint8Array(r)}for(let i=0;i<r;i++)s[i]=t();return R.makeTensor(s,n,e)}});var b_=Q(340);class LI{constructor(t,e,r,s,i){this.mean=t,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=i||Math.random();this.random=b_.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let t,e,r=!1;for(;!r;){let s,i,o;do{s=2*this.random()-1,i=2*this.random()-1,o=s*s+i*i}while(o>=1||0===o);const a=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*s*a,e=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class goe{constructor(t,e,r,s){this.alpha=t,this.beta=1/e,this.dtype=r;const i=s||Math.random();this.randu=b_.alea(i.toString()),this.randn=new LI(0,1,r,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,r,s,i,o;for(;;){do{s=this.randn.nextValue(),o=1+this.c*s}while(o<=0);if(o*=o*o,t=s*s,e=1-.331*t*t,r=.5*t+this.d*(1-o+Math.log(o)),i=this.randu(),i<e||Math.log(i)<r)break}return o*=1/this.beta*this.d,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class yoe{constructor(t=0,e=1,r,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=r,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=b_.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const woe=A({randomGamma_:function xoe(n,t,e=1,r="float32",s){if(ri(n),null==e&&(e=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const i=new goe(t,e,r,s),o=ot(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),VI=A({randomNormal_:function Coe(n,t=0,e=1,r,s){if(ri(n),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const i=new LI(t,e,r,!1,s),o=ot(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),Eoe=A({randomStandardNormal_:function Soe(n,t,e){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return VI(n,0,1,t,e)}}),Fp=A({randomUniform_:function Ioe(n,t=0,e=1,r="float32",s){ri(n);const i=ot(n,r),o=new yoe(t,e,null,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}});function bd(n,t,e=1,r="float32"){if(0===e)throw new Error("Cannot have a step of zero");return R.runKernel(pE,{},{start:n,stop:t,step:e,dtype:r})}const Op=A({real_:function Doe(n){const e={input:E(n,"input","real")};return R.runKernel(mE,e)}}),wB=A({reciprocal_:function Toe(n){const e={x:E(n,"x","reciprocal")};return R.runKernel(np,e)}}),Po=A({relu_:function koe(n){const e={x:E(n,"x","relu")};return R.runKernel(rp,e)}}),zI=A({relu6_:function Noe(n){const e={x:E(n,"x","relu6")};return R.runKernel(sp,e)}}),Fi=A({reverse_:function Aoe(n,t){const r={x:E(n,"x","reverse")};return R.runKernel(kb,r,{dims:t})}}),Moe=A({reverse1d_:function Roe(n){const t=E(n,"x","reverse");return S(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Fi(t,0)}}),Ooe=A({reverse2d_:function Foe(n,t){const e=E(n,"x","reverse");return S(2===e.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),Fi(e,t)}}),$oe=A({reverse3d_:function Poe(n,t){const e=E(n,"x","reverse");return S(3===e.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),Fi(e,t)}}),Boe=A({reverse4d_:function Loe(n,t){const e=E(n,"x","reverse");return S(4===e.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),Fi(e,t)}}),UI=A({round_:function Voe(n){const e={x:E(n,"x","round")};return R.runKernel(ip,e)}}),HI=A({rsqrt_:function zoe(n){const e={x:E(n,"x","rsqrt","float32")};return R.runKernel(op,e)}}),WI=A({selu_:function Uoe(n){const e={x:E(n,"x","selu")};return R.runKernel(ap,e)}}),jI=A({separableConv2d_:function Hoe(n,t,e,r,s,i=[1,1],o="NHWC"){const a=E(n,"x","separableConv2d"),l=E(t,"depthwiseFilter","separableConv2d"),c=E(e,"pointwiseFilter","separableConv2d");let u=a,d=!1;if(3===a.rank&&(d=!0,u=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");S(4===u.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),S(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),S(4===c.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),S(1===c.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),S(1===c.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const h=l.shape[2],f=l.shape[3];S(c.shape[2]===h*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*f}, but got ${c.shape[2]}.`);const p=Dp(u,l,r,s,o,i),g=ol(p,c,1,"valid",o);return d?F(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});function GI(){return(GI=ee(function*(n,t){const e=E(n,"x","setdiff1d"),r=E(t,"y","setdiff1d");S(e.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${r.dtype}).`),S(1===e.rank,()=>`x should be 1D tensor, but got x (${e.shape}).`),S(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=yield e.data(),i=yield r.data(),o=new Set(i);let a=0;for(let u=0;u<s.length;u++)o.has(s[u])||a++;const l=new vr([a],e.dtype),c=new vr([a],"int32");for(let u=0,d=0;u<s.length;u++)o.has(s[u])||(l.values[d]=s[u],c.values[d]=u,d++);return[l.toTensor(),c.toTensor()]})).apply(this,arguments)}const joe=function Woe(n,t){return GI.apply(this,arguments)},CB=A({sign_:function Goe(n){const e={x:E(n,"x","sign")};return R.runKernel(up,e)}}),qI=A({sin_:function qoe(n){const e={x:E(n,"x","sin","float32")};return R.runKernel(lp,e)}}),KI=A({sinh_:function Koe(n){const e={x:E(n,"x","sinh")};return R.runKernel(cp,e)}}),__=A({slice1d_:function Xoe(n,t,e){const r=E(n,"x","slice1d");return S(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Dt(r,[t],[e])}}),XI=A({slice2d_:function Yoe(n,t,e){const r=E(n,"x","slice2d");return S(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Dt(r,t,e)}}),v_=A({slice3d_:function Zoe(n,t,e){const r=E(n,"x","slice3d");return S(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Dt(r,t,e)}}),Pp=A({slice4d_:function Qoe(n,t,e){const r=E(n,"x","slice4d");return S(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Dt(r,t,e)}}),x_=A({softmax_:function Joe(n,t=-1){const e=E(n,"logits","softmax","float32");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);return R.runKernel(Ob,{logits:e},{dim:t})}}),w_=A({fft_:function eae(n){return S("complex64"===n.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`),R.runKernel("FFT",{input:n})}}),$p=A({ifft_:function tae(n){return S("complex64"===n.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`),R.runKernel(eE,{input:n})}}),YI=A({irfft_:function nae(n){const t=n.shape[n.shape.length-1],e=n.size/t;let r;if(t<=2){const s=F(n,[e,t]);r=$p(s)}else{const s=[e,2*(t-1)],i=F(Op(n),[e,t]),o=F(c_(n),[e,t]),a=Fi(Dt(i,[0,1],[e,t-2]),1),l=M(Fi(Dt(o,[0,1],[e,t-2]),1),Be(-1)),c=Xn([i,a],1),u=Xn([o,l],1),d=F(el(c,u),[s[0],s[1]]);r=$p(d)}if(r=Op(r),3===n.rank&&0!==n.shape[0]){const s=r,i=n.shape[0];r=F(r,[i,r.shape[0]/i,r.shape[1]]),s.dispose()}return r}}),$s=A({split_:function rae(n,t,e=0){const s={x:E(n,"x","split")};return R.runKernel(Fb,s,{numOrSizeSplits:t,axis:e})}}),C_=A({rfft_:function sae(n,t){S("float32"===n.dtype,()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const r=n.size/e;let s;if(null!=t&&t<e){const p=n.shape.map(g=>0),m=n.shape.map(g=>g);m[n.shape.length-1]=t,s=Dt(n,p,m),e=t}else if(null!=t&&t>e){const p=n.shape.map(m=>m);p[n.shape.length-1]=t-e,s=Xn([n,sr(p)],n.shape.length-1),e=t}else s=n;const i=Tt(s),o=F(el(s,i),[r,e]),a=w_(o),l=Math.floor(e/2)+1,c=Op(a),u=c_(a),d=$s(c,[l,e-l],c.shape.length-1),h=$s(u,[l,e-l],u.shape.length-1),f=s.shape.slice();return f[s.shape.length-1]=l,F(el(d[0],h[0]),f)}}),ZI=A({squaredDifference_:function iae(n,t){let e=E(n,"a","squaredDifference"),r=E(t,"b","squaredDifference");return[e,r]=An(e,r),et(e.shape,r.shape),R.runKernel(pp,{a:e,b:r},{})}}),_c=A({squeeze_:function oae(n,t){const e=E(n,"x","squeeze","string_or_numeric");return F(e,Ka(e.shape,t).newShape)}}),ui=A({stack_:function aae(n,t=0){const e=Yb(n,"tensors","stack","string_or_numeric");return S(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&S(t<=e[0].rank,()=>"Axis must be <= rank of the tensor"),R.runKernel(wb,e,{axis:t})}}),_d=A({step_:function lae(n,t=0){const r={x:E(n,"x","step")};return R.runKernel(_p,r,{alpha:t})}}),SB=A({stridedSlice_:function cae(n,t,e,r,s=0,i=0,o=0,a=0,l=0){const u={x:E(n,"x","stridedSlice","string_or_numeric")};return R.runKernel(IE,u,{begin:t,end:e,strides:r,beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l})}}),EB=A({tan_:function uae(n){const e={x:E(n,"x","tan","float32")};return R.runKernel(gp,e)}});function ys(n,t){Xu(n);const e=Ja(n,t);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return tl(n,null,e,t)}function Lp(n,t,e){if(Xu(n),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Ja(n,e);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return tl(n,t,r,e)}function dae(n,t,e){if(Xu(n),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=Ja(n,e);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return tl(n,t,r,e)}function hae(n,t,e){if(Xu(n),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=Ja(n,e);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return tl(n,t,r,e)}function fae(n,t,e){if(Xu(n),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=Ja(n,e);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return tl(n,t=t||r,r,e)}const IB=A({topk_:function pae(n,t=1,e=!0){const r=E(n,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const i={x:r},o={k:t,sorted:e},[a,l]=R.runKernel(NE,i,o);return{values:a,indices:l}}}),QI=A({truncatedNormal_:function mae(n,t=0,e=1,r,s){if(ri(n),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const i=new LI(t,e,r,!0,s),o=ot(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),DB=A({unique_:function gae(n,t=0){const e=E(n,"x","unique","string_or_numeric");S(e.rank>0,()=>"The input tensor must be at least 1D");const r={x:e},s={axis:t},[i,o]=R.runKernel(RE,r,s);return{values:i,indices:o}}}),JI=A({unsortedSegmentSum_:function yae(n,t,e){const r=E(n,"x","unsortedSegmentSum"),s=E(t,"segmentIds","unsortedSegmentSum","int32");return S(Zu(e),()=>"numSegments must be of dtype int"),R.runKernel($b,{x:r,segmentIds:s},{numSegments:e})}}),Oi=A({unstack_:function bae(n,t=0){const e=E(n,"x","unstack","string_or_numeric");return S(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`),R.runKernel(Pb,{value:e},{axis:t})}});function _ae(n,t){return PI(n,t,"right")}function TB(n,t=!0,e,r){return R.makeVariable(n,t,e,r)}function eD(n,t){const e=[];for(let i=0;i<t.length;i++)t[i]&&e.push(i);const r=ot(n,"int32"),s=ot([e.length,n.length],"int32");for(let i=0;i<e.length;i++){const o=r.indexToLoc(e[i]);s.values.set(o,i*n.length)}return s.toTensor()}function tD(){return(tD=ee(function*(n){const t=E(n,"condition","whereAsync","bool"),e=yield t.data(),r=eD(t.shape,e);return n!==t&&t.dispose(),r})).apply(this,arguments)}const kB=function vae(n){return tD.apply(this,arguments)};function nD(){return(nD=ee(function*(n,t,e){const r=E(n,"tensor","boolMask"),s=E(t,"mask","boolMask","bool"),i=e??0,o=s.rank,a=r.shape;S(o>0,()=>"mask cannot be scalar"),Ms(a.slice(i,i+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=i;m<i+o;m++)l*=a[m];const c=a.slice(0,i).concat([l],a.slice(i+o)),u=F(r,c),d=F(s,[-1]),h=yield kB(d),f=_c(h,[1]),p=Rp(u,f,i);return n!==r&&r.dispose(),t!==s&&s.dispose(),f.dispose(),u.dispose(),d.dispose(),h.dispose(),p})).apply(this,arguments)}const wae=function xae(n,t,e){return nD.apply(this,arguments)},wt=A({transpose_:function Cae(n,t,e){const r=E(n,"x","transpose");if(null==t&&(t=r.shape.map((o,a)=>a).reverse()),S(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(o=>{S(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();const s={x:r},i={perm:t};return"complex64"===r.dtype?V(()=>{let o=Op(r),a=c_(r);return o=R.runKernel(nd,{x:o},i),a=R.runKernel(nd,{x:a},i),e&&(a=_n(a)),el(o,a)}):R.runKernel(nd,s,i)}}),Eae=A({movingAverage_:function Sae(n,t,e,r,s=!0){const i=E(n,"v","movingAverage"),o=E(t,"x","movingAverage"),a=E(e,"decay","movingAverage");(function une(n,t){S(n.dtype===t.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`)})(i,o),S(It(i.shape,o.shape),()=>"Shape mismatch in v and x");const l=Be(1),c=De(l,a);let u=M(De(o,i),c);if(s){S(null!=r,()=>"When using zeroDebias: true, step is required.");const d=E(r,"step","movingAverage");u=Pe(u,De(l,ll(a,d)))}return le(i,u)}});function NB(n,t,e){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(e.rank<s)throw new Error(i+` update.rank < ${s}. `);if(n.length<r+(e.rank-s))throw new Error(i+` Output shape length < ${r+(e.rank-s)}`);if(e.rank!==s+n.length-r)throw new Error(i+" update.rank != "+(s+n.length-r));for(let o=0;o<s;++o)if(e.shape[o]!==t.shape[o])throw new Error(i+` updates.shape[${o}] (${e.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<e.rank-s;++o)if(e.shape[o+s]!==n[o+r])throw new Error(i+` updates.shape[${o+s}] (${e.shape[o+s]}) != shape[${o+s}] (${n[o+s]})`)}function AB(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===n.size)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}NB(e,t,n)}function Bp(n,t,e){const r=t.shape.length,s=r>1?t.shape[r-1]:1,i=e.length;let o=1;for(let d=s;d<i;++d)o*=e[d];const a=s<1?1:s;return{sliceRank:s,numUpdates:X(t.shape)/a,sliceSize:o,strides:[...Le(e.slice(0,s)),1],outputSize:X(e)}}const Dae=A({scatterND_:function Iae(n,t,e){ri(e);const r=E(n,"indices","scatterND","int32"),s=E(t,"updates","scatterND");return AB(s,r,e),R.runKernel(bE,{indices:r,updates:s},{shape:e})}}),Nae=A({sparseToDense_:function kae(n,t,e,r=0){ri(e);const s=E(n,"sparseIndices","sparseToDense","int32"),i=E(t,"sparseValues","sparseToDense","string_or_numeric"),o=E(r,"defaultValue","sparseToDense",i.dtype);return function Tae(n,t,e,r){if("int32"!==n.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(e.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${i}.`);if(0!==t.rank&&(1!==t.rank||t.size!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,i,e,o),R.runKernel(SE,{sparseIndices:s,sparseValues:i,defaultValue:o},{outputShape:e})}}),Rae=A({gatherND_:function Aae(n,t){const e=E(t,"indices","gatherND","int32"),s={params:E(n,"x","gatherND","string_or_numeric"),indices:e};return R.runKernel(JS,s)}}),RB=A({dropout_:function Fae(n,t,e,r){const s=E(n,"x","dropout");if(S("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),S(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return n instanceof pn?s.clone():s;const i=function Mae(n,t){if(null==t)return n.shape.slice();if(It(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let r=0;r<n.shape.length;r++)e.push(null==t[r]&&null!=n.shape[r]?n.shape[r]:t[r]);return e}return t}(s,e),o=1-t,a=Pe(Ap(le(Fp(i,0,1,"float32",r),o)),o);return M(s,a)}});function MB(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function rD(n,t,e){const r=1-n%2,s=new Float32Array(n);for(let i=0;i<n;++i){const o=2*Math.PI*i/(n+r-1);s[i]=t-e*Math.cos(o)}return ys(s,"float32")}function sD(){return(sD=ee(function*(n,t,e=1){const r=E(n,"predictions","inTopK"),s=E(t,"targets","inTopK");S(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),S(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Ms(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=r.shape[r.shape.length-1];S(e>0&&e<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${e}`);const o=yield r.data(),a=yield s.data(),[l,c]=[o.length/i,i],u=br("bool",l);for(let d=0;d<l;d++){const h=d*c,f=o.subarray(h,h+c),p=[];for(let m=0;m<f.length;m++)p.push({value:f[m],index:m});p.sort((m,g)=>g.value-m.value),u[d]=0;for(let m=0;m<e;m++)if(p[m].index===a[d]){u[d]=1;break}}return n!==r&&r.dispose(),t!==s&&s.dispose(),ao(u,s.shape,"bool")})).apply(this,arguments)}const Pae=function Oae(n,t){return sD.apply(this,arguments)},iD=A({conv2DBackpropFilter_:function $ae(n,t,e,r,s,i="NHWC",o){let a=n;3===n.rank&&(a=F(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;3===l.rank&&(l=F(t,[1,t.shape[0],t.shape[1],t.shape[2]])),S(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),S(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),S(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const c="NHWC"===i?a.shape[3]:a.shape[1],u="NHWC"===i?l.shape[3]:l.shape[1];return S(c===e[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${e[2]}.`),S(u===e[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${e[3]}).`),Zr("conv2dDerFilter",s,o),R.runKernel(PS,{x:a,dy:l},{strides:r,pad:s,dataFormat:i,dimRoundingMode:o,filterShape:e})}});function S_(n,t,e){if(null==e||"linear"===e)return n;if("relu"===e)return M(n,_d(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function E_(n,t){let e=t;const r=nr(n.shape,t.shape);return r.length>0&&(e=Ae(e,r)),F(e,n.shape)}function I_(n,t,e,r){if("linear"===t)return n;if("relu"===t)return Po(n);if("elu"===t)return Tp(n);if("relu6"===t)return zI(n);if("prelu"===t)return y_(n,e);if("leakyrelu"===t)return u_(n,r);if("sigmoid"===t)return Fo(n);throw new Error(`Unknown fused activation ${t}.`)}const D_=(n,t)=>!(n>0)||"linear"===t,FB=A({fusedConv2d_:function Lae({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(!1===D_(R.state.gradientDepth,l=l||"linear")){S("NHWC"===s,()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let C=ol(n,t,e,r,s,i,o);return null!=a&&(C=le(C,a)),I_(C,l,c,u)}const d=E(n,"x","conv2d","float32"),h=E(t,"filter","conv2d","float32");let f=d,p=!1;3===d.rank&&(p=!0,f=F(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(4===f.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),S(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),Zr("fused conv2d",r,o);const m="NHWC"===s?f.shape[3]:f.shape[1];S(h.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`),S(Nr(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const g=wr(f.shape,h.shape,e,i,r,o);let y,b;if(null!=a&&(y=E(a,"bias","fused conv2d"),[y]=An(y,d),"NHWC"===s?et(g.outShape,y.shape):(S(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),S(0===y.shape.length||y.shape[0]===g.outChannels||1===y.shape[0],()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`))),null!=c){const C=c.shape;if(S(C.length<=1||3===C.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${C.length}.`),1===C.length)S(1===C[0]||C[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the number of output channels (${g.outChannels}).`);else if(3===C.length)try{et(C,g.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the output shape of the conv2d (${g.outShape}).`)}b=E(c,"prelu weights","fused conv2d")}const _=(C,I)=>{S("NHWC"===s,()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[D,T,N,$]=I,z=S_(C,N,l);S(il(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const K=[SI(T.shape,z,D,e,r),iD(T,z,D.shape,e,r)];if(null!=$){const P=E_($,z);K.push(P)}return K},v={x:f,filter:h,bias:y,preluActivationWeights:b},w={strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return null==a?ga((I,D,T)=>{let N=R.runKernel(Vb,v,w);return T([D,I,N]),p&&(N=F(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:_}})(f,h):ga((I,D,T,N)=>{let $=R.runKernel(Vb,v,w);return N([D,I,$,T]),p&&($=F($,[$.shape[1],$.shape[2],$.shape[3]])),{value:$,gradFunc:_}})(f,h,y)}}),OB=A({depthwiseConv2dNativeBackpropFilter_:function Bae(n,t,e,r,s,i=[1,1],o){let a=n;3===n.rank&&(a=F(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;return 3===l.rank&&(l=F(t,[1,t.shape[0],t.shape[1],t.shape[2]])),R.runKernel(HS,{x:a,dy:l},{strides:r,pad:s,dimRoundingMode:o,dilations:i,filterShape:e})}}),PB=A({depthwiseConv2dNativeBackpropInput_:function Vae(n,t,e,r,s,i=[1,1],o){let a=t,l=!1;3===t.rank&&(l=!0,a=F(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const d=R.runKernel(WS,{dy:a,filter:e},{strides:r,pad:s,dimRoundingMode:o,dilations:i,inputShape:n});return l?F(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Uae=A({fusedDepthwiseConv2d_:function zae({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(!1===D_(R.state.gradientDepth,l)){let w=Dp(n,t,e,r,s,i,o);return null!=a&&(w=le(w,a)),I_(w,l,c,u)}const d=E(n,"x","depthwiseConv2d","float32"),h=E(t,"filter","depthwiseConv2d","float32");let f=d,p=!1;3===d.rank&&(p=!0,f=F(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(4===f.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),S(4===h.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),S(f.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),null==i&&(i=[1,1]),S(Nr(e,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),Zr("fused depthwiseConv2d",r,o);const m=wr(f.shape,h.shape,e,i,r,o,!0);let g,y;null!=a&&(g=E(a,"bias","fused conv2d"),[g]=An(g,d),et(m.outShape,g.shape)),null!=c&&(y=E(c,"prelu weights","fused depthwiseConv2d"));const b=(w,C)=>{S(il(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[I,D,T,N]=C,$=S_(w,T,l),z=PB(D.shape,$,I,e,r,i,o),j=OB(D,$,I.shape,e,r,i,o);return null!=N?[z,j,E_(g,$)]:[z,j]},_={x:f,filter:h,bias:g,preluActivationWeights:y},v={strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return null==a?ga((C,I,D)=>{let T=R.runKernel(zb,_,v);return D([I,C,T]),p&&(T=F(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:b}})(f,h):ga((C,I,D,T)=>{let N=R.runKernel(zb,_,v);return T([I,C,N,D]),p&&(N=F(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:b}})(f,h,g)}}),oD=A({fusedMatMul_:function Hae({a:n,b:t,transposeA:e=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(!1===D_(R.state.gradientDepth,i)){let $=mt(n,t,e,r);return null!=s&&($=le($,s)),I_($,i,o,a)}let l=E(n,"a","fused matMul"),c=E(t,"b","fused matMul");[l,c]=An(l,c);const u=e?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?c.shape[c.rank-1]:c.shape[c.rank-2],h=e?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?c.shape[c.rank-2]:c.shape[c.rank-1],p=l.shape.slice(0,-2),m=c.shape.slice(0,-2),g=X(p),y=X(m);S(u===d,()=>`Error in fused matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${e} and transposeB=${r} must match.`);const _=et(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([h,f]),v=F(l,e?[g,u,h]:[g,h,u]),w=F(c,r?[y,f,d]:[y,d,f]);let C,I;null!=s&&(C=E(s,"bias","fused matMul"),[C]=An(C,l),et(_,C.shape)),null!=o&&(I=E(o,"prelu weights","fused matMul"));const D=($,z)=>{const[j,q,K,P]=z,B=S_(F($,K.shape),K,i);let L,W;return e||r?!e&&r?(L=mt(B,q,!1,!1),W=mt(B,j,!0,!1)):e&&!r?(L=mt(q,B,!1,!0),W=mt(j,B,!1,!1)):(L=mt(q,B,!0,!0),W=mt(B,j,!0,!0)):(L=mt(B,q,!1,!0),W=mt(j,B,!0,!1)),null!=s?[L,W,E_(P,B)]:[L,W]},T={a:v,b:w,bias:C,preluActivationWeights:I},N={transposeA:e,transposeB:r,activation:i,leakyreluAlpha:a};return null==s?ga((z,j,q)=>{const K=R.runKernel(Bb,T,N);return q([z,j,K]),{value:F(K,_),gradFunc:D}})(v,w):ga((z,j,q,K)=>{const P=R.runKernel(Bb,T,N);return K([z,j,P,q]),{value:F(P,_),gradFunc:D}})(v,w,C)}}),jae=A({hammingWindow_:function Wae(n){return rD(n,.54,.46)}}),$B=A({hannWindow_:function Gae(n){return rD(n,.5,.5)}}),LB=A({frame_:function qae(n,t,e,r=!1,s=0){let i=0;const o=[];for(;i+t<=n.size;)o.push(Dt(n,i,t)),i+=e;if(r)for(;i<n.size;){const a=i+t-n.size,l=Xn([Dt(n,i,t-a),md([a],s)]);o.push(l),i+=e}return 0===o.length?Lp([],[0,t]):F(Xn(o),[o.length,t])}}),Xae=A({stft_:function Kae(n,t,e,r,s=$B){null==r&&(r=MB(t));const i=LB(n,t,e),o=M(i,s(t));return C_(o,r)}}),Zae=A({cropAndResize_:function Yae(n,t,e,r,s="bilinear",i=0){const o=E(n,"image","cropAndResize"),a=E(t,"boxes","cropAndResize","float32"),l=E(e,"boxInd","cropAndResize","int32"),c=a.shape[0];return S(4===o.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),S(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),S(1===l.rank&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),S(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),S(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),S("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),R.runKernel(VS,{image:o,boxes:a,boxInd:l},{method:s,extrapolationValue:i,cropSize:r})}}),Jae=A({flipLeftRight_:function Qae(n){const t=E(n,"image","flipLeftRight","float32");return S(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),R.runKernel(QS,{image:t},{})}}),tle=A({grayscaleToRGB_:function ele(n){const t=E(n,"image","grayscaleToRGB"),e=t.rank-1,r=t.shape[e];S(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),S(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(t.rank);return s.fill(1,0,e),s[e]=3,Mi(t,s)}}),rle=A({rotateWithOffset_:function nle(n,t,e=0,r=.5){const s=E(n,"image","rotateWithOffset","float32");return S(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),R.runKernel(FE,{image:s},{radians:t,fillValue:e,center:r})}});function vd(n,t,e,r,s,i){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==i&&(i=0);const o=n.shape[0];return e=Math.min(e,o),S(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),S(2===n.rank,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),S(4===n.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),S(1===t.rank,()=>"scores must be a 1D tensor"),S(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),S(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:s,softNmsSigma:i}}const ile=A({nonMaxSuppression_:function sle(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const i=E(n,"boxes","nonMaxSuppression","float32"),o=E(t,"scores","nonMaxSuppression","float32"),a=vd(i,o,e,r,s);return R.runKernel(lE,{boxes:i,scores:o},{maxOutputSize:e=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}});function ole(n,t,e){const r=function ale(n,t,e){return function cle(n,t,e){let r=0,s=n.length,i=0,o=!1;for(;r<s;){i=r+(s-r>>>1);const a=e(t,n[i]);a>0?r=i+1:(s=i,o=!a)}return o?r:-r-1}(n,t,e||lle)}(n,t,e);n.splice(r<0?-(r+1):r,0,t)}function lle(n,t){return n>t?1:n<t?-1:0}function aD(n,t,e,r,s){return uD(n,t,e,r,s,0)}function lD(n,t,e,r,s,i){return uD(n,t,e,r,s,0,!1,i,!0)}function cD(n,t,e,r,s,i){return uD(n,t,e,r,s,i,!0)}function uD(n,t,e,r,s,i,o=!1,a=!1,l=!1){const c=[];for(let g=0;g<t.length;g++)t[g]>s&&c.push({score:t[g],boxIndex:g,suppressBeginIndex:0});c.sort(BB);const u=i>0?-.5/i:0,d=[],h=[];for(;d.length<e&&c.length>0;){const g=c.pop(),{score:y,boxIndex:b,suppressBeginIndex:_}=g;if(y<s)break;let v=!1;for(let w=d.length-1;w>=_;--w){const C=ule(n,b,d[w]);if(C>=r){v=!0;break}if(g.score=g.score*dle(r,u,C),g.score<=s)break}g.suppressBeginIndex=d.length,v||(g.score===y?(d.push(b),h.push(g.score)):g.score>s&&ole(c,g,BB))}const f=d.length,p=e-f;a&&p>0&&(d.push(...new Array(p).fill(0)),h.push(...new Array(p).fill(0)));const m={selectedIndices:d};return o&&(m.selectedScores=h),l&&(m.validOutputs=f),m}function ule(n,t,e){const r=n.subarray(4*t,4*t+4),s=n.subarray(4*e,4*e+4),i=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),u=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),f=(a-i)*(l-o),p=(d-c)*(h-u);if(f<=0||p<=0)return 0;const m=Math.max(i,c),g=Math.max(o,u),y=Math.min(a,d),b=Math.min(l,h),_=Math.max(y-m,0)*Math.max(b-g,0);return _/(f+p-_)}function dle(n,t,e){const r=Math.exp(t*e*e);return e<=n?r:0}function BB(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}function dD(){return(dD=ee(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const i=E(n,"boxes","nonMaxSuppressionAsync"),o=E(t,"scores","nonMaxSuppressionAsync"),a=vd(i,o,e,r,s);e=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=yield Promise.all([i.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:d}=aD(c,u,e,r,s);return i!==n&&i.dispose(),o!==t&&o.dispose(),ys(d,"int32")})).apply(this,arguments)}const mle=A({nonMaxSuppressionWithScore_:function ple(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=E(n,"boxes","nonMaxSuppression"),a=E(t,"scores","nonMaxSuppression"),l=vd(o,a,e,r,s,i),d=R.runKernel(uE,{boxes:o,scores:a},{maxOutputSize:e=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:i=l.softNmsSigma});return{selectedIndices:d[0],selectedScores:d[1]}}});function hD(){return(hD=ee(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=E(n,"boxes","nonMaxSuppressionAsync"),a=E(t,"scores","nonMaxSuppressionAsync"),l=vd(o,a,e,r,s,i);e=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const c=yield Promise.all([o.data(),a.data()]),u=c[0],d=c[1],{selectedIndices:h,selectedScores:f}=cD(u,d,e,r,s,i);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:ys(h,"int32"),selectedScores:ys(f)}})).apply(this,arguments)}const _le=A({nonMaxSuppressionPadded_:function ble(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=E(n,"boxes","nonMaxSuppression"),a=E(t,"scores","nonMaxSuppression"),l=vd(o,a,e,r,s,null),p=R.runKernel(cE,{boxes:o,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:i});return{selectedIndices:p[0],validOutputs:p[1]}}});function fD(){return(fD=ee(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=E(n,"boxes","nonMaxSuppressionAsync"),a=E(t,"scores","nonMaxSuppressionAsync"),l=vd(o,a,e,r,s,null),c=l.maxOutputSize,u=l.iouThreshold,d=l.scoreThreshold,[h,f]=yield Promise.all([o.data(),a.data()]),{selectedIndices:p,validOutputs:m}=lD(h,f,c,u,d,i);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:ys(p,"int32"),validOutputs:Be(m,"int32")}})).apply(this,arguments)}const VB=A({resizeBilinear_:function wle(n,t,e=!1,r=!1){const s=E(n,"images","resizeBilinear");S(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),S(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),S(!1===r||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;3===s.rank&&(o=!0,i=F(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,c=R.runKernel(Tb,{images:i},{alignCorners:e,halfPixelCenters:r,size:t});return o?F(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),zB=A({resizeNearestNeighbor_:function Cle(n,t,e=!1,r=!1){const s=E(n,"images","resizeNearestNeighbor");S(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),S(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),S("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),S(!1===r||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;3===s.rank&&(o=!0,i=F(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,c=R.runKernel(Db,{images:i},{alignCorners:e,halfPixelCenters:r,size:t});return o?F(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),Ile=A({threshold_:function Sle(n,t="binary",e=!1,r=.5){const s=E(n,"image","threshold"),l=s.shape[0]*s.shape[1];let u,d,h,f,c=M(ys([r]),255);if(S(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),S(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),S("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),S("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===s.shape[2]){[u,d,h]=$s(s,[1,1,1],-1);const g=M(u,.2989),y=M(d,.587),b=M(h,.114);f=le(le(g,y),b)}else f=n;"otsu"===t&&(c=function Ele(n,t){let i,o,a,l,c,u,e=ys([-1]),r=ys([0]),s=ys([0]);for(let d=0;d<n.size-1;d++){i=Dt(n,0,d+1),o=Dt(n,d+1),c=Pe(Ae(i),t),u=Pe(Ae(o),t);const h=Ae(M(i,bd(0,i.size)));a=Pe(h,Ae(i));const f=md(o.shape,i.size),p=le(bd(0,o.size),f),m=M(o,p);l=Pe(Ae(m),Ae(o));const g=De(a,l),y=De(a,l),b=M(c,u);s=M(M(b,g),y);const _=Ps(s,r);r=ms(_,s,r),e=ms(_,ys([d]),e)}return e}(qL(ve(UI(f),"int32"),ao([]),256),l));const p=e?bc(f,c):Ps(f,c);return ve(M(p,255),"int32")}}),Tle=A({transform_:function Dle(n,t,e="nearest",r="constant",s=0,i){const o=E(n,"image","transform","float32"),a=E(t,"transforms","transform","float32");return S(4===o.rank,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),S(2===a.rank&&(a.shape[0]===o.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),S(null==i||2===i.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`),R.runKernel(AE,{image:o,transforms:a},{interpolation:e,fillMode:r,fillValue:s,outputShape:i})}}),Nle=A({bandPart_:function kle(n,t,e){S(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),S(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);const r=E(n,"a","bandPart");S(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[i,o]=r.shape.slice(-2);if(!(t<=i))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`);if(!(e<=o))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${o}).`);t<0&&(t=i),e<0&&(e=o);const a=F(bd(0,i,1,"int32"),[-1,1]),l=bd(0,o,1,"int32"),c=De(a,l),u=Oo(bc(c,Be(+t,"int32")),cl(c,Be(-e,"int32"))),d=sr([i,o],r.dtype);return F(ui(Oi(F(r,[-1,i,o])).map(h=>ms(u,h,d))),s)}}),Rle=A({gramSchmidt_:function Ale(n){let t;if(Array.isArray(n)){t=!1,S(null!=n&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let i=1;i<n.length;++i)S(n[i].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${s})`)}else t=!0,n=$s(n,n.shape[0],0).map(s=>_c(s,[0]));S(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],r=n;for(let s=0;s<n.length;++s)e.push(R.tidy(()=>{let i=r[s];if(s>0)for(let o=0;o<s;++o){const a=M(Ae(M(e[o],i)),e[o]);i=De(i,a)}return Pe(i,Np(i,"euclidean"))}));return t?ui(e,0):e}});function UB(n,t=!1){return R.tidy(()=>{S(2===n.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],r=n.shape[1];let s=AI(e),i=ma(n);const o=Lp([[1]],[1,1]);let a=ma(o);const l=e>=r?r:e;for(let c=0;c<l;++c){const u=i,d=a,h=s;[a,i,s]=R.tidy(()=>{const f=Dt(i,[c,c],[e-c,1]),p=Np(f),m=Dt(i,[c,c],[1,1]),g=ms(Ps(m,0),Lp([[-1]]),Lp([[1]])),y=De(m,M(g,p)),b=Pe(f,y);a=1===b.shape[0]?ma(o):Xn([o,Dt(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const _=_n(Pe(mt(g,y),p)),v=Dt(i,[c,0],[e-c,r]),w=M(_,a),C=wt(a);if(0===c)i=De(v,mt(w,mt(C,v)));else{const T=De(v,mt(w,mt(C,v)));i=Xn([Dt(i,[0,0],[c,r]),T],0)}const I=wt(w),D=Dt(s,[0,c],[e,s.shape[1]-c]);if(0===c)s=De(D,mt(mt(D,a),I));else{const T=De(D,mt(mt(D,a),I));s=Xn([Dt(s,[0,0],[e,c]),T],1)}return[a,i,s]}),Qe([u,d,h])}return!t&&e>r&&(s=Dt(s,[0,0],[e,r]),i=Dt(i,[0,0],[r,r])),[s,i]})}const Fle=A({qr_:function Mle(n,t=!1){if(S(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),2===n.rank)return UB(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),r=Oi(F(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],i=[];return r.forEach(l=>{const[c,u]=UB(l,t);s.push(c),i.push(u)}),[F(ui(s,0),n.shape),F(ui(i,0),n.shape)]}}});var Qr=(()=>{return(n=Qr||(Qr={}))[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",Qr;var n})();const va=A({computeWeightedLoss_:function Ole(n,t,e=Qr.SUM_BY_NONZERO_WEIGHTS){const r=E(n,"losses","computeWeightedLoss");let s=null;null!=t&&(s=E(t,"weights","computeWeightedLoss"));const i=null==s?r:M(r,s);if(e===Qr.NONE)return i;if(e===Qr.SUM)return Ae(i);if(e===Qr.MEAN){if(null==s)return Rn(i);{const o=r.size/s.size,a=Pe(Ae(i),Ae(s));return o>1?Pe(a,Be(o)):a}}if(e===Qr.SUM_BY_NONZERO_WEIGHTS){if(null==s)return Pe(Ae(i),Be(r.size));{const o=M(s,li(r.shape)),a=ve(Ae(yd(o,Be(0))),"float32");return Pe(Ae(i),a)}}throw Error(`Unknown reduction: ${e}`)}}),$le=A({absoluteDifference_:function Ple(n,t,e,r=Qr.SUM_BY_NONZERO_WEIGHTS){const s=E(n,"labels","absoluteDifference"),i=E(t,"predictions","absoluteDifference");let o=null;null!=e&&(o=E(e,"weights","absoluteDifference")),Ms(s.shape,i.shape,"Error in absoluteDifference: ");const a=rr(De(s,i));return va(a,o,r)}}),Ble=A({cosineDistance_:function Lle(n,t,e,r,s=Qr.SUM_BY_NONZERO_WEIGHTS){const i=E(n,"labels","cosineDistance"),o=E(t,"predictions","cosineDistance");let a=null;null!=r&&(a=E(r,"weights","cosineDistance")),Ms(i.shape,o.shape,"Error in cosineDistance: ");const l=Be(1),c=De(l,Ae(M(i,o),e,!0));return va(c,a,s)}}),zle=A({hingeLoss_:function Vle(n,t,e,r=Qr.SUM_BY_NONZERO_WEIGHTS){let s=E(n,"labels","hingeLoss");const i=E(t,"predictions","hingeLoss");let o=null;null!=e&&(o=E(e,"weights","hingeLoss")),Ms(s.shape,i.shape,"Error in hingeLoss: ");const a=Be(1);s=De(M(Be(2),s),a);const l=Po(De(a,M(s,i)));return va(l,o,r)}}),Hle=A({huberLoss_:function Ule(n,t,e,r=1,s=Qr.SUM_BY_NONZERO_WEIGHTS){const i=E(n,"labels","huberLoss"),o=E(t,"predictions","huberLoss");let a=null;null!=e&&(a=E(e,"weights","huberLoss")),Ms(i.shape,o.shape,"Error in huberLoss: ");const l=Be(r),c=rr(De(o,i)),u=Mp(c,l),d=De(c,u),h=le(M(Be(.5),Jt(u)),M(l,d));return va(h,a,s)}}),jle=A({logLoss_:function Wle(n,t,e,r=1e-7,s=Qr.SUM_BY_NONZERO_WEIGHTS){const i=E(n,"labels","logLoss"),o=E(t,"predictions","logLoss");let a=null;null!=e&&(a=E(e,"weights","logLoss")),Ms(i.shape,o.shape,"Error in logLoss: ");const l=Be(1),c=Be(r),u=_n(M(i,ai(le(o,c)))),d=M(De(l,i),ai(le(De(l,o),c))),h=De(u,d);return va(h,a,s)}}),qle=A({meanSquaredError_:function Gle(n,t,e,r=Qr.SUM_BY_NONZERO_WEIGHTS){const s=E(n,"labels","meanSquaredError"),i=E(t,"predictions","meanSquaredError");let o=null;null!=e&&(o=E(e,"weights","meanSquaredError")),Ms(s.shape,i.shape,"Error in meanSquaredError: ");const a=ZI(s,i);return va(a,o,r)}}),Yle=A({sigmoidCrossEntropy_:function Xle(n,t,e,r=0,s=Qr.SUM_BY_NONZERO_WEIGHTS){let i=E(n,"multiClassLabels","sigmoidCrossEntropy");const o=E(t,"logits","sigmoidCrossEntropy");let a=null;if(null!=e&&(a=E(e,"weights","sigmoidCrossEntropy")),Ms(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const c=Be(r),u=Be(1),d=Be(.5);i=le(M(i,De(u,c)),M(d,c))}const l=function Kle(n,t){const e=E(n,"labels","sigmoidCrossEntropyWithLogits"),r=E(t,"logits","sigmoidCrossEntropyWithLogits");Ms(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Po(r),i=M(r,e),o=d_(oi(_n(rr(r))));return le(De(s,i),o)}(i,o);return va(l,a,s)}}),Jle=A({softmaxCrossEntropy_:function Qle(n,t,e,r=0,s=Qr.SUM_BY_NONZERO_WEIGHTS){let i=E(n,"onehotLabels","softmaxCrossEntropy");const o=E(t,"logits","softmaxCrossEntropy");let a=null;if(null!=e&&(a=E(e,"weights","softmaxCrossEntropy")),Ms(i.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const c=Be(r),u=Be(1),d=Be(i.shape[1]);i=le(M(i,De(u,c)),Pe(c,d))}const l=function Zle(n,t,e=-1){if(-1===e&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return ga((s,i,o)=>{const l=FI(i,[e],!0),c=De(ve(i,"float32"),l);o([s,c]);const u=_n(M(c,s));return{value:Ae(u,[e]),gradFunc:(f,p)=>{const[m,g]=p,y=Vn(f.shape,[e]);return[M(F(f,y),De(ve(m,"float32"),oi(g))),M(F(f,y),De(oi(g),ve(m,"float32")))]}}})(n,t)}(i,o);return va(l,a,s)}}),tce=A({sparseFillEmptyRows_:function ece(n,t,e,r){const s=E(n,"indices","sparseFillEmptyRows","int32"),i=E(t,"values","sparseFillEmptyRows"),o=E(e,"denseShape","sparseFillEmptyRows","int32"),a=E(r,"defaultValue","sparseFillEmptyRows",i.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==i.rank)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(1!==o.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(0!==a.rank)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const c=R.runKernel(vE,{indices:s,values:i,denseShape:o,defaultValue:a});return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}}),rce=A({sparseReshape_:function nce(n,t,e){const r=E(n,"inputIndices","sparseReshape","int32"),s=E(t,"inputShape","sparseReshape","int32"),i=E(e,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const a=R.runKernel(xE,{inputIndices:r,inputShape:s,newShape:i});return{outputIndices:a[0],outputShape:a[1]}}}),ice=A({sparseSegmentMean_:function sce(n,t,e){const r=E(n,"data","sparseSegmentMean"),s=E(t,"indices","sparseSegmentMean","int32"),i=E(e,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${i.shape}`);return R.runKernel(wE,{data:r,indices:s,segmentIds:i})}}),ace=A({sparseSegmentSum_:function oce(n,t,e){const r=E(n,"data","sparseSegmentSum"),s=E(t,"indices","sparseSegmentSum","int32"),i=E(e,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${i.shape}`);return R.runKernel(CE,{data:r,indices:s,segmentIds:i})}}),cce=A({stringNGrams_:function lce(n,t,e,r,s,i,o,a){const l=E(n,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=E(t,"dataSplits","stringNGrams");if("int32"!==c.dtype)throw new Error("Data splits must be of datatype int32");const h=R.runKernel(DE,{data:l,dataSplits:c},{separator:e,nGramWidths:r,leftPad:s,rightPad:i,padWidth:o,preserveShortSequences:a});return{nGrams:h[0],nGramsSplits:h[1]}}}),dce=A({stringSplit_:function uce(n,t,e=!0){const r=E(n,"input","stringSplit","string"),s=E(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a=R.runKernel(TE,{input:r,delimiter:s},{skipEmpty:e});return{indices:a[0],values:a[1],shape:a[2]}}}),fce=A({stringToHashBucketFast_:function hce(n,t){const e=E(n,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");return R.runKernel(kE,{input:e},r)}}),pce={fft:w_,ifft:$p,rfft:C_,irfft:YI},mce={hammingWindow:jae,hannWindow:$B,frame:LB,stft:Xae},xa={flipLeftRight:Jae,grayscaleToRGB:tle,resizeNearestNeighbor:zB,resizeBilinear:VB,rotateWithOffset:rle,cropAndResize:Zae,nonMaxSuppression:ile,nonMaxSuppressionAsync:function hle(n,t,e){return dD.apply(this,arguments)},nonMaxSuppressionWithScore:mle,nonMaxSuppressionWithScoreAsync:function gle(n,t,e){return hD.apply(this,arguments)},nonMaxSuppressionPadded:_le,nonMaxSuppressionPaddedAsync:function vle(n,t,e){return fD.apply(this,arguments)},threshold:Ile,transform:Tle},HB={bandPart:Nle,gramSchmidt:Rle,qr:Fle},gce={absoluteDifference:$le,computeWeightedLoss:va,cosineDistance:Ble,hingeLoss:zle,huberLoss:Hle,logLoss:jle,meanSquaredError:qle,sigmoidCrossEntropy:Yle,softmaxCrossEntropy:Jle},yce={sparseFillEmptyRows:tce,sparseReshape:rce,sparseSegmentMean:ice,sparseSegmentSum:ace},bce={stringNGrams:cce,stringSplit:dce,stringToHashBucketFast:fce};let pD=(()=>{class n extends rl{constructor(e,r,s=null){super(),this.learningRate=e,this.rho=r,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==s&&(this.epsilon=R.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=R.registeredVariables[s];null==this.accumulatedGrads[i]&&(this.accumulatedGrads[i]={originalName:`${s}/accum_grad`,variable:V(()=>Tt(o).variable(!1))}),null==this.accumulatedUpdates[i]&&(this.accumulatedUpdates[i]={originalName:`${s}/accum_var`,variable:V(()=>Tt(o).variable(!1))});const l=Array.isArray(e)?e[i].tensor:e[s];if(null==l)return;const c=this.accumulatedGrads[i].variable,u=this.accumulatedUpdates[i].variable;V(()=>{const d=le(M(c,this.rho),M(Jt(l),1-this.rho)),h=M(Pe(Vr(le(u,this.epsilon)),Vr(le(c,this.epsilon))),l),f=le(M(u,this.rho),M(Jt(h),1-this.rho));c.assign(d),u.assign(f);const p=le(M(h,-this.learningRate),o);o.assign(p)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Qe(this.accumulatedGrads.map(e=>e.variable)),Qe(this.accumulatedUpdates.map(e=>e.variable)))}getWeights(){var e=this;return ee(function*(){const r=[...e.accumulatedGrads,...e.accumulatedUpdates];return[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return ee(function*(){const s=(e=yield r.extractIterations(e)).length/2;r.accumulatedGrads=e.slice(0,s).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),r.accumulatedUpdates=e.slice(s,2*s).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,r){return new e(r.learningRate,r.rho,r.epsilon)}}return n.className="Adadelta",n})();se(pD);let mD=(()=>{class n extends rl{constructor(e,r=.1){super(),this.learningRate=e,this.initialAccumulatorValue=r,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=R.registeredVariables[s];null==this.accumulatedGrads[i]&&(this.accumulatedGrads[i]={originalName:`${s}/accumulator`,variable:V(()=>md(o.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[i].tensor:e[s];if(null==a)return;const l=this.accumulatedGrads[i].variable;V(()=>{const c=le(l,Jt(a));l.assign(c);const u=le(M(Pe(a,Vr(le(c,R.backend.epsilon()))),-this.learningRate),o);o.assign(u)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Qe(this.accumulatedGrads.map(e=>e.variable))}getWeights(){var e=this;return ee(function*(){return[yield e.saveIterations()].concat(e.accumulatedGrads.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(e){var r=this;return ee(function*(){e=yield r.extractIterations(e),r.accumulatedGrads=e.map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,r){return new e(r.learningRate,r.initialAccumulatorValue)}}return n.className="Adagrad",n})();se(mD);let gD=(()=>{class n extends rl{constructor(e,r,s,i=null){super(),this.learningRate=e,this.beta1=r,this.beta2=s,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],V(()=>{this.accBeta1=Be(r).variable(),this.accBeta2=Be(s).variable()}),null==i&&(this.epsilon=R.backend.epsilon())}applyGradients(e){const r=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);V(()=>{const s=De(1,this.accBeta1),i=De(1,this.accBeta2);r.forEach((o,a)=>{const l=R.registeredVariables[o];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:V(()=>Tt(l).variable(!1))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${o}/v`,variable:V(()=>Tt(l).variable(!1))});const u=Array.isArray(e)?e[a].tensor:e[o];if(null==u)return;const d=this.accumulatedFirstMoment[a].variable,h=this.accumulatedSecondMoment[a].variable,f=le(M(d,this.beta1),M(u,1-this.beta1)),p=le(M(h,this.beta2),M(Jt(u),1-this.beta2)),m=Pe(f,s),g=Pe(p,i);d.assign(f),h.assign(p);const y=le(M(Pe(m,le(Vr(g),this.epsilon)),-this.learningRate),l);l.assign(y)}),this.accBeta1.assign(M(this.accBeta1,this.beta1)),this.accBeta2.assign(M(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Qe(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&Qe(this.accumulatedSecondMoment.map(e=>e.variable))}getWeights(){var e=this;return ee(function*(){const r=[...e.accumulatedFirstMoment,...e.accumulatedSecondMoment];return[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return ee(function*(){e=yield r.extractIterations(e),V(()=>{r.accBeta1.assign(ll(r.beta1,r.iterations_+1)),r.accBeta2.assign(ll(r.beta2,r.iterations_+1))});const s=e.length/2;r.accumulatedFirstMoment=e.slice(0,s).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),r.accumulatedSecondMoment=e.slice(s,2*s).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,r){return new e(r.learningRate,r.beta1,r.beta2,r.epsilon)}}return n.className="Adam",n})();se(gD);let yD=(()=>{class n extends rl{constructor(e,r,s,i=null,o=0){super(),this.learningRate=e,this.beta1=r,this.beta2=s,this.epsilon=i,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],V(()=>{this.iteration=Be(0).variable(),this.accBeta1=Be(r).variable()}),null==i&&(this.epsilon=R.backend.epsilon())}applyGradients(e){const r=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);V(()=>{const s=De(1,this.accBeta1),i=Pe(-this.learningRate,le(M(this.iteration,this.decay),1));r.forEach((o,a)=>{const l=R.registeredVariables[o];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:Tt(l).variable(!1)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${o}/v`,variable:Tt(l).variable(!1)});const u=Array.isArray(e)?e[a].tensor:e[o];if(null==u)return;const d=this.accumulatedFirstMoment[a].variable,h=this.accumulatedWeightedInfNorm[a].variable,f=le(M(d,this.beta1),M(u,1-this.beta1)),p=M(h,this.beta2),m=rr(u),g=_a(p,m);d.assign(f),h.assign(g);const y=le(M(Pe(i,s),Pe(f,le(g,this.epsilon))),l);l.assign(y)}),this.iteration.assign(le(this.iteration,1)),this.accBeta1.assign(M(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Qe(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&Qe(this.accumulatedWeightedInfNorm.map(e=>e.variable))}getWeights(){return ee(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(e){return ee(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,r){return new e(r.learningRate,r.beta1,r.beta2,r.epsilon,r.decay)}}return n.className="Adamax",n})();se(yD);let T_=(()=>{class n extends rl{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=Array.isArray(e)?e[i].tensor:e[s];if(null==o)return;const a=R.registeredVariables[s];V(()=>{const l=le(M(this.c,o),a);a.assign(l)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=xr(Be(-e))}dispose(){this.c.dispose()}getWeights(){var e=this;return ee(function*(){return[yield e.saveIterations()]})()}setWeights(e){var r=this;return ee(function*(){if(0!==(e=yield r.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,r){return new e(r.learningRate)}}return n.className="SGD",n})();se(T_);let bD=(()=>{class n extends T_{constructor(e,r,s=!1){super(e),this.learningRate=e,this.momentum=r,this.useNesterov=s,this.accumulations=[],this.m=Be(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=R.registeredVariables[s];null==this.accumulations[i]&&(this.accumulations[i]={originalName:`${s}/momentum`,variable:V(()=>Tt(o).variable(!1))});const a=this.accumulations[i].variable,l=Array.isArray(e)?e[i].tensor:e[s];null!=l&&V(()=>{let c;const u=le(M(this.m,a),l);c=le(M(this.c,this.useNesterov?le(l,M(u,this.m)):u),o),a.assign(u),o.assign(c)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Qe(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}getWeights(){var e=this;return ee(function*(){return[yield e.saveIterations()].concat(e.accumulations.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(e){var r=this;return ee(function*(){e=yield r.extractIterations(e),r.accumulations=e.map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,r){return new e(r.learningRate,r.momentum,r.useNesterov)}}return n.className="Momentum",n})();se(bD);let _D=(()=>{class n extends rl{constructor(e,r=.9,s=0,i=null,o=!1){if(super(),this.learningRate=e,this.decay=r,this.momentum=s,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,null==i&&(this.epsilon=R.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=R.registeredVariables[s],a=!1;null==this.accumulatedMeanSquares[i]&&(this.accumulatedMeanSquares[i]={originalName:`${s}/rms`,variable:V(()=>Tt(o).variable(a))}),null==this.accumulatedMoments[i]&&(this.accumulatedMoments[i]={originalName:`${s}/momentum`,variable:V(()=>Tt(o).variable(a))}),null==this.accumulatedMeanGrads[i]&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${s}/mg`,variable:V(()=>Tt(o).variable(a))});const l=Array.isArray(e)?e[i].tensor:e[s];if(null==l)return;const c=this.accumulatedMeanSquares[i].variable,u=this.accumulatedMoments[i].variable;V(()=>{const d=le(M(c,this.decay),M(Jt(l),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[i].variable,f=le(M(h,this.decay),M(l,1-this.decay)),p=Pe(M(l,this.learningRate),Vr(De(d,le(Jt(f),this.epsilon)))),m=le(M(u,this.momentum),p);c.assign(d),h.assign(f),u.assign(m);const g=De(o,m);o.assign(g)}else{const h=le(M(c,this.decay),M(Jt(l),1-this.decay)),f=le(M(u,this.momentum),Pe(M(l,this.learningRate),Vr(le(h,this.epsilon))));c.assign(h),u.assign(f);const p=De(o,f);o.assign(p)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Qe(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&Qe(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&Qe(this.accumulatedMoments.map(e=>e.variable))}getWeights(){var e=this;return ee(function*(){const r=[...e.accumulatedMeanSquares,...e.accumulatedMoments];return e.centered&&r.push(...e.accumulatedMeanGrads),[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return ee(function*(){e=yield r.extractIterations(e);const s=r.centered?e.length/3:e.length/2,i=!1;r.accumulatedMeanSquares=e.slice(0,s).map(o=>({originalName:o.name,variable:o.tensor.variable(i)})),r.accumulatedMoments=e.slice(s,2*s).map(o=>({originalName:o.name,variable:o.tensor.variable(i)})),r.centered&&(r.accumulatedMeanGrads=e.slice(2*s,3*s).map(o=>({originalName:o.name,variable:o.tensor.variable(i)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,r){return new e(r.learningRate,r.decay,r.momentum,r.epsilon,r.centered)}}return n.className="RMSProp",n})();se(_D);class vc{static sgd(t){return new T_(t)}static momentum(t,e,r=!1){return new bD(t,e,r)}static rmsprop(t,e=.9,r=0,s=null,i=!1){return new _D(t,e,r,s,i)}static adam(t=.001,e=.9,r=.999,s=null){return new gD(t,e,r,s)}static adadelta(t=.001,e=.95,r=null){return new pD(t,e,r)}static adamax(t=.002,e=.9,r=.999,s=null,i=0){return new yD(t,e,r,s,i)}static adagrad(t,e=.1){return new mD(t,e)}}const xd={sgd:vc.sgd,momentum:vc.momentum,adadelta:vc.adadelta,adagrad:vc.adagrad,rmsprop:vc.rmsprop,adamax:vc.adamax,adam:vc.adam},_ce=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function WB(){return new Promise(n=>_ce(()=>n()))}function vD(n,t){const e=n[0].length;n.forEach((s,i)=>{S(s.length===e,()=>`Error in concat${e}D: rank of tensors[${i}] must be the same as the rank of the rest (${e})`)}),S(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const r=n[0];n.forEach((s,i)=>{for(let o=0;o<e;o++)S(o===t||s[o]===r[o],()=>`Error in concat${e}D: Shape of tensors[${i}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`)})}function $o(n,t){const e=n[0].slice();for(let r=1;r<n.length;r++)e[t]+=n[r][t];return e}var Pi=(()=>{return(n=Pi||(Pi={}))[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS",Pi;var n})();function jB(n,t,e){let r=new Array;if(null==e&&null==t)return r;if(null==t)for(;r.length<n+e.length;)r.push(-1);else r=t.slice();if(null==e)return r;if(n+e.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${r.length}`);for(let s=1;s<e.length;++s){const i=e[s],o=r[r.length-e.length+s],a=r[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+n}] = ${i} but shape[${s+n}] = ${a}`)}else r[o]=i}return r}function GB(n){const t={FIRST_DIM_SIZE:Pi.FIRST_DIM_SIZE,VALUE_ROWIDS:Pi.VALUE_ROWIDS,ROW_LENGTHS:Pi.ROW_LENGTHS,ROW_SPLITS:Pi.ROW_SPLITS,ROW_LIMITS:Pi.ROW_LIMITS,ROW_STARTS:Pi.ROW_STARTS},e=[];for(const r of n){if(!(r in t))break;e.push(t[r])}return e}function qB(n){return 0===n.length?0:n[0]===Pi.FIRST_DIM_SIZE?n.length-1:n.length}function KB(n,t){if(null==n||null==t)return;const e=n.length,r=t.length;if(e>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(e,r-1);++s){const i=n[s],o=t[s+1];if(i>=0&&o>=0&&1!==i&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-n.length}] = ${i} but ragged tensor input.flatValues.shape[${s-n.length}] = ${o}`)}}const xD=30;function k_(n){return n<=xD?n:ES(n,Math.floor(Math.sqrt(n)))}function wD(n,t,e){return[e*("number"==typeof n?n:n[0]),t*("number"==typeof n?n:n[1])]}function Vp(n,t,e,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(n[0]/e),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const i=t.length;for(let o=0;o<i;++o)s=s.concat([n[o+1]/t[o],t[o]]);s=s.concat(n.slice(i+1))}return s}function zp(n,t,e=!0){const r=[];if(e){r.push(t);for(let s=t+1;s<n;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{const s=[],i=[];for(let o=1;o<n;++o)o>=2*t+1||o%2==1?i.push(o):s.push(o);r.push(...s),r.push(0),r.push(...i)}return r}function Up(n,t,e,r=!0){const s=[];s.push(r?n[0]/e:n[0]*e);for(let i=1;i<n.length;++i)s.push(i<=t.length?r?t[i-1]*n[i]:n[i]/t[i-1]:n[i]);return s}function CD(n,t){const e=[0];for(let r=0;r<t;++r)e.push(n[r][0]);return e}function SD(n,t,e){const r=n.slice(0,1);for(let s=0;s<e;++s)r.push(n[s+1]-t[s][0]-t[s][1]);return r}function ED(n,t){const e=n.shape.length,r=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${e}`);if(0===X(n.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=t.shape,i=s[s.length-1];let o=1;for(let d=0;d<s.length-1;++d)o*=s[d];const a=n.shape,l=s.slice();l.pop();let c=1;for(let d=i;d<e;++d)c*=a[d],l.push(a[d]);const u=[...Le(n.shape).map(d=>d/c),1].slice(0,i);return[l,o,c,u]}const N_=1.7580993408473768,A_=1.0507009873554805,ID=.3275911,DD=.254829592,TD=-.284496736,kD=1.421413741,ND=-1.453152027,AD=1.061405429;function wa(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(2*n.length);for(let r=0;r<e.length;r+=2)e[r]=n[r/2],e[r+1]=t[r/2];return e}function XB(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)t[r/2]=n[r],e[r/2]=n[r+1];return{real:t,imag:e}}function YB(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function ZB(n){const t=Math.floor(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function RD(n,t){return{real:n[2*t],imag:n[2*t+1]}}function QB(n,t,e,r){n[2*r]=t,n[2*r+1]=e}function JB(n,t){const e=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const i=(t?2:-2)*Math.PI*(s/n);e[s]=Math.cos(i),r[s]=Math.sin(i)}return{real:e,imag:r}}function eV(n,t,e){const r=(e?2:-2)*Math.PI*(n/t);return{real:Math.cos(r),imag:Math.sin(r)}}const vce=/->/g;function FD(n,t){const e=((n=n.replace(/\s/g,"")).length-n.replace(vce,"").length)/"->".length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,s]=n.split("->");S(-1===r.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const i=r.split(","),o=i.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<s.length;++h){const f=s[h];if(!i.some(p=>-1!==p.indexOf(f)))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);-1===a.indexOf(f)&&a.push(f)}for(let h=0;h<r.length;++h){const f=r[h];-1===a.indexOf(f)&&","!==f&&a.push(f)}const l=new Array(i.length);for(let h=0;h<o;++h){if(new Set(i[h].split("")).size!==i[h].length)throw new Error(`Found duplicate axes in input component ${i[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let f=0;f<i[h].length;++f)l[h].push(a.indexOf(i[h][f]))}const c=a.length,d=[];for(let h=s.length;h<c;++h)d.push(h);return{allDims:a,summedDims:d,idDims:l}}function OD(n,t){let e=new Array(n);e.fill(-1);for(let s=0;s<t.length;++s)e[t[s]]=s;const r=[];for(let s=0;s<n;++s)-1===e[s]&&r.push(s);return e=e.filter(s=>-1!==s),{permutationIndices:e,expandDims:r}}function PD(n,t,e){const r=new Array(n);for(let s=0;s<e.length;++s){const i=e[s].shape;for(let o=0;o<t[s].length;++o)void 0===r[t[s][o]]?r[t[s][o]]=i[o]:S(r[t[s][o]]===i[o],()=>`Expected dimension ${r[t[s][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function $D(n,t){const e=n,r=[];let s=0;0===n.length&&e.push(-1),s=n.length+1;for(let o=0;o<s;++o)r.push([]);const i=[];for(let o=0;o<e.length;++o){const l=xce(t,e[o]);for(const c of l)-1===i.indexOf(c)&&(r[o].push(c),i.push(c))}return{path:e,steps:r}}function LD(n){return n.every((t,e)=>t===e)}function xce(n,t){const e=[];for(let r=0;r<n.length;++r)(0===n[r].length||-1!==n[r].indexOf(t)||-1===t)&&e.push(r);return e}function BD(n,t,e=0){let r=[];if("number"==typeof t)S(n.shape[e]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(n.shape[e]/t);else{S(t.reduce((o,a)=>(-1===a&&(o+=1),o),0)<=1,()=>"There should be only one negative value in split array.");const i=t.indexOf(-1);if(-1!==i){const o=t.reduce((a,l)=>l>0?a+l:a);t[i]=n.shape[e]-o}S(n.shape[e]===t.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function rV(n){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${n}`}function sV(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function iV(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function oV(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function aV(n,t){return`size ${n} must be non-negative, not ${t}`}function lV(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function cV(n,t){return`Input to reshape is a SparseTensor with ${X(n)}\n  dense values, but the requested shape requires a multiple of ${X(t)}. inputShape=${n} outputShape= ${t}`}function uV(n,t){return`Input to reshape is a tensor with ${X(n)} dense values, but the requested shape has ${X(t)}. inputShape=${n} outputShape=${t}`}function VD(){return"segment ids must be >= 0"}function dV(){return"segment ids are not increasing"}function hV(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function fV(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function pV(n,t){let r,e=!1;for(n<=xD?(r=n,e=!0):r=ES(n,Math.floor(Math.sqrt(n)));!e;)r>t||r===n?e=!0:r=ES(n,r+1);return r}function mV(n,t,e){const r=[],s=n.length;for(let i=0;i<s;i++)r.push(i!==t?n[i]:e);return r}function zD(n,t,e,r){const s=t.shape.length,i=n.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>i)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${i}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let d=0;d<r;++d)if(n.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const o=n.shape[e],a=[];let l=1,c=1,u=1;for(let d=0;d<r;++d)a.push(n.shape[d]),l*=n.shape[d];for(let d=r;d<e;d++)a.push(n.shape[d]),c*=n.shape[d];for(let d=r;d<s;d++)a.push(t.shape[d]);for(let d=e+1;d<i;d++)a.push(n.shape[d]),u*=n.shape[d];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}function xc(n){try{return n.map(t=>Qa(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function gV(n){return n.map(t=>Za(t))}const yV={kernelName:Ly,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,_d(ve(e,"float32"),-1))}}},wce={kernelName:Ef,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=Jt(ve(e,"float32")),s=Vr(De(Be(1),r));return _n(Pe(n,s))}}}},Cce={kernelName:If,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=Vr(De(Jt(ve(e,"float32")),1));return Pe(n,r)}}}},Sce={kernelName:td,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=et(e.shape,r.shape);return{a:()=>{let a=n;const l=nr(e.shape,s);return l.length>0&&(a=Ae(a,l)),F(a,e.shape)},b:()=>{let a=n;const l=nr(r.shape,s);return l.length>0&&(a=Ae(a,l)),F(a,r.shape)}}}},Ece={kernelName:By,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((r,s)=>{e[s]=()=>n.clone()}),e}},Ice={kernelName:Vy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Tt(e)}}},Dce={kernelName:zy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Tt(e)}}},Tce={kernelName:Df,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,Vr(De(Be(1),Jt(ve(e,"float32")))))}}},kce={kernelName:Tf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=Vr(le(Be(1),Jt(ve(e,"float32"))));return Pe(n,r)}}}},Nce={kernelName:Af,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=et(e.shape,r.shape);return{a:()=>{const a=le(Jt(e),Jt(r));let l=M(n,Pe(r,a));const c=nr(e.shape,s);return c.length>0&&(l=Ae(l,c)),F(l,e.shape)},b:()=>{const a=le(Jt(e),Jt(r));let l=_n(M(n,Pe(e,a)));const c=nr(r.shape,s);return c.length>0&&(l=Ae(l,c)),F(l,r.shape)}}}},Ace={kernelName:kf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,le(Jt(ve(e,"float32")),1))}}},Rce={kernelName:Nf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,De(Be(1),Jt(ve(e,"float32"))))}}},Fce=A({avgPool3dGrad_:function Mce(n,t,e,r,s,i){const o=E(n,"dy","avgPool3dGrad"),a=E(t,"input","avgPool3dGrad");let l=o,c=a,u=!1;4===a.rank&&(u=!0,l=F(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),S(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),S(5===c.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),Zr("avgPool3dGrad",s,i);const f=R.runKernel(RS,{dy:l,input:c},{filterSize:e,strides:r,pad:s,dimRoundingMode:i});return u?F(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),Oce={kernelName:Hy,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:a}=e;return{x:()=>Fce(n,r,s,i,o,a)}}},$ce=A({avgPoolGrad_:function Pce(n,t,e,r,s){const i=E(n,"dy","avgPoolGrad"),o=E(t,"input","avgPoolGrad");S(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,c=!1;3===o.rank&&(c=!0,a=F(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),S(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const h=R.runKernel(AS,{dy:l,input:a},{filterSize:e,strides:r,pad:s});return c?F(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Lce={kernelName:Uy,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:s,strides:i,pad:o}=e;return{x:()=>$ce(n,r,s,i,o)}}},Bce={kernelName:Wy,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[r,s]=t,{transposeA:i,transposeB:o}=e;return i||o?!i&&o?{a:()=>mt(n,s,!1,!1),b:()=>mt(n,r,!0,!1)}:i&&!o?{a:()=>mt(s,n,!1,!0),b:()=>mt(r,n,!1,!1)}:{a:()=>mt(s,n,!0,!0),b:()=>mt(n,r,!0,!0)}:{a:()=>mt(n,s,!1,!0),b:()=>mt(r,n,!0,!1)}}},Vce={kernelName:jy,gradFunc:(n,t,e)=>{const{blockShape:r,crops:s}=e;return{x:()=>g_(n,r,s)}}},zce={kernelName:"BroadcastTo",gradFunc:(n,t,e)=>{const s=e.inputShape,i=e.shape,o=Array.from(i);for(let l=s.length-1;l>=0;l--)if(s[l]===i[l])o[l]=1;else if(1!==s[l])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>Ae(n,a,!0)}}},Uce={kernelName:Rf,gradFunc:n=>({x:()=>n.clone()})},Hce={kernelName:Mf,gradFunc:n=>({x:()=>Tt(n)})},Wce={kernelName:Ff,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{clipValueMin:s,clipValueMax:i}=e;return{x:()=>ms(Oo(cl(r,s),bc(r,i)),n,Tt(n))}}},jce={kernelName:Gy,inputsToSave:["x"],gradFunc:yV.gradFunc},Gce={kernelName:qy,saveAllInputs:!0,gradFunc:(n,t,e)=>{const r=t.map(l=>l.shape),{axis:s}=e,i=ft(s,t[0].shape)[0],o=r.map(l=>l[i]);return $s(n,o,i).map(l=>()=>l)}},qce={kernelName:Ky,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,{dilations:i,strides:o,pad:a,dataFormat:l}=e;return S(il(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>SI(r.shape,n,s,o,a,l),filter:()=>iD(r,n,s.shape,o,a,l)}}},Kce={kernelName:Xy,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>ol(n,s,i,o,a,1,l),filter:()=>iD(n,r,s.shape,i,o,a,l)}}},Yce=A({conv3DBackpropFilter_:function Xce(n,t,e,r,s){let i=n;4===n.rank&&(i=F(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=t;return 4===o.rank&&(o=F(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),S(5===i.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),S(5===o.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),S(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),S(i.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${e[3]}.`),S(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`),R.runKernel($S,{x:i,dy:o},{strides:r,pad:s,filterShape:e})}}),Zce={kernelName:Yy,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:s,pad:i}=e;S(il(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,a]=t;return{x:()=>eB(o.shape,n,a,s,i),filter:()=>Yce(o,n,a.shape,s,i)}}},Qce={kernelName:Of,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(_n(qI(ve(e,"float32"))),n)}}},Jce={kernelName:Pf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(KI(ve(e,"float32")),n)}}},eue={kernelName:Zy,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s,exclusive:i,reverse:o}=e;return{x:()=>{const a=Dn([s],r.rank);let l=DI(n,s,i,!o);return null!=a&&(l=wt(l,a)),l}}}},tue={kernelName:Qy,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:s,pad:i,dimRoundingMode:o}=e,a=r??[1,1];S(il(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=t;return S(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),S(4===c.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),S(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),S(Nr(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),Zr("depthwiseConv2d",i,o),{x:()=>PB(l.shape,n,c,s,i,a,o),filter:()=>OB(l,n,c.shape,s,i,a,o)}}},nue={kernelName:Jy,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,i={x:r,filter:s,dy:n},o={x:r,filter:s,dy:n};return{x:()=>R.runKernel(GS,i,e),filter:()=>R.runKernel(qS,o,e)}}},rue={kernelName:Lf,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,r={dy:n,y:e};return{x:()=>R.runKernel(XS,r)}}},sue={kernelName:Bf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=M(oi(_n(Jt(e))),2/Math.sqrt(Math.PI));return{x:()=>M(n,r)}}},iue={kernelName:Vf,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,e)}}},oue={kernelName:tb,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>F(n,e.shape)}}},aue={kernelName:zf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,oi(e))}}},lue={kernelName:Uf,gradFunc:n=>({x:()=>Tt(n)})},cue={kernelName:Hf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=et(e.shape,r.shape);return{a:()=>{const a=Pe(n,ve(r,"float32")),l=nr(e.shape,s);return l.length>0?F(Ae(a,l),e.shape):a},b:()=>{let a=M(n,ve(e,"float32"));const l=nr(r.shape,s);l.length>0&&(a=F(Ae(a,l),r.shape));const c=Jt(r);return _n(Pe(a,ve(c,"float32")))}}}},uue={kernelName:nb,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:r}=e,[s,i,o,a]=t,l=a??Be(1),c=nr(i.shape,s.shape),u=[];if(1===i.rank){for(let v=0;v<s.shape.length-1;++v)u.push(s.shape[v]);u.push(1)}const d=De(s,i),h=M(n,l),f=HI(le(o,Be(r))),p=M(M(M(f,f),f),Be(-.5));return{x:()=>F(M(M(n,1===i.rank?Mi(F(f,[1,1,1,i.shape[0]]),u):f),l),s.shape),mean:()=>{let v=M(M(f,Be(-1)),h);return 1===i.rank&&(v=Ae(v,c)),F(v,i.shape)},variance:()=>{let v=M(M(p,d),h);return 1===i.rank&&(v=Ae(v,c)),F(v,i.shape)},scale:()=>{const v=M(d,f);let w=M(n,v);return 1===i.rank&&(w=Ae(w,c)),F(w,i.shape)},offset:()=>{let v=n;return 1===i.rank&&(v=Ae(v,c)),F(v,i.shape)}}}},due={kernelName:rb,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[r,s]=t,{axis:i}=e,o=ft(i,r.shape)[0];return{x:()=>{const l=r.shape,c=s.size,u=l.slice(0,o),d=u.length,h=l.slice(i,l.length).slice(1),f=h.length,p=bV(0,d),m=bV(d+1,d+1+f),g=_V([u,[c],h]),y=F(n,g),b=F(s,[c]),_=_V([[d],p,m]),v=wt(y,_);let w=JI(v,b,r.shape[o]);const C=al(_);return w=wt(w,C),w},indices:()=>s}}};function bV(n,t){const e=[];for(let r=n;r<t;++r)e.push(r);return e}function _V(n){const t=[];for(let e=0;e<n.length;++e)for(let r=0;r<n[e].length;++r)t.push(n[e][r]);return t}const hue={kernelName:Wf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>Tt(e),b:()=>Tt(r)}}},fue={kernelName:jf,gradFunc:n=>({x:()=>ve(n,"float32")})},pue={kernelName:Gf,gradFunc:n=>({x:()=>Tt(n)})},mue={kernelName:qf,gradFunc:n=>({x:()=>Tt(n)})},gue={kernelName:Kf,gradFunc:n=>({x:()=>Tt(n)})},yue={kernelName:ib,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{alpha:s}=e,i=Ps(r,0);return{x:()=>ms(i,n,M(n,s))}}},bue={kernelName:Yf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,le(e,1))}}},_ue={kernelName:Xf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,ve(e,"float32"))}}},vue={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e;return{logits:()=>{const o=oi(r);return De(n,M(Ae(n,s,!0),o))}}}},wue=A({localResponseNormalizationBackprop_:function xue(n,t,e,r=5,s=1,i=1,o=.5){return R.runKernel(rE,{x:n,y:t,dy:e},{depthRadius:r,bias:s,alpha:i,beta:o})}}),Cue={kernelName:db,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{depthRadius:i,bias:o,alpha:a,beta:l}=e;return{x:()=>wue(r,s,n,i,o,a,l)}}};function vV(n,t,e,r){return t.rank<e.rank&&(t=F(t,Vn(t.shape,r))),n.rank<e.rank&&(n=F(n,Vn(n.shape,r))),{x:()=>M(n,ve(lo(e,t),n.dtype))}}const xV={kernelName:hb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{reductionIndices:s}=r,i=t[0],l=vV(n,t[1],i,ft(s,i.shape));return{x:()=>l.x()}}},Sue={kernelName:Zf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>M(n,ve(cl(e,r),"float32")),b:()=>M(n,ve(RI(e,r),"float32"))}}},Iue=A({maxPool3dGrad_:function Eue(n,t,e,r,s,i,o){const a=E(n,"dy","maxPool3dGrad"),l=E(t,"input","maxPool3dGrad"),c=E(e,"output","maxPool3dGrad");let u=a,d=l,h=c,f=!1;4===l.rank&&(f=!0,u=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=F(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=F(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),S(5===u.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),S(5===d.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),S(5===h.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),Zr("maxPool3dGrad",i,o);const g=R.runKernel(iE,{dy:u,input:d,output:h},{filterSize:r,strides:s,pad:i,dimRoundingMode:o});return f?F(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),Due={kernelName:pb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=e;return{x:()=>Iue(n,r,s,i,o,a,l)}}},kue=A({maxPoolGrad_:function Tue(n,t,e,r,s,i,o){const a=E(n,"dy","maxPoolGrad"),l=E(t,"input","maxPoolGrad"),c=E(e,"output","maxPoolGrad");return S(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),S(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),S(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Zr("maxPoolGrad",i,o),R.runKernel(sE,{dy:a,input:l,output:c},{filterSize:r,strides:s,pad:i,dimRoundingMode:o})}}),wV={kernelName:Cb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:s}=e,i=s.map(o=>o[0]);return{x:()=>Dt(n,i,r.shape)}}};const CV={kernelName:Mb,gradFunc:(n,t,e)=>{const{blockShape:r,paddings:s}=e;return{x:()=>o_(n,r,s)}}},SV={kernelName:Fb,gradFunc:(n,t,e)=>{const{axis:r}=e;return{x:()=>Xn(n,r)}}},Ede=[yV,wce,Cce,Sce,Ece,Ice,Dce,Tce,kce,Nce,Ace,Rce,Oce,Lce,Bce,Vce,zce,Uce,Hce,Wce,jce,Gce,Kce,qce,Zce,Qce,Jce,eue,tue,nue,{kernelName:$f,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=et(e.shape,r.shape);return{a:()=>{const a=Pe(n,ve(r,"float32")),l=nr(e.shape,s);return l.length>0?F(Ae(a,l),e.shape):a},b:()=>{let a=M(n,ve(e,"float32"));const l=nr(r.shape,s);l.length>0&&(a=F(Ae(a,l),r.shape));const c=Jt(r);return _n(Pe(a,ve(c,"float32")))}}}},rue,sue,iue,oue,aue,cue,lue,uue,due,hue,fue,pue,mue,gue,yue,bue,_ue,vue,Cue,xV,xV,Sue,Due,{kernelName:fb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{filterSize:i,strides:o,pad:a}=e;return{x:()=>kue(n,r,s,i,o,a)}}},{kernelName:mb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e,i=ft(s,r.shape),l=X(Cr(r.shape,i)[1]);return{x:()=>{const u=r.shape.slice();i.forEach(f=>{u[f]=1});const d=F(n,u);return Pe(M(d,li(r.shape,"float32")),l)}}}},{kernelName:gb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{axis:s}=r,[i,o]=t,l=vV(n,o,i,ft(s,i.shape));return{x:()=>l.x()}}},{kernelName:Qf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>M(n,ve(bc(e,r),"float32")),b:()=>M(n,ve(Ps(e,r),"float32"))}}},{kernelName:yb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:s}=e,i=s.map(o=>o[0]);return{x:()=>Dt(n,i,r.shape)}}},{kernelName:Jf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=et(e.shape,r.shape);return{a:()=>{const a=nr(e.shape,s);return a.length>0?F(Ae(n,a),e.shape):n},b:()=>{const a=M(n,_n(Ap(Pe(e,r)))),l=nr(r.shape,s);return l.length>0?F(Ae(a,l),r.shape):a}}}},{kernelName:ep,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=et(e.shape,r.shape);return{a:()=>{const a=M(n,ve(r,"float32")),l=nr(e.shape,s);return l.length>0?F(Ae(a,l),e.shape):a},b:()=>{const a=M(n,ve(e,"float32")),l=nr(r.shape,s);return l.length>0?F(Ae(a,l),r.shape):a}}}},{kernelName:bb,gradFunc:n=>({x:()=>_n(n)})},{kernelName:xb,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>sr(e.shape,"float32")}}},{kernelName:vb,gradFunc:n=>({x:()=>Tt(n)})},{kernelName:wb,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:r}=e;return Oi(n,r).map(i=>()=>i)}},wV,wV,{kernelName:tp,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,r,s]=t,i=e,o=r,a=et(i.shape,o.shape);return{a:()=>{const u=ve(o,"float32");let d=M(n,M(u,ll(i,De(u,Be(1)))));const h=nr(i.shape,a);return h.length>0&&(d=Ae(d,h)),F(d,i.shape)},b:()=>{const u=Ps(i,0),d=ms(u,ai(i),Tt(i));let h=M(n,M(s,d));const f=nr(o.shape,a);return f.length>0&&(h=Ae(h,f)),F(h,o.shape)}}}},{kernelName:Sb,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,r]=t,s=Ps(e,0);return{x:()=>ms(s,n,M(n,r)),alpha:()=>{let i=ms(s,Tt(n),M(n,e));const o=nr(r.shape,n.shape);return o.length>0&&(i=Ae(i,o)),F(i,r.shape)}}}},{kernelName:Eb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e;let i=[];return i=null==s?r.shape.map((o,a)=>a):"number"==typeof s?[s]:s,{x:()=>function Wue(n,t,e){const r=n.shape.length,s=r-e.length,i=Dn(e,r);let o=n;null!=i&&(o=wt(n,i));const a=o.shape.slice(),c=a.splice(r-e.length,e.length).reduce((h,f)=>h*f,1);a.push(c);let d=function Hue(n,t,e){const r=n.shape.slice();r[e]=1;const s=F(t,r),i=l_(n,e,!0,!1),o=l_(n,e,!0,!0),a=M(i,o);return M(s,a)}(o.reshape(a),t,s);if(d=d.reshape(o.shape),null!=i){const h=al(i);d=wt(d,h)}return d}(r,n,i)}}},{kernelName:np,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,_n(Jt(e)))}}},{kernelName:sp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=M(bc(e,6),_d(e));return{x:()=>M(n,ve(r,"float32"))}}},{kernelName:rp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,ve(_d(e),"float32"))}}},{kernelName:Ib,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>F(n,e.shape)}}},{kernelName:Tb,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,s={dy:n,images:r};return{images:()=>R.runKernel(yE,s,e)}}},{kernelName:Db,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,s={dy:n,images:r};return{images:()=>R.runKernel(gE,s,e)}}},{kernelName:kb,gradFunc:(n,t,e)=>{const{dims:r}=e,s=ft(r,n.shape);return{x:()=>Fi(n,s)}}},{kernelName:ip,gradFunc:n=>({x:()=>Tt(n)})},{kernelName:op,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>_n(Pe(n,M(ll(e,1.5),2)))}}},{kernelName:Nb,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>ve(Tt(e),"float32"),t:()=>M(n,ve(e,n.dtype)),e:()=>M(n,ve(h_(e),n.dtype))}}},{kernelName:ap,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=Ps(e,Be(0)),s=Be(N_),i=Be(A_),o=M(n,i),a=M(M(n,s),oi(ve(e,"float32")));return ms(r,o,a)}}}},{kernelName:dp,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,M(e,De(Be(1),e)))}}},{kernelName:up,gradFunc:n=>({x:()=>Tt(n)})},{kernelName:lp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(a_(ve(e,"float32")),n)}}},{kernelName:cp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(II(ve(e,"float32")),n)}}},{kernelName:Ab,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{begin:s,size:i}=e,o=r.shape,[a,l]=t_(r,s,i),c=[];for(let u=0;u<n.rank;u++)c.push([a[u],o[u]-a[u]-l[u]]);return{x:()=>ul(n,c)}}},{kernelName:Ob,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{dim:s}=e,o=M(n,r);return{logits:()=>De(o,M(Ae(o,[s],!0),r))}}},{kernelName:hp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,Fo(e))}}},CV,CV,SV,SV,{kernelName:fp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,M(Vr(ve(e,"float32")),2))}}},{kernelName:pp,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Be(2);return{a:()=>M(n,M(s,De(e,r))),b:()=>M(n,M(s,De(r,e)))}}},{kernelName:EE,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,M(ve(e,"float32"),2))}}},{kernelName:_p,gradFunc:n=>({x:()=>Tt(n)})},{kernelName:mp,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=et(e.shape,r.shape);return{a:()=>{let a=n;const l=nr(e.shape,s);return l.length>0&&(a=Ae(a,l)),F(a,e.shape)},b:()=>{let a=n;const l=nr(r.shape,s);return l.length>0&&(a=Ae(a,l)),F(_n(a),r.shape)}}}},{kernelName:Rb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,s=r.shape.slice(),{axis:i}=e;ft(i,r.shape).forEach(c=>{s[c]=1});const a=F(n,s),l=M(a,li(r.shape,"float32"));return{x:()=>l}}},{kernelName:gp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,Jt(a_(e)))}}},{kernelName:yp,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(De(Be(1),Jt(e)),n)}}},{kernelName:bp,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{reps:s}=e;return{x:()=>{let o=Tt(r);if(1===r.rank)for(let a=0;a<s[0];++a)o=le(o,Dt(n,[a*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)o=le(o,Dt(n,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let c=0;c<s[2];++c)o=le(o,Dt(n,[a*r.shape[0],l*r.shape[1],c*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let c=0;c<s[2];++c)for(let u=0;u<s[3];++u)o=le(o,Dt(n,[a*r.shape[0],l*r.shape[1],c*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return o}}}},{kernelName:nd,gradFunc:(n,t,e)=>{const r=e,{perm:s}=r,i=al(s);return{x:()=>wt(n,i)}}},{kernelName:Pb,gradFunc:(n,t,e)=>{const r=e,{axis:s}=r;return{value:()=>ui(n,s)}}},{kernelName:$b,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>function Cde(n,t){const e=_a(t,Tt(t)),r=Rp(n,e);let s=cl(t,Be(0,"int32"));const i=r.rank-s.rank;for(let a=0;a<i;++a)s=gs(s,a+1);s=Oo(s,li(r.shape,"bool"));const o=Tt(r);return ms(s,r,o)}(n,e)}}},{kernelName:Lb,gradFunc:n=>({x:()=>Tt(n)})}];for(const n of Ede)jte(n);Y().prototype.abs=function(){return this.throwIfDisposed(),rr(this)},Y().prototype.acos=function(){return this.throwIfDisposed(),OL(this)},Y().prototype.acosh=function(){return this.throwIfDisposed(),PL(this)},Y().prototype.add=function(n){return this.throwIfDisposed(),le(this,n)},Y().prototype.all=function(n,t){return this.throwIfDisposed(),vI(this,n,t)},Y().prototype.any=function(n,t){return this.throwIfDisposed(),r_(this,n,t)},Y().prototype.argMax=function(n){return this.throwIfDisposed(),dd(this,n)},Y().prototype.argMin=function(n){return this.throwIfDisposed(),$L(this,n)},Y().prototype.asScalar=function(){return this.throwIfDisposed(),S(1===this.size,()=>"The array must have only 1 element."),F(this,[])},Y().prototype.asType=function(n){return this.throwIfDisposed(),ve(this,n)},Y().prototype.as1D=function(){return this.throwIfDisposed(),F(this,[this.size])},Y().prototype.as2D=function(n,t){return this.throwIfDisposed(),F(this,[n,t])},Y().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),F(this,[n,t,e])},Y().prototype.as4D=function(n,t,e,r){return this.throwIfDisposed(),F(this,[n,t,e,r])},Y().prototype.as5D=function(n,t,e,r,s){return this.throwIfDisposed(),F(this,[n,t,e,r,s])},Y().prototype.asin=function(){return this.throwIfDisposed(),LL(this)},Y().prototype.asinh=function(){return this.throwIfDisposed(),BL(this)},Y().prototype.atan=function(){return this.throwIfDisposed(),VL(this)},Y().prototype.atan2=function(n){return this.throwIfDisposed(),zL(this,n)},Y().prototype.atanh=function(){return this.throwIfDisposed(),UL(this)},Y().prototype.avgPool=function(n,t,e,r){return this.throwIfDisposed(),i_(this,n,t,e,r)},Y().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),o_(this,n,t)},Y().prototype.batchNorm=function(n,t,e,r,s){return this.throwIfDisposed(),Ip(this,n,t,e,r,s)},Y().prototype.broadcastTo=function(n){return this.throwIfDisposed(),pd(this,n)},Y().prototype.cast=function(n){return this.throwIfDisposed(),ve(this,n)},Y().prototype.ceil=function(){return this.throwIfDisposed(),KL(this)},Y().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Os(this,n,t)},Y().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof pn&&(n=[n]),Xn([this,...n],t)},Y().prototype.conv1d=function(n,t,e,r,s,i){return this.throwIfDisposed(),CI(this,n,t,e,r,s,i)},Y().prototype.conv2dTranspose=function(n,t,e,r,s){return this.throwIfDisposed(),EI(this,n,t,e,r,s)},Y().prototype.conv2d=function(n,t,e,r,s,i){return this.throwIfDisposed(),ol(this,n,t,e,r,s,i)},Y().prototype.cos=function(){return this.throwIfDisposed(),a_(this)},Y().prototype.cosh=function(){return this.throwIfDisposed(),II(this)},Y().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),l_(this,n,t,e)},Y().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),DI(this,n,t,e)},Y().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),nB(this,n,t)},Y().prototype.depthwiseConv2d=function(n,t,e,r,s,i){return this.throwIfDisposed(),Dp(this,n,t,e,r,s,i)},Y().prototype.dilation2d=function(n,t,e,r,s){return this.throwIfDisposed(),rB(this,n,t,e,r,s)},Y().prototype.divNoNan=function(n){return this.throwIfDisposed(),sB(this,n)},Y().prototype.div=function(n){return this.throwIfDisposed(),Pe(this,n)},Y().prototype.dot=function(n){return this.throwIfDisposed(),iB(this,n)},Y().prototype.elu=function(){return this.throwIfDisposed(),Tp(this)},Y().prototype.equal=function(n){return this.throwIfDisposed(),lo(this,n)},Y().prototype.erf=function(){return this.throwIfDisposed(),oB(this)},Y().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),cB(this,n,t)},Y().prototype.exp=function(){return this.throwIfDisposed(),oi(this)},Y().prototype.expandDims=function(n){return this.throwIfDisposed(),gs(this,n)},Y().prototype.expm1=function(){return this.throwIfDisposed(),uB(this)},Y().prototype.fft=function(){return this.throwIfDisposed(),w_(this)},Y().prototype.flatten=function(){return this.throwIfDisposed(),F(this,[this.size])},Y().prototype.floor=function(){return this.throwIfDisposed(),Ap(this)},Y().prototype.floorDiv=function(n){return this.throwIfDisposed(),kI(this,n)},Y().prototype.gather=function(n,t){return this.throwIfDisposed(),Rp(this,n,t)},Y().prototype.greaterEqual=function(n){return this.throwIfDisposed(),cl(this,n)},Y().prototype.greater=function(n){return this.throwIfDisposed(),Ps(this,n)},Y().prototype.ifft=function(){return this.throwIfDisposed(),$p(this)},Y().prototype.irfft=function(){return this.throwIfDisposed(),YI(this)},Y().prototype.isFinite=function(){return this.throwIfDisposed(),dB(this)},Y().prototype.isInf=function(){return this.throwIfDisposed(),hB(this)},Y().prototype.isNaN=function(){return this.throwIfDisposed(),fB(this)},Y().prototype.leakyRelu=function(n){return this.throwIfDisposed(),u_(this,n)},Y().prototype.lessEqual=function(n){return this.throwIfDisposed(),bc(this,n)},Y().prototype.less=function(n){return this.throwIfDisposed(),RI(this,n)},Y().prototype.localResponseNormalization=function(n,t,e,r){return this.throwIfDisposed(),pB(this,n,t,e,r)},Y().prototype.logSigmoid=function(){return this.throwIfDisposed(),mB(this)},Y().prototype.logSoftmax=function(n){return this.throwIfDisposed(),MI(this,n)},Y().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),FI(this,n,t)},Y().prototype.log=function(){return this.throwIfDisposed(),ai(this)},Y().prototype.log1p=function(){return this.throwIfDisposed(),d_(this)},Y().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Oo(this,n)},Y().prototype.logicalNot=function(){return this.throwIfDisposed(),h_(this)},Y().prototype.logicalOr=function(n){return this.throwIfDisposed(),OI(this,n)},Y().prototype.logicalXor=function(n){return this.throwIfDisposed(),gB(this,n)},Y().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),mt(this,n,t,e)},Y().prototype.maxPool=function(n,t,e,r){return this.throwIfDisposed(),p_(this,n,t,e,r)},Y().prototype.max=function(n,t){return this.throwIfDisposed(),Ri(this,n,t)},Y().prototype.maximum=function(n){return this.throwIfDisposed(),_a(this,n)},Y().prototype.mean=function(n,t){return this.throwIfDisposed(),Rn(this,n,t)},Y().prototype.min=function(n,t){return this.throwIfDisposed(),kp(this,n,t)},Y().prototype.minimum=function(n){return this.throwIfDisposed(),Mp(this,n)},Y().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),bB(this,n,t)},Y().prototype.mod=function(n){return this.throwIfDisposed(),_B(this,n)},Y().prototype.mul=function(n){return this.throwIfDisposed(),M(this,n)},Y().prototype.neg=function(){return this.throwIfDisposed(),_n(this)},Y().prototype.norm=function(n,t,e){return this.throwIfDisposed(),Np(this,n,t,e)},Y().prototype.notEqual=function(n){return this.throwIfDisposed(),yd(this,n)},Y().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),$I(this,n,t,e)},Y().prototype.onesLike=function(){return this.throwIfDisposed(),ci(this)},Y().prototype.pad=function(n,t){return this.throwIfDisposed(),ul(this,n,t)},Y().prototype.pool=function(n,t,e,r,s,i){return this.throwIfDisposed(),vB(this,n,t,e,r,s,i)},Y().prototype.pow=function(n){return this.throwIfDisposed(),ll(this,n)},Y().prototype.prelu=function(n){return this.throwIfDisposed(),y_(this,n)},Y().prototype.prod=function(n,t){return this.throwIfDisposed(),xB(this,n,t)},Y().prototype.reciprocal=function(){return this.throwIfDisposed(),wB(this)},Y().prototype.relu=function(){return this.throwIfDisposed(),Po(this)},Y().prototype.relu6=function(){return this.throwIfDisposed(),zI(this)},Y().prototype.reshapeAs=function(n){return this.throwIfDisposed(),F(this,n.shape)},Y().prototype.reshape=function(n){return this.throwIfDisposed(),F(this,n)},Y().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),VB(this,n,t,e)},Y().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),zB(this,n,t,e)},Y().prototype.reverse=function(n){return this.throwIfDisposed(),Fi(this,n)},Y().prototype.rfft=function(){return this.throwIfDisposed(),C_(this)},Y().prototype.round=function(){return this.throwIfDisposed(),UI(this)},Y().prototype.rsqrt=function(){return this.throwIfDisposed(),HI(this)},Y().prototype.selu=function(){return this.throwIfDisposed(),WI(this)},Y().prototype.separableConv2d=function(n,t,e,r,s,i){return this.throwIfDisposed(),jI(this,n,t,e,r,s,i)},Y().prototype.sigmoid=function(){return this.throwIfDisposed(),Fo(this)},Y().prototype.sign=function(){return this.throwIfDisposed(),CB(this)},Y().prototype.sin=function(){return this.throwIfDisposed(),qI(this)},Y().prototype.sinh=function(){return this.throwIfDisposed(),KI(this)},Y().prototype.slice=function(n,t){return this.throwIfDisposed(),Dt(this,n,t)},Y().prototype.softmax=function(n){return this.throwIfDisposed(),x_(this,n)},Y().prototype.softplus=function(){return this.throwIfDisposed(),gd(this)},Y().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),g_(this,n,t)},Y().prototype.split=function(n,t){return this.throwIfDisposed(),$s(this,n,t)},Y().prototype.sqrt=function(){return this.throwIfDisposed(),Vr(this)},Y().prototype.square=function(){return this.throwIfDisposed(),Jt(this)},Y().prototype.squaredDifference=function(n){return this.throwIfDisposed(),ZI(this,n)},Y().prototype.squeeze=function(n){return this.throwIfDisposed(),_c(this,n)},Y().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof pn?[this,n]:[this,...n];return ui(e,t)},Y().prototype.step=function(n){return this.throwIfDisposed(),_d(this,n)},Y().prototype.stridedSlice=function(n,t,e,r,s,i,o,a){return this.throwIfDisposed(),SB(this,n,t,e,r,s,i,o,a)},Y().prototype.sub=function(n){return this.throwIfDisposed(),De(this,n)},Y().prototype.sum=function(n,t){return this.throwIfDisposed(),Ae(this,n,t)},Y().prototype.tan=function(){return this.throwIfDisposed(),EB(this)},Y().prototype.tanh=function(){return this.throwIfDisposed(),fd(this)},Y().prototype.tile=function(n){return this.throwIfDisposed(),Mi(this,n)},Y().prototype.toBool=function(){return this.throwIfDisposed(),ve(this,"bool")},Y().prototype.toFloat=function(){return this.throwIfDisposed(),ve(this,"float32")},Y().prototype.toInt=function(){return this.throwIfDisposed(),ve(this,"int32")},Y().prototype.topk=function(n,t){return this.throwIfDisposed(),IB(this,n,t)},Y().prototype.transpose=function(n){return this.throwIfDisposed(),wt(this,n)},Y().prototype.unique=function(n){return this.throwIfDisposed(),DB(this,n)},Y().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),JI(this,n,t)},Y().prototype.unstack=function(n){return this.throwIfDisposed(),Oi(this,n)},Y().prototype.where=function(n,t){return this.throwIfDisposed(),ms(n,this,t)},Y().prototype.zerosLike=function(){return this.throwIfDisposed(),Tt(this)};class Lo extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Lo.prototype)}}class $i extends Error{constructor(t){super(t),Object.setPrototypeOf(this,$i.prototype)}}class O extends Error{constructor(t){super(t),Object.setPrototypeOf(this,O.prototype)}}class tt extends Error{constructor(t){super(t),Object.setPrototypeOf(this,tt.prototype)}}class UD extends Error{constructor(t){super(t),Object.setPrototypeOf(this,UD.prototype)}}class EV extends Error{constructor(t){super(t),Object.setPrototypeOf(this,EV.prototype)}}class IV{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=t}}function wc(n,t){if(Array.isArray(n)){let e=[];for(let r=0;r<t;r++)e=e.concat(n);return e}{const e=new Array(t);return e.fill(n),e}}function di(n,t){if(!n)throw new UD(t)}function DV(n,t){let e=0;for(const r of n)r===t&&e++;return e}function bs(n){return 1===n.length?n[0]:n}function sn(n){return Array.isArray(n)?n:[n]}function Ca(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function Cc(n){return n.length<=1||-1===n.indexOf("_")?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let Li={};function HD(n){if(null==n)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function WD(n){if(null!=n&&"object"==typeof n)if(Array.isArray(n))n.forEach(t=>WD(t));else{const t=Object.keys(n);for(const e of t){const r=n[e];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?WD(r):n[e]=r.value)}}}function Hp(n,t={},e={},r="object",s=!1){if("string"==typeof n){const i=n;let o;if(i in e)o=e[i];else if(i in Li)o=Li[i];else if(o=t[i],null==o)throw new O(`Unknown ${r}: ${n}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}{const i=n;if(null==i.className||null==i.config)throw new O(`${r}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);const o=i.className;let a,l;if(o in e?[a,l]=e[o]:o in Li?[a,l]=Li.className:o in t&&([a,l]=t[o]),null==a)throw new O(`Unknown ${r}: ${o}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const c={};for(const f of Object.keys(Li))c[f]=Li[f];for(const f of Object.keys(e))c[f]=e[f];i.config.customObjects=c;const d=Object.assign({},Li);for(const f of Object.keys(e))Li[f]=e[f];WD(i.config);const h=l(a,i.config,e,s);return Li=Object.assign({},d),h}{const c=Object.assign({},Li);for(const d of Object.keys(e))Li[d]=e[d];const u=new a(i.config);return Li=Object.assign({},c),u}}}function R_(n,t){return-1*function Ide(n,t){return n<t?-1:n>t?1:0}(n,t)}function dl(n){if(null==n)return n;const t=[];for(const e of n)-1===t.indexOf(e)&&t.push(e);return t}function Dde(n){if(null==n)throw new O(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function Sc(n,t,e){if(null!=e&&n.indexOf(e)<0)throw new O(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function jD(n,t,e=0,r=1/0){return di(e>=0),di(r>=e),Array.isArray(n)&&n.length>=e&&n.length<=r&&n.every(s=>typeof s===t)}function Sr(n,t){Array.isArray(n)?(S(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,r)=>Sr(e,`element ${r+1} of ${t}`))):S(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${TV(n)}.`)}function TV(n){return null===n?"null":Array.isArray(n)?"["+n.map(t=>TV(t)).join(",")+"]":"string"==typeof n?`"${n}"`:`${n}`}function kV(n){return"relu"===n?"relu":"linear"===n?"linear":"elu"===n?"elu":null}let kde=0;function NV(){return kde++}const M_={};function F_(n=""){return n in M_||(M_[n]=0),M_[n]+=1,n+M_[n].toString()}const Nde=["channelsFirst","channelsLast"],Ade=["nearest","bilinear"],Rde=["valid","same","causal"],Mde=["max","avg"],Fde=["sum","mul","concat","ave"],wd=new Map;function Un(n){Sc(Nde,"DataFormat",n)}function hi(n){Sc(Rde,"PaddingMode",n)}function AV(n){Sc(Mde,"PoolMode",n)}const Wp=[];function Ec(n,t){Wp.push(n);try{const e=t();return Wp.pop(),e}catch(e){throw Wp.pop(),e}}function MV(n){if(!OV(n))throw new Error("Not a valid tensor name: '"+n+"'");return function Pde(){return 0===Wp.length?"":Wp.join("/")+"/"}()+n}function FV(n){if(!OV(n))throw new Error("Not a valid tensor name: '"+n+"'");wd.has(n)||wd.set(n,0);const t=wd.get(n);if(wd.set(n,wd.get(n)+1),t>0){const e=`${n}_${t}`;return wd.set(e,1),e}return n}const $de=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function OV(n){return!!n.match($de)}function Lde(n){return n===parseInt(n.toString(),10)}function hl(n,t,e){null==t&&(t=0),null==e&&(e=n.length);let r=1;for(let s=t;s<e;++s)r*=n[s];return r}function Cd(n){if(0===n.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r<t&&(t=r)}return t}function fl(n){if(0===n.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r>t&&(t=r)}return t}function co(n,t){if(t<n)throw new O(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let r=n;r<t;++r)e.push(r);return e}let O_;function ir(){return null==O_&&(O_=function _re(){return R.backend}().epsilon()),O_}function Bo(n,t){return ve(n,t)}function jp(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),F(n,e)}function Ic(n,t,e){return V(()=>{switch(n.rank){case 1:return __(n,t,e);case 2:return XI(n,[t,0],[e,n.shape[1]]);case 3:return v_(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return Pp(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Dt(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Dt(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new O(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function GD(n,t,e){return V(()=>{switch(n.rank){case 1:return __(n,t,e);case 2:return XI(n,[0,t],[n.shape[0],e]);case 3:return v_(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return Pp(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new O(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function P_(n,t,e,r){return V(()=>{switch(n.rank){case 1:return __(n,t,e);case 2:switch(r){case 1:return Ic(n,t,e);case 2:return GD(n,t,e);default:throw new O(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Ic(n,t,e);case 2:return v_(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return GD(n,t,e);default:throw new O(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Ic(n,t,e);case 2:return Pp(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return Pp(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return GD(n,t,e);default:throw new O(`The axis is not within the rank of the tensor ${r}`)}default:throw new O(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function qD(n,t=-1){let e;return t<0&&(e=n[0].rank,t=0!==e?e:0),t===n[0].rank&&(t=-1),Xn(n,t)}function $V(n,t){switch(n.rank){case 1:return XL([n,t]);case 2:return YL([n,t],0);case 3:return ZL([n,t],0);case 4:return QL([n,t],0);default:throw new O(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function KD(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new O(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return Mi(n,t)}function $_(n,t=0,e=1,r,s){return VI(n,t,e,r,s)}function Vo(n,t,e,r){if(n.rank<2||t.rank<2)throw new tt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3&&n.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new tt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`);if(2===n.rank&&2===t.rank)return oD({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?XD(n.rank,r,"channelsLast"):null,activation:e});{const s=n.shape.slice(),i=s.pop();n=F(n,[-1,i]);const o=t.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],u=Array.from({length:t.rank},(p,m)=>0===m?t.rank-2:m<=t.rank-2?m-1:m);t=F(wt(t,u),[l,-1]);const d=[...s,...c];return F(oD({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?XD(n.rank,r,"channelsLast"):null,activation:e}),d)}}function LV(n,t,e){return V(()=>(t=Array.isArray(t)?ys(t,"int32"):ve(t,"int32"),Rp(n,t,e)))}function Gp(n){return M(n,n)}function XD(n,t,e){const r=t.shape;if(1!==t.rank&&t.rank!==n)throw new O(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(5===n){if("channelsFirst"===e)return F(t,1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===e)return F(t,1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===n){if("channelsFirst"===e)return F(t,1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===e)return F(t,1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===n){if("channelsFirst"===e)return F(t,1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===e)return F(t,1===r.length?[1,1,r[0]]:[1].concat(r))}else if(n<3)return t;throw new O(`Unsupported input rank by biasAdd: ${t.rank}`)}function ho(n,t,e){return V(()=>(null==e&&(e="channelsLast"),Un(e),le(n,XD(n.rank,t,e))))}function BV(n,t,e,r){return V(()=>RB(n,t,e,r))}function qp(n,t,e=!1){return e?n():t()}const qde=["fanIn","fanOut","fanAvg"],Kde=["normal","uniform","truncatedNormal"];class Bi extends ud{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}se((()=>{class n extends Bi{apply(e,r){return sr(e,r)}}return n.className="Zeros",n})());let VV=(()=>{class n extends Bi{apply(e,r){return li(e,r)}}return n.className="Ones",n})();se(VV),se((()=>{class n extends Bi{constructor(e){if(super(),"object"!=typeof e)throw new O(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new O(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return V(()=>M(Be(this.value),li(e,r)))}getConfig(){return{value:this.value}}}return n.className="Constant",n})()),se((()=>{class n extends Bi{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return Fp(e,this.minval,this.maxval,r)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return n.className="RandomUniform",n})()),se((()=>{class n extends Bi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new tt(`randomNormal does not support dType ${r}.`);return $_(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="RandomNormal",n})()),se((()=>{class n extends Bi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new tt(`truncatedNormal does not support dType ${r}.`);return QI(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="TruncatedNormal",n})()),se((()=>{class n extends Bi{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,r){return V(()=>{if(2!==e.length||e[0]!==e[1])throw new O("Identity matrix initializer can only be used for 2D square matrices.");return M(this.gain,AI(e[0]))})}getConfig(){return{gain:this.gain}}}return n.className="Identity",n})());let fi=(()=>{class n extends Bi{constructor(e){if(super(),e.scale<0)throw new O(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale??1,this.mode=e.mode??"fanIn",function Xde(n){Sc(qde,"FanMode",n)}(this.mode),this.distribution=e.distribution??"normal",function Yde(n){Sc(Kde,"Distribution",n)}(this.distribution),this.seed=e.seed}apply(e,r){const s=function Zde(n,t="channelsLast"){let e,r;if(Un(t),2===n.length)e=n[0],r=n[1];else if(-1!==[3,4,5].indexOf(n.length)){if("channelsFirst"===t){const s=hl(n,2);e=n[1]*s,r=n[0]*s}else if("channelsLast"===t){const s=hl(n,0,n.length-2);e=n[n.length-2]*s,r=n[n.length-1]*s}}else{const s=hl(n);e=Math.sqrt(s),r=Math.sqrt(s)}return[e,r]}(e),i=s[0],o=s[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,i):"fanOut"===this.mode?Math.max(1,o):Math.max(1,(i+o)/2),"normal"===this.distribution){const l=Math.sqrt(a);if("float32"!==(r=r||"float32")&&"int32"!==r)throw new tt(`${this.getClassName()} does not support dType ${r}.`);return QI(e,0,l,r,this.seed)}{const l=Math.sqrt(3*a);return Fp(e,-l,l,r)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return n.className="VarianceScaling",n})();se(fi);let zV=(()=>{class n extends fi{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return fi.className}}return n.className="GlorotUniform",n})();se(zV);let UV=(()=>{class n extends fi{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return fi.className}}return n.className="GlorotNormal",n})();se(UV);let HV=(()=>{class n extends fi{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return fi.className}}return n.className="HeNormal",n})();se(HV);let WV=(()=>{class n extends fi{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return fi.className}}return n.className="HeUniform",n})();se(WV);let jV=(()=>{class n extends fi{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return fi.className}}return n.className="LeCunNormal",n})();se(jV);let GV=(()=>{class n extends fi{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return fi.className}}return n.className="LeCunNormal",n})();se(GV),se((()=>{class n extends Bi{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=e.gain??this.DEFAULT_GAIN,this.seed=e.seed,null!=this.seed)throw new tt("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,r){return V(()=>{if(e.length<2)throw new tt("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const i=$_(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let o=HB.gramSchmidt(i);return e[0]>e[1]&&(o=wt(o)),M(this.gain,o)})}getConfig(){return{gain:this.gain,seed:this.seed}}}return n.className="Orthogonal",n})());const qV={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function KV(n,t={}){return Hp(n,Ni.getMap().classNameMap,t,"initializer")}function Tn(n){return HD(n)}function vn(n){if("string"==typeof n){const t=n in qV?qV[n]:n;if("GlorotNormal"===t)return new UV;if("GlorotUniform"===t)return new zV;if("HeNormal"===t)return new HV;if("HeUniform"===t)return new WV;if("LeCunNormal"===t)return new jV;if("LeCunUniform"===t)return new GV;{const e={};return e.className=t,e.config={},KV(e)}}return n instanceof Bi?n:KV(n)}function YD(n){return Array.isArray(n)&&Array.isArray(n[0])}function L_(n){return 0===n.length?[]:Array.isArray(n[0])?n:[n]}function Ye(n){let t;if(Array.isArray(n)){if(1!==n.length)throw new O(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function $t(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(1===n.length)return n[0];throw new O(`Expected exactly 1 Shape; got ${n.length}`)}return n}function B_(n){let t=0;for(const e of n)t+=0===e.shape.length?1:e.shape.reduce((r,s)=>r*s);return t}const XV="Variable";class zo{constructor(t,e="float32",r=XV,s=!0,i=null){this.dtype=e??"float32",this.shape=t.shape,this.id=NV(),this.originalName=MV(r=r??XV),this.name=FV(this.originalName),this.trainable_=s,this.constraint=i,this.val=TB(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function Qde(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function ZD(n){return n.map(t=>t.read())}function QD(n){n.forEach(t=>{t[0].write(t[1])})}class or{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class Uo{constructor(t,e,r,s,i,o,a){this.dtype=t,this.shape=e,this.sourceLayer=r,this.inputs=s,this.callArgs=i,this.outputTensorIndex=a,this.id=NV(),null!=o&&(this.originalName=MV(o),this.name=FV(this.originalName)),this.rank=e.length}}let Jde=0;class V_{constructor(t,e){this.callArgs=e,this.id=Jde++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const r of t.inboundLayers)r?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let ehe=0;class gt extends ud{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=ehe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const r=this.getClassName();e=Ca(r)+"_"+F_(r)}if(this.name=e,this.trainable_=t.trainable??!0,null!=t.inputShape||null!=t.batchInputShape){let r;if(null!=t.batchInputShape)r=t.batchInputShape;else if(null!=t.inputShape){let i=null;null!=t.batchSize&&(i=t.batchSize),r=[i].concat(t.inputShape)}this.batchInputShape=r;let s=t.dtype;null==s&&(s=t.inputDType),null==s&&(s="float32"),this.dtype=s}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new $i(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new O(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return bs(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return bs(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Lo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Lo(`Layer ${this.name} is not connected, no input to return.`);return bs(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Lo(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Lo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return bs(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=sn(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=sn(this.inputSpec);if(t.length!==e.length)throw new O(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let r=0;r<t.length;r++){const s=t[r],i=e[r];if(null==i)continue;const o=s.rank;if(null!=i.ndim&&o!==i.ndim)throw new O(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);if(null!=i.maxNDim&&o>i.maxNDim)throw new O(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);if(null!=i.minNDim&&o<i.minNDim)throw new O(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);if(null!=i.dtype&&s.dtype!==i.dtype)throw new O(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${s.dtype}.`);if(i.axes){const a=s.shape;for(const l in i.axes){const c=Number(l),u=i.axes[l],d=c>=0?a[c]:a[a.length+c];if(null!=u&&-1===[u,null].indexOf(d))throw new O(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${u} but got shape ${a}.`)}}if(null!=i.shape)for(let a=0;a<i.shape.length;++a){const l=i.shape[a],c=s.shape[a];if(null!=l&&null!=c&&l!==c)throw new O(`Input ${r} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${s.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const r=sn(t);let s=!0;for(const o of r)if(!(o instanceof Uo)){s=!1;break}let i=!0;for(const o of r)if(o instanceof Uo){i=!1;break}if(s===i)throw new O("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ec(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const o=[];for(const a of sn(t))o.push(a.shape);this.build(bs(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&i&&(this._refCount=1)}if(this.assertInputCompatibility(t),i){let o=this.call(t,e);const a=sn(o),l=[];for(let c of a)-1!==r.indexOf(c)&&(c=c.clone()),l.push(c);if(o=bs(l),null!=this.activityRegularizer)throw new tt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}{const o=function the(n){n=sn(n);const t=[];for(const e of n)t.push(e.shape);return bs(t)}(t),a=this.computeOutputShape(o);let l;const c="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?o[0]:o),l=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((u,d)=>new Uo(c,u,this,sn(t),e,this.name,d)):new Uo(c,a,this,sn(t),e,this.name),this.addInboundNode(t,l,null,null,o,a,e),this._refCount++,null!=this.activityRegularizer)throw new tt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,s)=>{null!=r&&null!=t[s]&&t[s]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Lo(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const r=JSON.stringify(e.outputShapes);-1===t.indexOf(r)&&t.push(r)}if(1===t.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Lo(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new $i(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return B_(this.weights)}build(t){this.built=!0}getWeights(t=!1){return ZD(t?this.trainableWeights:this.weights)}setWeights(t){V(()=>{const e=this.weights;if(e.length!==t.length)throw new O(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const r=[],s=ZD(e);for(let i=0;i<s.length;++i){const o=s[i],a=e[i],l=t[i];if(!It(o.shape,l.shape))throw new O(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}QD(r)})}addWeight(t,e,r,s,i,o,a,l){if(-1!==this._addedWeightNames.indexOf(t))throw new O(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(s=null!=l?l():vn("zeros"));const c=s.apply(e,r),u=new zo(c,r,t,o,a);return c.dispose(),null!=i&&this.addLoss(()=>i.apply(u.read())),null==o&&(o=!0),o?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=sn(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(r=>{if(null!=r)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,r,s,i,o,a=null){const l=sn(t);e=sn(e),r=sn(r),s=sn(s),i=L_(i),o=L_(o);const c=[],u=[],d=[];for(const h of l)c.push(h.sourceLayer),u.push(h.nodeIndex),d.push(h.tensorIndex);new V_({outboundLayer:this,inboundLayers:c,nodeIndices:u,tensorIndices:d,inputTensors:l,outputTensors:e,inputMasks:r,outputMasks:s,inputShapes:i,outputShapes:o},a);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function YV(n,t,e){if((null==t||null!=e&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),0===t.inboundNodes.length)return[n];{const r=t.inboundNodes[e];if(0===r.inboundLayers.length)return r.inputTensors;{const s=[];for(let i=0;i<r.inboundLayers.length;i++){const c=YV(r.inputTensors[i],r.inboundLayers[i],r.nodeIndices[i]);for(const u of c)-1===s.indexOf(u)&&s.push(u)}return s}}}let z_=(()=>{class n extends gt{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:F_("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new O("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new O("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new O("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=r,this.dtype=s,this.inputSpec=[{shape:r}];const i=new Uo(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new V_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new O(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return n.className="InputLayer",n})();se(z_);class pl{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof pl)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,r){if(null!=this.id2Value[t.id])throw new O(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function she(n,t){if(null==n.dtype||n.dtype===t.dtype)return t;try{return ve(t,n.dtype)}catch{throw new O(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=r&&(this.id2Mask[t.id]=r),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Uo){if(null==this.id2Value[t.id])throw new O(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new O(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof Uo){if(null==this.id2Value[t.id])throw new O(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new O(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&Qe(this.id2Mask)}}const U_=new IV,H_=new IV;function Kp(n,t,e,r){const s=null!=e&&e.training,i=Array.isArray(n),o=i?n:[n],a=o.map(p=>p.name),l=[],c=t.names();for(const p of a)-1!==c.indexOf(p)?l.push(t.getValue(p)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const u=a.join(",")+"|"+t.names().sort().join(",");let h,d=U_.get(u);if(null==d){const p=function ohe(n,t){S(null!=n&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(1===n.length){const s=ZV(n[0],t);e=s.sorted,r=s.recipientMap}else{const s=new Set;for(const i of n){const{sorted:o,recipientMap:a}=ZV(i,t);for(const l of o)s.has(l.name)||(e.push(l),s.add(l.name));for(const l in a)null==r[l]&&(r[l]=new Set),a[l].forEach(c=>r[l].add(c))}}return{sorted:e,recipientCounts:ahe(r)}}(o,t);d=p.sorted,h=p.recipientCounts,U_.put(u,d),H_.put(u,h)}h={},s||Object.assign(h,H_.get(u));const f=new pl(t);for(let p=0;p<d.length;++p){if(null!=r){const T=_I().numTensors;T>r.maxNumTensors&&(r.maxNumTensors=T),T<r.minNumTensors&&(r.minNumTensors=T)}const m=d[p],g=m.sourceLayer;if(g instanceof z_)continue;const y=[],b=[],_=[];let v=!1;for(const T of m.inputs){const N=f.getValue(T),$=f.getMask(T);y.push(N),b.push($),null!=$&&(v=!0),s||(h[T.name]--,0===h[T.name]&&!t.hasKey(T)&&-1===a.indexOf(T.name)&&!N.isDisposed&&!0!==T.sourceLayer.stateful&&_.push(N))}v&&((e=e||{}).mask=b[0]);const w=sn(g.apply(y,e));let C=null;g.supportsMasking&&(C=g.computeMask(y,b));const I=lhe(m),D=Array.isArray(I)?I:[I];for(let T=0;T<D.length;++T){f.hasKey(D[T])||f.add(D[T],w[T],Array.isArray(C)?C[0]:C);const N=a.indexOf(D[T].name);-1!==N&&(l[N]=w[T])}s||Qe(_)}return f.disposeMasks(),i?l:l[0]}function ahe(n){const t={};for(const e in n)t[e]=n[e].size;return t}function ZV(n,t){const e=new Set,r=[],s={};for(const a of t.names())e.add(a);const i=[],o=[];for(i.push(n);i.length>0;){const a=i[i.length-1];if(e.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(0===a.inputs.length||l)i.pop(),r.push(a),e.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const c of a.inputs)null==s[c.name]&&(s[c.name]=new Set),s[c.name].add(a.name),!e.has(c.name)&&i.push(c)}}return{sorted:r,recipientMap:s}}function lhe(n){let t;if(1===n.sourceLayer.inboundNodes.length)t=n.sourceLayer.output;else{let e=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const s of n.sourceLayer.inboundNodes[r].outputTensors)if(s.id===n.id){e=r;break}t=n.sourceLayer.getOutputAt(e)}return t}function JD(n,t){return V(()=>Vr(Ae(M(n,n),t,!0)))}G().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function ihe(n){U_?.setMaxEntries(n),H_?.setMaxEntries(n)});class Xp extends ud{getConfig(){return{}}}se((()=>{class n extends Xp{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return V(()=>{const r=JD(e,this.axis),s=Os(r,0,this.maxValue);return M(e,Pe(s,le(ir(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return n.className="MaxNorm",n})()),se((()=>{class n extends Xp{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return V(()=>Pe(e,le(ir(),JD(e,this.axis))))}getConfig(){return{axis:this.axis}}}return n.className="UnitNorm",n})()),se((()=>{class n extends Xp{apply(e){return Po(e)}}return n.className="NonNeg",n})()),se((()=>{class n extends Xp{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return V(()=>{const r=JD(e,this.axis),s=le(M(this.rate,Os(r,this.minValue,this.maxValue)),M(1-this.rate,r));return M(e,Pe(s,le(ir(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return n.className="MinMaxNorm",n})());const QV={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ar(n){return HD(n)}function JV(n,t={}){return Hp(n,Ni.getMap().classNameMap,t,"constraint")}function lr(n){return null==n?null:"string"==typeof n?JV({className:n in QV?QV[n]:n,config:{}}):n instanceof Xp?n:JV(n)}function ml(n){return eT.apply(this,arguments)}function eT(){return(eT=ee(function*(n){if(null==n)return;const t=[],e=[],r=[];for(const s in n){const i=n[s];if("number"!=typeof i){const o=i;t.push(o.data()),e.push(s),r.push(o)}}if(t.length>0){const s=yield Promise.all(t);for(let i=0;i<s.length;++i)n[e[i]]=s[i][0];Qe(r)}})).apply(this,arguments)}function ez(n){if(null!=n)for(const t in n){const e=n[t];"number"!=typeof e&&e.dispose()}}class Sd{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return ee(function*(){})()}onEpochEnd(t,e){return ee(function*(){})()}onBatchBegin(t,e){return ee(function*(){})()}onBatchEnd(t,e){return ee(function*(){})()}onTrainBegin(t){return ee(function*(){})()}onTrainEnd(t){return ee(function*(){})()}setModel(t){}}class uhe{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){var r=this;return ee(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochBegin(t,e)})()}onEpochEnd(t,e){var r=this;return ee(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochEnd(t,e)})()}onBatchBegin(t,e){var r=this;return ee(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchBegin(t,e)})()}onBatchEnd(t,e){var r=this;return ee(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchEnd(t,e)})()}onTrainBegin(t){var e=this;return ee(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainBegin(t)})()}onTrainEnd(t){var e=this;return ee(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainEnd(t)})()}}class dhe extends Sd{constructor(){super()}onEpochBegin(t){var e=this;return ee(function*(){e.seen=0,e.totals={}})()}onBatchEnd(t,e){var r=this;return ee(function*(){null==e&&(e={});const s=e.size??0;r.seen+=s;for(const i in e){const o=e[i];if("number"==typeof o)r.totals.hasOwnProperty(i)||(r.totals[i]=0),r.totals[i]=r.totals[i]+o*s;else{let a;i in r.totals?a=r.totals[i]:r.totals[i]=0;const l=V(()=>le(r.totals[i],M(o,s)));r.totals[i]=l,a?.dispose()}}})()}onEpochEnd(t,e){var r=this;return ee(function*(){if(null!=e)for(const s of r.params.metrics)null!=r.totals[s]&&("number"==typeof r.totals[s]?e[s]=r.totals[s]/r.seen:V(()=>{const i=M(Pe(1,r.seen),r.totals[s]);e[s]=i,r.totals[s].dispose(),xr(e[s])}))})()}}class hhe extends Sd{onTrainBegin(t){var e=this;return ee(function*(){e.epoch=[],e.history={}})()}onEpochEnd(t,e){var r=this;return ee(function*(){null==e&&(e={}),r.epoch.push(t);for(const s in e)null==r.history[s]&&(r.history[s]=[]),r.history[s].push(e[s])})()}syncData(){var t=this;return ee(function*(){const e=[],r=[],s=[];for(const o in t.history){const a=t.history[o];for(let l=0;l<a.length;++l)"number"!=typeof a[l]&&(e.push(a[l].data()),r.push(o),s.push(l))}const i=yield Promise.all(e);for(let o=0;o<i.length;++o)t.history[r[o]][s[o]].dispose(),t.history[r[o]][s[o]]=i[o][0]})()}}class fhe extends Sd{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||WB,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");CS(this.yieldEvery)&&(this.maybeWait=function Tde(n,t,e){let s,r=null!=e?e():ps();return(...o)=>{const a=null!=e?e():ps();return a-r<t||(r=a,s=n(...o)),s}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,r){var s=this;return ee(function*(){const i=[];null!=s.yield&&(yield ml(r),i.push(s.yield(t,e,r))),i.push(s.nextFrameFunc()),yield Promise.all(i)})()}onEpochBegin(t,e){var r=this;return ee(function*(){r.currentEpoch=t,null!=r.epochBegin&&(yield ml(e),yield r.epochBegin(t,e))})()}onEpochEnd(t,e){var r=this;return ee(function*(){const s=[];null!=r.epochEnd&&(yield ml(e),s.push(r.epochEnd(t,e))),"epoch"===r.yieldEvery&&s.push(r.nextFrameFunc()),yield Promise.all(s)})()}onBatchBegin(t,e){var r=this;return ee(function*(){null!=r.batchBegin&&(yield ml(e),yield r.batchBegin(t,e))})()}onBatchEnd(t,e){var r=this;return ee(function*(){const s=[];null!=r.batchEnd&&(yield ml(e),s.push(r.batchEnd(t,e))),"batch"===r.yieldEvery?s.push(r.nextFrameFunc()):CS(r.yieldEvery)&&s.push(r.maybeWait(r.currentEpoch,t,e)),yield Promise.all(s)})()}onTrainBegin(t){var e=this;return ee(function*(){null!=e.trainBegin&&(yield ml(t),yield e.trainBegin(t))})()}onTrainEnd(t){var e=this;return ee(function*(){null!=e.trainEnd&&(yield ml(t),yield e.trainEnd(t))})()}}function tz(n,t){return null==n&&(n={}),n instanceof Sd?[n]:Array.isArray(n)&&n[0]instanceof Sd?n:sn(n).map(r=>new fhe(r,t))}let phe=(()=>{class n{constructor(){}static registerCallbackConstructor(e,r){S(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),n.checkForDuplicate(r),null==n.constructors[e]&&(n.constructors[e]=[]),n.constructors[e].push(r)}static checkForDuplicate(e){for(const r in n.constructors)n.constructors[+r].forEach(i=>{if(i===e)throw new O("Duplicate callback constructor.")})}static clear(){n.constructors={}}static createCallbacks(e){const r=[];for(const s in n.constructors){const i=+s;e>=i&&r.push(...n.constructors[i])}return r.map(s=>new s)}}return n.constructors={},n})();function nz(n,t,e,r,s,i,o,a,l){const c=new hhe,u=[new dhe,...phe.createCallbacks(t)];null!=n&&u.push(...n),u.push(c);const d=new uhe(u);return d.setParams({epochs:e,initialEpoch:r,samples:s,steps:i,batchSize:o,verbose:t,doValidation:a,metrics:l}),{callbackList:d,history:c}}function Sa(n,t={},e=!1){return Hp(n,Ni.getMap().classNameMap,t,"layer",e)}function W_(n,t){return V(()=>{"float32"!==n.dtype&&(n=ve(n,"float32"));const e=Ae(Gp(n),t,!0),r=md(e.shape,ir()),s=Vr(_a(e,r));return Pe(n,s)})}function j_(n,t){return V(()=>Rn(Gp(De(t,n)),-1))}function tT(n,t){return V(()=>Rn(rr(De(t,n)),-1))}function nT(n,t){return V(()=>{const e=De(n,t),r=Os(rr(n),ir(),Number.MAX_VALUE),s=rr(Pe(e,r));return M(100,Rn(s,-1))})}function Yp(n,t,e=!1){return V(()=>{if(e)t=x_(t);else{const r=Ae(t,t.shape.length-1,!0);t=Pe(t,r)}return t=Os(t,ir(),1-ir()),_n(Ae(M(ve(n,"float32"),ai(t)),t.shape.length-1))})}function G_(n,t,e=!1){return V(()=>{const r=ve(Ap(function Ude(n){const t=[hl(n.shape)];return F(n,t)}(n)),"int32"),s=(t=Os(t,ir(),1-ir())).shape;return Yp(F($I(r,s[s.length-1]),s),t,e)})}function q_(n,t){return V(()=>{let e;return e=Os(t,ir(),1-ir()),e=ai(Pe(e,De(1,e))),Rn(function vhe(n,t){if(!It(n.shape,t.shape))throw new O(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return V(()=>{const e=Po(t),r=_n(rr(t));return le(De(e,M(t,n)),d_(oi(r)))})}(n,e),-1)})}function rz(n,t){return V(()=>{const e=W_(n,-1),r=W_(t,-1),s=M(e,r);return _n(Ae(s,-1))})}const K_={meanSquaredError:j_,meanAbsoluteError:tT,meanAbsolutePercentageError:nT,meanSquaredLogarithmicError:function mhe(n,t){return V(()=>{const e=Os(t,ir(),Number.MAX_VALUE),r=ai(le(1,e)),s=Os(n,ir(),Number.MAX_VALUE),i=ai(le(1,s));return Rn(Gp(De(r,i)),-1)})},squaredHinge:function ghe(n,t){return V(()=>{const e=_a(0,De(1,M(n,t)));return Rn(Gp(e),-1)})},hinge:function yhe(n,t){return V(()=>{const e=_a(0,De(1,M(n,t)));return Rn(e,-1)})},categoricalHinge:function bhe(n,t){return V(()=>{const e=Ae(M(n,t),-1),r=Ri(M(De(1,n),t),-1);return _a(0,le(1,De(r,e)))})},logcosh:function _he(n,t){return V(()=>{const e=Math.log(2),r=De(t,n),s=De(le(r,gd(M(-2,r))),e);return Rn(s,-1)})},categoricalCrossentropy:Yp,sparseCategoricalCrossentropy:G_,binaryCrossentropy:q_,kullbackLeiblerDivergence:function xhe(n,t){return V(()=>{const e=Os(n,ir(),1),r=Os(t,ir(),1);return Ae(M(n,ai(Pe(e,r))),-1)})},poisson:function whe(n,t){return V(()=>{const e=ai(le(ir(),t));return Rn(De(t,M(n,e)),-1)})},cosineProximity:rz};function rT(n){if("string"==typeof n){if(n in K_)return K_[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new O(t)}return n}function sz(n,t){return V(()=>{const e=M(.5,ci(t)),r=Bo(Ps(t,e),n.dtype);return Rn(lo(n,r),-1)})}function iz(n,t){return V(()=>Bo(lo(dd(n,-1),dd(t,-1)),"float32"))}function Ihe(n,t){return q_(n,t)}function Dhe(n,t){return n.rank===t.rank&&(n=_c(n,[n.rank-1])),(t=dd(t,-1)).dtype!==n.dtype&&(t=ve(t,n.dtype)),ve(lo(n,t),"float32")}const az=Yp,lz=G_,X_={binaryAccuracy:sz,categoricalAccuracy:iz,precision:function Ehe(n,t){return V(()=>{const e=function oz(n,t){return V(()=>ve(Ae(Oo(lo(n,1),lo(t,1))),"float32"))}(n,t),r=function She(n,t){return V(()=>ve(Ae(Oo(lo(n,0),lo(t,1))),"float32"))}(n,t),s=le(e,r);return ve(ms(Ps(s,0),Pe(e,s),0),"float32")})},categoricalCrossentropy:az,sparseCategoricalCrossentropy:lz,mse:j_,MSE:j_,mae:tT,MAE:tT,mape:nT,MAPE:nT,cosine:rz};function Ohe(n){if("string"==typeof n&&n in X_)return X_[n];if("string"!=typeof n&&null!=n)return n;throw new O(`Unknown metric ${n}`)}function Y_(n){if(di(null!==n,`Unknown LossOrMetricFn ${n}`),"string"==typeof n)return n;{let t;for(const e of Object.keys(K_))if(K_[e]===n){t=e;break}if(void 0!==t)return t;for(const e of Object.keys(X_))if(X_[e]===n){t=e;break}return void 0!==t?t:n.name}}function uz(n,t,e=!1){if(null==n||"object"!=typeof n||Object.getPrototypeOf(n)!==Object.prototype||!sT(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const r=JSON.stringify(n);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function sT(n){if(null===n)return!0;if("object"==typeof n){if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if("string"!=typeof e||!sT(n[e]))return!1;return!0}if(Array.isArray(n)){for(const t of n)if(!sT(t))return!1;return!0}return!1}{const t=typeof n;return"string"===t||"number"===t||"boolean"===t}}function Z_(n,t,e=console.log){let r="";for(let s=0;s<n.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=n[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);e(r)}function Vhe(n,t,e){let r,s;try{s=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}Z_([`${n.name} (${n.getClassName()})`,s,r,n.countParams().toString()],t,e)}function zhe(n,t,e,r){let s,i;try{i=n.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const o=[];for(const d of n.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(d)))for(let h=0;h<d.inboundLayers.length;++h)o.push(`${d.inboundLayers[h].name}[${d.nodeIndices[h]}][${d.tensorIndices[h]}]`);const a=n.name,l=n.getClassName(),c=0===o.length?"":o[0];Z_([`${a} (${l})`,i,s,n.countParams().toString(),c],t,r);for(let d=1;d<o.length;++d)Z_(["","","","",o[d]],t,r)}function dz(n,t,e){return("inboundNodes"===n||"outputLayers"===n||"inputLayers"===n)&&0===t&&"string"==typeof e}function iT(n,t){if(null===n)return null;if("string"==typeof n)return Cc(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];dz(t,s,i)?e.push(i):e.push(iT(i,t))}return e}{const e={};for(const r of Object.keys(n)){const s=n[r];if("name"===r&&"string"==typeof s)e[r]=s;else{const i=Cc(r);e[i]=iT(s,i)}}return e}}function oT(n,t){if(null==n)return null;if("string"==typeof n)return Ca(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];dz(t,s,i)?e.push(i):e.push(oT(i,t))}return e}{const e={};for(const r of Object.keys(n)){const s=n[r];e[Ca(r)]="name"!==r&&"className"!==r||"string"!=typeof s?oT(s,r):s}return e}}class fo extends gt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const b=this.getClassName().toLowerCase();this.name=F_(b)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],dl(this.inputs).length!==this.inputs.length)throw new O(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);dl(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const v=b.nodeIndex,w=b.tensorIndex;this.outputLayers.push(b.sourceLayer),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(w)}for(const b of this.inputs){const _=b.sourceLayer,v=b.nodeIndex,w=b.tensorIndex;di(0===v,"input layer has >1 nodes"),di(0===w,"input layer has >1 tensors"),this.inputLayers.push(_),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const _=this.inputLayers[b];if(!(_ instanceof z_))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${_.getClassName()}.`);this.inputNames.push(_.name),this.feedInputShapes.push(_.batchInputShape),this.feedInputNames.push(_.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const e={},r={},s={},i={},o={},a=[],l=(b,_,v,w,C,I)=>{(null==w||null==C||null==I)&&(w=b.sourceLayer,C=b.nodeIndex,I=b.tensorIndex);const D=w.inboundNodes[C];if(-1!==v.indexOf(D))throw new $i(`The tensor ${b.name} at layer "${w.name}" is part of a cycle.`);if(-1!==_.indexOf(D))return;this.containerNodes.add(fo.nodeKey(w,C)),w.id in o||(o[w.id]=Object.keys(o).length),-1===v.indexOf(D)&&v.push(D);const T=D.inboundLayers.length;for(let N=0;N<T;N++)l(D.inputTensors[N],_,v,D.inboundLayers[N],D.nodeIndices[N],D.tensorIndices[N]);for(_.push(D);v.indexOf(D)>=0;)v.splice(v.indexOf(D),1);a.push(D)},c=[],u=[];for(const b of this.outputs)l(b,c,u);const d=a.slice().reverse();for(const b of d){r[b.id]=b,b.id in e||(e[b.id]=0);let _=e[b.id];_=Math.max(_,s[b.outboundLayer.id]??0),s[b.outboundLayer.id]=_,i[b.outboundLayer.id]=b.outboundLayer,e[b.id]=_;for(let w=0;w<b.inboundLayers.length;w++){const D=b.inboundLayers[w].inboundNodes[b.nodeIndices[w]];e[D.id]=Math.max(_+1,e[D.id]??0),r[D.id]=D}}const h={};for(const b in e){const _=e[b];_ in h||(h[_]=[]),h[_].push(r[b])}const f={};for(const b in s){const _=s[b];_ in f||(f[_]=[]),f[_].push(i[b])}let p=Object.keys(f).map(b=>parseInt(b,10)).sort(R_);this.layers=[];for(const b of p){const _=f[b];_.sort((v,w)=>{const C=o[v.id],I=o[w.id];return C<I?-1:C>I?1:0});for(const v of _)v instanceof fo&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=f,p=Object.keys(h).map(b=>parseInt(b,10)).sort(R_);const m=this.inputs.slice(),g=[];for(const b of p)for(const _ of h[b]){const v=_.outboundLayer;if(null!=v){for(const w of _.inputTensors)if(-1===m.indexOf(w))throw new $i(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${v.name}". The following previous layers were accessed without issue: ${g}`);for(const w of _.outputTensors)m.push(w);g.push(v.name)}}this.nodesByDepth=h;const y=this.layers.map(b=>b.name);for(const b of y){const _=y.filter(v=>v===b).length;if(1!==_)throw new $i(`The name "${b}" is used ${_} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new V_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new O("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.layers)e.push(...r.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const r={};let s=0;for(const o of this.layers)for(const a of o.weights){if(null!=r[a.originalName])throw new O(`Duplicate weight name: ${a.originalName}`);r[a.originalName]=a,s++}const i=[];for(const o in t){let a=o;if(null==r[o]){const l=o.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(null!=r[a])i.push([r[a],t[o]]);else if(e)throw new O(`Provided weight data has no target variable: ${o}`);delete r[a]}if(e){const o=[];for(const a in r)o.push(a);if(o.length>0)throw new O(`${o.length} of ${s} weights are not set: ${o}`)}QD(i)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 4.1.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const r=oT(this.updatedConfig());return e?JSON.stringify(r):r}call(t,e){return V(()=>{t=sn(t);const r=new pl;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],t[s]);return Kp(this.outputs,r,e)})}computeMask(t,e){return V(()=>{let r;return t=sn(t),r=null==e?wc(null,t.length):sn(e),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){const e=L_(t);if(e.length!==this.inputLayers.length)throw new O(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<e.length;a++)r[this.inputLayers[a].name+"_0_0"]=e[a];const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(R_);if(s.length>1)for(const a of s){const l=this.nodesByDepth[a];for(const c of l){const u=c.outboundLayer;if(-1!==this.inputLayers.map(m=>m.id).indexOf(u.id))continue;const d=[];for(let m=0;m<c.inboundLayers.length;m++)d.push(r[`${c.inboundLayers[m].name}_${c.nodeIndices[m]}_${c.tensorIndices[m]}`]);const f=L_(u.computeOutputShape(bs(d))),p=u.inboundNodes.indexOf(c);for(let m=0;m<f.length;m++)r[`${u.name}_${p}_${m}`]=f[m]}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++)o.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<o.length;a++){const l=o[a];di(l in r),i.push(r[l])}return bs(i)}runInternalGraph(t,e){null==e&&(e=wc(null,t.length));const r={};for(let l=0;l<this.inputs.length;++l)r[this.inputs[l].id]=[t[l],e[l]];const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(R_);for(const l of s){const c=this.nodesByDepth[l];for(const u of c){const d=u.outboundLayer,h=u.inputTensors,f=u.outputTensors,p=new Array;for(const m of h)m.id in r&&p.push(r[m.id]);if(p.length===h.length){let g,y,b,_,m={};if(null!=u.callArgs&&(m=u.callArgs),1===p.length){const[v,w]=p[0];null==m.mask&&(m.mask=w),b=sn(d.call(v,m)),_=sn(d.computeMask(v,w)),g=[v],y=[w]}else g=p.map(v=>v[0]),y=p.map(v=>v[1]),null==m.mask&&(m.mask=y),b=sn(d.call(g,m)),_=sn(d.computeMask(g,y));if(d.activityRegularizer)throw new tt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<f.length;++v)r[f[v].id]=[b[v],_[v]]}}}const i=[],o=[],a=[];for(const l of this.outputs){di(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[c,u]=r[l.id];a.push(c.shape),i.push(c),o.push(u)}return[i,o,a]}buildNodeConversionMap(t){const e={};let r;for(const s of this.layers){r=s instanceof fo?1:0;for(let i=0;i<s.inboundNodes.length;i++){const o=fo.nodeKey(s,i);this.containerNodes.has(o)&&(e[o]=r,r+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new O(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new O("Provide either a layer name or layer index");for(const r of this.layers)if(r.name===t)return r;throw new O(`No such layer: ${t}`)}calculateLosses(){return V(()=>{const t=[];for(const e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){const s=fo.nodeKey(e,r);this.containerNodes.has(s)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let d=0;d<o.inboundNodes.length;d++){const h=o.inboundNodes[d],f=fo.nodeKey(o,d);let p={};if(this.containerNodes.has(f)){if(h.callArgs)try{JSON.stringify(h.callArgs),p=h.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(h.inboundLayers.length>0){const m=[];for(let g=0;g<h.inboundLayers.length;g++){const y=h.inboundLayers[g],_=h.tensorIndices[g];let w=e[fo.nodeKey(y,h.nodeIndices[g])];null==w&&(w=0),m.push([y.name,w,_,p])}c.push(m)}}}const u={};u.name=o.name,u.className=a,u.config=l,u.inboundNodes=c,r.push(u)}t.layers=r;const s=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],c=fo.nodeKey(a,this.inputLayersNodeIndices[o]);if(!this.containerNodes.has(c))continue;let u=e[c];null==u&&(u=0),s.push([a.name,u,this.inputLayersTensorIndices[o]])}t.inputLayers=s;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],c=fo.nodeKey(a,this.outputLayersNodeIndices[o]);if(!this.containerNodes.has(c))continue;let u=e[c];null==u&&(u=0),i.push([a.name,u,this.outputLayersTensorIndices[o]])}return t.outputLayers=i,t}static fromConfig(t,e,r={},s=!1){const i={},o={};function a(g,y){g.name in o?o[g.name].push(y):o[g.name]=[y]}function l(g,y){const b=[];let _;for(const v of y){const w=v[0],C=v[1],I=v[2];if(_=v[3]??{},!(w in i))return void a(g,y);const D=i[w];if(D.inboundNodes.length<=C)return void a(g,y);b.push(D.inboundNodes[C].outputTensors[I])}b.length>0&&g.apply(bs(b),_)}function c(g){const y=g.name,b=Sa(g,null!=e.customObjects?e.customObjects:{});b.setFastWeightInitDuringBuild(s),i[y]=b,g.inboundNodes.forEach(v=>{if(!(v instanceof Array))throw new O(`Corrupted configuration, expected array for nodeData: ${v}`);a(b,v)})}const u=e.name,d=e.layers;for(const g of d)c(g);for(;!Dde(o);)for(const g of d){const y=i[g.name];if(y.name in o){const b=o[y.name];delete o[y.name];for(const _ of b)l(y,_)}}const h=[],f=[],p=e.inputLayers;for(const g of p){const y=g[0],b=g[1],_=g[2];di(y in i),h.push(i[y].inboundNodes[b].outputTensors[_])}const m=e.outputLayers;for(const g of m){const y=g[0],b=g[1],_=g[2];di(y in i),f.push(i[y].inboundNodes[b].outputTensors[_])}return new t({inputs:h,outputs:f,name:u})}get stateful(){if(this._stateful)throw new O("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){V(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function fz(n,t){return function hz(n,t,e){const r=t.length;if(null==n||Array.isArray(n)&&0===n.length)return t.map(s=>null);if(1===r)return Array.isArray(n)&&1===n.length?n:"object"==typeof n&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}if("object"==typeof n&&Object.keys(n).length>0&&"object"==typeof n[Object.keys(n)[0]]){const s=[];return t.forEach(i=>{s.push(i in n?n[i]:null)}),s}throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}(n,t,"classWeight")}function pz(n,t,e,r){return lT.apply(this,arguments)}function lT(){return(lT=ee(function*(n,t,e,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const s=V(()=>{if(1===n.shape.length)return ma(n);if(2===n.shape.length){if(n.shape[1]>1)return dd(n,1);if(1===n.shape[1])return F(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(yield s.data());Qe(s);const o=[];return i.forEach(a=>{if(null==e[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(e[a])}),ys(o,"float32")}return null})).apply(this,arguments)}function Uhe(n,t){return M(n,t)}function mz(n,t){let e,r;e=t.xs,r=t.ys,S(null!=e&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const i=gz("input",n.inputNames,e),o=gz("output",n.outputNames,r),a=i[0].shape[0];S(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),S(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<i.length;l++)S(i[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)S(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function gz(n,t,e){if(e instanceof pn)return[e];if(Array.isArray(e))return S(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const r=[];for(const s of t){if(null==e[s])throw new O(`The feature data generated by the dataset lacks the required ${n} key '${s}'.`);r.push(e[s])}return r}}function Whe(n){if(3===n.length)throw new tt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}function cT(){return(cT=ee(function*(n,t,e){const r=null!=e.batchesPerEpoch;if(S(null!=n.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),S(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),S(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),S(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),S(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const s=null!=e.validationData;let i,o;if(s)if(yz(e.validationData))S(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const g=Whe(e.validationData);i=g.xs,o=g.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;c=s?l.slice().concat(l.map(g=>"val_"+g)):l.slice();const u=tz(e.callbacks,e.yieldEvery),d=e.verbose??1,{callbackList:h,history:f}=nz(u,d,e.epochs,null,null,Ghe(t,e),null,s,c);h.setModel(n),n.history=f,yield h.onTrainBegin(),n.stopTraining_=!1;let p=e.initialEpoch??0,m=yield t.iterator();for(;p<e.epochs;){const g={};yield h.onEpochBegin(p);let y=0,b=0;for(r||(m=yield t.iterator());!r||y<e.batchesPerEpoch;){const _=yield m.next();if(r&&_.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=_.value){const{xs:v,ys:w}=mz(n,_.value),C={};C.batch=b,C.size=v[0].shape[0],yield h.onBatchBegin(b,C);const I=[];if(null!=e.classWeight){const N=fz(e.classWeight,n.outputNames);for(let $=0;$<N.length;++$)I.push(yield pz(w[$],null,N[$]))}const D=v.concat(w).concat(I),T=a(D);Qe(D);for(let N=0;N<l.length;++N){const z=T[N];C[l[N]]=z,xr(z)}yield h.onBatchEnd(b,C),ez(C),b++,y++}if(r?y>=e.batchesPerEpoch:_.done){if(s){let v;v=yz(e.validationData)?sn(yield n.evaluateDataset(e.validationData,{batches:e.validationBatches})):sn(n.evaluate(i,o,{batchSize:e.validationBatchSize??32,verbose:0}));for(let w=0;w<n.metricsNames.length;++w)g[`val_${n.metricsNames[w]}`]=v[w]}break}if(n.stopTraining_)break}if(yield h.onEpochEnd(p,g),p++,n.stopTraining_)break}return yield h.onTrainEnd(),yield n.history.syncData(),n.history}finally{n.isTraining=!1}})).apply(this,arguments)}function Ghe(n,t){let e=null;return null!=t.batchesPerEpoch?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function yz(n){return"function"==typeof n.iterator}function qhe(n){return"function"==typeof n.next}function uT(){return(uT=ee(function*(n,t,e){const r=null!=(e=e||{}).batches,s=n.testFunction;let i=[];if(e.verbose>0)throw new tt("Verbose mode is not implemented yet.");S(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=qhe(t)?t:yield t.iterator();let a=0,l=0;for(;!r||l<e.batches;){const c=yield o.next();if(i=V(()=>{if(c.value){const{xs:u,ys:d}=mz(n,c.value),h=u.concat(d),f=V(()=>s(h));if(Qe(h),0===l)for(let m=0;m<f.length;++m)i.push(Be(0));const p=h[0].shape[0];for(let m=0;m<f.length;++m){const g=f[m],y=i[m];i[m]=V(()=>le(i[m],M(p,g))),l>0&&Qe(y)}Qe(f),a+=p,++l}return i}),c.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<i.length;++c){const u=i[c];i[c]=Pe(i[c],a),Qe(u)}return bs(i)})).apply(this,arguments)}function dT(n){S(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Zp(n,t,e){return null==n?[null]:Array.isArray(n)?n.map(r=>Ic(r,t,e-t)):Ic(n,t,e-t)}function hT(n,t){return V(()=>null==n?null:Array.isArray(n)?n.map(e=>hT(e,t)):LV(n,"int32"===t.dtype?t:ve(t,"int32")))}function fT(n,t){const e=[];let r=0,s=null;for(;r<n;)s=r+t,s>=n&&(s=n),e.push([r,s]),r=s;return e}function bz(n){const t=[];n instanceof pn&&(n=[n]);for(let e=0;e<n.length;++e){const r=n[e];if(1===r.rank)t.push(jp(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function po(n,t){if(null==n)return;const e=[];if(t instanceof pn)e.push(t.id);else if(Array.isArray(t))t.forEach(s=>e.push(s.id));else if(null!=t)for(const s in t)e.push(t[s].id);const r=[];if(n instanceof pn)-1===e.indexOf(n.id)&&r.push(n);else if(Array.isArray(n))n.forEach(s=>{-1===e.indexOf(s.id)&&r.push(s)});else if(null!=n)for(const s in n){const i=n[s];-1===e.indexOf(i.id)&&r.push(i)}r.forEach(s=>{s.isDisposed||s.dispose()})}function pT(n){return Array.isArray(n)}function _z(n){return!function Xhe(n){return n instanceof pn}(n)&&!pT(n)}function vz(n,t,e,r=!0,s=""){if(null==t||0===t.length){if(null!=n){let o=!1;if(pT(n)&&n.length>0)o=!0;else if(_z(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new O(`Error when checking model ${s} expected no data, but got ${n}`)}return[]}if(null==n)return t.map(o=>null);let i;if(_z(n)){i=[];for(const o of t){if(null==n[o])throw new O(`No data provided for "${o}". Need data for each key in: ${t}`);i.push(n[o])}}else if(pT(n)){if(n.length!==t.length)throw new O(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(t.length>1)throw new O(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=bz(i),null!=e)for(let o=0;o<t.length;++o){if(null==e[o])continue;const a=i[o];if(a.shape.length!==e[o].length)throw new O(`Error when checking ${s}: expected ${t[o]} to have ${e[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[o].length;++l){if(0===l&&!r)continue;const c=a.shape[l],u=e[o][l];if(null!=u&&u>=0&&c!==u)throw new O(`${s} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${s} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function xz(n,t,e,r=!0,s=""){let i;if(Array.isArray(n)){if(n.length!==t.length)throw new O(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(t.length>1)throw new O(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(null!=e)for(let o=0;o<t.length;++o){if(null==e[o])continue;const a=i[o];if(a.shape.length!==e[o].length)throw new O(`Error when checking ${s}: expected ${t[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[o].length;++l){if(0===l&&!r)continue;const c=a.shape[l],u=e[o][l];if(null!=u&&u!==c)throw new O(`Error when checking ${s}: expected ${t[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let Ed=(()=>{class n extends fo{constructor(e){super(e),this.isTraining=!1}summary(e,r,s=console.log){if(!this.built)throw new O("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function $he(n,t,e,r=console.log){const s=function Bhe(n){let t=!0;const e=[],r=[];for(const s in n.nodesByDepth)e.push(n.nodesByDepth[s]);for(const s of e){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of n.layers){let i=!1;for(const o of s.inboundNodes)if(-1!==r.indexOf(o)){if(i){t=!1;break}i=!0}if(!t)break}return t}(n),i=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(s?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(u=>Math.floor(t*u))),!s){i.push("Receives inputs"),o=[];for(const u in n.nodesByDepth)o.push(...n.nodesByDepth[u])}r("_".repeat(t)),Z_(i,e,r),r("=".repeat(t));const a=n.layers;for(let u=0;u<a.length;++u)s?Vhe(a[u],e,r):zhe(a[u],e,o,r),r((u===a.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const l=function Lhe(n){let t;return t=B_(null!=n.collectedTrainableWeights?n.collectedTrainableWeights:n.trainableWeights),t}(n),c=B_(n.nonTrainableWeights);r(`Total params: ${l+c}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${c}`),r("_".repeat(t))}(this,e,r,s)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function Phe(n){const t={Adagrad:()=>xd.adagrad(.01),Adadelta:()=>xd.adadelta(1,.95,ir()),Adam:()=>xd.adam(.001,.9,.999,ir()),Adamax:()=>xd.adamax(.002,.9,.999,ir(),0),RMSProp:()=>xd.rmsprop(.001,.9,0,ir()),SGD:()=>xd.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new O(`Unknown Optimizer ${n}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof rl))throw new O("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new O(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(l=>rT(l))}else{const a=rT(e.loss);this.outputs.forEach(l=>{r.push(a)})}else{e.loss=e.loss;for(const a in e.loss)if(-1===this.outputNames.indexOf(a))throw new O(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==e.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(rT(e.loss[a]))}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const l=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ec("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(-1!==s.indexOf(a))continue;const l=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([l,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const i=function Qhe(n,t){if(null==n||Array.isArray(n)&&0===n.length)return t.map(r=>[]);let e;if("string"==typeof n||"function"==typeof n)e=[n];else{if(!Array.isArray(n)&&"object"!=typeof n)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);e=n}if(Array.isArray(e))return t.map(r=>e);{const r=[];for(const s of t){let i=e.hasOwnProperty(s)?e[s]:[];Array.isArray(i)||(i=[i]),r.push(i)}return r}}(e.metrics,this.outputNames),o=(a,l,c)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([c,a])};Ec("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===s.indexOf(a)&&(u=>{let h,f,p;for(const m of u){if("string"==typeof m&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(m)){const y=this.internalOutputShapes[a];let b;1===y[y.length-1]||this.lossFunctions[a]===q_?-1!==["accuracy","acc"].indexOf(m)?f=sz:-1!==["crossentropy","ce"].indexOf(m)&&(f=Ihe):this.lossFunctions[a]===G_?-1!==["accuracy","acc"].indexOf(m)?f=Dhe:-1!==["crossentropy","ce"].indexOf(m)&&(f=lz):-1!==["accuracy","acc"].indexOf(m)?f=iz:-1!==["crossentropy","ce"].indexOf(m)&&(f=az),-1!==["accuracy","acc"].indexOf(m)?b="acc":-1!==["crossentropy","ce"].indexOf(m)&&(b="ce"),p=f,h=""+b}else p=Ohe(m),h=""+Y_(m);let g;Ec(h,()=>{g=p}),o(a,h,g)}})(i[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,s={}){const i=s.batchSize??32;dT(i);const a=this.standardizeUserDataXY(e,r,!0,i);try{const l=a[0].concat(a[1]);return this.makeTestFunction(),bs(this.testLoop(this.testFunction,l,i,s.verbose,s.steps))}finally{po(a[0],e),po(a[1],r)}}evaluateDataset(e,r){var s=this;return ee(function*(){return s.makeTestFunction(),function Khe(n,t,e){return uT.apply(this,arguments)}(s,e,r)})()}checkNumSamples(e,r,s,i="steps"){let o;if(null!=s){if(o=null,null!=r)throw new O(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else{if(null==e)throw new O(`Either the input data should have a defined shape, or ${i} shoud be specified.`);o=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return o}execute(e,r){if(Array.isArray(r)&&0===r.length)throw new O("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(r),o=this.retrieveSymbolicTensors(s?r:[r]),a=new pl;if(e instanceof pn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new O(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)a.add(this.inputs[c],e[c])}else for(const c of this.inputs){const u=e[c.name];if(null==u)throw new O(`No value is provided for the model's input ${c.name}`);a.add(c,u)}const l=Kp(o,a);return s?l:l[0]}retrieveSymbolicTensors(e){const r=wc(null,e.length);let s=e.length;for(const i of this.layers){const o=Array.isArray(i.output)?i.output:[i.output],a=o.map(l=>l.name);for(let l=0;l<e.length;++l){const c=a.indexOf(e[l]);if(-1!==c&&(r[l]=o[c],s--),0===s)break}if(0===s)break}if(s>0){const i=[];throw r.forEach((o,a)=>{null==o&&i.push(e[a])}),new O(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return r}predictLoop(e,r=32,s=!1){return V(()=>{const i=this.checkNumSamples(e);if(s)throw new tt("Verbose predictLoop() is not implemented yet.");const o=fT(i,r),a=this.outputs.map(l=>[]);for(let l=0;l<o.length;++l)V(()=>{const h=Zp(e,o[l][0],o[l][1]),f=[];if(Array.isArray(h))for(let m=0;m<h.length;++m)f.push({key:this.inputs[m],value:h[m]});else f.push({key:this.inputs[0],value:h});const p=new pl(f);return Kp(this.outputs,p)}).forEach((u,d)=>a[d].push(u));return bs(a.map(l=>Xn(l,0)))})}predict(e,r={}){const s=bz(e);xz(s,this.inputNames,this.feedInputShapes,!1);try{const i=r.batchSize??32;return dT(i),this.predictLoop(s,i)}finally{po(s,e)}}predictOnBatch(e){xz(e,this.inputNames,this.feedInputShapes,!0);const r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,s=!0,i){if(null==this.optimizer_)throw new $i("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let a=0;a<this.feedOutputShapes.length;++a){const l=this.feedOutputShapes[a];o.push(this.feedLossFns[a]===G_?l.slice(0,l.length-1).concat([1]):l)}if(function Yhe(n,t,e){const r=dl(n.map(i=>i.shape[0]));r.sort();const s=dl(t.map(i=>i.shape[0]));if(s.sort(),r.length>1)throw new O(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(s.length>1)throw new O(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(r.length>0&&s.length>0&&!It(r,s))throw new O(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(e=vz(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=vz(r,this.feedOutputNames,o,!1,"target")),function Zhe(n,t,e){const r=[j_,q_,Yp];for(let s=0;s<n.length;++s){const i=n[s],o=t[s],a=e[s];if(null!=o){if(o===Yp&&1===i.shape[i.shape.length-1])throw new O(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(o)){const l=i.shape.slice(1),c=a.slice(1);for(let u=0;u<l.length;++u){const d=l[u],h=c[u];if(null!=h&&d!==h)throw new O(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=i&&i>0&&e[0].shape[0]%i!=0)throw new O(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,s,i,o=!0,a){var l=this;return ee(function*(){const[c,u]=l.standardizeUserDataXY(e,r,o,a);if(null!=s)throw new Error("sample weight is not supported yet.");let d=null;if(null!=i){const h=fz(i,l.outputNames);d=[];for(let f=0;f<h.length;++f)d.push(yield pz(u[f],null,h[f]))}return[c,u,d]})()}testLoop(e,r,s,i=0,o){return V(()=>{const a=this.checkNumSamples(r,s,o,"steps"),l=[];if(i>0)throw new tt("Verbose mode is not implemented yet.");if(null!=o)throw new tt("steps mode in testLoop() is not implemented yet");{const c=fT(a,s),u=ys(co(0,a));for(let d=0;d<c.length;++d){const h=c[d][0],f=c[d][1],p=Ic(u,h,f-h),m=hT(r,p),g=e(m);if(0===d)for(let y=0;y<g.length;++y)l.push(Be(0));for(let y=0;y<g.length;++y)l[y]=le(l[y],M(f-h,g[y]))}for(let d=0;d<l.length;++d)l[d]=Pe(l[d],a)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,r=[];for(let s=0;s<e.length;++s){const i=e[s];let o=i;DV(e,i)>1&&(o+=`_${DV(e.slice(0,s),i)}`),r.push(o)}return r}makeTrainFunction(){return e=>{const r=[],s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],c=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(()=>{const h=[];for(let g=0;g<this.inputs.length;++g)h.push({key:this.inputs[g],value:s[g]});const f=new pl(h),p=Kp(this.outputs,f,{training:!0});let m;for(let g=0;g<this.lossFunctions.length;++g){let b=(0,this.lossFunctions[g])(i[g],p[g]);null!=o[g]&&(b=Uhe(b,o[g]));const _=Rn(b);r.push(_),m=0===g?b:le(m,b)}for(let g=0;g<this.metricsTensors.length;++g){let y;if(this.outputs.length>1&&g<this.outputs.length)y=r[g];else{const _=this.metricsTensors[g][1];y=Rn((0,this.metricsTensors[g][0])(i[_],p[_]))}xr(y),a.push(y)}return m=Rn(m),this.calculateLosses().forEach(g=>{m=le(m,g)}),m},!0,c)].concat(a)}}makeTestFunction(){this.testFunction=e=>V(()=>{const r=[];let s;const i=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let u=0;u<this.inputs.length;++u)a.push({key:this.inputs[u],value:i[u]});const l=new pl(a),c=Kp(this.outputs,l);for(let u=0;u<this.lossFunctions.length;++u){const h=Rn((0,this.lossFunctions[u])(o[u],c[u]));s=0===u?h:le(s,h),r.push(s)}for(let u=0;u<this.metricsTensors.length;++u){const h=this.metricsTensors[u][1],f=Rn((0,this.metricsTensors[u][0])(o[h],c[h]));r.push(f)}return r})}fit(e,r,s={}){var i=this;return ee(function*(){if(i.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let o,a,l,c,u,d,h,f,p;i.isTraining=!0;try{const m=s.batchSize??32;dT(m);const g=!1,y=yield i.standardizeUserData(e,r,s.sampleWeight,s.classWeight,g,m);o=y[0],a=y[1],p=y[2];let _,b=!1;if(null!=s.validationData&&s.validationData.length>0){if(b=!0,2!==s.validationData.length)throw 3===s.validationData.length?new tt("validationData including sample weights is not supported yet."):new O(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);u=s.validationData[0],d=s.validationData[1];const $=!0,z=yield i.standardizeUserData(u,d,null,null,$,m);h=z[0],f=z[1],_=h.concat(f)}else if(null!=s.validationSplit&&s.validationSplit>0&&s.validationSplit<1){b=!0;const $=Math.floor(o[0].shape[0]*(1-s.validationSplit)),z=o[0].shape[0];h=Zp(o,$,z),l=o,o=Zp(o,0,$),f=Zp(a,$,z),c=a,a=Zp(a,0,$),_=h.concat(f)}else null!=s.validationSteps&&(b=!0);const v=o.concat(a).concat(p);i.checkTrainableWeightsConsistency();const w=i.makeTrainFunction(),C=i.getDedupedMetricsNames();let I,D;b?(i.makeTestFunction(),I=i.testFunction,D=C.slice().concat(C.map($=>"val_"+$))):(I=null,_=[],D=C.slice());const T=tz(s.callbacks,s.yieldEvery);return yield i.fitLoop(w,v,C,m,s.epochs,s.verbose,T,I,_,s.shuffle,D,s.initialEpoch,null,null)}finally{i.isTraining=!1,po(o,e),po(a,r),po(l,e),po(c,r),po(h,u),po(f,d),null!=p&&Qe(p)}})()}fitLoop(e,r,s,i,o,a,l,c,u,d,h,f,p,m){var g=this;return ee(function*(){null==i&&(i=32),null==o&&(o=1),null==d&&(d=!0),null==f&&(f=0);let y=!1;if(null!=c&&null!=u&&(y=!0),null!=m&&(y=!0,null==p))throw new O("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const b=g.checkNumSamples(r,i,p,"steps_per_epoch");let _;null!=b&&(_=co(0,b)),null==a&&(a=1);const{callbackList:v,history:w}=nz(l,a,o,f,b,p,i,y,h);v.setModel(g),g.history=w,yield v.onTrainBegin(),g.stopTraining_=!1;for(let C=f;C<o;++C){yield v.onEpochBegin(C);const I={};if(null!=p)throw new tt("stepsPerEpoch mode is not implemented yet.");{if("batch"===d)throw new tt("batch shuffling is not implemneted yet");d&&T$(_);const D=ys(_),T=fT(b,i);for(let N=0;N<T.length;++N){const $={};if(yield v.onBatchBegin(N,$),V(()=>{const z=T[N][0],j=T[N][1],q=Ic(D,z,j-z);$.batch=N,$.size=j-z;const K=hT(r,q),P=e(K);for(let B=0;B<s.length;++B){const W=P[B];$[s[B]]=W,xr(W)}if(N===T.length-1&&y){const B=g.testLoop(c,u,i);for(let L=0;L<s.length;++L){const W=s[L],ne=B[L];xr(ne),I["val_"+W]=ne}}}),yield v.onBatchEnd(N,$),ez($),g.stopTraining_)break}D.dispose()}if(yield v.onEpochEnd(C,I),g.stopTraining_)break}return yield v.onTrainEnd(),yield g.history.syncData(),g.history})()}fitDataset(e,r){var s=this;return ee(function*(){return function jhe(n,t,e){return cT.apply(this,arguments)}(s,e,r)})()}trainOnBatch(e,r){var s=this;return ee(function*(){const i=yield s.standardizeUserData(e,r),o=i[0],a=i[1],c=s.makeTrainFunction()(o.concat(a)),u=[];for(const d of c){const h=yield d.data();u.push(h[0])}return Qe(c),po(i[0],e),po(i[1],r),bs(u)})()}getNamedWeights(e){const r=[],s=null!=e&&e.trainableOnly,i=s?this.trainableWeights:this.weights,o=this.getWeights(s);for(let a=0;a<i.length;++a)s&&!i[a].trainable||r.push({name:i[a].originalName,tensor:o[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const r=_I().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-_I().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=Ca(this.loss);else if(Array.isArray(this.loss)){for(const r of this.loss)if("string"!=typeof r)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>Ca(r))}else{const r=Object.keys(this.loss);e={};const s=this.loss;for(const i of r){if("string"!=typeof s[i])throw new Error("Serialization of non-string loss is not supported.");e[i]=Ca(s[i])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Ca(Y_(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Ca(Y_(e)));{const e={};for(const r in this.metrics)e[r]=Ca(Y_(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const s=Sa(iT(e.optimizer_config));let i,o;if("string"==typeof e.loss)i=Cc(e.loss);else if(Array.isArray(e.loss))i=e.loss.map(a=>Cc(a));else if(null!=e.loss){i={};for(const a in e.loss)i[a]=Cc(e.loss[a])}if(Array.isArray(e.metrics))o=e.metrics.map(a=>Cc(a));else if(null!=e.metrics){o={};for(const a in e.metrics)o[a]=Cc(e.metrics[a])}this.compile({loss:i,metrics:o,optimizer:s})}save(e,r){var s=this;return ee(function*(){if("string"==typeof e){const d=oL(e);if(0===d.length)throw new O(`Cannot find any save handlers for URL '${e}'`);if(d.length>1)throw new O(`Found more than one (${d.length}) save handlers for URL '${e}'`);e=d[0]}if(null==e.save)throw new O("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const i=yield jE(s.getNamedWeights(r)),c={modelTopology:s.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v4.1.0",convertedBy:null};if(null!=r&&r.includeOptimizer&&null!=s.optimizer){c.trainingConfig=s.getTrainingConfig();const d="optimizer",{data:h,specs:f}=yield jE(yield s.optimizer.getWeights(),d);i.specs.push(...f),i.data=Qb([i.data,h])}return null!=s.userDefinedMetadata&&(uz(s.userDefinedMetadata,s.name,!0),c.userDefinedMetadata=s.userDefinedMetadata),c.weightData=i.data,c.weightSpecs=i.specs,e.save(c)})()}setUserDefinedMetadata(e){uz(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return n.className="Model",n})();se(Ed),se((()=>{class n extends Ed{}return n.className="Functional",n})()),se((()=>{class n extends Ed{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:F_("sequential_"),null!=e.layers)for(const r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new O(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const r=e instanceof n||e instanceof Ed;let s;if(r){if(s=e,1!==s.outputs.length)throw new O("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==s.inputs.length)throw new O("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new O("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=function rhe(n){if(null==n.batchShape&&null==n.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=n.batchShape&&null!=n.shape)throw new O("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;null!=n.shape&&null==t&&(t=[null].concat(n.shape));let e=n.dtype;return null==e&&(e="float32"),new z_({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(r)this.outputs=s.outputs,this.inputs=s.inputs;else{if(1!==e.inboundNodes.length)throw new O(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new O("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=YV(this.outputs[0])}this.inboundNodes=[],new V_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:wc(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=e.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return null==this.model&&this.build(),this.model.call(e,r)}build(e){if($t(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Ed({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,s=console.log){this.built||this.build(),super.summary(e,r,s)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,r,s={}){if(!this.built)throw new $i("The model needs to be compiled before being used.");return this.model.evaluate(e,r,s)}evaluateDataset(e,r){var s=this;return ee(function*(){if(!s.built)throw new $i("The model needs to be compiled before being used.");return s.model.evaluateDataset(e,r)})()}predict(e,r={}){return null==this.model&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,r,s={}){var i=this;return ee(function*(){if(!i.built)throw new $i("The model needs to be compiled before being used.");return i.model.fit(e,r,s)})()}fitDataset(e,r){var s=this;return ee(function*(){if(!s.built)throw new $i("The model needs to be compiled before being used.");return s.model.fitDataset(e,r)})()}trainOnBatch(e,r){var s=this;return ee(function*(){return s.model.trainOnBatch(e,r)})()}static fromConfig(e,r,s={},i=!1){let o,a={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new O("Legacy serialization format not supported yet.");o=r}else S(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=r.layers,delete r.layers,a=r;const l=new e(a);if(!(l instanceof n))throw new tt(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const c of o){const d=Sa(c,void 0,i);i&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(e){if(null==this.model)throw new O("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new O("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const r of this.layers){const s={};s.className=r.getClassName(),s.config=r.getConfig(),e.push(s)}return{name:this.name,layers:e}}}return n.className="Sequential",n})());class _s extends ud{getConfig(){return{}}}se((()=>{class n extends _s{apply(e,r=1){return function Wde(n,t=1){if(1!==t)throw new tt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Tp(n)}(e,r)}}return n.className="elu",n})()),se((()=>{class n extends _s{apply(e){return WI(e)}}return n.className="selu",n})()),se((()=>{class n extends _s{apply(e){return Po(e)}}return n.className="relu",n})()),se((()=>{class n extends _s{apply(e){return V(()=>Mp(6,Po(e)))}}return n.className="relu6",n})()),se((()=>{class n extends _s{apply(e){return e}}return n.className="linear",n})()),se((()=>{class n extends _s{apply(e){return Fo(e)}}return n.className="sigmoid",n})()),se((()=>{class n extends _s{apply(e){return function Gde(n){return V(()=>{const t=le(.5,M(.2,n));return Os(t,0,1)})}(e)}}return n.className="hardSigmoid",n})()),se((()=>{class n extends _s{apply(e){return gd(e)}}return n.className="softplus",n})()),se((()=>{class n extends _s{apply(e){return function jde(n){return V(()=>Pe(n,le(rr(n),1)))}(e)}}return n.className="softsign",n})()),se((()=>{class n extends _s{apply(e){return fd(e)}}return n.className="tanh",n})());let wz=(()=>{class n extends _s{apply(e,r=-1){return x_(e,r)}}return n.className="softmax",n})();function gl(n){return n.getClassName()}function bT(n,t={}){return Hp(n,Ni.getMap().classNameMap,t,"activation")}function yl(n){if(null==n){return bT({className:"linear",config:{}})}if("string"==typeof n){const t={};return t.className=n,t.config={},bT(t)}return n instanceof _s?n:bT(n)}se(wz),se((()=>{class n extends _s{apply(e,r=-1){return MI(e,r)}}return n.className="logSoftmax",n})()),se((()=>{class n extends _s{apply(e,r=1){return V(()=>M(Fo(M(e,r)),e))}}return n.className="swish",n})()),se((()=>{class n extends _s{apply(e){return V(()=>M(e,fd(gd(e))))}}return n.className="mish",n})());class Cz extends ud{}se((()=>{class n extends Cz{constructor(e){super(),function _T(n){if(null!=n&&"object"!=typeof n)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return V(()=>{let r=sr([1]);return this.hasL1&&(r=le(r,Ae(M(this.l1,rr(e))))),this.hasL2&&(r=le(r,Ae(M(this.l2,Gp(e))))),F(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return n.className="L1L2",n})());const Sz={l1l2:"L1L2"};function en(n){return HD(n)}function Ez(n,t={}){return Hp(n,Ni.getMap().classNameMap,t,"regularizer")}function xn(n){return null==n?null:"string"==typeof n?Ez({className:n in Sz?Sz[n]:n,config:{}}):n instanceof Cz?n:Ez(n)}function Id(n,t,e){if("number"==typeof n)return wc(n,t);if(n.length!==t)throw new O(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let r=0;r<t;++r){const s=n[r];if(!Lde(s))throw new O(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${s}`)}return n}function mo(n,t,e,r,s=1){if(null==n)return n;let o;return o="same"===e?n:n-(t+(t-1)*(s-1))+1,Math.floor((o+r-1)/r)}function Ho(n,t,e,r){if(null==n)return null;if("valid"===r)n=n*t+fl([e-t,0]);else{if("same"!==r)throw new O(`Unsupport padding mode: ${r}.`);n*=t}return n}function xT(n,t){return V(()=>(Un(t),"channelsFirst"===t?wt(n,[0,2,3,1]):n))}function Iz(n,t){return V(()=>(Un(t),"channelsFirst"===t?wt(n,[0,2,3,4,1]):n))}function wT(n,t,e,r=[1,1],s="valid",i,o,a=null){return V(()=>{if(null==i&&(i="channelsLast"),Un(i),3!==n.rank&&4!==n.rank)throw new O(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(3!==t.rank&&4!==t.rank)throw new O(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=xT(n,i);if("causal"===s)throw new tt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=FB({x:l,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:a}),"channelsFirst"===i&&(l=wt(l,[0,3,1,2])),l})}se((()=>{class n extends gt{constructor(e){super(e??{}),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,r){e=Ye(e);let s=Po(e);return null!=this.maxValue&&(s=Os(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ReLU",n})()),se((()=>{class n extends gt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=e.alpha??this.DEFAULT_ALPHA}call(e,r){const s=Ye(e);return u_(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LeakyReLU",n})()),se((()=>{class n extends gt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=vn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=xn(e.alphaRegularizer),this.alphaConstraint=lr(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new O(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const r=(e=$t(e)).slice(1);if(null!=this.sharedAxes)for(const i of this.sharedAxes)r[i-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(null!=this.sharedAxes)for(let i=1;i<e.length;++i)s[i]=e[i];this.inputSpec=[new or({ndim:e.length,axes:s})],this.built=!0}call(e,r){return e=Ye(e),y_(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Tn(this.alphaInitializer),alphaRegularizer:en(this.alphaRegularizer),alphaConstraint:ar(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return n.className="PReLU",n})()),se((()=>{class n extends gt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new tt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha??this.DEFAULT_ALPHA}call(e,r){const s=Ye(e);return Tp(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ELU",n})()),se((()=>{class n extends gt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=e.theta??this.DEFAULT_THETA}call(e,r){const s=Ye(e);return M(s,ve(Ps(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ThresholdedReLU",n})()),se((()=>{class n extends gt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new wz).apply,this.axis=e.axis??this.DEFAULT_AXIS}call(e,r){const s=Ye(e);return this.softmax(s,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Softmax",n})());class Q_ extends gt{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Q_.verifyArgs(e),this.rank=t,Sr(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new tt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Id(e.kernelSize,t,"kernelSize"),this.strides=Id(e.strides??1,t,"strides"),this.padding=e.padding??"valid",hi(this.padding),this.dataFormat=e.dataFormat??"channelsLast",Un(this.dataFormat),this.activation=yl(e.activation),this.useBias=e.useBias??!0,this.biasInitializer=vn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=lr(e.biasConstraint),this.biasRegularizer=xn(e.biasRegularizer),this.activityRegularizer=xn(e.activityRegularizer),this.dilationRate=Id(e.dilationRate??1,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new O(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new O(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new O(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(di("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!jD(t.kernelSize,"number",1,3))throw new O(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:gl(this.activation),useBias:this.useBias,biasInitializer:Tn(this.biasInitializer),biasRegularizer:en(this.biasRegularizer),activityRegularizer:en(this.activityRegularizer),biasConstraint:ar(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Dd extends Q_{constructor(t,e){super(t,e),this.kernel=null,Dd.verifyArgs(e),this.filters=e.filters,Sr(this.filters,"filters"),this.kernelInitializer=vn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=lr(e.kernelConstraint),this.kernelRegularizer=xn(e.kernelRegularizer)}build(t){t=$t(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new O(`The channel dimension of the input should be defined. Found ${t[e]}`);const r=t[e],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(t,e){return V(()=>{let r;t=Ye(t);const s=null==this.bias?null:this.bias.read(),i=kV(this.activation.getClassName());if(null!=i&&2===this.rank)r=wT(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(1===this.rank)r=function Dz(n,t,e,r=1,s="valid",i,o=1){return V(()=>{if(null==i&&(i="channelsLast"),Un(i),3!==n.shape.length)throw new O(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(3!==t.shape.length)throw new O(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new O(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===i&&(n=wt(n,[0,2,1])),"causal"===s)throw new tt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=CI(n,t,r,"same"===s?"same":"valid","NWC",o);return null!=e&&(a=ho(a,e)),a})}(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=wT(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new tt("convolutions greater than 3D are not implemented yet.");r=function Tz(n,t,e,r=[1,1,1],s="valid",i,o){return V(()=>{if(null==i&&(i="channelsLast"),Un(i),4!==n.rank&&5!==n.rank)throw new O(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(4!==t.rank&&5!==t.rank)throw new O(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=Iz(n,i);if("causal"===s)throw new tt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=JL(a,t,r,"same"===s?"same":"valid","NDHWC",o),null!=e&&(a=ho(a,e)),"channelsFirst"===i&&(a=wt(a,[0,4,1,2,3])),a})}(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=$t(t);const e=[],r="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let i=0;i<r.length;++i){const o=mo(r[i],this.kernelSize[i],this.padding,this.strides[i],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[i]);e.push(o)}let s=[t[0]];return"channelsLast"===this.dataFormat?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){const t={filters:this.filters,kernelInitializer:Tn(this.kernelInitializer),kernelRegularizer:en(this.kernelRegularizer),kernelConstraint:ar(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new O(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}let kz=(()=>{class n extends Dd{constructor(e){super(2,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!jD(e.kernelSize,"number",1,2))throw new O(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv2D",n})();se(kz);let Nz=(()=>{class n extends Dd{constructor(e){super(3,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new O(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv3D",n})();se(Nz),se((()=>{class n extends kz{constructor(e){if(super(e),this.inputSpec=[new or({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new O(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=$t(e)).length)throw new O("Input should have rank 4; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new O("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new or({ndim:4,axes:{[r]:s}})],this.built=!0}call(e,r){return V(()=>{let s=Ye(e);if(4!==s.shape.length)throw new O(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape;let a,l;"channelsFirst"===this.dataFormat?(a=2,l=3):(a=1,l=2);const u=i[l],h=this.kernelSize[1],p=this.strides[1],y=[i[0],Ho(i[a],this.strides[0],this.kernelSize[0],this.padding),Ho(u,p,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=wt(s,[0,2,3,1]));let b=EI(s,this.kernel.read(),y,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=wt(b,[0,3,1,2])),null!=this.bias&&(b=ho(b,this.bias.read(),this.dataFormat)),null!=this.activation&&(b=this.activation.apply(b)),b})}computeOutputShape(e){const r=(e=$t(e)).slice();let s,i,o;"channelsFirst"===this.dataFormat?(s=1,i=2,o=3):(s=3,i=1,o=2);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.strides[0],u=this.strides[1];return r[s]=this.filters,r[i]=Ho(r[i],c,a,this.padding),r[o]=Ho(r[o],u,l,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv2DTranspose",n})()),se((()=>{class n extends Nz{constructor(e){if(super(e),this.inputSpec=[new or({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new O(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=$t(e)).length)throw new O("Input should have rank 5; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new O("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new or({ndim:5,axes:{[r]:s}})],this.built=!0}call(e,r){return V(()=>{let s=Ye(e);if(5!==s.shape.length)throw new O(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape;let a,l,c;"channelsFirst"===this.dataFormat?(c=2,a=3,l=4):(c=1,a=2,l=3);const d=i[a],h=i[l],p=this.kernelSize[1],m=this.kernelSize[2],y=this.strides[1],b=this.strides[2],C=[i[0],Ho(i[c],this.strides[0],this.kernelSize[0],this.padding),Ho(d,y,p,this.padding),Ho(h,b,m,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=wt(s,[0,2,3,4,1]));let I=tB(s,this.kernel.read(),C,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(I=wt(I,[0,4,1,2,3])),null!==this.bias&&(I=ho(I,this.bias.read(),this.dataFormat)),null!==this.activation&&(I=this.activation.apply(I)),I})}computeOutputShape(e){const r=(e=$t(e)).slice();let s,i,o,a;"channelsFirst"===this.dataFormat?(s=1,i=2,o=3,a=4):(s=4,i=1,o=2,a=3);const l=this.kernelSize[0],c=this.kernelSize[1],u=this.kernelSize[2],d=this.strides[0],h=this.strides[1],f=this.strides[2];return r[s]=this.filters,r[i]=Ho(r[i],d,l,this.padding),r[o]=Ho(r[o],h,c,this.padding),r[a]=Ho(r[a],f,u,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv3DTranspose",n})());let nfe=(()=>{class n extends Dd{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==r.filters)throw new O("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=r.kernelInitializer||null!=r.kernelRegularizer||null!=r.kernelConstraint)throw new O("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=r.padding&&"same"!==r.padding&&"valid"!==r.padding)throw new O(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=r.depthMultiplier??1,this.depthwiseInitializer=vn(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=xn(r.depthwiseRegularizer),this.depthwiseConstraint=lr(r.depthwiseConstraint),this.pointwiseInitializer=vn(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=xn(r.pointwiseRegularizer),this.pointwiseConstraint=lr(r.pointwiseConstraint)}build(e){if((e=$t(e)).length<this.rank+2)throw new O(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r]||e[r]<0)throw new O(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);const s=e[r],i=this.kernelSize.concat([s,this.depthMultiplier]),o=[];for(let l=0;l<this.rank;++l)o.push(1);o.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new or({ndim:this.rank+2,axes:{[r]:s}})],this.built=!0}call(e,r){return V(()=>{let s;if(e=Ye(e),1===this.rank)throw new tt("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=wt(e,[0,2,3,1])),s=jI(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=ho(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),"channelsFirst"===this.dataFormat&&(s=wt(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Tn(this.depthwiseInitializer),e.pointwiseInitializer=Tn(this.pointwiseInitializer),e.depthwiseRegularizer=en(this.depthwiseRegularizer),e.pointwiseRegularizer=en(this.pointwiseRegularizer),e.depthwiseConstraint=ar(this.depthwiseConstraint),e.pointwiseConstraint=ar(this.pointwiseConstraint),e}}return n.className="SeparableConv",n})();function Az(n,t,e,r){if(Array.isArray(n)){if(null!=t||null!=e)throw new O("When inputs is an array, neither initialState or constants should be provided");null!=r&&(e=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function s(i){return null==i||Array.isArray(i)?i:[i]}return{inputs:n,initialState:t=s(t),constants:e=s(e)}}function Rz(n,t,e,r=!1,s,i,o=!1,a=!1){return V(()=>{const l=t.shape.length;if(l<3)throw new O(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(co(2,l));if(t=wt(t,c),null!=i)throw new tt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=ve(ve(s,"bool"),"float32")).rank===l-1&&(s=gs(s,-1)),s=wt(s,c)),r&&(t=Fi(t,0),null!=s&&(s=Fi(s,0)));const u=[];let d,h=e;const f=t.shape[0],p=Oi(t);let m,g;null!=s&&(m=Oi(s));for(let y=0;y<f;++y){const b=p[y],_=V(()=>n(b,h));if(null==s)d=_[0],h=_[1];else{const v=V(()=>{const w=m[y],C=De(ci(w),w);return{output:le(M(_[0],w),M(h[0],C)),newStates:h.map((T,N)=>le(M(_[1][N],w),M(T,C)))}});d=v.output,h=v.newStates}a&&u.push(d)}return a&&(g=ui(u,1)),[d,g,h]})}se((()=>{class n extends nfe{constructor(e){super(2,e)}}return n.className="SeparableConv2D",n})()),se((()=>{class n extends Dd{constructor(e){super(1,e),n.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!jD(e.kernelSize,"number",1,1))throw new O(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv1D",n})()),se((()=>{class n extends gt{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return V(()=>{if(e=Ye(e),"channelsLast"===this.dataFormat){const s=P_(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return P_(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const s=P_(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return P_(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Cropping2D",n})()),se((()=>{class n extends gt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size??this.DEFAULT_SIZE,this.dataFormat=e.dataFormat??"channelsLast",Un(this.dataFormat),this.interpolation=e.interpolation??"nearest",function Ode(n){Sc(Ade,"InterpolationFormat",n)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,r){return V(()=>{let s=Ye(e);const i=s.shape;if("channelsFirst"===this.dataFormat){s=wt(s,[0,2,3,1]);const o=this.size[0]*i[2],a=this.size[1]*i[3],l="nearest"===this.interpolation?xa.resizeNearestNeighbor(s,[o,a]):xa.resizeBilinear(s,[o,a]);return wt(l,[0,3,1,2])}{const o=this.size[0]*i[1],a=this.size[1]*i[2];return"nearest"===this.interpolation?xa.resizeNearestNeighbor(s,[o,a]):xa.resizeBilinear(s,[o,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}}return n.className="UpSampling2D",n})()),se((()=>{class n extends Q_{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier??1,this.depthwiseInitializer=vn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=lr(e.depthwiseConstraint),this.depthwiseRegularizer=xn(e.depthwiseRegularizer)}build(e){if((e=$t(e)).length<4)throw new O(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const r="channelsFirst"===this.dataFormat?1:3;if(null==e[r]||e[r]<0)throw new O(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);const s=e[r];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return V(()=>{let s=function rfe(n,t,e=[1,1],r="valid",s,i){return V(()=>{null==s&&(s="channelsLast"),Un(s);let o=xT(n,s);if(4!==n.rank)throw new O(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(4!==t.rank)throw new O(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=Dp(o,t,e,"same"===r?"same":"valid","NHWC",i),"channelsFirst"===s&&(o=wt(o,[0,3,1,2])),o})}(e=Ye(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=ho(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=$t(e);const s="channelsFirst"===this.dataFormat?e[3]:e[2],i="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,o=mo("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),a=mo(s,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],i,o,a]:[e[0],o,a,i]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Tn(this.depthwiseInitializer),e.depthwiseRegularizer=en(this.depthwiseRegularizer),e.depthwiseConstraint=ar(this.depthwiseRegularizer),e}}return n.className="DepthwiseConv2D",n})());let Qp=(()=>{class n extends gt{constructor(e){let r;if(super(e),null==e.cell)throw new O("cell property is missing for the constructor of RNN.");if(r=Array.isArray(e.cell)?new Oz({cells:e.cell}):e.cell,null==r.stateSize)throw new O("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=e.returnSequences??!1,this.returnState=e.returnState??!1,this.goBackwards=e.goBackwards??!1,this._stateful=e.stateful??!1,this.unroll=e.unroll??!1,this.supportsMasking=!0,this.inputSpec=[new or({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return this.states_??co(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null)}setStates(e){this.states_=e}computeOutputShape(e){YD(e)&&(e=e[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);const s=r[0];let i;if(i=this.returnSequences?[e[0],e[1],s]:[e[0],s],this.returnState){const o=[];for(const a of r)o.push([e[0],a]);return[i].concat(o)}return i}computeMask(e,r){return V(()=>{Array.isArray(r)&&(r=r[0]);const s=this.returnSequences?r:null;if(this.returnState){const i=this.states.map(o=>null);return[s].concat(i)}return s})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let s=0;s<e;++s)r.push(null);return r}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new tt("Constants support is not implemented in RNN yet.");YD(e)&&(e=e[0]);const s=this.stateful?e[0]:null,i=e.slice(2);this.inputSpec[0]=new or({shape:[s,null,...i]});const o=[e[0]].concat(e.slice(2));let a;if(this.cell.build(o),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!It(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new O(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new or({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){V(()=>{if(!this.stateful)throw new Lo("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(null==s)throw new O("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(i=>sr([s,i])):[sr([s,this.cell.stateSize])];else if(null==e)Qe(this.states_),null!=this.keptStates&&(Qe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>sr([s,i])):this.states_[0]=sr([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new O(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===r?this.keptStates.push(this.states_.slice()):Qe(this.states_);for(let i=0;i<this.states_.length;++i){const o=e[i],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,l=[s,a];if(!It(o.shape,l))throw new O(`State ${i} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${o.shape}`);this.states_[i]=o}}this.states_=this.states_.map(i=>xr(i.clone()))})}apply(e,r){let s=null==r?null:r.initialState,i=null==r?null:r.constants;null==r&&(r={});const o=Az(e,s,i,this.numConstants);e=o.inputs,s=o.initialState,i=o.constants;let a=[],l=[];if(null!=s){r.initialState=s,a=a.concat(s),this.stateSpec=[];for(const u of s)this.stateSpec.push(new or({shape:u.shape}));l=l.concat(this.stateSpec)}if(null!=i&&(r.constants=i,a=a.concat(i),this.numConstants=i.length),a[0]instanceof Uo){const u=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(u,r);return this.inputSpec=h,f}return super.apply(e,r)}call(e,r){return V(()=>{const s=null==r?null:r.mask,i=null==r?null:r.training;let o=null==r?null:r.initialState;e=Ye(e),null==o&&(o=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==a)throw new O(`RNN Layer has ${a} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:i},u=Rz((m,g)=>{const y=this.cell.call([m].concat(g),l);return[y[0],y.slice(1)]},e,o,this.goBackwards,s,null,this.unroll,this.returnSequences),d=u[0],h=u[1],f=u[2];this.stateful&&this.resetStates(f,i);const p=this.returnSequences?h:d;return this.returnState?[p].concat(f):p})}getInitialState(e){return V(()=>{let r=sr(e.shape);return r=Ae(r,[1,2]),r=jp(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?KD(r,[1,s]):r):this.cell.stateSize>1?[KD(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===n.className&&(r.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),r)}static fromConfig(e,r,s={}){const o=Sa(r.cell,s);return new e(Object.assign(r,{cell:o}))}}return n.className="RNN",n})();se(Qp);class J_ extends gt{}let Mz=(()=>{class n extends J_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Sr(this.units,"units"),this.activation=yl(e.activation??this.DEFAULT_ACTIVATION),this.useBias=e.useBias??!0,this.kernelInitializer=vn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=vn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=vn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=xn(e.kernelRegularizer),this.recurrentRegularizer=xn(e.recurrentRegularizer),this.biasRegularizer=xn(e.biasRegularizer),this.kernelConstraint=lr(e.kernelConstraint),this.recurrentConstraint=lr(e.recurrentConstraint),this.biasConstraint=lr(e.biasConstraint),this.dropout=Cd([1,fl([0,e.dropout??0])]),this.recurrentDropout=Cd([1,fl([0,e.recurrentDropout??0])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=$t(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return V(()=>{if(2!==e.length)throw new O(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const i=r.training??!1;let o;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=bl({ones:()=>ci(e),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=bl({ones:()=>ci(s),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,l=this.recurrentDropoutMask;o=Vo(null!=a?M(e,a):e,this.kernel.read()),null!=this.bias&&(o=ho(o,this.bias.read())),null!=l&&(s=M(s,l));let c=le(o,Vo(s,this.recurrentKernel.read()));return null!=this.activation&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:gl(this.activation),useBias:this.useBias,kernelInitializer:Tn(this.kernelInitializer),recurrentInitializer:Tn(this.recurrentInitializer),biasInitializer:Tn(this.biasInitializer),kernelRegularizer:en(this.kernelRegularizer),recurrentRegularizer:en(this.recurrentRegularizer),biasRegularizer:en(this.biasRegularizer),activityRegularizer:en(this.activityRegularizer),kernelConstraint:ar(this.kernelConstraint),recurrentConstraint:ar(this.recurrentConstraint),biasConstraint:ar(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),r)}}return n.className="SimpleRNNCell",n})();se(Mz),se((()=>{class n extends Qp{constructor(e){e.cell=new Mz(e),super(e)}call(e,r){return V(()=>(null!=this.cell.dropoutMask&&(Qe(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Qe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return new e(r)}}return n.className="SimpleRNN",n})());let Fz=(()=>{class n extends J_{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new O("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Sr(this.units,"units"),this.activation=yl(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=yl(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias??!0,this.kernelInitializer=vn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=vn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=vn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=xn(e.kernelRegularizer),this.recurrentRegularizer=xn(e.recurrentRegularizer),this.biasRegularizer=xn(e.biasRegularizer),this.kernelConstraint=lr(e.kernelConstraint),this.recurrentConstraint=lr(e.recurrentConstraint),this.biasConstraint=lr(e.biasConstraint),this.dropout=Cd([1,fl([0,e.dropout??0])]),this.recurrentDropout=Cd([1,fl([0,e.recurrentDropout??0])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=$t(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return V(()=>{if(2!==e.length)throw new O(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training??!1;let i=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=bl({ones:()=>ci(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=bl({ones:()=>ci(i),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const a=this.recurrentDropoutMask;let l,c,u;0<this.dropout&&this.dropout<1&&(e=M(e,this.dropoutMask[0]));let d=Vo(e,this.kernel.read());this.useBias&&(d=ho(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=M(i,a[0]));const h=this.recurrentKernel.read(),[f,p]=$s(h,[2*this.units,this.units],h.rank-1),m=Vo(i,f),[g,y,b]=$s(d,3,d.rank-1),[_,v]=$s(m,2,m.rank-1);l=this.recurrentActivation.apply(le(g,_)),c=this.recurrentActivation.apply(le(y,v));const w=Vo(M(c,i),p);u=this.activation.apply(le(b,w));const C=le(M(l,i),M(le(1,_n(l)),u));return[C,C]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:gl(this.activation),recurrentActivation:gl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Tn(this.kernelInitializer),recurrentInitializer:Tn(this.recurrentInitializer),biasInitializer:Tn(this.biasInitializer),kernelRegularizer:en(this.kernelRegularizer),recurrentRegularizer:en(this.recurrentRegularizer),biasRegularizer:en(this.biasRegularizer),activityRegularizer:en(this.activityRegularizer),kernelConstraint:ar(this.kernelConstraint),recurrentConstraint:ar(this.recurrentConstraint),biasConstraint:ar(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),r)}}return n.className="GRUCell",n})();se(Fz),se((()=>{class n extends Qp{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Fz(e),super(e)}call(e,r){return V(()=>(null!=this.cell.dropoutMask&&(Qe(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Qe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="GRU",n})());let CT=(()=>{class n extends J_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Sr(this.units,"units"),this.activation=yl(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=yl(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias??!0,this.kernelInitializer=vn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=vn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=vn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=xn(e.kernelRegularizer),this.recurrentRegularizer=xn(e.recurrentRegularizer),this.biasRegularizer=xn(e.biasRegularizer),this.kernelConstraint=lr(e.kernelConstraint),this.recurrentConstraint=lr(e.recurrentConstraint),this.biasConstraint=lr(e.biasConstraint),this.dropout=Cd([1,fl([0,e.dropout??0])]),this.recurrentDropout=Cd([1,fl([0,e.recurrentDropout??0])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;let i;if(e=$t(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,a=this.units;i=new((r=class extends Bi{apply(c,u){const d=o.apply([a]),h=(new VV).apply([a]),f=o.apply([2*a]);return $V($V(d,h),f)}}).className="CustomInit",r)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return V(()=>{const s=r.training??!1;if(3!==e.length)throw new O(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let i=e[1];const o=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=bl({ones:()=>ci(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=bl({ones:()=>ci(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const l=this.recurrentDropoutMask;let c,u,d,h;0<this.dropout&&this.dropout<1&&(e=M(e,this.dropoutMask[0]));let f=Vo(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=M(i,l[0])),f=le(f,Vo(i,this.recurrentKernel.read())),this.useBias&&(f=ho(f,this.bias.read()));const[p,m,g,y]=$s(f,4,f.rank-1);c=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(m),d=le(M(u,o),M(c,this.activation.apply(g))),h=this.recurrentActivation.apply(y);const b=M(h,this.activation.apply(d));return[b,b,d]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:gl(this.activation),recurrentActivation:gl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Tn(this.kernelInitializer),recurrentInitializer:Tn(this.recurrentInitializer),biasInitializer:Tn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:en(this.kernelRegularizer),recurrentRegularizer:en(this.recurrentRegularizer),biasRegularizer:en(this.biasRegularizer),activityRegularizer:en(this.activityRegularizer),kernelConstraint:ar(this.kernelConstraint),recurrentConstraint:ar(this.recurrentConstraint),biasConstraint:ar(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),r)}}return n.className="LSTMCell",n})();se(CT),se((()=>{class n extends Qp{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new CT(e),super(e)}call(e,r){return V(()=>(null!=this.cell.dropoutMask&&(Qe(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Qe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="LSTM",n})());let Oz=(()=>{class n extends J_{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return V(()=>{let s=e.slice(1);const i=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?i.push(s.splice(0,l.stateSize.length)):i.push(s.splice(0,1));i.reverse();const o=[];let a;for(let l=0;l<this.cells.length;++l){const c=this.cells[l];s=i[l],a=0===l?[e[0]].concat(s):[a[0]].concat(s),a=c.call(a,r),o.push(a.slice(1))}s=[];for(const l of o.slice().reverse())s.push(...l);return[a[0]].concat(s)})}build(e){let r;YD(e)&&(e=e[0]),this.cells.forEach((s,i)=>{Ec(`RNNCell_${i}`,()=>{s.build(e),r=Array.isArray(s.stateSize)?s.stateSize[0]:s.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){const e=super.getConfig(),i={cells:this.cells.map(o=>({className:o.getClassName(),config:o.getConfig()}))};return Object.assign(Object.assign({},e),i)}static fromConfig(e,r,s={}){const i=[];for(const o of r.cells)i.push(Sa(o,s));return new e({cells:i})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){const r=[];for(const s of this.cells)r.push(...s.trainableWeights);return r.concat(e)}return e}getWeights(){const e=[];for(const r of this.cells)e.push(...r.weights);return ZD(e)}setWeights(e){const r=[];for(const s of this.cells){const o=e.splice(s.weights.length);for(let a=0;a<s.weights.length;++a)r.push([s.weights[a],o[a]])}QD(r)}}return n.className="StackedRNNCells",n})();function bl(n){const{ones:t,rate:e,training:r=!1,count:s=1,dropoutFunc:i}=n,o=()=>null!=i?i(t(),e):BV(t(),e),a=()=>qp(o,t,r);return!s||s<=1?xr(a().clone()):Array(s).fill(void 0).map(a).map(c=>xr(c.clone()))}se(Oz);let ife=(()=>{class n extends Qp{constructor(e){if(e.unroll)throw new tt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new tt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new or({ndim:5})]}call(e,r){return V(()=>{if(null!=this.cell.dropoutMask&&(Qe(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Qe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new O("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return V(()=>{const{stateSize:r}=this.cell,i=this.computeSingleOutputShape(e.shape),a=sr([i[0],...i.slice(2)]);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){V(()=>{if(!this.stateful)throw new Lo("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,i=this.computeSingleOutputShape(s),o=[i[0],...i.slice(2)];if(null==s[0])throw new O("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>sr(o)):[sr(o)];else if(null==e)Qe(this.states_),null!=this.keptStates&&(Qe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>sr(o)):this.states_[0]=sr(o);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new O(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):Qe(this.states_);for(let l=0;l<this.states_.length;++l){const c=e[l],u=o;if(!It(c.shape,u))throw new O(`State ${l} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${c.shape}`);this.states_[l]=c}}this.states_=this.states_.map(l=>xr(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:r,filters:s,kernelSize:i,padding:o,strides:a,dilationRate:l}=this.cell,c="channelsFirst"===r,d=e[c?4:3],h=mo(e[c?3:2],i[0],o,a[0],l[0]),f=mo(d,i[1],o,a[1],l[1]);return[...e.slice(0,2),...c?[s,h,f]:[h,f,s]]}}return n.className="ConvRNN2D",n})(),Pz=(()=>{class n extends CT{constructor(e){const{filters:r,kernelSize:s,strides:i,padding:o,dataFormat:a,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:r})),this.filters=r,Sr(this.filters,"filters"),this.kernelSize=Id(s,2,"kernelSize"),this.kernelSize.forEach(c=>Sr(c,"kernelSize")),this.strides=Id(i||1,2,"strides"),this.strides.forEach(c=>Sr(c,"strides")),this.padding=o||"valid",hi(this.padding),this.dataFormat=a||"channelsLast",Un(this.dataFormat),this.dilationRate=Id(l||1,2,"dilationRate"),this.dilationRate.forEach(c=>Sr(c,"dilationRate"))}build(e){var r;e=$t(e);const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new O(`The channel dimension of the input should be defined. Found ${e[s]}`);const a=this.kernelSize.concat([e[s],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){const u=this.biasInitializer,d=this.filters;c=new((r=class extends Bi{apply(f,p){return qD([u.apply([d]),li([d]),u.apply([2*d])])}}).className="CustomInit",r)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return V(()=>{if(3!==e.length)throw new O(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training||!1,i=e[0],o=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=bl({ones:()=>ci(i),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const c=this.dropoutMask,u=(ie,de,ue)=>de&&de[ue]?M(de[ue],ie):ie;let d=u(i,c,0),h=u(i,c,1),f=u(i,c,2),p=u(i,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=bl({ones:()=>ci(o),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const m=this.recurrentDropoutMask;let g=u(o,m,0),y=u(o,m,1),b=u(o,m,2),_=u(o,m,3);const[w,C,I,D]=$s(this.kernel.read(),4,3),[T,N,$,z]=this.useBias?$s(this.bias.read(),4):[null,null,null,null];d=this.inputConv(d,w,T,this.padding),h=this.inputConv(h,C,N,this.padding),f=this.inputConv(f,I,$,this.padding),p=this.inputConv(p,D,z,this.padding);const[j,q,K,P]=$s(this.recurrentKernel.read(),4,3);g=this.recurrentConv(g,j),y=this.recurrentConv(y,q),b=this.recurrentConv(b,K),_=this.recurrentConv(_,P);const B=this.recurrentActivation.apply(le(d,g)),L=this.recurrentActivation.apply(le(h,y)),W=le(M(L,a),M(B,this.activation.apply(le(f,b)))),ne=M(this.recurrentActivation.apply(le(p,_)),this.activation.apply(W));return[ne,ne,W]})}getConfig(){const s=function(n,t){var e={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&t.indexOf(r)<0&&(e[r]=n[r]);if(null!=n&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(n);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(n,r[s])&&(e[r[s]]=n[r[s]])}return e}(super.getConfig(),["units"]),i={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),i)}inputConv(e,r,s,i){const o=ol(e,r,this.strides,i||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return s?ho(o,s,this.dataFormat):o}recurrentConv(e,r){return ol(e,r,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return n.className="ConvLSTM2DCell",n})();se(Pz),se((()=>{class n extends ife{constructor(e){const r=new Pz(e);super(Object.assign(Object.assign({},e),{cell:r}))}static fromConfig(e,r){return new e(r)}}return n.className="ConvLSTM2D",n})());let $z=(()=>{class n extends gt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const r=e.shape,s=[];for(let i=0;i<this.noiseShape.length;++i)s.push(this.noiseShape[i]??r[i]);return s}call(e,r){return V(()=>{this.invokeCallHook(e,r);const s=Ye(e);if(0<this.rate&&this.rate<1){const i=r.training??!1,o=this.getNoiseShape(s);return qp(()=>BV(s,this.rate,o,this.seed),()=>s,i)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return n.className="Dropout",n})();se($z),se((()=>{class n extends $z{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const r=e.shape;return[r[0],1,r[2]]}}return n.className="SpatialDropout1D",n})()),se((()=>{class n extends gt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,Sr(this.units,"units"),this.activation=yl(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=vn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=vn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=lr(e.kernelConstraint),this.biasConstraint=lr(e.biasConstraint),this.kernelRegularizer=xn(e.kernelRegularizer),this.biasRegularizer=xn(e.biasRegularizer),this.activityRegularizer=xn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const r=(e=$t(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){const r=(e=$t(e)).slice();return r[r.length-1]=this.units,r}call(e,r){return V(()=>{this.invokeCallHook(e,r);const s=Ye(e),i=kV(this.activation.getClassName());let o;return null!=i?o=Vo(s,this.kernel.read(),i,this.bias?this.bias.read():null):(o=Vo(s,this.kernel.read()),null!=this.bias&&(o=ho(o,this.bias.read())),null!=this.activation&&(o=this.activation.apply(o))),o})}getConfig(){const e={units:this.units,activation:gl(this.activation),useBias:this.useBias,kernelInitializer:Tn(this.kernelInitializer),biasInitializer:Tn(this.biasInitializer),kernelRegularizer:en(this.kernelRegularizer),biasRegularizer:en(this.biasRegularizer),activityRegularizer:en(this.activityRegularizer),kernelConstraint:ar(this.kernelConstraint),biasConstraint:ar(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dense",n})()),se((()=>{class n extends gt{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=$t(e);for(const r of e.slice(1))if(null==r)throw new O(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],hl(e,1)]}call(e,r){return V(()=>{this.invokeCallHook(e,r);let s=Ye(e);if("channelsFirst"===this.dataFormat&&s.rank>1){const i=[0];for(let o=2;o<s.rank;++o)i.push(o);i.push(1),s=wt(s,i)}return function Hde(n){if(n.rank<=1)throw new O(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],hl(n.shape,1)];return F(n,t)}(s)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const r=super.getConfig();return Object.assign(e,r),e}}return n.className="Flatten",n})()),se((()=>{class n extends gt{constructor(e){super(e),this.supportsMasking=!0,this.activation=yl(e.activation)}call(e,r){return V(()=>{this.invokeCallHook(e,r);const s=Ye(e);return this.activation.apply(s)})}getConfig(){const e={activation:gl(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Activation",n})()),se((()=>{class n extends gt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return V(()=>function zde(n,t){return V(()=>{if(2!==n.shape.length)throw new O(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);return KD(jp(n,1),[1,t,1])})}(e=Ye(e),this.n))}getConfig(){const e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return n.className="RepeatVector",n})()),se((()=>{class n extends gt{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,r){const s="Total size of new array must be unchanged.",i=r.slice();let o=1,a=null;for(let c=0;c<i.length;++c){const u=i[c];if(this.isUnknown(u)){if(null!==a)throw new O("Can only specifiy one unknown dimension.");a=c}else o*=u}const l=hl(e);if(null!==a){if(0===o||l%o!=0)throw new O(s);i[a]=l/o}else if(l!==o)throw new O(s);return i}computeOutputShape(e){let r=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return V(()=>{this.invokeCallHook(e,r);const s=Ye(e),i=s.shape,o=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return F(s,o)})}getConfig(){const e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Reshape",n})()),se((()=>{class n extends gt{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const r=co(1,e.dims.length+1);if(!It(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new or({ndim:this.dims.length+1})]}computeOutputShape(e){const r=(e=$t(e)).slice();return this.dims.forEach((s,i)=>{r[i+1]=e[s]}),r}call(e,r){return wt(Ye(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Permute",n})()),se((()=>{class n extends gt{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=null!=e?e.maskValue??0:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){const s=Ye(e);return r_(yd(s,this.maskValue),-1)}call(e,r){return V(()=>{this.invokeCallHook(e,r);const s=Ye(e),a=r_(yd(s,this.maskValue),-1,!0);return M(s,ve(a,s.dtype))})}}return n.className="Masking",n})()),se((()=>{class n extends gt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=null==e.inputLength?[r,null]:[r].concat(sn(e.inputLength))}this.inputDim=e.inputDim,Sr(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Sr(this.outputDim,"outputDim"),this.embeddingsInitializer=vn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=xn(e.embeddingsRegularizer),this.activityRegularizer=xn(e.activityRegularizer),this.embeddingsConstraint=lr(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return V(()=>this.maskZero?(e=Ye(e),yd(e,Tt(e))):null)}computeOutputShape(e){if(e=$t(e),null==this.inputLength)return[...e,this.outputDim];const r=sn(this.inputLength);if(r.length!==e.length-1)throw new O(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let i=0;i<r.length;++i){const o=r[i],a=e[i+1];if(null!=o&&null!=a&&o!==a)throw new O(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==o&&(r[s]=a),s++}}return[e[0],...r,this.outputDim]}call(e,r){return V(()=>{this.invokeCallHook(e,r);let s=Ye(e);"int32"!==s.dtype&&(s=Bo(s,"int32"));const i=LV(this.embeddings.read(),F(s,[s.size]));return F(i,$t(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Tn(this.embeddingsInitializer),embeddingsRegularizer:en(this.embeddingsRegularizer),activityRegularizer:en(this.activityRegularizer),embeddingsConstraint:ar(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Embedding",n})());class Dc extends gt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new tt}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const r=t.slice(0,t.length-e.length);for(let s=0;s<e.length;++s){const i=t[t.length-e.length+s],o=e[s];if(null==i||null==o||i<0||o<0)r.push(null);else if(1===i)r.push(o);else if(1===o)r.push(i);else{if(i!==o)throw new O("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));r.push(i)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[$t(t)]),t.length<2)throw new O(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const i of t)null!=i&&null!==i[0]&&e.push(i[0]);if(e=dl(e),e.length>1)throw new O(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=null==t[0]?null:t[0].slice(1);for(let i=1;i<t.length;++i){const o=null==t[i]?null:t[i].slice(1);r=this.computeElementwiseOpOutputShape(r,o)}const s=t.map(i=>i.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==dl(s).length}call(t,e){return V(()=>{if(this.reshapeRequired){const r=[],s=t.map(i=>i.rank);if(-1===s.indexOf(null)){const i=fl(s);for(let o of t){const a=o.rank;for(let l=0;l<i-a;++l)o=jp(o,1);r.push(o)}return this.mergeFunction(r)}{let i=!1;for(const l of t){const c=l.rank;if(null==c){const u=l.shape,d=u[0],h=u.slice(1).concat([d]);let f=F(l,[d].concat(hl(u.slice(1))));f=wt(f,[1,0]),f=F(f,h),r.push(f),i=!0}else if(c>1){const u=co(1,c).concat([0]);r.push(wt(l,u)),i=!0}else r.push(l)}let o=this.mergeFunction(r);const a=o.rank;if(i)if(null==a){const l=o.shape,u=l[l.length-1],d=[u].concat(l.slice(0,l.length-1));o=F(wt(F(o,[-1,u]),[1,0]),d)}else if(a>1){const l=[a-1].concat(co(0,a-1));o=wt(o,l)}return o}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let s=1;s<t.length;++s){const i=null==t[s]?null:t[s].slice(1);e=this.computeElementwiseOpOutputShape(e,i)}let r=[];for(const s of t)null!=s&&null!==s[0]&&r.push(s[0]);return r=dl(r),e=1===r.length?r.concat(e):[null].concat(e),e}computeMask(t,e){return V(()=>{if(null==e)return null;if(!Array.isArray(e))throw new O("`mask` should be an Array");if(!Array.isArray(t))throw new O("`inputs` should be an Array");if(e.length!==t.length)throw new O(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(s=>null==s))return null;let r=(e=e.map(s=>null==s?s:gs(s,0)))[0];for(let s=1;s<e.length-1;++s)r=Oo(r,e[s]);return r})}}function Jp(n,t){for(;n<0;)n+=t;return n}function em(n,t,e,r,s,i=.001){let o;if(2===n.rank)o=WL(n,t,e,r,s,i);else if(3===n.rank)o=jL(n,t,e,r,s,i);else{if(4!==n.rank)throw new tt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);o=GL(n,t,e,r,s,i)}return o}function ev(n,t,e,r,s,i){return V(()=>{let o;Un(s),AV(i),hi(r),null==e&&(e=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),n=xT(n,s);const a="same"===r?"same":"valid";return o="max"===i?p_(n,t,e,a):i_(n,t,e,a),"channelsFirst"===s&&(o=wt(o,[0,3,1,2])),o})}function Lz(n,t,e,r,s,i){return V(()=>{let o;Un(s),AV(i),hi(r),null==e&&(e=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),n=Iz(n,s);const a="same"===r?"same":"valid";return o="max"===i?yB(n,t,e,a):HL(n,t,e,a),"channelsFirst"===s&&(o=wt(o,[0,4,1,2,3])),o})}se((()=>{class n extends Dc{constructor(e){super(e)}mergeFunction(e){return V(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=le(r,e[s]);return r})}}return n.className="Add",n})()),se((()=>{class n extends Dc{constructor(e){super(e)}mergeFunction(e){return V(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=M(r,e[s]);return r})}}return n.className="Multiply",n})()),se((()=>{class n extends Dc{constructor(e){super(e)}mergeFunction(e){return V(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=le(r,e[s]);return M(1/e.length,r)})}}return n.className="Average",n})()),se((()=>{class n extends Dc{constructor(e){super(e)}mergeFunction(e){return V(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=_a(r,e[s]);return r})}}return n.className="Maximum",n})()),se((()=>{class n extends Dc{constructor(e){super(e)}mergeFunction(e){return V(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=Mp(r,e[s]);return r})}}return n.className="Minimum",n})()),se((()=>{class n extends Dc{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=e.axis??this.DEFAULT_AXIS,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new O("A `Concatenate` layer should be called on a list of at least 2 inputs");let r=!0;for(const i of e)if(null!=i){r=!1;break}if(r)return;const s=[];for(let i=0;i<e.length;++i){const o=e[i].slice();o.splice(this.axis,1);let a=!1;for(const l of s)if(It(l,o)){a=!0;break}a||s.push(o)}if(s.length>1)throw new O("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return V(()=>qD(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new O("A `Concatenate` layer should be called on a list of inputs.");const r=e,s=r[0].slice(),i=this.axis<0?s.length+this.axis:this.axis;for(const o of r.slice(1)){if(null==s[i]||null==o[i]){s[i]=null;break}s[i]+=o[i]}return s}computeMask(e,r){if(null==r)return null;if(!Array.isArray(r))throw new O("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new O("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new O(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return V(()=>{let s=!0;if(r.forEach(a=>{null==a||(s=!1)}),s)return null;const i=[];for(let a=0;a<e.length;++a)i.push(null==r[a]?ve(ci(e[a]),"bool"):r[a].rank<e[a].rank?gs(r[a],-1):r[a]);const o=Xn(i,this.axis);return vI(o,-1,!1)})}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Concatenate",n})()),se((()=>{class n extends Dc{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize??!1,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){S(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0],s=e[1];if(r.length>3||s.length>3)throw new tt("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(r,s);if(r[i[0]]!==s[i[1]])throw new O(`Dimension incompatibility: ${r[i[0]]} !== ${s[i[1]]}`)}mergeFunction(e){if(2!==e.length)throw new O(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let i,r=e[0],s=e[1];return i=Array.isArray(this.axes)?this.axes.map((o,a)=>Jp(o,e[a].shape.length)):[Jp(this.axes,r.shape.length),Jp(this.axes,s.shape.length)],this.normalize&&(r=W_(r,i[0]),s=W_(s,i[1])),function ofe(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new tt("batchDot is not implemented for tensors of 4D or higher rank yet");if(S(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),S(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===n.dtype||"complex64"===t.dtype)throw new tt("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,s=t.shape.length;null==e&&(e=[r-1,s-2]);const i=e;return V(()=>{let o,a;if(r>s){o=r-s;const l=[];for(let c=0;c<o;++c)l.push(1);t=F(t,t.shape.concat(l))}else if(s>r){o=s-r;const l=[];for(let c=0;c<o;++c)l.push(1);n=F(n,n.shape.concat(l))}else o=0;if(a=2===n.shape.length&&2===t.shape.length?i[0]===i[1]?Ae(M(n,t),i[0]):Ae(M(wt(n,[1,0]),t),i[1]):mt(n,t,i[0]!==n.shape.length-1,i[1]===t.shape.length-1),o>0){let l;l=r>s?r+s-3:r-1;const c=[];for(let u=l;u<l+o;++u)c.push(u);a=_c(a,c)}return 1===a.shape.length&&(a=gs(a,1)),a})}(r,s,i)}interpretAxes(e,r){let s;return s=Array.isArray(this.axes)?this.axes:[Jp(this.axes,e.length),Jp(this.axes,r.length)],s}computeOutputShape(e){S(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0].slice(),s=e[1].slice();if(r.length>3||s.length>3)throw new tt("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(r,s);r.splice(i[0],1),s.splice(i[1],1),s.splice(0,1);const o=r.concat(s);return 1===o.length&&o.push(1),o}computeMask(e,r){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dot",n})()),se((()=>{class n extends gt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return V(()=>{this.invokeCallHook(e,r);const s=Ye(e);return qp(()=>le($_(s.shape,0,this.stddev),s),()=>s,r.training||!1)})}}return n.className="GaussianNoise",n})()),se((()=>{class n extends gt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return V(()=>{this.invokeCallHook(e,r);const s=Ye(e);return this.rate>0&&this.rate<1?qp(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return M(s,$_(s.shape,1,o))},()=>s,r.training||!1):s})}}return n.className="GaussianDropout",n})()),se((()=>{class n extends gt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ye(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return V(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return qp(()=>{const o=Ye(e),c=-1.7580993408473766;let u=cl(Fp(s),this.rate);u=Bo(u,"float32");const d=((1-this.rate)*(1+this.rate*c**2))**-.5,h=-d*c*this.rate,f=le(M(o,u),M(le(u,-1),c));return le(M(f,d),h)},()=>Ye(e),r.training||!1)}return e})}}return n.className="AlphaDropout",n})()),se((()=>{class n extends gt{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis??-1,this.momentum=e.momentum??.99,this.epsilon=e.epsilon??.001,this.center=e.center??!0,this.scale=e.scale??!0,this.betaInitializer=vn(e.betaInitializer||"zeros"),this.gammaInitializer=vn(e.gammaInitializer||"ones"),this.movingMeanInitializer=vn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=vn(e.movingVarianceInitializer||"ones"),this.betaConstraint=lr(e.betaConstraint),this.gammaConstraint=lr(e.gammaConstraint),this.betaRegularizer=xn(e.betaRegularizer),this.gammaRegularizer=xn(e.gammaRegularizer)}build(e){e=$t(e);const r=this.axis>=0?this.axis:this.axis+e.length,s=e[r];if(null==s)throw new O(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new or({ndim:e.length,axes:{[r]:s}})];const i=[s];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return V(()=>{const s=r.training??!1,i=Ye(e),o=i.shape,a=o.length,l=co(0,a),c=this.axis>=0?this.axis:this.axis+a;l.splice(c,1);const u=wc(1,a);u[c]=o[c];const d=l.slice();d.sort();const h=!It(d,co(0,a).slice(0,a-1));if(!s)return(()=>{if(h){const _=F(this.movingMean.read(),u),v=F(this.movingVariance.read(),u),w=this.center?F(this.beta.read(),u):null,C=this.scale?F(this.gamma.read(),u):null;return em(i,_,v,w,C,this.epsilon)}return em(i,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[p,m,g]=function cfe(n,t,e,r,s=.001){return It(r.slice().sort(),co(0,n.rank-1))?function afe(n,t,e,r,s=.001){return V(()=>{const i=m_(n,r),o=i.mean,a=i.variance;return[em(n,o,a,e,t,s),o,a]})}(n,t,e,r,s):function lfe(n,t,e,r,s=.001){return V(()=>{const i=m_(n,r),o=i.mean,a=i.variance,l=[];for(const p of co(0,n.rank))-1!==r.indexOf(p)?l.push(1):l.push(n.shape[p]);const c=F(o,l),u=F(a,l),d=null==t?null:F(t,l),h=null==e?null:F(e,l);return[em(n,c,u,h,d,s),o,a]})}(n,t,e,r,s)}(i,this.gamma.read(),this.beta.read(),l,this.epsilon),y=(_,v,w)=>{V(()=>{const C=1-w,I=_.read(),D=M(De(I,v),C);_.write(De(I,D))})};return(()=>{y(this.movingMean,m,this.momentum),y(this.movingVariance,g,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Tn(this.betaInitializer),gammaInitializer:Tn(this.gammaInitializer),movingMeanInitializer:Tn(this.movingMeanInitializer),movingVarianceInitializer:Tn(this.movingVarianceInitializer),betaRegularizer:en(this.betaRegularizer),gammaRegularizer:en(this.gammaRegularizer),betaConstraint:ar(this.betaConstraint),gammaConstraint:ar(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="BatchNormalization",n})()),se((()=>{class n extends gt{constructor(e){if(null==e&&(e={}),super(e),this.axis=e.axis??-1,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=e.epsilon??.001,this.center=e.center??!0,this.scale=e.scale??!0,this.betaInitializer=vn(e.betaInitializer||"zeros"),this.gammaInitializer=vn(e.gammaInitializer||"ones"),this.betaRegularizer=xn(e.betaRegularizer),this.gammaRegularizer=xn(e.gammaRegularizer),this.supportsMasking=!0}build(e){const r=(e=$t(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=r);for(const o of this.axis)if(o<0||o>=r)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==dl(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(o=>e[o]);this.gamma=this.scale?this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,r){const s=Ye(e),i=s.shape,o=i.length;return V(()=>{let{mean:l,variance:c}=m_(s,this.axis,!0);const u=wc(1,o);for(const g of this.axis)u[g]=i[g];const d=g=>null!=g&&g.shape.length!==o?F(g,u):g;let h=this.scale?d(this.gamma.read()):null,f=this.center?d(this.beta.read()):null;const p=[],m=[];for(let g=0;g<o;++g)-1!==this.axis.indexOf(g)?(p.push(i[g]),m.push(1)):(p.push(1),m.push(i[g]));return l=Mi(l,p),c=Mi(c,p),null!=h&&(h=Mi(h,m)),null!=f&&(f=Mi(f,m)),em(s,l,c,f,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Tn(this.betaInitializer),gammaInitializer:Tn(this.gammaInitializer),betaRegularizer:en(this.betaRegularizer),gammaRegularizer:en(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LayerNormalization",n})()),se((()=>{class n extends gt{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=e.dataFormat??"channelsLast",null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new O(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,s;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new O(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],2!==e.padding[1].length)throw new O(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[r,s]}this.inputSpec=[new or({ndim:4})]}computeOutputShape(e){let r,s;return e=$t(e),"channelsFirst"===this.dataFormat?(r=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],r,s]):(r=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],r,s,e[3]])}call(e,r){return V(()=>function ufe(n,t,e){return V(()=>{if(4!==n.rank)throw new O(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new O("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new O(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===e?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],ul(n,r)})}(Ye(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ZeroPadding2D",n})());class Bz extends gt{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new O(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(Sr(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new O(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}Sr(this.strides,"strides"),this.padding=t.padding??"valid",hi(this.padding),this.inputSpec=[new or({ndim:3})]}computeOutputShape(t){const e=mo((t=$t(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return V(()=>{this.invokeCallHook(t,e),t=jp(Ye(t),2);const r=this.poolingFunction(Ye(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return _c(r,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}se((()=>{class n extends Bz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return Un(o),hi(i),ev(e,r,s,i,o,"max")}}return n.className="MaxPooling1D",n})()),se((()=>{class n extends Bz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return Un(o),hi(i),ev(e,r,s,i,o,"avg")}}return n.className="AveragePooling1D",n})());class Vz extends gt{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new O(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Sr(this.poolSize,"poolSize"),Sr(this.strides,"strides"),this.padding=t.padding??"valid",this.dataFormat=t.dataFormat??"channelsLast",Un(this.dataFormat),hi(this.padding),this.inputSpec=[new or({ndim:4})]}computeOutputShape(t){t=$t(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2];return e=mo(e,this.poolSize[0],this.padding,this.strides[0]),r=mo(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r]:[t[0],e,r,t[3]]}call(t,e){return V(()=>(this.invokeCallHook(t,e),this.poolingFunction(Ye(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}se((()=>{class n extends Vz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return Un(o),hi(i),ev(e,r,s,i,o,"max")}}return n.className="MaxPooling2D",n})()),se((()=>{class n extends Vz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return Un(o),hi(i),ev(e,r,s,i,o,"avg")}}return n.className="AveragePooling2D",n})());class zz extends gt{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new O(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Sr(this.poolSize,"poolSize"),Sr(this.strides,"strides"),this.padding=t.padding??"valid",this.dataFormat=t.dataFormat??"channelsLast",Un(this.dataFormat),hi(this.padding),this.inputSpec=[new or({ndim:5})]}computeOutputShape(t){t=$t(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2],s="channelsFirst"===this.dataFormat?t[4]:t[3];return e=mo(e,this.poolSize[0],this.padding,this.strides[0]),r=mo(r,this.poolSize[1],this.padding,this.strides[1]),s=mo(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r,s]:[t[0],e,r,s,t[4]]}call(t,e){return V(()=>(this.invokeCallHook(t,e),this.poolingFunction(Ye(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}se((()=>{class n extends zz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return Un(o),hi(i),Lz(e,r,s,i,o,"max")}}return n.className="MaxPooling3D",n})()),se((()=>{class n extends zz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return Un(o),hi(i),Lz(e,r,s,i,o,"avg")}}return n.className="AveragePooling3D",n})());class Uz extends gt{constructor(t){super(t),this.inputSpec=[new or({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new tt}}se((()=>{class n extends Uz{constructor(e){super(e||{})}call(e,r){return V(()=>{const s=Ye(e);return Rn(s,1)})}}return n.className="GlobalAveragePooling1D",n})()),se((()=>{class n extends Uz{constructor(e){super(e||{})}call(e,r){return V(()=>{const s=Ye(e);return Ri(s,1)})}}return n.className="GlobalMaxPooling1D",n})());class Hz extends gt{constructor(t){super(t),this.dataFormat=t.dataFormat??"channelsLast",Un(this.dataFormat),this.inputSpec=[new or({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new tt}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}se((()=>{class n extends Hz{call(e,r){return V(()=>{const s=Ye(e);return Rn(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalAveragePooling2D",n})()),se((()=>{class n extends Hz{call(e,r){return V(()=>{const s=Ye(e);return Ri(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalMaxPooling2D",n})());class Wz extends gt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,r={}){const i=Sa(e.layer,r);delete e.layer;const o={layer:i};return Object.assign(o,e),new t(o)}}se((()=>{class n extends Wz{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=$t(e)).length<3)throw new O(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){const r=[(e=$t(e))[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(r);return[s[0],e[1]].concat(s.slice(1))}call(e,r){return V(()=>Rz((a,l)=>[Ye(this.layer.call(a,r)),[]],e=Ye(e),[],!1,null,null,!1,!0)[1])}}return n.className="TimeDistributed",n})()),se((()=>{class n extends Wz{constructor(e){super(e);const r=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=r,this.forwardLayer=Sa(s),r.goBackwards=!0!==r.goBackwards;const i={};if(i.className=e.layer.getClassName(),i.config=r,this.backwardLayer=Sa(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function dfe(n){Sc(Fde,"BidirectionalMergeMode",n)}(this.mergeMode),e.weights)throw new tt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const s=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let s,i,o,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState&&(o=r.slice(1)),s=r[0],"concat"===this.mergeMode?(s[s.length-1]*=2,i=[s]):i=null==this.mergeMode?[s,s.slice()]:[s],this.returnState?null==this.mergeMode?i.concat(o).concat(o.slice()):[s].concat(o).concat(o.slice()):bs(i)}apply(e,r){let s=null==r?null:r.initialState,i=null==r?null:r.constants;null==r&&(r={});const o=Az(e,s,i,this.numConstants);if(e=o.inputs,s=o.initialState,i=o.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(null==s||0===s.length)&&null==i)return super.apply(e,r);const a=[],l=[];if(null!=s){const u=s.length;if(u%2>0)throw new O("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=s,a.push(...s);const d=s.map(h=>new or({shape:h.shape}));this.forwardLayer.stateSpec=d.slice(0,u/2),this.backwardLayer.stateSpec=d.slice(u/2),l.push(...d)}if(null!=i)throw new tt("Support for constants in Bidirectional layers is not implemented yet.");const c=a[0]instanceof Uo;for(const u of a)if(u instanceof Uo!==c)throw new O("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const u=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(u,r);return this.inputSpec=h,f}return super.apply(e,r)}call(e,r){return V(()=>{const s=r.initialState;let i,o,a,l;if(null==s)i=this.forwardLayer.call(e,r),o=this.backwardLayer.call(e,r);else{const c=s.slice(0,s.length/2),u=s.slice(s.length/2);i=this.forwardLayer.call(e,Object.assign(r,{initialState:c})),o=this.backwardLayer.call(e,Object.assign(r,{initialState:u}))}return this.returnState&&(Array.isArray(i)&&(a=i.slice(1).concat(o.slice(1))),i=i[0],o=o[0]),this.returnSequences&&(o=Fi(o,1)),"concat"===this.mergeMode?l=qD([i,o]):"sum"===this.mergeMode?l=le(i,o):"ave"===this.mergeMode?l=M(.5,le(i,o)):"mul"===this.mergeMode?l=M(i,o):null==this.mergeMode&&(l=[i,o]),this.returnState?null==this.mergeMode?l.concat(a):[l].concat(a):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Ec(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Ec(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){let s;if(Array.isArray(r)&&(r=r[0]),s=this.returnSequences?null==this.mergeMode?[r,r]:r:null==this.mergeMode?[null,null]:null,this.returnState){const o=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(o).concat(o):[s].concat(o).concat(o)}return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){const s=Sa(r.layer);if(delete r.layer,null!=r.numConstants)throw new tt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=r;return i.layer=s,new e(i)}}return n.className="Bidirectional",n})()),se((()=>{class n extends gt{constructor(e){super(e),this.scale=e.scale,this.offset=e.offset?e.offset:0}getConfig(){const e={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return V(()=>("float32"!==(e=Ye(e)).dtype&&(e=Bo(e,"float32")),le(M(e,this.scale),this.offset)))}}return n.className="Rescaling",n})());const{resizeBilinear:ffe,cropAndResize:pfe}=xa;se((()=>{class n extends gt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,r,s,i,o,a,l,c){return V(()=>{let u,d=!1;const g=[r/a,s/l,(i+r)/a,(o+s)/l],y=[];3===e.rank?(d=!0,u=ui([e])):u=e;for(let C=0;C<u.shape[0];C++)y.push(g);const b=ao(y,[y.length,4]),_=bd(0,y.length,1,"int32"),w=pfe(u,b,_,[i,o],"nearest");return Bo(d?Ye(Oi(w)):w,c)})}upsize(e,r,s,i){return V(()=>Bo(ffe(e,[r,s]),i))}call(e,r){return V(()=>{const s=Ye(e),i=s.dtype,o=s.shape,a=o[o.length-3],l=o[o.length-2];let c=0;a!==this.height&&(c=Math.floor((a-this.height)/2));let u=0;return l!==this.width&&(u=Math.floor((l-this.width)/2),0===u&&(u=1)),c>=0&&u>=0?this.centerCrop(s,c,u,this.height,this.width,a,l,i):this.upsize(e,this.height,this.width,i)})}getConfig(){const e={height:this.height,width:this.width},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){const s=(e=$t(e)).length-2;return e[e.length-3]=this.height,e[s]=this.width,e}}return n.className="CenterCrop",n})()),se((()=>{class n extends gt{constructor(e){super(e),this.numTokens=e.numTokens,this.outputMode=e.outputMode?e.outputMode:"multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return null==(e=$t(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,r){return V(()=>{let s;if("int32"!==(e=Ye(e)).dtype&&(e=Bo(e,"int32")),typeof r.countWeights<"u"){if("count"!==this.outputMode)throw new O(`countWeights is not used when outputMode !== count.\n              Received countWeights=${r.countWeights}`);s=Ye(r.countWeights)}const i=Ri(e),o=kp(e),a=Ps(this.numTokens,i).bufferSync().get(0),l=cl(o,0).bufferSync().get(0);if(!a||!l)throw new O(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function mfe(n,t,e,r){let s=Ye(n);if("int32"!==s.dtype&&(s=Bo(s,"int32")),"int"===t)return s;const i=s.shape;if(0===s.rank&&(s=gs(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=gs(s,-1)),s.rank>2)throw new O(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${s.rank}.`);const o=["multiHot","oneHot"].includes(t);let l;if(l=TI(s,typeof r<"u"&&"count"===t?r:[],e,o),"tfIdf"!==t)return l;if(r)return M(l,r);throw new O("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,s)})}}return n.className="CategoryEncoding",n})());const jz=new Set(["bilinear","nearest"]);se((()=>{class n extends gt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!jz.has(e.interpolation))throw new O(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){return e=$t(e),[this.height,this.width,e[2]]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return V(()=>{const s=[this.height,this.width];if("bilinear"===this.interpolation)return xa.resizeBilinear(e,s,!this.cropToAspectRatio);if("nearest"===this.interpolation)return xa.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...jz]} are supported`)})}}return n.className="Resizing",n})()),G().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Yz,pi=(()=>{return(n=pi||(pi={}))[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF",pi;var n})();!function(n){let t;var e;(e=t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(Yz||(Yz={}));const NT={};function Zz(n){return NT[n]}function x(n,t,e,r,s){const i=t.inputParams[n];if(i&&void 0!==i.inputIndexStart){const a=i.inputIndexStart,l=0===i.inputIndexEnd?void 0:void 0===i.inputIndexEnd?a+1:i.inputIndexEnd;if("tensor"===i.type)return Jr(t.inputNames[i.inputIndexStart],e,r,s);if("tensors"===i.type)return t.inputNames.slice(a,l).map(h=>Jr(h,e,r,s));const c=Jr(t.inputNames.slice(a)[0],e,r,s),u=c.dataSync();return"number"===i.type?u[0]:ki(c.shape,u)}const o=t.attrParams[n];return o&&o.value}function Jr(n,t,e,r){const[s,i]=Ls(n);if(null!=r){const a=r.getHashTableHandleByName(s);if(null!=a)return a}const o=e.currentContextIds.find(a=>!!t[nv(s,a)]);return void 0!==o?t[nv(s,o)][i]:void 0}function Ea(n,t){const[e,r,s]=Ls(n);return[nv(e,t&&t.currentContextId),r,s]}function nv(n,t){return t?`${n}-${t}`:n}function Ls(n){const t=n.split(":");if(1===t.length)return[n,0,void 0];const r=3===t.length?t[1]:void 0;return[t[0],Number(t[t.length-1]),r]}function rv(n,t,e){let r=x("pad",n,t,e);if("explicit"===r){r=x("explicitPaddings",n,t,e);const s=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)s[i][0]=r[2*i],s[i][1]=r[2*i+1];return s}return r}function Ia(n){return n.kept?n:ma(n)}const xfe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],wfe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Cfe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Sfe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Efe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Ife=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Dfe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Tfe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],kfe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Nfe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Afe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Rfe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],Mfe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],Ffe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Ofe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],Pfe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],$fe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Lfe=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Bfe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class Qz{constructor(){const e=[].concat(...[Ve,st,Ie,U,pe,be,re,fe,Ne,Fe,zt,Qn,Wn,_i,Hs,St,Mt,Ft,ce].map(r=>r.json));this.opMappers=e.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}static get Instance(){return this._instance||(this._instance=new this)}transformGraph(t,e={}){const s=[],i=[],o=[],a=t.node.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?s.push(m[g.name]):"Const"===g.op?i.push(m[g.name]):(null==g.input||0===g.input.length)&&o.push(m[g.name]),m),{});let l=[];const c=[];let u={},d={};null!=e&&(u=this.mapSignatureEntries(e.inputs),d=this.mapSignatureEntries(e.outputs));const h=Object.keys(a);h.forEach(m=>{const g=a[m];g.inputNames.forEach((y,b)=>{const[_,,v]=Ea(y),w=a[_];if(null!=w.outputs){const C=w.outputs.indexOf(v);-1!==C&&(g.inputNames[b]=`${_}:${C}`)}g.inputs.push(w),w.children.push(g)})}),0===Object.keys(d).length?h.forEach(m=>{const g=a[m];0===g.children.length&&c.push(g)}):Object.keys(d).forEach(m=>{const[g]=Ea(m),y=a[g];null!=y&&(y.signatureKey=d[m],c.push(y))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{const[g]=Ea(m),y=a[g];y&&(y.signatureKey=u[m],l.push(y))}):l=s;let f={};null!=t.library&&null!=t.library.function&&(f=t.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const p={nodes:a,inputs:l,outputs:c,weights:i,placeholders:s,signature:e,functions:f};return o.length>0&&(p.initNodes=o),p}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,r)=>(e[t[r].name]=r,e),{})}mapNode(t){const e=Zz(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const r={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return null!=e.inputs&&(r.inputParams=e.inputs.reduce((s,i)=>(s[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},s),{})),null!=e.attrs&&(r.attrParams=e.attrs.reduce((s,i)=>{const o=i.type;let a;switch(i.type){case"string":a=AT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=AT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":a=BT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=BT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":a=MT(t.attr,i.tfName,i.defaultValue||0),void 0===a&&i.tfDeprecatedName&&(a=MT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":a=LT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=LT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":a=RT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=RT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":a=zT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=zT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":a=$T(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=$T(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":a=VT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=VT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":a=OT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=OT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":a=PT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=PT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":a=e3(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=e3(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${t.op}`)}return s[i.name]={value:a,type:o},s},{})),r}mapFunction(t){const e=t.nodeDef,s=[];let i={};null!=e&&(i=e.reduce((d,h)=>(d[h.name]=this.mapNode(h),"Const"===h.op&&s.push(d[h.name]),d),{}));const o=[],a=[];t.signature.inputArg.forEach(d=>{const[h]=Ea(d.name),f={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:FT(d.type),type:"dtype"}},children:[]};f.signatureKey=d.name,o.push(f),i[h]=f}),Object.keys(i).forEach(d=>{const h=i[d];h.inputNames.forEach((f,p)=>{const[m,,g]=Ea(f),y=i[m];if(null!=y.outputs){const b=y.outputs.indexOf(g);-1!==b&&(h.inputNames[p]=`${m}:${b}`)}h.inputs.push(y),y.children.push(h)})});const c=t.ret;t.signature.outputArg.forEach(d=>{const[h,f]=Ea(c[d.name]),p=i[h];null!=p&&(p.defaultOutput=f,a.push(p))});const u=this.mapArgsToSignature(t);return{nodes:i,inputs:o,outputs:a,weights:s,placeholders:[],signature:u}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r),e),{}),outputs:t.signature.outputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r,t.ret),e),{})}}mapArgToTensorInfo(t,e){let r=t.name;return null!=e&&(r=e[r]),{name:r,dtype:t.type}}}function Jz(n,t){const e=Array.isArray(n)?String.fromCharCode.apply(null,n):function Vfe(n){const t=G().global;if(typeof t.atob<"u")return t.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(n);return t?e:e.toLowerCase()}function AT(n,t,e,r=!1){const s=n[t];return null!=s?Jz(s.s,r):e}function RT(n,t,e){const r=n[t];return r?r.b:e}function MT(n,t,e){const r=n[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:e;return"number"==typeof s?s:parseInt(s,10)}function FT(n){switch("string"==typeof n&&(n=pi[n]),n){case pi.DT_FLOAT:case pi.DT_HALF:return"float32";case pi.DT_INT32:case pi.DT_INT64:case pi.DT_INT8:case pi.DT_UINT8:return"int32";case pi.DT_BOOL:return"bool";case pi.DT_DOUBLE:return"float32";case pi.DT_STRING:return"string";default:return null}}function e3(n,t,e){const r=n[t];return r&&r.func?r.func.name:e}function OT(n,t,e){const r=n[t];return r&&r.type?FT(r.type):e}function PT(n,t,e){const r=n[t];return r&&r.list&&r.list.type?r.list.type.map(s=>FT(s)):e}function t3(n){if(!n.unknownRank)return null!=n.dim?n.dim.map(t=>"number"==typeof t.size?t.size:parseInt(t.size,10)):[]}function $T(n,t,e){const r=n[t];return r&&r.shape?t3(r.shape):e}function LT(n,t,e){const r=n[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>"number"==typeof s?s:parseInt(s,10)):e}function BT(n,t,e,r=!1){const s=n[t];return s&&s.list&&s.list.s?s.list.s.map(i=>Jz(i,r)):e}function VT(n,t,e){const r=n[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>t3(s)):e}function zT(n,t,e){const r=n[t];return r&&r.list&&r.list.b?r.list.b:e}class zfe{constructor(t,e,r){this.node=t,this.tensorMap=e,this.context=r,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(s=>this.getInput(s)),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce((s,i)=>(s[i]=this.getAttr(i),s),{}))}getInput(t){return Jr(t,this.tensorMap,this.context)}getAttr(t,e){const r=this.node.rawAttrs[t];if(null!=r.tensor)return Jr(t,this.tensorMap,this.context);if(null!=r.i||null!=r.f)return MT(this.node.rawAttrs,t,e);if(null!=r.s)return AT(this.node.rawAttrs,t,e);if(null!=r.b)return RT(this.node.rawAttrs,t,e);if(null!=r.shape)return $T(this.node.rawAttrs,t,e);if(null!=r.type)return OT(this.node.rawAttrs,t,e);if(null!=r.list){if(null!=r.list.i||null!=r.list.f)return LT(this.node.rawAttrs,t,e);if(null!=r.list.s)return BT(this.node.rawAttrs,t,e);if(null!=r.list.shape)return VT(this.node.rawAttrs,t,e);if(null!=r.list.b)return zT(this.node.rawAttrs,t,e);if(null!=r.list.type)return PT(this.node.rawAttrs,t,e)}return e}}function Vi(n,t,e=""){if("number"!=typeof n&&"number"!=typeof t){S(n.length===t.length,()=>e+` Shapes ${n} and ${t} must match`);for(let r=0;r<n.length;r++){const s=n[r],i=t[r];S(s<0||i<0||s===i,()=>e+` Shapes ${n} and ${t} must match`)}}}function n3(n){return!("number"==typeof n||n.some(t=>t<0))}function tm(n,t,e){let r=UT(n,e);const s=!n3(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(i=>{r=UT(i.shape,r)}),!n3(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function UT(n,t){if("number"==typeof n)return t;if("number"==typeof t)return n;if(n.length!==t.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${t}`);const e=[];for(let r=0;r<n.length;++r){const s=n[r],i=t[r];if(s>=0&&i>=0&&s!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${t}`);e[r]=s>=0?s:i}return e}class Wfe{constructor(t,e,r,s,i,o,a){this.name=t,this.dtype=e,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Be(0),xr(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=e.shape),Vi(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);r.tensor=e,xr(e),r.written=!0,this.tensors[t]=r}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((r,s)=>this.write(r,e[s]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let s=0;s<this.size();s++)t.push(s)}if(0===t.length)return ao([],[0].concat(this.elementShape));const r=this.readMany(t);return Vi(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),ui(r,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return ao([],[0].concat(this.elementShape));const e=[];for(let s=0;s<this.size();s++)e.push(s);const r=this.readMany(e);return Vi(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Xn(r,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const r=Math.max(...t);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(t,Oi(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let r=0;const s=t.map(l=>(r+=l,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const i=0===r?0:e.size/r,o=[];V(()=>{e=F(e,[1,r,i]);for(let l=0;l<t.length;++l)o[l]=F(Dt(e,[0,0===l?0:s[l-1],0],[1,t[l],i]),this.elementShape);return o});const a=[];for(let l=0;l<t.length;l++)a[l]=l;this.writeMany(a,o)}}class Tc{constructor(t,e,r,s=-1){this.tensors=t,this.elementShape=e,this.elementDtype=r,t?.forEach(i=>{if(r!==i.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${i.dtype}`);Vi(e,i.shape,"TensorList shape mismatch: "),xr(i)}),this.idTensor=Be(0),this.maxNumElements=s,xr(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Tc([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,r=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==r&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Vi(t,this.elementShape,"TensorList shape mismatch: ");const s=tm(this.elementShape,this.tensors,t);return V(()=>{const i=this.tensors.map(o=>F(o,s));return ui(i,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const r=tm(this.elementShape,this.tensors,t),s=this.tensors.pop();return s.kept=!1,Vi(s.shape,t,"TensorList shape mismatch: "),F(s,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Vi(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");xr(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new Tc([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)e.tensors[r]=this.tensors[r];return e}getItem(t,e,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);Vi(this.tensors[t].shape,e,"TensorList shape mismatch: ");const s=tm(this.elementShape,this.tensors,e);return F(this.tensors[t],s)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Vi(this.elementShape,e.shape,"TensorList shape mismatch: "),xr(e),null!=this.tensors[t]&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,r){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);Vi(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());const s=tm(this.elementShape,this.tensors,r);return 0===t.length?ao([],[0].concat(s)):V(()=>{const i=t.map(o=>F(this.tensors[o],s));return ui(i,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Vi(this.elementShape,e,"TensorList shape mismatch: ");const r=tm(this.elementShape,this.tensors,e);return 0===this.size()?ao([],[0].concat(r)):V(()=>{const s=this.tensors.map(i=>F(i,r));return Xn(s,0)})}}const Xfe=function(){var n=ee(function*(t,e,r){switch(t.op){case"If":case"StatelessIf":{const s=x("thenBranch",t,e,r),i=x("elseBranch",t,e,r),o=x("cond",t,e,r),a=x("args",t,e,r);return(yield o.data())[0]?r.functionMap[s].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap):r.functionMap[i].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap)}case"While":case"StatelessWhile":{const s=x("body",t,e,r),i=x("cond",t,e,r),o=x("args",t,e,r),a=yield r.functionMap[i].executeFunctionAsync(o,r.tensorArrayMap,r.tensorListMap),l=o.map(d=>d.id);let c=yield a[0].data();a.forEach(d=>{!d.kept&&-1===l.indexOf(d.id)&&d.dispose()});let u=o;for(;c[0];){const d=u;u=yield r.functionMap[s].executeFunctionAsync(u,r.tensorArrayMap,r.tensorListMap);const h=u.map(p=>p.id);d.forEach(p=>{!p.kept&&-1===l.indexOf(p.id)&&-1===h.indexOf(p.id)&&p.dispose()});const f=yield r.functionMap[i].executeFunctionAsync(u,r.tensorArrayMap,r.tensorListMap);c=yield f[0].data(),f.forEach(p=>{!p.kept&&-1===l.indexOf(p.id)&&-1===h.indexOf(p.id)&&p.dispose()})}return u}case"LoopCond":return[Ia(x("pred",t,e,r))];case"Switch":{const s=x("pred",t,e,r);let i=x("data",t,e,r);return i.kept||(i=Ia(i)),(yield s.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const s=t.inputNames.find(i=>void 0!==Jr(i,e,r));return s?[Ia(Jr(s,e,r))]:void 0}case"Enter":{const s=x("frameName",t,e,r),i=x("tensor",t,e,r);return r.enterFrame(s),[Ia(i)]}case"Exit":{const s=x("tensor",t,e,r);return r.exitFrame(),[Ia(s)]}case"NextIteration":{const s=x("tensor",t,e,r);return r.nextIteration(),[Ia(s)]}case"TensorArrayV3":{const s=x("size",t,e,r),i=x("dtype",t,e,r),o=x("elementShape",t,e,r),a=x("dynamicSize",t,e,r),l=x("clearAfterRead",t,e,r),c=x("identicalElementShapes",t,e,r),u=x("name",t,e,r),d=new Wfe(u,i,s,o,c,a,l);return r.addTensorArray(d),[d.idTensor,Be(1)]}case"TensorArrayWriteV3":{const s=x("tensorArrayId",t,e,r),i=x("index",t,e,r),o=x("tensor",t,e,r),a=r.getTensorArray(s.id);return a.write(i,o),[a.idTensor]}case"TensorArrayReadV3":{const s=x("tensorArrayId",t,e,r),i=x("index",t,e,r);return[r.getTensorArray(s.id).read(i)]}case"TensorArrayGatherV3":{const s=x("tensorArrayId",t,e,r),i=x("indices",t,e,r),o=x("dtype",t,e,r);return[r.getTensorArray(s.id).gather(i,o)]}case"TensorArrayScatterV3":{const s=x("tensorArrayId",t,e,r),i=x("indices",t,e,r),o=x("tensor",t,e,r),a=r.getTensorArray(s.id);return a.scatter(i,o),[a.idTensor]}case"TensorArrayConcatV3":{const s=x("tensorArrayId",t,e,r),i=r.getTensorArray(s.id),o=x("dtype",t,e,r);return[i.concat(o)]}case"TensorArraySplitV3":{const s=x("tensorArrayId",t,e,r),i=x("tensor",t,e,r),o=x("lengths",t,e,r),a=r.getTensorArray(s.id);return a.split(o,i),[a.idTensor]}case"TensorArraySizeV3":{const s=x("tensorArrayId",t,e,r);return[Be(r.getTensorArray(s.id).size(),"int32")]}case"TensorArrayCloseV3":{const s=x("tensorArrayId",t,e,r),i=r.getTensorArray(s.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const s=x("tensorListId",t,e,r),i=x("index",t,e,r),o=x("tensor",t,e,r),a=r.getTensorList(s.id);return a.setItem(i,o),[a.idTensor]}case"TensorListGetItem":{const s=x("tensorListId",t,e,r),i=x("index",t,e,r),o=x("elementShape",t,e,r),a=x("elementDType",t,e,r);return[r.getTensorList(s.id).getItem(i,o,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=x("indices",t,e,r),l=function qfe(n,t,e,r){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const i=new Tc([],e,n.dtype,r),o=Oi(n,0);return t.forEach((a,l)=>{i.setItem(a,o[l])}),i}(x("tensor",t,e,r),s,x("elementShape",t,e,r),x("numElements",t,e,r));return r.addTensorList(l),[l.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=x("elementShape",t,e,r),i=x("elementDType",t,e,r);let o;o="TensorListReserve"===t.op?"numElements":"maxNumElements";const a=x(o,t,e,r),c=function Gfe(n,t,e,r){return new Tc([],n,t,r)}(s,i,0,"TensorListReserve"===t.op?-1:a);return r.addTensorList(c),[c.idTensor]}case"TensorListGather":{const s=x("tensorListId",t,e,r),i=x("indices",t,e,r),o=x("elementShape",t,e,r),a=x("elementDType",t,e,r);return[r.getTensorList(s.id).gather(i,a,o)]}case"TensorListStack":{const s=x("tensorListId",t,e,r),i=x("elementShape",t,e,r),o=x("elementDType",t,e,r),a=x("numElements",t,e,r);return[r.getTensorList(s.id).stack(i,o,a)]}case"TensorListFromTensor":{const a=function jfe(n,t,e){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);Vi(n.shape.slice(1),t,"TensorList shape mismatch: ");const i=Oi(n);return new Tc(i,t,r)}(x("tensor",t,e,r),x("elementShape",t,e,r),x("elementDType",t,e,r));return r.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=x("tensorListId",t,e,r),i=r.getTensorList(s.id),o=x("dtype",t,e,r),a=x("elementShape",t,e,r);return[i.concat(o,a)]}case"TensorListPushBack":{const s=x("tensorListId",t,e,r),i=x("tensor",t,e,r),o=r.getTensorList(s.id);return o.pushBack(i),[o.idTensor]}case"TensorListPopBack":{const s=x("tensorListId",t,e,r),i=x("elementShape",t,e,r),o=x("elementDType",t,e,r);return[r.getTensorList(s.id).popBack(i,o)]}case"TensorListSplit":{const s=x("tensor",t,e,r),i=x("elementShape",t,e,r),a=function Kfe(n,t,e){let r=0;const s=t.map(u=>(r+=u,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${n.shape}`);const o=UT(n.shape.slice(1),e),a=0===r?0:n.size/r,l=V(()=>{const u=[];n=F(n,[1,r,a]);for(let d=0;d<t.length;++d)u[d]=F(Dt(n,[0,0===d?0:s[d-1],0],[1,t[d],a]),o);return n.dispose(),u}),c=new Tc([],e,n.dtype,t.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}(s,x("lengths",t,e,r),i);return r.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=x("tensorListId",t,e,r);return[Be(r.getTensorList(s.id).size(),"int32")]}case"TensorListResize":{const s=x("tensorListId",t,e,r),i=x("size",t,e,r),a=r.getTensorList(s.id).resize(i);return r.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s){return n.apply(this,arguments)}}();function r3(n,t,e){const[r,s]=x("fusedOps",n,t,e),i="biasadd"===r,o=!i,a="prelu"===s,l="fusedbatchnorm"===r,c=x("numArgs",n,t,e);if(i){if(a&&2!==c)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i&&1!==c)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=x("strides",n,t,e),d=rv(n,t,e),h=x("dataFormat",n,t,e).toUpperCase(),f=x("dilations",n,t,e);let[p,m]=x("args",n,t,e);return o&&(m=p,p=void 0),{stride:u,pad:d,dataFormat:h,dilations:f,biasArg:p,preluArg:m,activationFunc:s,leakyreluAlpha:x("leakyreluAlpha",n,t,e)}}function HT(n,t,e){return{boxes:x("boxes",n,t,e),scores:x("scores",n,t,e),maxOutputSize:x("maxOutputSize",n,t,e),iouThreshold:x("iouThreshold",n,t,e),scoreThreshold:x("scoreThreshold",n,t,e),softNmsSigma:x("softNmsSigma",n,t,e)}}const Qfe=function(){var n=ee(function*(t,e,r,s,i=J){switch(t.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:a,maxOutputSize:l,iouThreshold:c,scoreThreshold:u,softNmsSigma:d}=HT(t,e,r),h=yield i.image.nonMaxSuppressionWithScoreAsync(o,a,l,c,u,d);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:a,maxOutputSize:l,iouThreshold:c,scoreThreshold:u}=HT(t,e,r),d=x("padToMaxOutputSize",t,e,r),h=yield i.image.nonMaxSuppressionPaddedAsync(o,a,l,c,u,d);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:a,maxOutputSize:l,iouThreshold:c,scoreThreshold:u}=HT(t,e,r);return[yield i.image.nonMaxSuppressionAsync(o,a,l,c,u)]}case"Where":{const o=i.cast(x("condition",t,e,r),"bool"),a=[yield i.whereAsync(o)];return o.dispose(),a}case"ListDiff":return i.setdiff1dAsync(x("x",t,e,r),x("y",t,e,r));default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s,i){return n.apply(this,arguments)}}();class tpe{constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=Be(0),this.tensorMap=new Map,xr(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Be(this.size(),"int32")}import(t,e){var r=this;return ee(function*(){r.checkKeyAndValueTensor(t,e);const s=yield t.data();return r.tensorMap.forEach(i=>i.dispose()),r.tensorMap.clear(),V(()=>{const i=Oi(e),o=s.length,a=i.length;S(o===a,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${a} elements.`);for(let l=0;l<o;l++){const c=s[l],u=i[l];xr(u),r.tensorMap.set(c,u)}return r.handle})})()}find(t,e){var r=this;return ee(function*(){r.checkKeyAndValueTensor(t,e);const s=yield t.data();return V(()=>{const i=[];for(let o=0;o<s.length;o++){const l=r.findWithDefault(s[o],e);i.push(l)}return ui(i)})})()}findWithDefault(t,e){return this.tensorMap.get(t)??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}const npe=function(){var n=ee(function*(t,e,r,s){switch(t.op){case"HashTable":case"HashTableV2":{const i=s.getHashTableHandleByName(t.name);if(null!=i)return[i];{const o=x("keyDType",t,e,r),a=x("valueDType",t,e,r),l=new tpe(o,a);return s.addHashTable(t.name,l),[l.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const i=x("tableHandle",t,e,r,s),o=x("keys",t,e,r),a=x("values",t,e,r);return[yield s.getHashTableById(i.id).import(o,a)]}case"LookupTableFind":case"LookupTableFindV2":{const i=x("tableHandle",t,e,r,s),o=x("keys",t,e,r),a=x("defaultValue",t,e,r);return[yield s.getHashTableById(i.id).find(o,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=x("tableHandle",t,e,r,s);return[s.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s,i){return n.apply(this,arguments)}}();function s3(n,t,e,r,s=V){const i=((o,a,l)=>{switch(o.category){case"arithmetic":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(x("a",n,t,e),x("b",n,t,e))];case"AddN":return[r.addN(x("tensors",n,t,e))];case"FloorMod":case"Mod":return[r.mod(x("a",n,t,e),x("b",n,t,e))];case"Mul":return[r.mul(x("a",n,t,e),x("b",n,t,e))];case"RealDiv":case"Div":return[r.div(x("a",n,t,e),x("b",n,t,e))];case"DivNoNan":return[r.divNoNan(x("a",n,t,e),x("b",n,t,e))];case"FloorDiv":return[r.floorDiv(x("a",n,t,e),x("b",n,t,e))];case"Sub":return[r.sub(x("a",n,t,e),x("b",n,t,e))];case"Minimum":return[r.minimum(x("a",n,t,e),x("b",n,t,e))];case"Maximum":return[r.maximum(x("a",n,t,e),x("b",n,t,e))];case"Pow":return[r.pow(x("a",n,t,e),x("b",n,t,e))];case"SquaredDifference":return[r.squaredDifference(x("a",n,t,e),x("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"basic_math":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(x("x",n,t,e))];case"Acos":return[r.acos(x("x",n,t,e))];case"Acosh":return[r.acosh(x("x",n,t,e))];case"Asin":return[r.asin(x("x",n,t,e))];case"Asinh":return[r.asinh(x("x",n,t,e))];case"Atan":return[r.atan(x("x",n,t,e))];case"Atan2":return[r.atan2(x("x",n,t,e),x("y",n,t,e))];case"Atanh":return[r.atanh(x("x",n,t,e))];case"Ceil":return[r.ceil(x("x",n,t,e))];case"Complex":return[r.complex(x("real",n,t,e),x("imag",n,t,e))];case"Cos":return[r.cos(x("x",n,t,e))];case"Cosh":return[r.cosh(x("x",n,t,e))];case"Elu":return[r.elu(x("x",n,t,e))];case"Erf":return[r.erf(x("x",n,t,e))];case"Exp":return[r.exp(x("x",n,t,e))];case"Expm1":return[r.expm1(x("x",n,t,e))];case"Floor":return[r.floor(x("x",n,t,e))];case"Log":return[r.log(x("x",n,t,e))];case"Log1p":return[r.log1p(x("x",n,t,e))];case"Imag":return[r.imag(x("x",n,t,e))];case"Neg":return[r.neg(x("x",n,t,e))];case"Reciprocal":return[r.reciprocal(x("x",n,t,e))];case"Real":return[r.real(x("x",n,t,e))];case"Relu":return[r.relu(x("x",n,t,e))];case"Round":return[r.round(x("x",n,t,e))];case"Selu":return[r.selu(x("x",n,t,e))];case"Sigmoid":return[r.sigmoid(x("x",n,t,e))];case"Sin":return[r.sin(x("x",n,t,e))];case"Sign":return[r.sign(x("x",n,t,e))];case"Sinh":return[r.sinh(x("x",n,t,e))];case"Softplus":return[r.softplus(x("x",n,t,e))];case"Sqrt":return[r.sqrt(x("x",n,t,e))];case"Square":return[r.square(x("x",n,t,e))];case"Tanh":return[r.tanh(x("x",n,t,e))];case"Tan":return[r.tan(x("x",n,t,e))];case"ClipByValue":return[r.clipByValue(x("x",n,t,e),x("clipValueMin",n,t,e),x("clipValueMax",n,t,e))];case"Relu6":return[r.relu6(x("x",n,t,e))];case"Rsqrt":return[r.rsqrt(Jr(n.inputNames[0],t,e))];case"Prod":return[r.prod(x("x",n,t,e),x("axes",n,t,e))];case"LeakyRelu":return[r.leakyRelu(x("x",n,t,e),x("alpha",n,t,e))];case"Prelu":return[r.prelu(x("x",n,t,e),x("alpha",n,t,e))];case"IsNan":return[r.isNaN(Jr(n.inputNames[0],t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"control":return Xfe(o,a,l);case"convolution":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"Conv1D":{const s=x("stride",n,t,e),i=x("pad",n,t,e),o=x("dataFormat",n,t,e).toUpperCase(),a=x("dilation",n,t,e);return[r.conv1d(x("x",n,t,e),x("filter",n,t,e),s,i,o,a)]}case"Conv2D":{const s=x("strides",n,t,e),i=rv(n,t,e),o=x("dataFormat",n,t,e).toUpperCase(),a=x("dilations",n,t,e);return[r.conv2d(x("x",n,t,e),x("filter",n,t,e),[s[1],s[2]],i,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:d}=r3(n,t,e);return[r.fused.conv2d({x:x("x",n,t,e),filter:x("filter",n,t,e),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:d}=r3(n,t,e);return[r.fused.depthwiseConv2d({x:x("x",n,t,e),filter:x("filter",n,t,e),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=x("outputShape",n,t,e),i=x("strides",n,t,e),o=rv(n,t,e);return[r.conv2dTranspose(x("x",n,t,e),x("filter",n,t,e),s,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=x("strides",n,t,e),i=rv(n,t,e),o=x("dilations",n,t,e),a=x("dataFormat",n,t,e).toUpperCase();return[r.depthwiseConv2d(x("input",n,t,e),x("filter",n,t,e),[s[1],s[2]],i,a,[o[1],o[2]])]}case"Conv3D":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("dataFormat",n,t,e).toUpperCase(),a=x("dilations",n,t,e);return[r.conv3d(x("x",n,t,e),x("filter",n,t,e),[s[1],s[2],s[3]],i,o,[a[1],a[2],a[3]])]}case"AvgPool":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("kernelSize",n,t,e);return[r.avgPool(x("x",n,t,e),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPool":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("kernelSize",n,t,e);return[r.maxPool(x("x",n,t,e),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPoolWithArgmax":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("kernelSize",n,t,e),a=x("includeBatchInIndex",n,t,e),{result:l,indexes:c}=r.maxPoolWithArgmax(x("x",n,t,e),[o[1],o[2]],[s[1],s[2]],i,a);return[l,c]}case"AvgPool3D":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("kernelSize",n,t,e);return[r.avgPool3d(x("x",n,t,e),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"MaxPool3D":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("kernelSize",n,t,e);return[r.maxPool3d(x("x",n,t,e),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"Dilation2D":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("dilations",n,t,e),a=s[1],l=s[2],c=o[1],u=o[2];return[r.dilation2d(x("x",n,t,e),x("filter",n,t,e),[a,l],i,[c,u],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"creation":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"Fill":{const s=x("shape",n,t,e),i=x("dtype",n,t,e),o=x("value",n,t,e);return[r.fill(s,o,i)]}case"LinSpace":{const s=x("start",n,t,e),i=x("stop",n,t,e),o=x("num",n,t,e);return[r.linspace(s,i,o)]}case"Multinomial":{const s=x("logits",n,t,e),i=x("numSamples",n,t,e),o=x("seed",n,t,e);return[r.multinomial(s,i,o)]}case"OneHot":{const s=x("indices",n,t,e),i=x("depth",n,t,e),o=x("onValue",n,t,e),a=x("offValue",n,t,e),l=x("dtype",n,t,e);return[r.oneHot(s,i,o,a,l)]}case"Ones":return[r.ones(x("shape",n,t,e),x("dtype",n,t,e))];case"OnesLike":return[r.onesLike(x("x",n,t,e))];case"RandomStandardNormal":return[r.randomStandardNormal(x("shape",n,t,e),x("dtype",n,t,e),x("seed",n,t,e))];case"RandomUniform":return[r.randomUniform(x("shape",n,t,e),x("minval",n,t,e),x("maxval",n,t,e),x("dtype",n,t,e))];case"Range":{const s=x("start",n,t,e),i=x("stop",n,t,e),o=x("step",n,t,e);return[r.range(s,i,o,x("dtype",n,t,e))]}case"TruncatedNormal":{const s=x("shape",n,t,e),i=x("mean",n,t,e),o=x("stdDev",n,t,e),a=x("seed",n,t,e);return[r.truncatedNormal(s,i,o,x("dtype",n,t,e),a)]}case"Zeros":return[r.zeros(x("shape",n,t,e),x("dtype",n,t,e))];case"ZerosLike":return[r.zerosLike(x("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"dynamic":return Qfe(o,a,l);case"evaluation":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"LowerBound":{const s=x("sortedSequence",n,t,e),i=x("values",n,t,e);return[r.lowerBound(s,i)]}case"TopKV2":{const s=x("x",n,t,e),i=x("k",n,t,e),o=x("sorted",n,t,e),a=r.topk(s,i,o);return[a.values,a.indices]}case"UpperBound":{const s=x("sortedSequence",n,t,e),i=x("values",n,t,e);return[r.upperBound(s,i)]}case"Unique":{const s=x("x",n,t,e),i=r.unique(s);return[i.values,i.indices]}case"UniqueV2":{const s=x("x",n,t,e),i=x("axis",n,t,e),o=r.unique(s,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"image":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"ResizeBilinear":{const s=x("images",n,t,e),i=x("size",n,t,e),o=x("alignCorners",n,t,e),a=x("halfPixelCenters",n,t,e);return[r.image.resizeBilinear(s,[i[0],i[1]],o,a)]}case"ResizeNearestNeighbor":{const s=x("images",n,t,e),i=x("size",n,t,e),o=x("alignCorners",n,t,e),a=x("halfPixelCenters",n,t,e);return[r.image.resizeNearestNeighbor(s,[i[0],i[1]],o,a)]}case"CropAndResize":{const s=x("image",n,t,e),i=x("boxes",n,t,e),o=x("boxInd",n,t,e),a=x("cropSize",n,t,e),l=x("method",n,t,e),c=x("extrapolationValue",n,t,e);return[r.image.cropAndResize(s,i,o,a,l,c)]}case"ImageProjectiveTransformV3":{const s=x("images",n,t,e),i=x("transforms",n,t,e),o=x("outputShape",n,t,e),a=x("fillValue",n,t,e),l=x("interpolation",n,t,e),c=x("fillMode",n,t,e);return[r.image.transform(s,i,l.toLowerCase(),c.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"graph":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":const s=x("default",n,t,e);return[Jr(n.name,t,e)||s];case"Placeholder":return[Jr(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Ia(x("x",n,t,e))];case"IdentityN":return x("x",n,t,e).map(u=>Ia(u));case"Shape":return[r.tensor1d(x("x",n,t,e).shape,"int32")];case"ShapeN":return x("x",n,t,e).map(u=>r.tensor1d(u.shape));case"Size":return[r.scalar(x("x",n,t,e).size,"int32")];case"Rank":return[r.scalar(x("x",n,t,e).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=x("x",n,t,e),a=x("data",n,t,e),l=x("message",n,t,e),c=x("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<a.length;u++)console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"logical":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"Equal":return[r.equal(x("a",n,t,e),x("b",n,t,e))];case"NotEqual":return[r.notEqual(x("a",n,t,e),x("b",n,t,e))];case"Greater":return[r.greater(x("a",n,t,e),x("b",n,t,e))];case"GreaterEqual":return[r.greaterEqual(x("a",n,t,e),x("b",n,t,e))];case"Less":return[r.less(x("a",n,t,e),x("b",n,t,e))];case"LessEqual":return[r.lessEqual(x("a",n,t,e),x("b",n,t,e))];case"LogicalAnd":return[r.logicalAnd(x("a",n,t,e),x("b",n,t,e))];case"LogicalNot":return[r.logicalNot(x("a",n,t,e))];case"LogicalOr":return[r.logicalOr(x("a",n,t,e),x("b",n,t,e))];case"Select":case"SelectV2":return[r.where(x("condition",n,t,e),x("a",n,t,e),x("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"matrices":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(x("a",n,t,e),x("b",n,t,e),x("transposeA",n,t,e),x("transposeB",n,t,e))];case"Einsum":return[r.einsum(x("equation",n,t,e),...x("tensors",n,t,e))];case"Transpose":return[r.transpose(x("x",n,t,e),x("perm",n,t,e))];case"_FusedMatMul":const[s,i]=x("fusedOps",n,t,e),o="biasadd"===s,a="prelu"===i,l=x("numArgs",n,t,e),c=x("leakyreluAlpha",n,t,e);if(o){if(a&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,d]=x("args",n,t,e);return[r.fused.matMul({a:x("a",n,t,e),b:x("b",n,t,e),transposeA:x("transposeA",n,t,e),transposeB:x("transposeB",n,t,e),bias:u,activation:i,preluActivationWeights:d,leakyreluAlpha:c})];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"normalization":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(x("x",n,t,e),x("axis",n,t,e),x("keepDims",n,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(x("x",n,t,e),x("mean",n,t,e),x("variance",n,t,e),x("offset",n,t,e),x("scale",n,t,e),x("epsilon",n,t,e))];case"LRN":return[r.localResponseNormalization(x("x",n,t,e),x("radius",n,t,e),x("bias",n,t,e),x("alpha",n,t,e),x("beta",n,t,e))];case"Softmax":return[r.softmax(x("x",n,t,e))];case"LogSoftmax":return[r.logSoftmax(x("x",n,t,e))];case"SparseToDense":return[r.sparseToDense(x("sparseIndices",n,t,e),x("outputShape",n,t,e),x("sparseValues",n,t,e),x("defaultValue",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"ragged":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:i}=r.raggedGather(x("paramsNestedSplits",n,t,e),x("paramsDenseValues",n,t,e),x("indices",n,t,e),x("outputRaggedRank",n,t,e));return s.concat(i)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:i}=r.raggedRange(x("starts",n,t,e),x("limits",n,t,e),x("splits",n,t,e));return[s,i]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(x("shape",n,t,e),x("values",n,t,e),x("defaultValue",n,t,e),x("rowPartitionTensors",n,t,e),x("rowPartitionTypes",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"reduction":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"Max":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.max(x("x",n,t,e),a,l)]}case"Mean":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.mean(x("x",n,t,e),a,l)]}case"Min":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.min(x("x",n,t,e),a,l)]}case"Sum":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.sum(x("x",n,t,e),a,l)]}case"All":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.all(x("x",n,t,e),a,l)]}case"Any":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.any(x("x",n,t,e),a,l)]}case"ArgMax":{const a=x("axis",n,t,e);return[r.argMax(x("x",n,t,e),a)]}case"ArgMin":{const a=x("axis",n,t,e);return[r.argMin(x("x",n,t,e),a)]}case"Prod":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.prod(x("x",n,t,e),a,l)]}case"Cumprod":{const a=x("axis",n,t,e),l=x("exclusive",n,t,e),c=x("reverse",n,t,e);return[r.cumprod(x("x",n,t,e),a,l,c)]}case"Cumsum":{const a=x("axis",n,t,e),l=x("exclusive",n,t,e),c=x("reverse",n,t,e);return[r.cumsum(x("x",n,t,e),a,l,c)]}case"Bincount":const s=x("x",n,t,e),i=x("weights",n,t,e),o=x("size",n,t,e);return[r.bincount(s,i,o)];case"DenseBincount":{const a=x("x",n,t,e),l=x("weights",n,t,e),c=x("size",n,t,e),u=x("binaryOutput",n,t,e);return[r.denseBincount(a,l,c,u)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"slice_join":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=x("n",n,t,e),i=x("axis",n,t,e);let o=x("tensors",n,t,e);return o=o.slice(0,s),[r.concat(o,i)]}case"Gather":{const s=x("x",n,t,e),i=x("indices",n,t,e);return[r.gather(s,r.cast(i,"int32"),0)]}case"GatherV2":{const s=x("axis",n,t,e),i=x("batchDims",n,t,e),o=x("x",n,t,e),a=x("indices",n,t,e);return[r.gather(o,r.cast(a,"int32"),s,i)]}case"Reverse":{const s=x("dims",n,t,e),i=[];for(let a=0;a<s.length;a++)s[a]&&i.push(a);const o=x("x",n,t,e);return[r.reverse(o,i)]}case"ReverseV2":{const s=x("axis",n,t,e),i=x("x",n,t,e);return[r.reverse(i,s)]}case"Slice":{const s=x("begin",n,t,e),i=x("size",n,t,e);return[r.slice(x("x",n,t,e),s,i)]}case"StridedSlice":{const s=x("begin",n,t,e),i=x("end",n,t,e),o=x("strides",n,t,e),a=x("beginMask",n,t,e),l=x("endMask",n,t,e),c=x("ellipsisMask",n,t,e),u=x("newAxisMask",n,t,e),d=x("shrinkAxisMask",n,t,e),h=x("x",n,t,e);return[r.stridedSlice(h,s,i,o,a,l,c,u,d)]}case"Pack":return V(()=>{const s=x("axis",n,t,e),i=x("tensors",n,t,e),o=i[0].shape,a=r.squeeze(i[0]).shape,l=i.map(c=>{const u=It(c.shape,o);if(!u&&!It(r.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return u?c:r.reshape(c,o)});return[r.stack(l,s)]});case"Unpack":{const s=x("axis",n,t,e),i=x("tensor",n,t,e);return r.unstack(i,s)}case"Tile":{const s=x("reps",n,t,e);return[r.tile(x("x",n,t,e),s)]}case"Split":case"SplitV":{const s=x("axis",n,t,e),i=x("numOrSizeSplits",n,t,e),o=x("x",n,t,e);return r.split(o,i,s)}case"ScatterNd":{const s=x("indices",n,t,e),i=x("values",n,t,e),o=x("shape",n,t,e);return[r.scatterND(s,i,o)]}case"GatherNd":{const s=x("x",n,t,e),i=x("indices",n,t,e);return[r.gatherND(s,i)]}case"SparseToDense":{const s=x("sparseIndices",n,t,e),i=x("outputShape",n,t,e),o=x("sparseValues",n,t,e),a=x("defaultValue",n,t,e);return[r.sparseToDense(s,o,i,o.dtype===a.dtype?a:r.cast(a,o.dtype))]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"sparse":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:i,emptyRowIndicator:o,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(x("indices",n,t,e),x("values",n,t,e),x("denseShape",n,t,e),x("defaultValue",n,t,e));return[s,i,o,a]}case"SparseReshape":{const{outputIndices:s,outputShape:i}=r.sparse.sparseReshape(x("inputIndices",n,t,e),x("inputShape",n,t,e),x("newShape",n,t,e));return[s,i]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(x("data",n,t,e),x("indices",n,t,e),x("segmentIds",n,t,e))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(x("data",n,t,e),x("indices",n,t,e),x("segmentIds",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"spectral":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"FFT":return[r.fft(x("x",n,t,e))];case"IFFT":return[r.ifft(x("x",n,t,e))];case"RFFT":return[r.rfft(x("x",n,t,e))];case"IRFFT":return[r.irfft(x("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"string":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"StringNGrams":{const{nGrams:s,nGramsSplits:i}=r.string.stringNGrams(x("data",n,t,e),x("dataSplits",n,t,e),x("separator",n,t,e),x("nGramWidths",n,t,e),x("leftPad",n,t,e),x("rightPad",n,t,e),x("padWidth",n,t,e),x("preserveShortSequences",n,t,e));return[s,i]}case"StringSplit":{const{indices:s,values:i,shape:o}=r.string.stringSplit(x("input",n,t,e),x("delimiter",n,t,e),x("skipEmpty",n,t,e));return[s,i,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(x("input",n,t,e),x("numBuckets",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"transformation":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"Cast":return[r.cast(x("x",n,t,e),x("dtype",n,t,e))];case"ExpandDims":{const s=x("axis",n,t,e);return[r.expandDims(x("x",n,t,e),s)]}case"Squeeze":{const s=x("axis",n,t,e);return[r.squeeze(x("x",n,t,e),s)]}case"Reshape":return[r.reshape(x("x",n,t,e),x("shape",n,t,e))];case"MirrorPad":return[r.mirrorPad(x("x",n,t,e),x("padding",n,t,e),x("mode",n,t,e))];case"PadV2":case"Pad":return[r.pad(x("x",n,t,e),x("padding",n,t,e),x("constantValue",n,t,e))];case"SpaceToBatchND":{const s=x("blockShape",n,t,e),i=x("paddings",n,t,e);return[r.spaceToBatchND(x("x",n,t,e),s,i)]}case"BatchToSpaceND":{const s=x("blockShape",n,t,e),i=x("crops",n,t,e);return[r.batchToSpaceND(x("x",n,t,e),s,i)]}case"DepthToSpace":{const s=x("blockSize",n,t,e),i=x("dataFormat",n,t,e).toUpperCase();return[r.depthToSpace(x("x",n,t,e),s,i)]}case"BroadcastTo":return[r.broadcastTo(x("x",n,t,e),x("shape",n,t,e))];case"BroadcastArgs":return[r.broadcastArgs(x("s0",n,t,e),x("s1",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"hash_table":return npe(o,a,l,r);case"custom":const c=Zz(o.op);if(c&&c.customExecutor)return c.customExecutor(new zfe(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return ed(i)?i.then(o=>[].concat(o)):[].concat(i)}class o3{constructor(t={},e={},r={},s={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const r=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(r))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function a3(n,t,e,r){const s=new Set,i=[];let o=null,a=null;const l=new Set,c=Object.keys(n).map(h=>Ls(h)[0]);let u=[];null!=r&&(u=r.map(h=>Ls(h.name)[0]));const d=[...t];for(;d.length>0;){const h=d.pop();if((l3(h)||bpe(h)||_pe(h))&&null==o&&(o=h,a=o.children.map(f=>f.name).filter(f=>s.has(f))),s.add(h.name),null==e[h.name]&&-1===c.indexOf(h.name)&&-1===u.indexOf(h.name)){if(0===h.inputs.length){i.push(h.name);continue}h.inputs.forEach(f=>{l.has(f.name)||(l.add(f.name),d.push(f))})}}return{inputs:n,outputs:t,usedNodes:s,missingInputs:i,dynamicNode:o,syncInputs:a}}const mpe=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],gpe=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],ype=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function l3(n){return mpe.indexOf(n.op)>=0}function bpe(n){return gpe.indexOf(n.op)>=0}function _pe(n){return ype.indexOf(n.op)>=0}class sv{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new sv(t.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(r=>t[r].map(s=>s.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}getCompilationKey(t,e){const r=t.map(i=>i.name).sort(),s=e.map(i=>i.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(t,e){const r=a3(t,e,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:i,syncInputs:o}=r;if(null!=i)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(s.length>0){const a=e.map(c=>c.name),l=Object.keys(t);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${l}]. Missing the following inputs: [${s}]`)}return function ppe(n,t,e){const{usedNodes:r,inputs:s}=e,i=[],o=Object.keys(s).map(u=>Ls(u)[0]).map(u=>n.nodes[u]),a=n.initNodes;o.forEach(u=>{r.has(u.name)&&i.push(u)}),n.weights.forEach(u=>{r.has(u.name)&&i.push(u)}),a?.forEach(u=>{r.has(u.name)&&i.push(u)});const l=new Set,c=[];for(;i.length>0;){const u=i.pop();l.add(u.name),t[u.name]||c.push(u),u.children.forEach(d=>{!l.has(d.name)&&r.has(d.name)&&d.inputs.every(h=>l.has(h.name))&&i.push(d)})}return c}(this.graph,this.weightMap,r)}cloneAndKeepTensor(t){if(null==t)return null;const e=t.clone();return xr(e),e}cloneTensorList(t){return t?t.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,r])=>[e,this.cloneTensorList(r)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const s=r.map(d=>this.graph.nodes[Ls(d)[0]]),i=e.map(d=>Ls(d)[0]);let o=i.map(d=>this.graph.nodes[d]);0===o.length&&(o=this._outputs);const a=this.getCompilationKey(s,o);let l=this.compiledMap.get(a);null==l&&(l=this.compile(t,o),this.compiledMap.set(a,l));try{this.keepIntermediateTensors=G().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const c={},u={};return V(()=>{const d=new o3(this.weightMap,c,u,this.functionExecutorMap),h=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(m=>{const[g,y]=Ls(m),b=[];b[y]=t[m],h[g]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[g]=this.cloneTensorList(b))});const f=this.getFrozenTensorIds(h),p={};for(let m=0;m<l.length;m++){const g=l[m];if(!h[g.name]){const y=s3(g,h,d,this._resourceManager);if(ed(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);h[g.name]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[g.name]=this.cloneTensorList(y)),this.checkTensorForDisposal(g.name,g,h,d,f,i,p)}}return null==this.parent&&d.dispose(f),e.map(m=>Jr(m,h,d))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(s=>s.id)));return new Set(e)}checkTensorForDisposal(t,e,r,s,i,o,a){"control"===e.category||-1!==o.indexOf(t)||(r[t].forEach(l=>{null!=l&&(a[l.id]=(a[l.id]||0)+e.children.length)}),e.inputs.forEach(l=>{if("control"!==l.category){const c=function vfe(n,t,e){return t[nv(n,e.currentContextId)]}(l.name,r,s);c?.forEach(u=>{if(u&&!u.kept&&!i.has(u.id)){const d=a[u.id];1===d?(u.dispose(),delete a[u.id]):null!=d&&a[u.id]--}})}}))}executeAsync(t,e){var r=this;return ee(function*(){return r._executeAsync(t,e)})()}disposeIntermediateTensors(){!this.clonedTensorsMap||(Object.values(this.clonedTensorsMap).forEach(t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(t,e,r=!1,s={},i={}){var o=this;return ee(function*(){o.disposeIntermediateTensors(),r||(t=o.mapInputs(t),o.checkInputs(t),o.checkInputShapeAndType(t),e=o.mapOutputs(e),o.checkOutputs(e));try{o.keepIntermediateTensors=G().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){o.keepIntermediateTensors=!1,console.warn(f.message)}const a=new o3(o.weightMap,s,i,o.functionExecutorMap);o.keepIntermediateTensors&&(o.clonedTensorsMap=o.cloneTensorMap(o.weightMap));const l=yield o.executeWithControlFlow(t,a,e,r),c=e.map(f=>Jr(f,l,a)),u=c.map(f=>f.id),d=Object.keys(t).map(f=>t[f].id),h=new Set([...u,...d,...o.weightIds]);return Object.values(l).forEach(f=>{f.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),null==o.parent&&a.dispose(h),c})()}executeFunctionAsync(t,e,r){var s=this;return ee(function*(){const i=t.reduce((o,a,l)=>(o[s.inputs[l].name]=a,o),{});return s._executeAsync(i,s.outputNodes,!0,e,r)})()}executeWithControlFlow(t,e,r,s){var i=this;return ee(function*(){const o=Object.keys(t),a=o.map(v=>i.graph.nodes[Ls(v)[0]]),l=r.map(v=>Ls(v)[0]);let c=l.map(v=>i.graph.nodes[v]);0===c.length&&(c=i._outputs);const{usedNodes:u,missingInputs:d,dynamicNode:h,syncInputs:f}=a3(t,c,i.weightMap,i._initNodes),p=[...a,...i.graph.weights,...i._initNodes||[]].map(v=>({node:v,contexts:e.currentContext})),m=Object.assign({},i.weightMap);Object.keys(t).forEach(v=>{const[w,C]=Ls(v),I=[];I[C]=t[v],m[w]=I});const g={},y=i.getFrozenTensorIds(m),b={};for(;p.length>0;){const v=i.processStack(a,p,e,m,b,y,l,g,u);yield Promise.all(v)}null==h&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const _=c.filter(v=>!l3(v)&&!Jr(v.name,m,e)).map(v=>v.name);if(_.length>0){let v="";throw null!=h&&(v=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${_}] from the provided inputs [${o}]. Consider providing the following inputs: [${d}]. ${v}`)}return m})()}processStack(t,e,r,s,i,o,a,l,c){const u=[];for(;e.length>0;){const d=e.pop();r.currentContext=d.contexts;let h="";if("Enter"===d.node.op&&x("isConstant",d.node,s,r)&&([h]=Ea(d.node.name,r)),null==s[d.node.name]){const f=s3(d.node,s,r,this._resourceManager);h||([h]=Ea(d.node.name,r));const p=r.currentContext;ed(f)?u.push(f.then(m=>(s[h]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(m)),r.currentContext=p,this.checkTensorForDisposal(h,d.node,s,r,o,a,l),this.processChildNodes(d.node,e,r,s,i,c),m))):(s[h]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(f)),this.checkTensorForDisposal(h,d.node,s,r,o,a,l),this.processChildNodes(d.node,e,r,s,i,c))}else this.processChildNodes(d.node,e,r,s,i,c)}return u}processChildNodes(t,e,r,s,i,o){t.children.forEach(a=>{const[l]=Ea(a.name,r);i[l]||!o.has(a.name)||("Merge"===a.op?a.inputNames.some(c=>!!Jr(c,s,r))&&(i[l]=!0,e.push({contexts:r.currentContext,node:a})):a.inputNames.every(c=>!!Jr(c,s,r))&&(i[l]=!0,e.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const r=t[e],[s]=Ls(e),i=this.graph.nodes[s];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value;S(o.length===r.shape.length&&r.shape.every((l,c)=>-1===o[c]||o[c]===l),()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&S(r.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var e,r;const s={};for(const i in t){const o=null===(r=null===(e=this._signature)||void 0===e?void 0:e.inputs)||void 0===r?void 0:r[i];null!=o?s[o.name]=t[i]:s[i]=t[i]}return s}checkInputs(t){const e=Object.keys(t).filter(r=>{const[s]=Ls(r);return null==this.graph.nodes[s]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var r,s;const i=null===(s=null===(r=this._signature)||void 0===r?void 0:r.outputs)||void 0===s?void 0:s[e];return null!=i?i.name:e},{})}checkOutputs(t){t.forEach(e=>{const[r]=Ls(e);if(!this.graph.nodes[r])throw new Error(`The output '${e}' is not found in the graph`)})}}class vpe{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}class c3{constructor(t,e={},r=Ue){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=r,null==e&&(this.loadOptions={}),this.resourceManager=new vpe}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return ed(t)?t.then(e=>this.loadSync(e)):this.loadSync(t)}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const i=this.artifacts.userDefinedMetadata;null!=i.signature&&(r=i.signature),null!=i.structuredOutputKeys&&(this.structuredOutputKeys=i.structuredOutputKeys)}this.signature=r,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const s=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new sv(Qz.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const i=Qz.Instance.transformGraph(t.modelInitializer);this.initializer=new sv(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}save(t,e){var r=this;return ee(function*(){if("string"==typeof t){const s=r.io.getSaveHandlers(t);if(0===s.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${t}'`);t=s[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(r.artifacts)})()}addStructuredOutputNames(t){if(this.structuredOutputKeys){const r={};return(t instanceof pn?[t]:t).forEach((s,i)=>r[this.structuredOutputKeys[i]]=s),r}return t}predict(t,e){const r=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(r)}predictAsync(t,e){var r=this;return ee(function*(){const s=yield r.executeAsync(t,r.outputNodes);return r.addStructuredOutputNames(s)})()}normalizeInputs(t){var e;if(!(t instanceof pn||Array.isArray(t))){const i=null===(e=this.signature)||void 0===e?void 0:e.inputs;if(null!=i)for(const o in i){const a=i[o];null!=a.resourceId&&(t[o]=this.resourceIdToCapturedInput[a.resourceId])}return t}t=Array.isArray(t)?t:[t];const r=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${t.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((i,o)=>{var a,l,c;const u=null===(c=null===(l=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===l?void 0:l[o])||void 0===c?void 0:c.resourceId;return i[o]=null!=u?this.resourceIdToCapturedInput[u]:t[s++],i},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return null==this.initializer?[]:this.initializer.execute({},null==this.initializerSignature?[]:Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){var t=this;return ee(function*(){return null==t.initializer?[]:t.initializer.executeAsync({},null==t.initializerSignature?[]:Object.keys(t.initializerSignature.outputs))})()}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,r=Object.keys(e);for(let s=0;s<r.length;s++)this.resourceIdToCapturedInput[e[r[s]].resourceId]=t[s]}}execute(t,e){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const r=this.executor.execute(t,e);return r.length>1?r:r[0]}executeAsync(t,e){var r=this;return ee(function*(){null==r.resourceIdToCapturedInput&&r.setResourceIdToCapturedInput(yield r.executeInitializerGraphAsync()),t=r.normalizeInputs(t),e=r.normalizeOutputs(e);const s=yield r.executor.executeAsync(t,e);return s.length>1?s:s[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,r)=>(e[r]=[t[r]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Qe(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}function WT(){return(WT=ee(function*(n,t={},e=Ue){if(null==n)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof n&&(n=Spe(n));const r=new c3(n,t,e);return yield r.load(),r})).apply(this,arguments)}function Spe(n){return n.endsWith("/")||(n+="/"),`${n}model.json?tfjs-format=file`}function Te(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&S("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const Qpe=eD;let Jpe=(()=>{class n extends _S{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new D$(this,Mo())}nextDataId(){return n.nextDataId++}write(e,r,s){this.firstUse&&(this.firstUse=!1,G().get("IS_NODE")&&si("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const i={id:this.nextDataId()};return this.data.set(i,{values:e,dtype:s,refCount:1}),i}makeTensorInfo(e,r,s){let i;if("string"===r&&null!=s&&s.length>0&&Cf(s[0])){const o=s.map(a=>Za(a));i=this.write(o,e,r)}else i=this.write(s,e,r);return{dataId:i,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,s,i,o){this.data.set(e,{values:r,dtype:i,refCount:o})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return ee(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:s}=this.data.get(e);return"complex64"===r?wa(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):this.data.get(e).values}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(i=>Qa(i));return ot(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ot(e.shape,e.dtype,r)}makeOutput(e,r,s){return Mo().makeTensorFromTensorInfo(this.makeTensorInfo(r,s,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);null!=s&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return ee(function*(){const r=ps();return e(),{kernelMs:ps()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Te([e],"where");const r=this.readSync(e.dataId);return Qpe(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();function qt(n,t,e){return({inputs:r,attrs:s,backend:i})=>{const{x:o}=r;if(Te(o,n),"string"===o.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=i,l=a.data.get(o.dataId).values,c=X(o.shape),u=e||o.dtype,d=Kn(u,c);for(let h=0;h<c;++h)d[h]=t(l[h],s);return a.makeTensorInfo(o.shape,u,d)}}function Td(n,t,e){return({inputs:r,attrs:s,backend:i})=>{const{x:o}=r;if(Te(o,n),"string"===o.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=i,l=a.data.get(o.dataId).values,c=e||o.dtype,u=t(l,c,s);return a.makeTensorInfo(o.shape,c,u)}}FL("cpu",()=>new Jpe,1);const v3=qt(Lf,n=>n>=0?n:Math.exp(n)-1),tme={kernelName:Lf,backendName:"cpu",kernelFunc:v3};function Wo(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const nme={kernelName:jf,backendName:"cpu",kernelFunc:Wo};function x3(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:i}=r;Te([s],"leakyRelu");const o=X(s.shape),a=e.data.get(s.dataId).values,l=br("float32",o);for(let c=0;c<a.length;c++)l[c]=a[c]<0?i*a[c]:a[c];return e.makeTensorInfo(s.shape,"float32",l)}const rme={kernelName:ib,backendName:"cpu",kernelFunc:x3};function Yn(n){return(t,e,r,s,i)=>{const o=et(t,e),a=o.length,l=Le(o),u=br(i,X(o)),d=t.length,h=e.length,f=Le(t),p=Le(e),m=cd(t,o),g=cd(e,o);if(m.length+g.length===0)for(let y=0;y<u.length;++y)u[y]=n(r[y%r.length],s[y%s.length]);else for(let y=0;y<u.length;++y){const b=Ju(y,a,l),_=b.slice(-d);m.forEach(I=>_[I]=0);const v=Ao(_,d,f),w=b.slice(-h);g.forEach(I=>w[I]=0);const C=Ao(w,h,p);u[y]=n(r[v],s[C])}return[u,o]}}const sme=Yn((n,t)=>n<0?t*n:n);function w3(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t;Te([r,s],"prelu");const i=e.data.get(r.dataId).values,o=e.data.get(s.dataId).values,[a,l]=sme(r.shape,s.shape,i,o,"float32");return e.makeTensorInfo(l,"float32",a)}const ime={kernelName:Sb,backendName:"cpu",kernelFunc:w3},C3=qt(rp,n=>Math.max(0,n)),ome={kernelName:rp,backendName:"cpu",kernelFunc:C3},S3=qt(sp,n=>Math.min(Math.max(0,n),6)),ame={kernelName:sp,backendName:"cpu",kernelFunc:S3};function _l(n){return(t,e,r)=>{const s=br(e,t.length);for(let i=0;i<t.length;++i)s[i]=n(t[i],r);return s}}const lme=_l(n=>1/(1+Math.exp(-n))),E3=qt(dp,n=>1/(1+Math.exp(-n))),cme={kernelName:dp,backendName:"cpu",kernelFunc:E3};function lv(n,t,e,r,s){if("linear"===e)return Wo({inputs:{x:t},backend:n});if("relu"===e)return C3({inputs:{x:t},backend:n});if("elu"===e)return v3({inputs:{x:t},backend:n});if("relu6"===e)return S3({inputs:{x:t},backend:n});if("prelu"===e)return w3({inputs:{x:t,alpha:r},backend:n});if("leakyrelu"===e)return x3({inputs:{x:t},backend:n,attrs:{alpha:s}});if("sigmoid"===e)return E3({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Bs(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,i=e.data.get(r.dataId).values,o=e.data.get(s.dataId).values,a=e.makeTensorInfo(r.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",i),imag:e.makeTensorInfo(s.shape,"float32",o)},a}const ume={kernelName:OS,backendName:"cpu",kernelFunc:Bs};function cv(n,t,e="float32"){if("complex64"===e)return Bs({inputs:{real:cv(n,t,"float32"),imag:cv(n,t,"float32")},backend:n});const r=Br(X(t),e);return n.makeTensorInfo(t,e,r)}function kc(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.real,i=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,i)}const dme={kernelName:mE,backendName:"cpu",kernelFunc:kc};function I3(n,t,e,r){if("int32"===r)return[t,"int32",Int32Array.from(n)];if("bool"===r){const s=fc([0],e),[i,o]=Yn((a,l)=>a!==l?1:0)(t,[],n,s,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function vl(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:i}=r;if("complex64"===i){if("complex64"===s.dtype)return Wo({inputs:{x:s},backend:e});const u=cv(e,s.shape,s.dtype),d=vl({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),h=Bs({inputs:{real:d,imag:u},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),h}if("complex64"===s.dtype){const u=kc({inputs:{input:s},backend:e}),d=vl({inputs:{x:u},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(u),d}if(!A$(s.dtype,i)){const u=Wo({inputs:{x:s},backend:e});return{dataId:u.dataId,shape:u.shape,dtype:i}}const o=e.data.get(s.dataId).values,[a,l,c]=I3(o,s.shape,s.dtype,i);return e.makeTensorInfo(a,l,c)}const hme={kernelName:Rf,backendName:"cpu",kernelFunc:vl};function Er(n,t,e,r){return null==e?({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;Te([o,a],n);const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,d="string"===o.dtype?xc(c):c,h="string"===o.dtype?xc(u):u,f=r||o.dtype,[p,m]=t(o.shape,a.shape,d,h,f);return l.makeTensorInfo(m,f,p)}:({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;if("complex64"===o.dtype||"complex64"===a.dtype){const c=vl({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),h=u.complexTensorInfos.imag,f=l.data.get(u.complexTensorInfos.real.dataId).values,p=l.data.get(h.dataId).values,m=vl({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),b=g.complexTensorInfos.imag,_=l.data.get(g.complexTensorInfos.real.dataId).values,v=l.data.get(b.dataId).values,[w,C,I]=e(o.shape,a.shape,f,p,_,v),D=l.makeTensorInfo(I,"float32",w),T=l.makeTensorInfo(I,"float32",C),N=Bs({inputs:{real:D,imag:T},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(D),l.disposeIntermediateTensorInfo(T),N}{const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,d=r||o.dtype,[h,f]=t(o.shape,a.shape,c,u,d);return l.makeTensorInfo(f,d,h)}}}function ZT(n){return(t,e,r,s,i,o)=>{const a=et(t,e),l=X(a),c=a.length,u=Le(a),d=br("float32",l),h=br("float32",l),f=cd(t,a),p=cd(e,a),m=wa(r,s),g=wa(i,o),y=t.length,b=Le(t),_=e.length,v=Le(e);if(f.length+p.length===0)for(let w=0;w<d.length;w++){const C=w%m.length,I=w%g.length,D=n(m[2*C],m[2*C+1],g[2*I],g[2*I+1]);d[w]=D.real,h[w]=D.imag}else for(let w=0;w<d.length;w++){const C=Ju(w,c,u),I=C.slice(-y);f.forEach(z=>I[z]=0);const D=Ao(I,y,b),T=C.slice(-_);p.forEach(z=>T[z]=0);const N=Ao(T,_,v),$=n(m[2*D],m[2*D+1],g[2*N],g[2*N+1]);d[w]=$.real,h[w]=$.imag}return[d,h,a]}}const D3=Yn((n,t)=>n+t),fme=ZT((n,t,e,r)=>({real:n+e,imag:t+r})),kd=Er(td,D3,fme),pme={kernelName:td,backendName:"cpu",kernelFunc:kd};function on(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:i}=r,o=X(s.shape),a=N$(i,o),l=X(a);S(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.incRef(s.dataId);const c=e.data.get(s.dataId);if(null!=c.complexTensorInfos){const d=c.complexTensorInfos.imag;c.complexTensorInfos.real.shape=a,d.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const mme={kernelName:Ib,backendName:"cpu",kernelFunc:on};function T3(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i}=t,{transposeA:o,transposeB:a}=r;Te([s,i],"matMul");const l=s.shape.length,c=i.shape.length,u=o?s.shape[l-2]:s.shape[l-1],d=a?i.shape[c-1]:i.shape[c-2],h=o?s.shape[l-1]:s.shape[l-2],f=a?i.shape[c-2]:i.shape[c-1],p=s.shape.slice(0,-2),m=i.shape.slice(0,-2),g=X(p),y=X(m),_=et(s.shape.slice(0,-2),i.shape.slice(0,-2)).concat([h,f]);S(u===d,()=>`Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${s.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const w=a?[y,f,d]:[y,d,f],C=on({inputs:{x:s},backend:e,attrs:{shape:o?[g,u,h]:[g,h,u]}}),I=on({inputs:{x:i},backend:e,attrs:{shape:w}}),D=o?C.shape[1]:C.shape[2],T=o?C.shape[2]:C.shape[1],N=a?I.shape[1]:I.shape[2],$=Math.max(g,y),z=e.data.get(C.dataId).values,j=e.data.get(I.dataId).values,q=Le(C.shape),K=Le(I.shape),[P,B,L]=o?[q[0],1,q[1]]:[q[0],q[1],1],[W,ne,ie]=a?[1,K[1],K[0]]:[K[1],1,K[0]],de=T*N,ue=ot([$,T,N],C.dtype),he=ue.values,ge=e.blockSize;for(let Ee=0;Ee<$;Ee++)for(let _e=0;_e<T;_e+=ge)for(let Me=0;Me<N;Me+=ge)for(let ke=0;ke<D;ke+=ge){const Ze=Math.min(_e+ge,T),at=Math.min(Me+ge,N),Kt=Math.min(ke+ge,D);for(let ln=_e;ln<Ze;ln++)for(let mn=Me;mn<at;mn++){let wn=0;for(let Yt=ke;Yt<Kt;Yt++){const Mn=Math.min(Ee,g-1)*P,Hn=Math.min(Ee,y-1)*ie;wn+=z[Mn+ln*B+Yt*L]*j[Yt*W+mn*ne+Hn]}he[Ee*de+(ln*N+mn)]+=wn}}return e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo(I),e.makeTensorInfo(_,ue.dtype,ue.values)}const gme={kernelName:Wy,backendName:"cpu",kernelFunc:T3},bme={kernelName:Bb,backendName:"cpu",kernelFunc:function yme(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:d}=r;let h,f,p;const m=[];h=T3({inputs:{a:s,b:i},attrs:{transposeA:l,transposeB:c},backend:e}),o&&(f=kd({inputs:{a:h,b:o},backend:e}),m.push(h),h=f),u&&(p=lv(e,h,u,a,d),m.push(h),h=p);for(const y of m)e.disposeIntermediateTensorInfo(y);return h}};function k3(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const _me={kernelName:Ly,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend;Te(t,"abs");let r=new Float32Array(X(t.shape));return r=k3(e.data.get(t.dataId).values),e.makeOutput(r,t.shape,t.dtype)}},vme=qt(Ef,n=>Math.acos(n)),xme={kernelName:Ef,backendName:"cpu",kernelFunc:vme},wme=qt(If,n=>Math.acosh(n)),Cme={kernelName:If,backendName:"cpu",kernelFunc:wme},Eme={kernelName:By,backendName:"cpu",kernelFunc:function Sme(n){const{inputs:t,backend:e}=n,r=t;Te(t,"addN");const s=r.map(a=>e.data.get(a.dataId).values),i=ot(r[0].shape,r[0].dtype),o=i.values;for(let a=0;a<r.length;a++){const l=s[a];for(let c=0;c<o.length;c++)o[c]+=l[c]}return e.makeTensorInfo(i.shape,i.dtype,i.values)}};function QT(n,t,e,r,s){const i=t.length,o=X(t),a=Le(t),l=Le(s),c=br(e,X(s));for(let u=0;u<o;++u){const d=Ju(u,i,a),h=new Array(d.length);for(let p=0;p<h.length;p++)h[p]=d[r[p]];c[Ao(h,i,l)]=n[u]}return c}function vs(n){const{inputs:t,attrs:e,backend:r}=n,{x:s}=t,{perm:i}=e;Te(s,"transpose");const a=new Array(s.shape.length);for(let d=0;d<a.length;d++)a[d]=s.shape[i[d]];const c=QT(r.data.get(s.dataId).values,s.shape,s.dtype,i,a);return{dataId:r.write(c,a,s.dtype),shape:a,dtype:s.dtype}}const Ime={kernelName:nd,backendName:"cpu",kernelFunc:vs},Tme={kernelName:"All",backendName:"cpu",kernelFunc:function Dme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;Te(s,"all");const a=ft(i,s.shape);let l=a;const c=Dn(l,s.shape.length);let u=s;null!=c&&(u=vs({inputs:{x:s},backend:e,attrs:{perm:c}}),l=zn(l.length,s.shape.length)),Ar("all",l,u.shape.length);const[d,h]=Cr(u.shape,l),f=X(h),p=Br(X(d),u.dtype),m=e.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let _=m[b];for(let v=0;v<f;++v){const w=m[b+v];_=_&&w}p[y]=_}null!=c&&e.disposeIntermediateTensorInfo(u);const g=e.makeTensorInfo(d,u.dtype,p);if(o){const b=on({inputs:{x:g},backend:e,attrs:{shape:Vn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},Nme={kernelName:"Any",backendName:"cpu",kernelFunc:function kme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;Te(s,"any");const a=ft(i,s.shape);let l=a;const c=Dn(l,s.shape.length);let u=s;null!=c&&(u=vs({inputs:{x:s},backend:e,attrs:{perm:c}}),l=zn(l.length,s.shape.length)),Ar("any",l,u.shape.length);const[d,h]=Cr(u.shape,l),f=X(h),p=Br(X(d),u.dtype),m=e.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let _=m[b];for(let v=0;v<f;++v){const w=m[b+v];_=_||w}p[y]=_}null!=c&&e.disposeIntermediateTensorInfo(u);const g=e.makeTensorInfo(d,u.dtype,p);if(o){const b=on({inputs:{x:g},backend:e,attrs:{shape:Vn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},Rme={kernelName:Vy,backendName:"cpu",kernelFunc:function Ame(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;Te(s,"argMax");let o=ft(i,s.shape);const a=Dn(o,s.shape.length);let l=s;const c=[];null!=a&&(l=vs({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),o=zn(o.length,l.shape.length)),o=[o[0]],Ar("argMax",o,l.shape.length);const[u,d]=Cr(l.shape,o),f=Br(X(u),"int32"),p=X(d),m=e.data.get(l.dataId).values;for(let g=0;g<f.length;++g){const y=g*p;let b=m[y],_=0;for(let v=0;v<p;++v){const w=m[y+v];w>b&&(b=w,_=v)}f[g]=_}return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(u,"int32",f)}},Fme={kernelName:zy,backendName:"cpu",kernelFunc:function Mme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;Te(s,"argMin");let o=ft(i,s.shape);const a=Dn(o,s.shape.length);let l=s;const c=[];null!=a&&(l=vs({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),o=zn(o.length,l.shape.length)),o=[o[0]],Ar("argMin",o,l.shape.length);const[u,d]=Cr(l.shape,o),f=Br(X(u),"int32"),p=X(d),m=e.data.get(l.dataId).values;for(let g=0;g<f.length;++g){const y=g*p;let b=m[y],_=0;for(let v=0;v<p;++v){const w=m[y+v];w<b&&(b=w,_=v)}f[g]=_}return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(u,"int32",f)}},Ome=qt(Df,n=>Math.asin(n)),Pme={kernelName:Df,backendName:"cpu",kernelFunc:Ome},$me=qt(Tf,n=>Math.asinh(n)),Lme={kernelName:Tf,backendName:"cpu",kernelFunc:$me},Bme=qt(kf,n=>Math.atan(n)),Vme={kernelName:kf,backendName:"cpu",kernelFunc:Bme},zme=Yn((n,t)=>Math.atan2(n,t)),Ume=Er(Af,zme),Hme={kernelName:Af,backendName:"cpu",kernelFunc:Ume},Wme=qt(Nf,n=>Math.atanh(n)),jme={kernelName:Nf,backendName:"cpu",kernelFunc:Wme};function JT(n,t,e,r,s,i){const o=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,c=s.dilationWidth,u=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,f=s.padInfo.left,p="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=ot(s.outShape,e),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],_=s.outShape[3];for(let v=0;v<s.batchSize;++v){const w=v*y,C=v*r[0];for(let I=0;I<s.inChannels;++I)for(let D=0;D<s.outHeight;++D){const T=D*o-h,N=Math.max(0,T),$=Math.min(s.inHeight,u+T),z=w+D*b;for(let j=0;j<s.outWidth;++j){const q=j*a-f,K=Math.max(0,q),P=Math.min(s.inWidth,d+q);let B=p,L=0,W=0;for(let ie=N;ie<$;ie+=l){const de=C+ie*r[1];for(let ue=K;ue<P;ue+=c){const ge=n[de+ue*r[2]+I];"max"===i&&ge>B?B=ge:"avg"===i&&(L+=ge,W++)}if(isNaN(B))break}g[z+j*_+I]="avg"===i?L/W:B}}}return m}function N3(n,t,e,r,s=!1,i=!1){const o=ot(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,f=r.padInfo.top,p=r.padInfo.left,m=ot(t,e,n);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){const _=b*a-f;let v=_;for(;v<0;)v+=c;const w=Math.min(r.inHeight,d+_);for(let C=0;C<r.outWidth;++C){const I=C*l-p;let D=I;for(;D<0;)D+=u;const T=Math.min(r.inWidth,h+I);let N=Number.NEGATIVE_INFINITY,$=-1;for(let z=v;z<w;z+=c){const j=z-_;for(let q=D;q<T;q+=u){const K=q-I,P=m.get(g,z,q,y);P>N&&(N=P,$=s?i?((g*r.inHeight+z)*r.inWidth+q)*r.inChannels+y:(z*r.inWidth+q)*r.inChannels+y:j*h+K)}}o.set($,g,b,C,y)}}return o}function A3(n,t,e,r,s,i){const o=s.strideDepth,a=s.strideHeight,l=s.strideWidth,c=s.dilationDepth,u=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,f=s.effectiveFilterHeight,p=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,_=ot(s.outShape,e),v=_.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],C=s.outShape[2]*s.outShape[3]*s.outShape[4],I=s.outShape[3]*s.outShape[4],D=s.outShape[4];for(let T=0;T<s.batchSize;++T){const N=T*w,$=T*r[0];for(let z=0;z<s.inChannels;++z)for(let j=0;j<s.outDepth;++j){const q=j*o-m;let K=q;for(;K<0;)K+=c;const P=Math.min(s.inDepth,h+q),B=N+j*C;for(let L=0;L<s.outHeight;++L){const W=L*a-g;let ne=W;for(;ne<0;)ne+=u;const ie=Math.min(s.inHeight,f+W),de=B+L*I;for(let ue=0;ue<s.outWidth;++ue){const he=ue*l-y;let ge=he;for(;ge<0;)ge+=d;const Ee=Math.min(s.inWidth,p+he),_e=de+ue*D;let Me=b,ke=0,Ze=0;for(let Kt=K;Kt<P;Kt+=c){const ln=$+Kt*r[1];for(let mn=ne;mn<ie;mn+=u){const wn=ln+mn*r[2];for(let Yt=ge;Yt<Ee;Yt+=d){const Hn=n[wn+Yt*r[3]+z];if("max"===i&&Hn>Me?Me=Hn:"avg"===i&&(ke+=Hn,Ze++),isNaN(Me))break}if(isNaN(Me))break}if(isNaN(Me))break}v[_e+z]="avg"===i?ke/Ze:Me}}}}return _}const Kme={kernelName:Uy,backendName:"cpu",kernelFunc:function qme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Te(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r;S(Nr(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=Ai(s.shape,i,o,1,a,l);let d;if(1===u.filterWidth&&1===u.filterHeight&&It(u.inShape,u.outShape))d=Wo({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,f=Le(s.shape),p=JT(h,0,s.dtype,f,u,"avg");d=e.makeTensorInfo(u.outShape,s.dtype,p.values)}return d}},Yme={kernelName:Hy,backendName:"cpu",kernelFunc:function Xme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r;Te(s,"avgPool3d");const u=ya(s.shape,i,o,1,a,l,c),h=A3(e.data.get(s.dataId).values,0,s.dtype,Le(s.shape),u,"avg");return e.makeTensorInfo(h.shape,"float32",h.values)}},Qme={kernelName:RS,backendName:"cpu",kernelFunc:function Zme(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;Te([s,i],"avgPool3DGrad");const u=ya(i.shape,o,a,1,l,c),d=u.strideDepth,h=u.strideHeight,f=u.strideWidth,p=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,_=u.dilationWidth,v=u.effectiveFilterDepth,w=u.effectiveFilterHeight,C=u.effectiveFilterWidth,I=v-1-u.padInfo.front,D=C-1-u.padInfo.left,T=w-1-u.padInfo.top,N=ot(i.shape,"float32"),$=1/(p*m*g),z=e.bufferSync(s);for(let j=0;j<u.batchSize;++j)for(let q=0;q<u.inChannels;++q)for(let K=0;K<u.inDepth;++K)for(let P=0;P<u.inHeight;++P)for(let B=0;B<u.inWidth;++B){const L=K-I,W=P-T,ne=B-D;let ie=0;for(let de=0;de<v;de+=y){const ue=(L+de)/d;if(!(ue<0||ue>=u.outDepth||Math.floor(ue)!==ue))for(let he=0;he<w;he+=b){const ge=(W+he)/h;if(!(ge<0||ge>=u.outHeight||Math.floor(ge)!==ge))for(let Ee=0;Ee<C;Ee+=_){const _e=(ne+Ee)/f;_e<0||_e>=u.outWidth||Math.floor(_e)!==_e||(ie+=z.get(j,ue,ge,_e,q))}}}N.set(ie*$,j,K,P,B,q)}return e.makeTensorInfo(N.shape,N.dtype,N.values)}},ege={kernelName:AS,backendName:"cpu",kernelFunc:function Jme(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i;Te([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=Ai(o.shape,a,l,1,c),d=u.strideHeight,h=u.strideWidth,f=u.filterHeight,p=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,_=b-1-u.padInfo.left,v=y-1-u.padInfo.top,w=ot(o.shape,"float32"),C=1/(f*p),I=e.data.get(s.dataId).values,D=ot(s.shape,"float32",I);for(let T=0;T<u.batchSize;++T)for(let N=0;N<u.inChannels;++N)for(let $=0;$<u.inHeight;++$)for(let z=0;z<u.inWidth;++z){const j=$-v,q=z-_;let K=0;for(let P=0;P<y;P+=m){const B=(j+P)/d;if(!(B<0||B>=u.outHeight||Math.floor(B)!==B))for(let L=0;L<b;L+=g){const W=(q+L)/h;W<0||W>=u.outWidth||Math.floor(W)!==W||(K+=D.get(T,B,W,N))}}w.set(K*C,T,$,z,N)}return e.makeTensorInfo(w.shape,w.dtype,w.values)}},nge={kernelName:nb,backendName:"cpu",kernelFunc:function tge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,scale:i,offset:o,mean:a,variance:l}=t;S(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Te([s,a,l,i,o],"batchNorm");let{varianceEpsilon:c}=r;null==c&&(c=.001);const u=e.data.get(s.dataId).values,d=e.data.get(a.dataId).values,h=e.data.get(l.dataId).values,f=i?e.data.get(i.dataId).values:new Float32Array([1]),p=o?e.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=p.length,y=f.length,b=h.length,_=d.length;let v=0,w=0,C=0,I=0;for(let D=0;D<u.length;++D)m[D]=p[v++]+(u[D]-d[w++])*f[C++]/Math.sqrt(h[I++]+c),v>=g&&(v=0),w>=_&&(w=0),C>=y&&(C=0),I>=b&&(I=0);return e.makeTensorInfo(s.shape,s.dtype,m)}};function R3(n,t,e,r,s){const i=gI(r,t,e),o=X(e),a=Le(r);if(i){const d=yI(t,a);return"string"===s?n.slice(d,d+o):n.subarray(d,d+o)}const c=ot(r,s,"string"===s?xc(n):n),u=ot(e,s);for(let d=0;d<u.size;++d){const h=u.indexToLoc(d),f=h.map((p,m)=>p+t[m]);u.set(c.get(...f),...h)}return"string"===s?gV(u.values):u.values}function Nc(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,size:o}=r;Te(s,"slice");const[a,l]=t_(s,i,o);pI(s,a,l);const u=R3(e.data.get(s.dataId).values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,u)}const rge={kernelName:Ab,backendName:"cpu",kernelFunc:Nc},ige={kernelName:jy,backendName:"cpu",kernelFunc:function sge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,crops:o}=r;Te([s],"batchToSpaceND");const a=i.reduce((y,b)=>y*b),l=Vp(s.shape,i,a),c=zp(l.length,i.length),u=Up(s.shape,i,a),d=CD(o,i.length),h=SD(u,o,i.length),f=on({inputs:{x:s},backend:e,attrs:{shape:l}}),p=vs({inputs:{x:f},backend:e,attrs:{perm:c}}),m=on({inputs:{x:p},backend:e,attrs:{shape:u}}),g=Nc({inputs:{x:m},backend:e,attrs:{begin:d,size:h}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),g}};function e1(n,t,e,r,s){const i=X(r),o=Br(s,e);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(o[l]+=i>0?t[a]:1)}return o}function M3(n,t,e,r=!1){const s=n.shape[0],i=n.shape[1],o=ot([s,e],t.dtype);for(let a=0;a<s;a++)for(let l=0;l<i;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=e||o.set(r?1:t.size>0?o.get(a,c)+t.get(a,l):o.get(a,c)+1,a,c)}return o}const age={kernelName:MS,backendName:"cpu",kernelFunc:function oge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o}=r,c=e1(e.data.get(s.dataId).values,e.data.get(i.dataId).values,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,c)}},cge={kernelName:FS,backendName:"cpu",kernelFunc:function lge(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,i=e.data.get(r.dataId).values,o=e.data.get(s.dataId).values,a=et(Array.from(i),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},F3=_l(n=>Math.ceil(n)),uge=Td(Mf,F3),dge={kernelName:Mf,backendName:"cpu",kernelFunc:uge},hge=qt(Ff,(n,t)=>n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n),fge={kernelName:Ff,backendName:"cpu",kernelFunc:hge},pge={kernelName:Gy,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend,r=new Float32Array(X(t.shape)),s=e.data.get(t.dataId),o=s.complexTensorInfos.imag,a=e.data.get(s.complexTensorInfos.real.dataId).values,l=e.data.get(o.dataId).values;for(let c=0;c<a.length;c++)r[c]=Math.hypot(a[c],l[c]);return e.makeOutput(r,t.shape,"float32")}};function O3(n,t,e,r){const s=Kn(e,X(t));if(r&&"string"!==e){let i=0;n.forEach(o=>{const a=X(o.shape);s.set(o.vals,i),i+=a})}else{let i=0;n.forEach(o=>{const a="string"===e?xc(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const u=c*t[1]+i;for(let d=0;d<o.shape[1];++d)s[u+d]=a[l++]}i+=o.shape[1]})}return s}function Nd(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.imag,i=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,i)}const mge={kernelName:tE,backendName:"cpu",kernelFunc:Nd};function Ad(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,i=ft(s,t[0].shape)[0];vD(t.map(m=>m.shape),i);let a=$o(t.map(m=>m.shape),i);if(0===X(a))return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(m=>X(m.shape)>0);if(1===l.length)return Wo({inputs:{x:l[0]},backend:e});if("complex64"===l[0].dtype){const m=l.map(v=>kc({inputs:{input:v},backend:e})),g=l.map(v=>Nd({inputs:{input:v},backend:e})),y=Ad({inputs:m,backend:e,attrs:{axis:i}}),b=Ad({inputs:g,backend:e,attrs:{axis:i}}),_=Bs({inputs:{real:y,imag:b},backend:e});return m.forEach(v=>e.disposeIntermediateTensorInfo(v)),g.forEach(v=>e.disposeIntermediateTensorInfo(v)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),_}const c=l.map(m=>{const y=[-1,X(m.shape.slice(i))];return on({inputs:{x:m},backend:e,attrs:{shape:y}})}),u=c.map(m=>({vals:e.data.get(m.dataId).values,shape:m.shape}));a=$o(c.map(m=>m.shape),1);const h=O3(u,a,t[0].dtype,1===c[0].shape[0]),f=$o(l.map(m=>m.shape),i),p=e.makeTensorInfo(f,t[0].dtype,h);return c.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}const gge={kernelName:qy,backendName:"cpu",kernelFunc:Ad};function P3(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r;Te([s,i],"conv2d");const d=ba(l),h=wr(s.shape,i.shape,o,c,a,u,!1,d),f=h.filterHeight,p=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,_="channelsLast"===h.dataFormat,v=new vr(h.outShape,s.dtype),w=Le(s.shape),C=Le(i.shape),I=w[0],D=_?w[1]:w[2],T=_?w[2]:1,N=_?1:w[1],$=v.strides[0],z=_?v.strides[1]:v.strides[2],j=_?v.strides[2]:1,q=_?1:v.strides[1],K=e.data.get(s.dataId).values,P=e.data.get(i.dataId).values,B=v.values;for(let L=0;L<h.batchSize;++L){const W=L*I,ne=L*$;for(let ie=0;ie<h.outHeight;++ie){const de=ne+ie*z,ue=ie*h.strideHeight-b;for(let he=0;he<f;++he){const ge=ue+he*m;if(ge<0||ge>=h.inHeight)continue;const Ee=he*C[0],_e=W+ge*D;for(let Me=0;Me<h.outWidth;++Me){const ke=de+Me*j,Ze=Me*h.strideWidth-y;for(let at=0;at<p;++at){const Kt=Ze+at*g;if(Kt<0||Kt>=h.inWidth)continue;const mn=_e+Kt*T;let wn=Ee+at*C[1];for(let Yt=0;Yt<h.inChannels;++Yt){const Mn=K[mn+Yt*N];for(let Hn=0;Hn<h.outChannels;++Hn)B[ke+Hn*q]+=Mn*P[wn+Hn];wn+=h.outChannels}}}}}}return e.makeTensorInfo(v.shape,v.dtype,B)}const yge={kernelName:Ky,backendName:"cpu",kernelFunc:P3},_ge={kernelName:PS,backendName:"cpu",kernelFunc:function bge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r;Te([s,i],"conv2dBackpropFilter");const d=ba(l),h=wr(s.shape,u,o,1,a,c,!1,d),{strideHeight:f,strideWidth:p,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,b=new vr(h.filterShape,"float32"),_=h.padInfo.left,v=h.padInfo.top,w=e.data.get(s.dataId).values,C=e.data.get(i.dataId).values,I=new vr(s.shape,s.dtype,w),D=new vr(i.shape,i.dtype,C);for(let T=0;T<m;++T){const N=Math.max(0,Math.ceil((v-T)/f)),$=Math.min(h.outHeight,(h.inHeight+v-T)/f);for(let z=0;z<g;++z){const j=Math.max(0,Math.ceil((_-z)/p)),q=Math.min(h.outWidth,(h.inWidth+_-z)/p);for(let K=0;K<h.inChannels;++K)for(let P=0;P<h.outChannels;++P){let B=0;for(let L=0;L<h.batchSize;++L)for(let W=N;W<$;++W){const ne=T+W*f-v;for(let ie=j;ie<q;++ie){const de=z+ie*p-_;B+=y?I.get(L,ne,de,K)*D.get(L,W,ie,P):I.get(L,K,ne,de)*D.get(L,P,W,ie)}}b.set(B,T,z,K,P)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},xge={kernelName:Xy,backendName:"cpu",kernelFunc:function vge(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r;Te([s,i],"conv2dBackpropInput");const d=Le(i.shape),h=Le(s.shape);let f=ba(c);const p=wr(o,i.shape,a,1,l,u,!1,f),m=new vr(p.inShape,"float32"),g=m.values,y=e.data.get(s.dataId).values,b=e.data.get(i.dataId).values,[_,v,w]=d,{batchSize:C,filterHeight:I,filterWidth:D,inChannels:T,inHeight:N,inWidth:$,outChannels:z,outHeight:j,outWidth:q,strideHeight:K,strideWidth:P}=p;f=p.dataFormat;const B=I-1-p.padInfo.top,L=D-1-p.padInfo.left,W="channelsLast"===f,ne=m.strides[0],ie=W?m.strides[1]:m.strides[2],de=W?m.strides[2]:1,ue=W?1:m.strides[1],he=h[0],ge=W?h[1]:h[2],Ee=W?h[2]:1,_e=W?1:h[1];for(let Me=0;Me<C;++Me)for(let ke=0;ke<T;++ke)for(let Ze=0;Ze<N;++Ze){const at=Ze-B,Kt=Math.max(0,Math.ceil(at/K)),ln=Math.min(j,(I+at)/K);for(let mn=0;mn<$;++mn){const wn=mn-L,Yt=Math.max(0,Math.ceil(wn/P)),Mn=Math.min(q,(D+wn)/P);let Hn=0;for(let Mr=Kt;Mr<ln;++Mr){const Rl=Mr*K-at;for(let bi=Yt;bi<Mn;++bi){const yo=he*Me+ge*Mr+Ee*bi,Ma=_*(I-1-Rl)+v*(D-1-(bi*P-wn))+w*ke;for(let Ml=0;Ml<z;++Ml)Hn+=y[yo+_e*Ml]*b[Ma+Ml]}}g[ne*Me+ie*Ze+de*mn+ue*ke]=Hn}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}},Cge={kernelName:Yy,backendName:"cpu",kernelFunc:function wge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l}=r;Te([s,i],"conv3d");const c=sl(s.shape,i.shape,o,l,a),{filterDepth:u,filterHeight:d,filterWidth:h,dilationDepth:f,dilationHeight:p,dilationWidth:m,padInfo:g}=c,y=g.front,b=g.left,_=g.top,v=new vr(c.outShape,s.dtype),w=e.data.get(s.dataId).values,C=e.data.get(i.dataId).values,I=v.values,D=Le(s.shape),T=Le(i.shape);for(let N=0;N<c.batchSize;++N){const $=N*D[0],z=N*v.strides[0];for(let j=0;j<c.outDepth;++j){const q=z+j*v.strides[1],K=j*c.strideDepth-y;for(let P=0;P<u;++P){const B=K+P*f;if(B<0||B>=c.inDepth)continue;const L=P*T[0],W=$+B*D[1];for(let ne=0;ne<c.outHeight;++ne){const ie=q+ne*v.strides[2],de=ne*c.strideHeight-_;for(let ue=0;ue<d;++ue){const he=de+ue*p;if(he<0||he>=c.inHeight)continue;const ge=L+ue*T[1],Ee=W+he*D[2];for(let _e=0;_e<c.outWidth;++_e){const Me=ie+_e*c.outChannels,ke=_e*c.strideWidth-b;for(let Ze=0;Ze<h;++Ze){const at=ke+Ze*m;if(at<0||at>=c.inWidth)continue;const ln=Ee+at*c.inChannels;let mn=ge+Ze*T[2];for(let wn=0;wn<c.inChannels;++wn){const Yt=w[ln+wn];for(let Mn=0;Mn<c.outChannels;++Mn)I[Me+Mn]+=Yt*C[mn+Mn];mn+=c.outChannels}}}}}}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}},Ege={kernelName:$S,backendName:"cpu",kernelFunc:function Sge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,filterShape:l}=r;Te([s,i],"conv3dBackpropFilterV2");const c=Le(s.shape),u=Le(i.shape),d=sl(s.shape,l,o,1,a),h=d.strideDepth,f=d.strideHeight,p=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new vr(d.filterShape,"float32"),_=b.values,[v,w,C,I]=b.strides,D=e.data.get(i.dataId).values,[T,N,$,z]=u,j=e.data.get(s.dataId).values,[q,K,P,B]=c,L=d.padInfo.front,W=d.padInfo.left,ne=d.padInfo.top;for(let ie=0;ie<m;++ie){const de=Math.max(0,Math.ceil((L-ie)/h)),ue=Math.min(d.outDepth,(d.inDepth+L-ie)/h),he=ie*v;for(let ge=0;ge<g;++ge){const Ee=Math.max(0,Math.ceil((ne-ge)/f)),_e=Math.min(d.outHeight,(d.inHeight+ne-ge)/f),Me=ge*w+he;for(let ke=0;ke<y;++ke){const Ze=Math.max(0,Math.ceil((W-ke)/p)),at=Math.min(d.outWidth,(d.inWidth+W-ke)/p),Kt=ke*C+Me;for(let ln=0;ln<d.inChannels;++ln){const mn=ln*I+Kt;for(let wn=0;wn<d.outChannels;++wn){let Yt=0;for(let Mn=0;Mn<d.batchSize;++Mn){const Hn=Mn*q,Ra=Mn*T;for(let Mr=de;Mr<ue;++Mr){const bi=(ie+Mr*h-L)*K+Hn,jc=Mr*N+Ra;for(let yo=Ee;yo<_e;++yo){const Ml=(ge+yo*f-ne)*P+bi,Fl=yo*$+jc;for(let Ol=Ze;Ol<at;++Ol)Yt+=j[(ke+Ol*p-W)*B+Ml+ln]*D[Ol*z+Fl+wn]}}}_[mn+wn]=Yt}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},Dge={kernelName:LS,backendName:"cpu",kernelFunc:function Ige(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{pad:o,strides:a,inputShape:l}=r;Te([s],"conv3dBackpropInputV2");const c=Le(s.shape),u=Le(i.shape),d=sl(l,i.shape,a,1,o),h=new vr(d.inShape,"float32"),f=h.values,[p,m,g,y]=h.strides,b=e.data.get(s.dataId).values,[_,v,w,C]=c,I=e.data.get(i.dataId).values,[D,T,N,$]=u,{batchSize:z,filterDepth:j,filterHeight:q,filterWidth:K,inChannels:P,inDepth:B,inHeight:L,inWidth:W,outChannels:ne,outDepth:ie,outHeight:de,outWidth:ue,strideDepth:he,strideHeight:ge,strideWidth:Ee}=d,_e=j-1-d.padInfo.front,Me=q-1-d.padInfo.top,ke=K-1-d.padInfo.left;for(let Ze=0;Ze<z;++Ze)for(let at=0;at<P;++at)for(let Kt=0;Kt<B;++Kt){const ln=Kt-_e,mn=Math.max(0,Math.ceil(ln/he)),wn=Math.min(ie,(j+ln)/he);for(let Yt=0;Yt<L;++Yt){const Mn=Yt-Me,Hn=Math.max(0,Math.ceil(Mn/ge)),Ra=Math.min(de,(q+Mn)/ge);for(let Mr=0;Mr<W;++Mr){const Rl=Mr-ke,bi=Math.max(0,Math.ceil(Rl/Ee)),jc=Math.min(ue,(K+Rl)/Ee);let yo=0;for(let Ma=mn;Ma<wn;++Ma){const Ml=Ma*he-ln;for(let Fl=Hn;Fl<Ra;++Fl){const Ol=Fl*ge-Mn;for(let Pm=bi;Pm<jc;++Pm){const tN=_*Ze+v*Ma+w*Fl+C*Pm,pPe=D*(j-1-Ml)+T*(q-1-Ol)+N*(K-1-(Pm*Ee-Rl))+$*at;for(let Ex=0;Ex<ne;++Ex)yo+=b[tN+Ex]*I[pPe+Ex]}}}f[p*Ze+m*Kt+g*Yt+y*Mr+at]=yo}}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}},Tge=qt(Of,n=>Math.cos(n)),kge={kernelName:Of,backendName:"cpu",kernelFunc:Tge},Nge=qt(Pf,n=>Math.cosh(n)),Age={kernelName:Pf,backendName:"cpu",kernelFunc:Nge},Mge={kernelName:VS,backendName:"cpu",kernelFunc:function Rge(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:i,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:c}=r,[u,d,h,f]=s.shape,p=i.shape[0],[m,g]=a,y=ot([p,m,g,f],"float32"),b=e.data.get(i.dataId).values,_=e.data.get(o.dataId).values,v=e.data.get(s.dataId).values,w=Le(s.shape),C=Le(y.shape);for(let I=0;I<p;I++){const D=4*I,T=b[D],N=b[D+1],$=b[D+2],z=b[D+3],j=_[I];if(j>=u)continue;const q=m>1?($-T)*(d-1)/(m-1):0,K=g>1?(z-N)*(h-1)/(g-1):0;for(let P=0;P<m;P++){const B=m>1?T*(d-1)+P*q:.5*(T+$)*(d-1);if(B<0||B>d-1)for(let L=0;L<g;L++)for(let W=0;W<f;W++)y.values[W+L*C[2]+P*C[1]+I*C[0]]=c;else if("bilinear"===l){const L=Math.floor(B),W=Math.ceil(B),ne=B-L;for(let ie=0;ie<g;ie++){const de=g>1?N*(h-1)+ie*K:.5*(N+z)*(h-1);if(de<0||de>h-1){for(let Ee=0;Ee<f;Ee++)y.values[Ee+ie*C[2]+P*C[1]+I*C[0]]=c;continue}const ue=Math.floor(de),he=Math.ceil(de),ge=de-ue;for(let Ee=0;Ee<f;Ee++){let _e=Ee+ue*w[2]+L*w[1]+j*w[0];const Me=v[_e];_e=Ee+he*w[2]+L*w[1]+j*w[0];const ke=v[_e];_e=Ee+ue*w[2]+W*w[1]+j*w[0];const Ze=v[_e];_e=Ee+he*w[2]+W*w[1]+j*w[0];const at=v[_e],Kt=Me+(ke-Me)*ge;_e=Ee+ie*C[2]+P*C[1]+I*C[0],y.values[_e]=Kt+(Ze+(at-Ze)*ge-Kt)*ne}}}else for(let L=0;L<g;++L){const W=g>1?N*(h-1)+L*K:.5*(N+z)*(h-1);if(W<0||W>h-1){for(let de=0;de<f;de++)y.values[de+L*C[2]+P*C[1]+I*C[0]]=c;continue}const ne=Math.round(W),ie=Math.round(B);for(let de=0;de<f;de++)y.values[de+L*C[2]+P*C[1]+I*C[0]]=v[de+ne*w[2]+ie*w[1]+j*w[0]]}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},Oge={kernelName:BS,backendName:"cpu",kernelFunc:function Fge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;Te(s,"cumprod");const l=Dn([i],s.shape.length);let c=s;null!=l&&(c=vs({inputs:{x:s},backend:e,attrs:{perm:l}}));const u=zn(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const d=Fs(c.dtype,"int32"),h=IS(X(c.shape),d),f=e.data.get(c.dataId).values,p=c.shape[c.shape.length-1],m=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=p)for(let b=0;b<p;b++){const _=m(y,b);if(0===b)h[_]=o?1:f[_];else{const v=m(y,b-1);h[_]=o?f[v]*h[v]:f[_]*h[v]}}const g=e.makeTensorInfo(c.shape,d,h);if(null!=l){const b=vs({inputs:{x:g},backend:e,attrs:{perm:al(l)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(c),b}return g}},$ge={kernelName:Zy,backendName:"cpu",kernelFunc:function Pge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;Te(s,"cumsum");const l=Dn([i],s.shape.length);let c=s;null!=l&&(c=vs({inputs:{x:s},backend:e,attrs:{perm:l}}));const u=zn(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const d=Fs(c.dtype,"int32"),h=Br(X(c.shape),d),f=e.data.get(c.dataId).values,p=c.shape[c.shape.length-1],m=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=p)for(let b=0;b<p;b++){const _=m(y,b);if(0===b)h[_]=o?0:f[_];else{const v=m(y,b-1);h[_]=o?f[v]+h[v]:f[_]+h[v]}}const g=e.makeTensorInfo(c.shape,d,h);if(null!=l){const b=vs({inputs:{x:g},backend:e,attrs:{perm:al(l)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(c),b}return g}},Bge={kernelName:zS,backendName:"cpu",kernelFunc:function Lge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o,binaryOutput:a}=r;if(1===s.shape.length){const u=e1(e.data.get(s.dataId).values,e.data.get(i.dataId).values,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,u)}if(2===s.shape.length){const u=M3(e.bufferSync(s),e.bufferSync(i),o,a);return e.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},zge={kernelName:US,backendName:"cpu",kernelFunc:function Vge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:i,dataFormat:o}=r;S("NHWC"===o,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=s.shape[0],l=s.shape[1],c=s.shape[2],u=s.shape[3],d=l*i,h=c*i,f=u/(i*i),p=e.data.get(s.dataId).values,m=new Float32Array(a*d*h*f);let g=0;for(let y=0;y<a;++y)for(let b=0;b<d;++b){const _=Math.floor(b/i),v=b%i;for(let w=0;w<h;++w){const C=Math.floor(w/i),D=(v*i+w%i)*f;for(let T=0;T<f;++T)m[g++]=p[T+D+u*(C+c*(_+l*y))]}}return e.makeTensorInfo([a,d,h,f],s.dtype,m)}};function $3(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;Te([s,i],"depthwiseConv2DNative");const u=Le(s.shape),d=Le(i.shape);let h=l;null==h&&(h=[1,1]),S(Nr(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const f=wr(s.shape,i.shape,o,h,a,c,!0),{filterHeight:p,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=f,_=b.left,v=b.top,w=f.outChannels/f.inChannels,C=new vr(f.outShape,s.dtype),I=e.data.get(s.dataId).values,D=e.data.get(i.dataId).values,T=C.values;for(let N=0;N<f.batchSize;++N){const $=N*u[0],z=N*C.strides[0];for(let j=0;j<f.outHeight;++j){const q=z+j*C.strides[1],K=j*f.strideHeight-v;for(let P=0;P<p;++P){const B=K+P*g;if(B<0||B>=f.inHeight)continue;const L=P*d[0],W=$+B*u[1];for(let ne=0;ne<f.outWidth;++ne){const ie=q+ne*C.strides[2],de=ne*f.strideWidth-_;for(let ue=0;ue<m;++ue){const he=de+ue*y;if(he<0||he>=f.inWidth)continue;const Ee=W+he*f.inChannels;let _e=ie,Me=L+ue*d[1];for(let ke=0;ke<f.inChannels;++ke){const Ze=I[Ee+ke];for(let at=0;at<w;++at)T[_e+at]+=Ze*D[Me+at];_e+=w,Me+=w}}}}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}const Uge={kernelName:Qy,backendName:"cpu",kernelFunc:$3},Wge={kernelName:HS,backendName:"cpu",kernelFunc:function Hge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r;Te([s,i],"depthwiseConv2dNativeBackpropFilter");const d=wr(s.shape,u,o,a,l,c,!0),{strideHeight:h,strideWidth:f,filterHeight:p,filterWidth:m}=d,g=new vr(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,_=d.outChannels/d.inChannels,v=e.data.get(s.dataId).values,w=new vr(s.shape,s.dtype,v),C=e.data.get(i.dataId).values,I=new vr(i.shape,i.dtype,C);for(let D=0;D<p;++D){const T=Math.max(0,Math.ceil((b-D)/h)),N=Math.min(d.outHeight,(d.inHeight+b-D)/h);for(let $=0;$<m;++$){const z=Math.max(0,Math.ceil((y-$)/f)),j=Math.min(d.outWidth,(d.inWidth+y-$)/f);for(let q=0;q<d.outChannels;++q){const K=Math.trunc(q/_),P=q%_;let B=0;for(let L=0;L<d.batchSize;++L)for(let W=T;W<N;++W){const ne=D+W*h-b;for(let ie=z;ie<j;++ie)B+=w.get(L,ne,$+ie*f-y,K)*I.get(L,W,ie,q)}g.set(B,D,$,K,P)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}},Gge={kernelName:WS,backendName:"cpu",kernelFunc:function jge(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r;Te([s,i],"depthwiseConv2DNativeBackpropInput");const d=Le(s.shape),h=Le(i.shape),f=wr(u,i.shape,o,a,l,c,!0),p=new vr(f.inShape,"float32"),m=p.values,[g,y,b]=p.strides,_=e.data.get(s.dataId).values,[v,w,C]=d,I=e.data.get(i.dataId).values,[D,T,N]=h,{batchSize:$,filterHeight:z,filterWidth:j,inChannels:q,inHeight:K,inWidth:P,outChannels:B,outHeight:L,outWidth:W,strideHeight:ne,strideWidth:ie}=f,de=z-1-f.padInfo.top,ue=j-1-f.padInfo.left,he=B/q;for(let ge=0;ge<$;++ge)for(let Ee=0;Ee<q;++Ee)for(let _e=0;_e<K;++_e){const Me=_e-de,ke=Math.max(0,Math.ceil(Me/ne)),Ze=Math.min(L,(z+Me)/ne);for(let at=0;at<P;++at){const Kt=at-ue,ln=Math.max(0,Math.ceil(Kt/ie)),mn=Math.min(W,(j+Kt)/ie);let wn=0;for(let Yt=ke;Yt<Ze;++Yt){const Mn=Yt*ne-Me;for(let Hn=ln;Hn<mn;++Hn){const Mr=v*ge+w*Yt+C*Hn,Rl=D*(z-1-Mn)+T*(j-1-(Hn*ie-Kt))+N*Ee;for(let bi=0;bi<he;++bi)wn+=_[Mr+(Ee*he+bi)]*I[Rl+bi]}}m[g*ge+y*_e+b*at+Ee]=wn}}return e.makeTensorInfo(p.shape,p.dtype,p.values)}},Kge={kernelName:jS,backendName:"cpu",kernelFunc:function qge(n){const{inputs:t,backend:e}=n,{x:r}=t,s=X(r.shape),i=e.data.get(r.dataId).values,o=ot([s,s],r.dtype),a=o.values;for(let c=0;c<i.length;c++)a[c*s+c]=i[c];const l=[...r.shape,...r.shape];return e.makeTensorInfo(l,o.dtype,o.values)}},Xge={kernelName:Jy,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s}=n,{strides:i,pad:o,dilations:a}=e,l=t,c=l.data.get(r.dataId).values,u=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:f,inHeight:p,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:_,strideHeight:v,strideWidth:w,filterHeight:C,filterWidth:I,dilationHeight:D,dilationWidth:T,outShape:N}=Ep(r.shape,s.shape,i,o,"NHWC",a),$=X(N),z=N.length,j=Kn(r.dtype,$);for(let K=0;K<f;++K)for(let P=0;P<y;++P){const B=P*v-_.top;for(let L=0;L<b;++L){const W=L*w-_.left;for(let ne=0;ne<g;++ne){let ie=Number.MIN_SAFE_INTEGER;for(let ue=0;ue<C;++ue){const he=B+ue*D;if(he>=0&&he<p)for(let ge=0;ge<I;++ge){const Ee=W+ge*T;if(Ee>=0&&Ee<m){const _e=Ao([K,he,Ee,ne],u,Le(r.shape)),Me=Ao([ue,ge,ne],h,Le(s.shape)),ke=c[_e]+d[Me];ke>ie&&(ie=ke)}}}j[Ao([K,P,L,ne],z,Le(N))]=ie}}}return{dataId:l.write(fc(j,r.dtype),N,r.dtype),shape:N,dtype:r.dtype}}},Yge={kernelName:qS,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:l}=e,c=t,u=ki(r.shape,c.data.get(r.dataId).values),d=ki(s.shape,c.data.get(s.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:_,strideWidth:v,filterHeight:w,filterWidth:C,dilationHeight:I,dilationWidth:D,outShape:T}=Ep(r.shape,s.shape,o,a,"NHWC",l);S(i.rank===T.length,()=>`Error in ${qS}, dy must have the same rank as output ${T.length}, but got ${i.rank}`);const N=ki(T,c.data.get(i.dataId).values),$=M$(s.shape,s.dtype);for(let j=0;j<h;++j)for(let q=0;q<g;++q){const K=q*_-b.top;for(let P=0;P<y;++P){const B=P*v-b.left;for(let L=0;L<m;++L){let W=Number.MIN_SAFE_INTEGER,ne=0,ie=0;for(let de=0;de<w;++de){const ue=K+de*I;if(ue>=0&&ue<f)for(let he=0;he<C;++he){const ge=B+he*D;if(ge>=0&&ge<p){const Ee=u[j][ue][ge][L]+d[de][he][L];Ee>W&&(W=Ee,ne=de,ie=he)}}}$[ne][ie][L]+=N[j][q][P][L]}}}return{dataId:c.write(fc($,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},Zge={kernelName:GS,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:l}=e,c=t,u=ki(r.shape,c.data.get(r.dataId).values),d=ki(s.shape,c.data.get(s.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:_,strideWidth:v,filterHeight:w,filterWidth:C,dilationHeight:I,dilationWidth:D,outShape:T}=Ep(r.shape,s.shape,o,a,"NHWC",l);S(i.rank===T.length,()=>`Error in ${GS}, dy must have the same rank as output ${T.length}, but got ${i.rank}`);const N=ki(T,c.data.get(i.dataId).values),$=M$(r.shape,r.dtype);for(let j=0;j<h;++j)for(let q=0;q<g;++q){const K=q*_-b.top;for(let P=0;P<y;++P){const B=P*v-b.left;for(let L=0;L<m;++L){let W=Number.MIN_SAFE_INTEGER,ne=K<0?0:K,ie=B<0?0:B;for(let de=0;de<w;++de){const ue=K+de*I;if(ue>=0&&ue<f)for(let he=0;he<C;++he){const ge=B+he*D;if(ge>=0&&ge<p){const Ee=u[j][ue][ge][L]+d[de][he][L];Ee>W&&(W=Ee,ne=ue,ie=ge)}}}$[j][ne][ie][L]+=N[j][q][P][L]}}}return{dataId:c.write(fc($,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},t1=Yn((n,t)=>n*t),Qge=ZT((n,t,e,r)=>({real:n*e-t*r,imag:n*r+t*e})),uv=Er(ep,t1,Qge),Jge={kernelName:ep,backendName:"cpu",kernelFunc:uv};function sm(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;let a;Te(s,"sum"),a="bool"===s.dtype?vl({inputs:{x:s},backend:e,attrs:{dtype:"int32"}}):Wo({inputs:{x:s},backend:e});const l=a.shape.length,c=ft(i,a.shape),u=Dn(c,l);let d=c,h=a;null!=u&&(h=vs({inputs:{x:a},backend:e,attrs:{perm:u}}),d=zn(d.length,l)),Ar("sum",d,h.shape.length);const[f,p]=Cr(h.shape,d);let g=cv(e,f,Fs(h.dtype,"int32"));const y=X(p),b=e.data.get(g.dataId).values,_=e.data.get(h.dataId).values;for(let v=0;v<b.length;++v){const w=v*y;let C=0;for(let I=0;I<y;++I)C+=_[w+I];b[v]=C}if(o){const w=g;g=on({inputs:{x:g},backend:e,attrs:{shape:Vn(g.shape,c)}}),e.disposeIntermediateTensorInfo(w)}return e.disposeIntermediateTensorInfo(a),null!=u&&e.disposeIntermediateTensorInfo(h),g}const eye={kernelName:Rb,backendName:"cpu",kernelFunc:sm},nye={kernelName:KS,backendName:"cpu",kernelFunc:function tye(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,i=t,{allDims:o,summedDims:a,idDims:l}=FD(s,i.length);PD(o.length,l,i);const{path:c,steps:u}=$D(a,l),d=u.length;let h=null,f=o.length;const p=[];for(let m=0;m<d;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=OD(f,l[g]);let _;LD(y)?_=i[g]:(_=vs({inputs:{x:i[g]},backend:e,attrs:{perm:y}}),p.push(_));const v=_.shape.slice();for(let w=0;w<b.length;++w)v.splice(b[w],0,1);It(_.shape,v)||(_=on({inputs:{x:_},backend:e,attrs:{shape:v}}),p.push(_)),null===h?h=_:(h=uv({inputs:{a:_,b:h},backend:e}),p.push(h))}m<d-1&&(c[m]>=0&&(h=sm({inputs:{x:h},backend:e,attrs:{axis:c[m]-(o.length-f),keepDims:!1}}),p.push(h)),f--)}for(const m of p)m!==h&&e.disposeIntermediateTensorInfo(m);return h}},sye={kernelName:XS,backendName:"cpu",kernelFunc:function rye(n){const{inputs:t,backend:e}=n,{dy:r,y:s}=t;Te([r,s],"eluGrad");const i=new Float32Array(X(s.shape)),o=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values;for(let l=0;l<o.length;++l){const c=o[l];i[l]=c>=1?a[l]:a[l]*(c+1)}return e.makeTensorInfo(s.shape,"float32",i)}},L3=Yn((n,t)=>n===t?1:0),B3=Er(eb,L3,null,"bool"),iye={kernelName:eb,backendName:"cpu",kernelFunc:B3},oye=ID,aye=DD,lye=TD,cye=kD,uye=ND,dye=AD,hye=qt(Bf,n=>{const t=Math.sign(n),e=Math.abs(n),r=1/(1+oye*e);return t*(1-((((dye*r+uye)*r+cye)*r+lye)*r+aye)*r*Math.exp(-e*e))}),fye={kernelName:Bf,backendName:"cpu",kernelFunc:hye},V3=_l(n=>Math.exp(n)),z3=Td(Vf,V3,"float32"),pye={kernelName:Vf,backendName:"cpu",kernelFunc:z3};function dv(n){const{inputs:t,backend:e,attrs:r}=n,{input:s}=t,{dim:i}=r,o=s.shape.length,a=s.shape.slice();let l=i;return i<0&&(S(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),on({inputs:{x:s},backend:e,attrs:{shape:a}})}const mye={kernelName:tb,backendName:"cpu",kernelFunc:dv},U3=_l(n=>Math.expm1(n)),gye=Td(zf,U3),yye={kernelName:zf,backendName:"cpu",kernelFunc:gye},bye=Yn((n,t)=>n/t),n1=Er($f,bye),r1={kernelName:$f,backendName:"cpu",kernelFunc:n1},H3=Yn((n,t)=>n-t),_ye=ZT((n,t,e,r)=>({real:n-e,imag:t-r})),s1=Er(mp,H3,_ye),vye={kernelName:mp,backendName:"cpu",kernelFunc:s1};function W3(n,t,e){const r=n.shape,s=r[0],i=r[1],o=e.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[s,i],u=X(c),d=br("float32",u),h=br("float32",u);for(let g=0;g<s;g++){const y=Nc({inputs:{x:a},backend:e,attrs:{begin:[g,0],size:[1,i]}}),b=Nc({inputs:{x:l},backend:e,attrs:{begin:[g,0],size:[1,i]}}),_=Bs({inputs:{real:y,imag:b},backend:e}),{real:v,imag:w}=xye(_,t,e),C=wa(v,w);for(let I=0;I<i;I++){const D=RD(C,I);d[g*i+I]=D.real,h[g*i+I]=D.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(_)}const f=e.makeTensorInfo(c,"float32",d),p=e.makeTensorInfo(c,"float32",h),m=Bs({inputs:{real:f,imag:p},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),m}function xye(n,t,e){const r=X(n.shape),s=e.data.get(n.dataId),i=e.data.get(s.complexTensorInfos.real.dataId).values,o=e.data.get(s.complexTensorInfos.imag.dataId).values;if(function wye(n){return 0==(n&n-1)}(r)){const a=o1(i,o,r,t,e),l=[n.shape[0],n.shape[1]];if(t){const c=e.makeTensorInfo(l,"float32",a.real),u=e.makeTensorInfo(l,"float32",a.imag),d=e.makeTensorInfo([],"float32",Ya(r,"float32")),h=Wo({inputs:{x:d},backend:e}),f=r1.kernelFunc({inputs:{a:c,b:d},backend:e}),p=r1.kernelFunc({inputs:{a:u,b:h},backend:e}),m=e.data.get(f.dataId).values,g=e.data.get(p.dataId).values;return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),{real:m,imag:g}}return a}{const l=function Cye(n,t,e){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let i=0,o=0;for(let a=0;a<t;a++){const l=eV(s*a,t,e),c=RD(n,a);i+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}e&&(i/=t,o/=t),QB(r,i,o,s)}return r}(wa(i,o),r,t);return XB(l)}}function o1(n,t,e,r,s){if(1===e)return{real:n,imag:t};const i=wa(n,t),o=e/2,a=YB(i),l=a.real,c=a.imag,u=[l.length],d=s.makeTensorInfo(u,"float32",l),h=s.makeTensorInfo(u,"float32",c),f=Bs({inputs:{real:d,imag:h},backend:s}),p=ZB(i),m=p.real,g=p.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),_=s.makeTensorInfo(y,"float32",g),v=Bs({inputs:{real:b,imag:_},backend:s}),w=o1(l,c,o,r,s),C=w.real,I=w.imag,D=[C.length],T=s.makeTensorInfo(D,"float32",C),N=s.makeTensorInfo(D,"float32",I),$=Bs({inputs:{real:T,imag:N},backend:s}),z=o1(m,g,o,r,s),j=z.real,q=z.imag,K=[j.length],P=s.makeTensorInfo(K,"float32",j),B=s.makeTensorInfo(K,"float32",q),L=Bs({inputs:{real:P,imag:B},backend:s}),W=JB(e,r),ne=[W.real.length],ie=s.makeTensorInfo(ne,"float32",W.real),de=s.makeTensorInfo(ne,"float32",W.imag),ue=Bs({inputs:{real:ie,imag:de},backend:s}),he=uv({inputs:{a:ue,b:L},backend:s}),ge=kd({inputs:{a:$,b:he},backend:s}),Ee=s1({inputs:{a:$,b:he},backend:s}),_e=kc({inputs:{input:ge},backend:s}),Me=kc({inputs:{input:Ee},backend:s}),ke=Nd({inputs:{input:ge},backend:s}),Ze=Nd({inputs:{input:Ee},backend:s}),at=Ad({inputs:[_e,Me],backend:s,attrs:{axis:0}}),Kt=Ad({inputs:[ke,Ze],backend:s,attrs:{axis:0}}),ln=s.data.get(at.dataId).values,mn=s.data.get(Kt.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo(ie),s.disposeIntermediateTensorInfo(de),s.disposeIntermediateTensorInfo(ue),s.disposeIntermediateTensorInfo(he),s.disposeIntermediateTensorInfo(ge),s.disposeIntermediateTensorInfo(Ee),s.disposeIntermediateTensorInfo(_e),s.disposeIntermediateTensorInfo(ke),s.disposeIntermediateTensorInfo(Me),s.disposeIntermediateTensorInfo(Ze),s.disposeIntermediateTensorInfo(at),s.disposeIntermediateTensorInfo(Kt),{real:ln,imag:mn}}const Eye={kernelName:"FFT",backendName:"cpu",kernelFunc:function Sye(n){const{inputs:t,backend:e}=n,{input:r}=t,s=X(r.shape),i=r.shape[r.shape.length-1],a=on({inputs:{x:r},backend:e,attrs:{shape:[s/i,i]}}),l=W3(a,!1,e),c=on({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}};function a1(n){const{backend:t,attrs:e}=n,{shape:r,value:s,dtype:i}=e,o=i||Sf(s),a=Kn(o,X(r));return function Dye(n,t,e){n.fill(t)}(a,s),t.makeTensorInfo(r,o,a)}const Iye={kernelName:ZS,backendName:"cpu",kernelFunc:a1},Tye={kernelName:QS,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{image:r}=n,s=e,i=br(r.dtype,X(r.shape)),[o,a,l,c]=r.shape,u=s.data.get(r.dataId).values;for(let h=0;h<o;h++){const f=h*l*a*c;for(let p=0;p<a;p++){const m=p*(l*c);for(let g=0;g<l;g++){const y=g*c;for(let b=0;b<c;b++){const _=Math.round(l-g-1),v=f+m+y+b;let w=u[v];_>=0&&_<l&&(w=u[f+m+_*c+b]),i[v]=w}}}}return{dataId:s.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},j3=_l(n=>Math.floor(n)),kye=Td(Uf,j3),Nye={kernelName:Uf,backendName:"cpu",kernelFunc:kye},Aye=Yn((n,t)=>Math.floor(n/t)),Rye=Er(Hf,Aye,null,"int32"),Mye={kernelName:Hf,backendName:"cpu",kernelFunc:Rye},Oye={kernelName:Vb,backendName:"cpu",kernelFunc:function Fye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r;let m=P3({inputs:{x:s,filter:i},backend:e,attrs:{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h}});if(o){const g=m;if("NCHW"===u&&1===o.shape.length&&1!==o.shape[0]){const y=on({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});m=kd({inputs:{a:m,b:y},backend:e}),e.disposeIntermediateTensorInfo(y)}else m=kd({inputs:{a:m,b:o},backend:e});e.disposeIntermediateTensorInfo(g)}if(f){const g=m;if("NCHW"===u&&"prelu"===f&&1===a.shape.length&&1!==a.shape[0]){const y=on({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});m=lv(e,m,f,y,p),e.disposeIntermediateTensorInfo(y)}else m=lv(e,m,f,a,p);e.disposeIntermediateTensorInfo(g)}return m}},$ye={kernelName:zb,backendName:"cpu",kernelFunc:function Pye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r;let m=$3({inputs:{x:s,filter:i},backend:e,attrs:{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h}});if(o){const g=m;m=kd({inputs:{a:m,b:o},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){const g=m;m=lv(e,m,f,a,p),e.disposeIntermediateTensorInfo(g)}return m}};function G3(n,t,e,r,s,i,o,a,l){const c=ot([r,i],e);for(let u=0;u<r;u++){const d=[];let h=0;for(let f=0;f<s;f++){const p=n[u*s+f];h+=p*o[f],d.push(p)}if(h<0||h>=l/i)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let f=0;f<i;f++)c.values[u*i+f]=t.get(...t.indexToLoc(h*i+f))}return c}const Bye={kernelName:JS,backendName:"cpu",kernelFunc:function Lye(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,i=X(r.shape),o=s.shape,a=o[o.length-1],[l,c,u,d]=ED(r,s);if(0===c)return e.makeTensorInfo(l,r.dtype,[]);const p=G3(e.data.get(s.dataId).values,e.bufferSync(r),r.dtype,c,a,u,d,r.shape,i);return e.makeTensorInfo(l,r.dtype,p.values)}};function q3(n,t,e){const r=ot(e,n.dtype);for(let s=0;s<r.size;++s){const o=r.indexToLoc(s).slice(),c=t.locToIndex([o[0],o[2]]);o[2]=t.values[c];const u=n.locToIndex(o);0<=u&&u<n.values.length&&(r.values[s]=n.values[u])}return r}const zye={kernelName:rb,backendName:"cpu",kernelFunc:function Vye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:i}=t,{axis:o,batchDims:a}=r;Te([s,i],"gatherV2");const l=ft(o,s.shape)[0],c=e.data.get(i.dataId).values,u=s.shape[l];for(let v=0;v<c.length;++v){const w=c[v];S(w<=u-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${u-1}]`)}let d=a;null==a&&(d=0);const h=X(i.shape),f=zD(s,i,l,d),p=on({inputs:{x:s},backend:e,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),m=on({inputs:{x:i},backend:e,attrs:{shape:[f.batchSize,h/f.batchSize]}}),g=[f.batchSize,f.outerSize,h/f.batchSize,f.sliceSize],y=e.bufferSync(m),_=q3(e.bufferSync(p),y,g);return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.makeTensorInfo(f.outputShape,_.dtype,_.values)}},K3=Yn((n,t)=>n>t?1:0),Uye=Er(sb,K3,null,"bool"),Hye={kernelName:sb,backendName:"cpu",kernelFunc:Uye},X3=Yn((n,t)=>n>=t?1:0),Wye=Er(Wf,X3,null,"bool"),jye={kernelName:Wf,backendName:"cpu",kernelFunc:Wye},qye={kernelName:eE,backendName:"cpu",kernelFunc:function Gye(n){const{inputs:t,backend:e}=n,{input:r}=t,s=X(r.shape),i=r.shape[r.shape.length-1],a=on({inputs:{x:r},backend:e,attrs:{shape:[s/i,i]}}),l=W3(a,!0,e),c=on({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}},Kye=qt(Gf,n=>Number.isFinite(n)?1:0,"bool"),Xye={kernelName:Gf,backendName:"cpu",kernelFunc:Kye},Yye=qt(qf,n=>Math.abs(n)===1/0?1:0,"bool"),Zye={kernelName:qf,backendName:"cpu",kernelFunc:Yye},Qye=qt(Kf,n=>Number.isNaN(n)?1:0,"bool"),Jye={kernelName:Kf,backendName:"cpu",kernelFunc:Qye},Y3=Yn((n,t)=>n<t?1:0),ebe=Er(ob,Y3,null,"bool"),tbe={kernelName:ob,backendName:"cpu",kernelFunc:ebe},Z3=Yn((n,t)=>n<=t?1:0),nbe=Er(ab,Z3,null,"bool"),rbe={kernelName:ab,backendName:"cpu",kernelFunc:nbe};function Q3(n,t,e){const r=(t-n)/(e-1),s=Br(e,"float32");s[0]=n;for(let i=1;i<s.length;i++)s[i]=s[i-1]+r;return s}const ibe={kernelName:nE,backendName:"cpu",kernelFunc:function sbe(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:i}=e,o=Q3(r,s,i);return t.makeTensorInfo([o.length],"float32",o)}},J3=_l(n=>Math.log(n)),obe=Td(Xf,J3),abe={kernelName:Xf,backendName:"cpu",kernelFunc:obe},lbe=qt(Yf,n=>Math.log1p(n)),cbe={kernelName:Yf,backendName:"cpu",kernelFunc:lbe},ube=Yn((n,t)=>n&&t),dbe=Er(lb,ube,null,"bool"),hbe={kernelName:lb,backendName:"cpu",kernelFunc:dbe},fbe=qt(cb,n=>n?0:1,"bool"),pbe={kernelName:cb,backendName:"cpu",kernelFunc:fbe},mbe=Yn((n,t)=>n||t),gbe=Er(ub,mbe,null,"bool"),ybe={kernelName:ub,backendName:"cpu",kernelFunc:gbe},_be={kernelName:db,backendName:"cpu",kernelFunc:function bbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:i,bias:o,alpha:a,beta:l}=r;Te(s,"LRN");const c=s.shape[3],u=c-1,d=e.data.get(s.dataId).values,h=X(s.shape),f=new Float32Array(h);function p(m){const g=m%c;let y=m-g+Math.max(0,g-i);const b=m-g+Math.min(g+i,u);let _=0;for(;y<=b;y++){const v=d[y];_+=v*v}return _}for(let m=0;m<h;m++){const g=p(m),y=d[m]*Math.pow(o+a*g,-l);f[m]=y}return e.makeTensorInfo(s.shape,s.dtype,f)}},xbe={kernelName:rE,backendName:"cpu",kernelFunc:function vbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,y:i,dy:o}=t,{depthRadius:a,bias:l,alpha:c,beta:u}=r;Te(o,"LRNGrad");const d=X(o.shape),h=o.shape[3],f=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,m=e.data.get(i.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){const _=b%h,v=b-_+Math.max(0,_-a),w=b-_+Math.min(h,_+a+1);let C=0;for(let I=v;I<w;I++)C+=Math.pow(p[I],2);C=c*C+l;for(let I=v;I<w;I++){let D=-2*c*u*p[I]*m[b]/C;b===I&&(D+=Math.pow(C,-u)),D*=f[b],g[I]+=D}}return e.makeTensorInfo(o.shape,s.dtype,g)}};function eU(n,t,e,r){const s=br(r,X(e));for(let i=0;i<s.length;++i){const o=i*t;let a=n[o];for(let l=0;l<t;++l){const c=n[o+l];(Number.isNaN(c)||c>a)&&(a=c)}s[i]=a}return s}function tU(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:i,keepDims:o}=r,a=e;let l=s.shape;const c=l.length,u=ft(i,l);let d=u;const h=Dn(d,c);let f=a.data.get(s.dataId).values;if(null!=h){const v=new Array(c);for(let w=0;w<v.length;w++)v[w]=l[h[w]];f=QT(f,l,s.dtype,h,v),d=zn(d.length,c),l=v}Te(s,"max"),Ar("max",d,c);const[p,m]=Cr(l,d),y=eU(f,X(m),p,s.dtype),b=a.write(y,p,s.dtype);let _=p;return o&&(_=Vn(p,u)),{dataId:b,shape:_,dtype:s.dtype}}const wbe={kernelName:hb,backendName:"cpu",kernelFunc:tU},nU=Yn((n,t)=>Math.max(n,t)),Cbe=Er(Zf,nU),Sbe={kernelName:Zf,backendName:"cpu",kernelFunc:Cbe},Ibe={kernelName:fb,backendName:"cpu",kernelFunc:function Ebe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Te(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r;S(Nr(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=Ai(s.shape,i,o,1,a,l);let d;if(1===u.filterWidth&&1===u.filterHeight&&It(u.inShape,u.outShape))d=Wo({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,f=Le(s.shape),p=JT(h,0,s.dtype,f,u,"max");d=e.makeTensorInfo(u.outShape,s.dtype,p.values)}return d}},Tbe={kernelName:pb,backendName:"cpu",kernelFunc:function Dbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r;Te(s,"maxPool3d");const u=ya(s.shape,i,o,1,a,l,c),h=A3(e.data.get(s.dataId).values,0,s.dtype,Le(s.shape),u,"max");return e.makeTensorInfo(h.shape,"float32",h.values)}},Nbe={kernelName:iE,backendName:"cpu",kernelFunc:function kbe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;Te([s,i],"maxPool3DGrad");const u=ya(i.shape,o,a,1,l,c),h=function Gme(n,t){const e=ot(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,i=t.strideWidth,o=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,u=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,f=t.padInfo.top,p=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-h;let _=b;for(;_<0;)_+=o;const v=Math.min(t.inDepth,c+b);for(let w=0;w<t.outHeight;++w){const C=w*s-f;let I=C;for(;I<0;)I+=a;const D=Math.min(t.inHeight,u+C);for(let T=0;T<t.outWidth;++T){const N=T*i-p;let $=N;for(;$<0;)$+=l;const z=Math.min(t.inWidth,d+N);let j=Number.NEGATIVE_INFINITY,q=-1;for(let K=_;K<v;K+=o){const P=K-b;for(let B=I;B<D;B+=a){const L=B-C;for(let W=$;W<z;W+=l){const ne=W-N,ie=n.get(m,K,B,W,g);ie>=j&&(j=ie,q=P*u*d+L*u+ne)}}}e.set(q,m,y,w,T,g)}}}return e}(e.bufferSync(i),u),f=u.strideDepth,p=u.strideHeight,m=u.strideWidth,g=u.dilationDepth,y=u.dilationHeight,b=u.dilationWidth,_=u.effectiveFilterDepth,v=u.effectiveFilterHeight,w=u.effectiveFilterWidth,C=_-1-u.padInfo.front,I=w-1-u.padInfo.left,D=v-1-u.padInfo.top,T=ot(i.shape,"float32"),N=e.bufferSync(s);for(let $=0;$<u.batchSize;++$)for(let z=0;z<u.inChannels;++z)for(let j=0;j<u.inDepth;++j)for(let q=0;q<u.inHeight;++q)for(let K=0;K<u.inWidth;++K){const P=j-C,B=q-D,L=K-I;let W=0;for(let ne=0;ne<_;ne+=g){const ie=(P+ne)/f;if(!(ie<0||ie>=u.outDepth||Math.floor(ie)!==ie))for(let de=0;de<v;de+=y){const ue=(B+de)/p;if(!(ue<0||ue>=u.outHeight||Math.floor(ue)!==ue))for(let he=0;he<w;he+=b){const ge=(L+he)/m;if(ge<0||ge>=u.outWidth||Math.floor(ge)!==ge)continue;const Me=_*v*w-1-h.get($,ie,ue,ge,z)===ne*v*w+de*w+he?1:0;0!==Me&&(W+=N.get($,ie,ue,ge,z)*Me)}}}T.set(W,$,j,q,K,z)}return e.makeTensorInfo(T.shape,T.dtype,T.values)}},Rbe={kernelName:sE,backendName:"cpu",kernelFunc:function Abe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i,output:o}=t,a=i;Te([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=r,h=Ai(a.shape,l,c,1,u,d),f=e.data.get(a.dataId).values,p=ot(h.outShape,a.dtype,N3(f,a.shape,a.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,_=h.effectiveFilterHeight,v=h.effectiveFilterWidth,w=v-1-h.padInfo.left,C=_-1-h.padInfo.top,I=ot(a.shape,"float32"),D=e.data.get(s.dataId).values,T=ot(s.shape,"float32",D);for(let N=0;N<h.batchSize;++N)for(let $=0;$<h.inChannels;++$)for(let z=0;z<h.inHeight;++z)for(let j=0;j<h.inWidth;++j){const q=z-C,K=j-w;let P=0;for(let B=0;B<_;B+=y){const L=(q+B)/m;if(!(L<0||L>=h.outHeight||Math.floor(L)!==L))for(let W=0;W<v;W+=b){const ne=(K+W)/g;if(ne<0||ne>=h.outWidth||Math.floor(ne)!==ne)continue;const ue=_*v-1-p.get(N,L,ne,$)===B*v+W?1:0;0!==ue&&(P+=T.get(N,L,ne,$)*ue)}}I.set(P,N,z,j,$)}return e.makeTensorInfo(I.shape,I.dtype,I.values)}},Fbe={kernelName:oE,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=t,l=e;Te(r,"MaxPoolWithArgmax");const c=l.data.get(r.dataId).values,u=Ai(r.shape,s,i,[1,1],o),[d,h]=function Mbe(n,t,e,r,s){const o=JT(n,0,e,Le(t),s,"max"),a=N3(n,t,e,s,!0,r);return[o.values,a.values]}(c,r.shape,r.dtype,a,u),f=l.write(d,u.outShape,r.dtype),p=l.write(h,u.outShape,r.dtype);return[{dataId:f,shape:u.outShape,dtype:r.dtype},{dataId:p,shape:u.outShape,dtype:"int32"}]}},Pbe={kernelName:mb,backendName:"cpu",kernelFunc:function Obe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=ft(i,s.shape),u=X(Cr(s.shape,a)[1]),d=[],h=e.makeTensorInfo([],"float32",new Float32Array([u]));d.push(h);const f=vl({inputs:{x:s},backend:e,attrs:{dtype:"float32"}});d.push(f);const p=n1({inputs:{a:f,b:h},backend:e});d.push(p);const m=sm({inputs:{x:p},backend:e,attrs:{axis:i,keepDims:o}});return d.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}},Lbe={kernelName:gb,backendName:"cpu",kernelFunc:function $be(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;Te(s,"min");const a=ft(i,s.shape);let l=a;const c=Dn(l,s.shape.length);let u=s;null!=c&&(u=vs({inputs:{x:s},backend:e,attrs:{perm:c}}),l=zn(l.length,s.shape.length)),Ar("min",l,u.shape.length);const[d,h]=Cr(u.shape,l),f=X(h),p=Br(X(d),u.dtype),m=e.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let _=m[b];for(let v=0;v<f;++v){const w=m[b+v];(Number.isNaN(w)||w<_)&&(_=w)}p[y]=_}null!=c&&e.disposeIntermediateTensorInfo(u);const g=e.makeTensorInfo(d,u.dtype,p);if(o){const b=on({inputs:{x:g},backend:e,attrs:{shape:Vn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},rU=Yn((n,t)=>Math.min(n,t)),Bbe=Er(Qf,rU),Vbe={kernelName:Qf,backendName:"cpu",kernelFunc:Bbe},Ube={kernelName:yb,backendName:"cpu",kernelFunc:function zbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:i,mode:o}=r;Te(s,"mirrorPad");const a=i.map((_,v)=>_[0]+s.shape[v]+_[1]),l=i.map(_=>_[0]),c=i.map((_,v)=>_[0]+s.shape[v]),u="reflect"===o?0:1,d=e.data.get(s.dataId).values,h=s.shape.length,f=Le(s.shape),p=X(a),m=a.length,g=Le(a),y=br(s.dtype,p);for(let _=0;_<p;_++){let v=Ju(_,m,g);for(let C=0;C<m;C++)v[C]<l[C]?v[C]=2*l[C]-v[C]-u:v[C]>=c[C]&&(v[C]=2*(c[C]-1)-v[C]+u);v=v.map((C,I)=>C-l[I]);const w=Ao(v,h,f);y[_]=d[w]}return{dataId:e.write(y,a,s.dtype),shape:a,dtype:s.dtype}}},Hbe=Yn((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),Wbe=Er(Jf,Hbe),jbe={kernelName:Jf,backendName:"cpu",kernelFunc:Wbe};function sU(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:i}=r,o=s.shape.length;let a=i;if(-1===a&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=ft([a],s.shape),c=tU({inputs:{x:s},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),u=Vn(c.shape,l),d=on({inputs:{x:c},backend:e,attrs:{shape:u}}),h=s1({inputs:{a:s,b:d},backend:e}),f=z3({inputs:{x:h},backend:e}),p=sm({inputs:{x:f},backend:e,attrs:{axis:l,keepDims:!1}}),m=on({inputs:{x:p},backend:e,attrs:{shape:u}}),g=n1({inputs:{a:f,b:m},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),g}const Gbe={kernelName:Ob,backendName:"cpu",kernelFunc:sU},Kbe={kernelName:aE,backendName:"cpu",kernelFunc:function qbe(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:i,seed:o,normalized:a}=r;Te(s,"multinomial");const l=a?s:sU({inputs:{logits:s},backend:e,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],d=e.data.get(l.dataId).values,h=[c,i],f=Br(X(h),"int32");for(let p=0;p<c;++p){const m=p*u,g=new Float32Array(u-1);g[0]=d[m];for(let _=1;_<g.length;++_)g[_]=g[_-1]+d[m+_];const y=b_.alea(o.toString()),b=p*i;for(let _=0;_<i;++_){const v=y();f[b+_]=g.length;for(let w=0;w<g.length;w++)if(v<g[w]){f[b+_]=w;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(h,"int32",f)}};function iU(n,t,e){const r=Ya(-1,e);return t1([],t,r,n,e)}const Ybe={kernelName:bb,backendName:"cpu",kernelFunc:function Xbe(n){const{inputs:t,backend:e}=n,{x:r}=t;Te(r,"neg");const s=e.data.get(r.dataId).values,[i,o]=iU(s,r.shape,r.dtype);return e.makeTensorInfo(o,r.dtype,i)}},Zbe=aD,Jbe={kernelName:lE,backendName:"cpu",kernelFunc:function Qbe(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r;Te(s,"NonMaxSuppression");const c=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values,{selectedIndices:d}=Zbe(c,u,o,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},e_e=lD,n_e={kernelName:cE,backendName:"cpu",kernelFunc:function t_e(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r;Te(s,"NonMaxSuppressionPadded");const u=e.data.get(s.dataId).values,d=e.data.get(i.dataId).values,{selectedIndices:h,validOutputs:f}=e_e(u,d,o,a,l,c);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},r_e=cD,i_e={kernelName:uE,backendName:"cpu",kernelFunc:function s_e(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r;Te(s,"NonMaxSuppressionWithScore");const u=e.data.get(s.dataId).values,d=e.data.get(i.dataId).values,h=o,f=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=r_e(u,d,h,f,p,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},oU=Yn((n,t)=>n!==t?1:0),o_e=Er(_b,oU,null,"bool"),a_e={kernelName:_b,backendName:"cpu",kernelFunc:o_e},c_e={kernelName:xb,backendName:"cpu",kernelFunc:function l_e(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{dtype:i,depth:o,onValue:a,offValue:l}=r;Te(s,"oneHot");const c=X(s.shape),u=new Float32Array(c*o);u.fill(l);const d=e.data.get(s.dataId).values;for(let h=0;h<c;++h)d[h]>=0&&d[h]<o&&(u[h*o+d[h]]=a);return e.makeTensorInfo([...s.shape,o],i,u)}};function hv(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const s=kc({inputs:{input:r},backend:e}),i=hv({inputs:{x:s},backend:e}),o=Nd({inputs:{input:r},backend:e}),a=hv({inputs:{x:o},backend:e}),l=Bs({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return a1({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const u_e={kernelName:Lb,backendName:"cpu",kernelFunc:hv},d_e={kernelName:vb,backendName:"cpu",kernelFunc:function aU(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const s=kc({inputs:{input:r},backend:e}),i=aU({inputs:{x:s},backend:e}),o=Nd({inputs:{input:r},backend:e}),a=hv({inputs:{x:o},backend:e}),l=Bs({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return a1({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function lU(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return dv({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const i=t[0].shape,o=t[0].dtype;t.forEach(u=>{Ms(i,u.shape,"All tensors passed to stack must have matching shapes"),S(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=Ad({inputs:t.map(u=>{const d=dv({inputs:{input:u},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(u=>e.disposeIntermediateTensorInfo(u)),c}const h_e={kernelName:wb,backendName:"cpu",kernelFunc:lU},cU={kernelName:Cb,backendName:"cpu",kernelFunc:function f_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:i,constantValue:o}=r;Te(s,"pad");const a=i.map((b,_)=>b[0]+s.shape[_]+b[1]),l=i.map(b=>b[0]),c=e.data.get(s.dataId).values,u=X(s.shape),d=s.shape.length,h=Le(s.shape),f=X(a),p=a.length,m=Le(a),g=br(s.dtype,f);0!==o&&g.fill(o);for(let b=0;b<u;b++)g[Ao(Ju(b,d,h).map((C,I)=>C+l[I]),p,m)]=c[b];return{dataId:e.write(g,a,s.dtype),shape:a,dtype:s.dtype}}},p_e=Yn((n,t)=>Math.pow(n,t)),m_e=Er(tp,p_e),g_e={kernelName:tp,backendName:"cpu",kernelFunc:m_e};function uU(n,t,e,r){const[s,i]=Cr(n,r),o=Fs(t,"int32"),a=Br(X(s),o),l=X(i);for(let c=0;c<a.length;++c){const u=c*l;let d=1;for(let h=0;h<l;++h)d*=e[u+h];a[c]=d}return{outVals:a,outShape:s,outDtype:o}}const b_e={kernelName:Eb,backendName:"cpu",kernelFunc:function y_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;Te(s,"prod");const a=s.shape.length,l=ft(i,s.shape),c=Dn(l,a);let u=l,d=s;const h=[];null!=c&&(d=vs({inputs:{x:s},backend:e,attrs:{perm:c}}),h.push(d),u=zn(u.length,a));const f=e.data.get(d.dataId).values,{outVals:p,outShape:m,outDtype:g}=uU(d.shape,d.dtype,f,u);let y=m;return o&&(y=Vn(m,l)),h.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(y,g,p)}};function dU(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let r=t;r<n.length;r++)e[t-1]*=n[r];return e}function hU(n,t,e,r,s,i,o,a){if(0===n.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function __e(n,t,e){n.forEach((r,s)=>{if(r<0||r>=e){const i=Ju(s,t.length,Le(t)).join(",");throw new Error(`indices[${i}] = ${r} is not in [0, ${e})`)}})}(i,o,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:u,valueSlices:d,numValues:h}=function x_e(n,t,e,r){const s=[];let i=0;const a=new Array(t.length-1+e.length).fill(null).map(()=>[0]);!function v_e(n,t){for(let e=0;e<n.length;++e){const r=n[e],s=e===n.length-1?t:n[e+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let i=1;i<r.length;++i)if(r[i-1]>r[i])throw new Error("Ragged splits must be sorted in ascending order")}}(e,r);let l=1;for(let c=0;c<t.length-1;++c){l*=t[c];const u=t[c+1];for(let d=1;d<l+1;++d)a[c].push(d*u)}for(let c=0;c<n.length;++c){let u=n[c],d=n[c]+1;for(let h=0;h<e.length;++h){const f=e[h],p=h+t.length-1;if(p>=0){const m=a[p],g=m[m.length-1]-f[u];for(let y=u;y<d;++y)a[p].push(f[y+1]+g)}u=f[u],d=f[d]}d!==u&&(s.push([u,d]),i+=d-u)}return{outSplits:a,valueSlices:s,numValues:i}}(i,o,n,c),f=function w_e(n){const t=[];for(let e=0;e<n.length;++e){const s=Kn("int32",n[e].length);t.push(s),n[e].forEach((i,o)=>s[o]=i)}return t}(u),p=function S_e(n,t,e,r,s){const i=t.slice();i[0]=s;const o=Kn(e,X(i)),a=n.length;return function C_e(n,t,e,r,s,i){const o=dU(t,2)[1],a=dU(i,2)[1];let l=0;for(const c of e)for(let u=c[0];u<c[1];++u){for(let d=0;d<r;++d)s[l*a+d]=n[u*o+d];++l}}(n,t,r,0===a?0:a/t[0],o,i),[o,i]}(e,r,s,d,h);return[f,p[0],p[1]]}const I_e={kernelName:dE,backendName:"cpu",kernelFunc:function E_e(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=t,l=s.map(y=>e.data.get(y.dataId).values),c=s.map(y=>y.shape),u=e.data.get(i.dataId).values,d=e.data.get(o.dataId).values,[h,f,p]=hU(l,c,u,i.shape,i.dtype,d,o.shape),m=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),g=e.makeTensorInfo(p,i.dtype,f);return m.concat([g])}},fU=2147483647;function pU(n,t,e,r,s,i,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=0===t.length,l=0===s.length,c=0===o.length,u=[];a||u.push(t[0]),l||u.push(s[0]),c||u.push(o[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===u.length?1:u[0],h=Kn("int32",d+1);h[0]=0;for(let g=0;g<d;++g){const y=a?n[0]:n[g],b=l?r[0]:r[g],_=c?i[0]:i[g];if(0===_)throw new Error("Requires delta != 0");let v;if(_>0&&b<y||_<0&&b>y)v=0;else if(v=Math.ceil(Math.abs((b-y)/_)),v>fU)throw new Error(`Requires ((limit - start) / delta) <= ${fU}`);h[g+1]=h[g]+v}const p=Kn(e,h[d]);let m=0;for(let g=0;g<d;++g){const y=h[g+1]-h[g];let b=a?n[0]:n[g];const _=c?i[0]:i[g];for(let v=0;v<y;++v)p[m++]=b,b+=_}return[h,p]}const T_e={kernelName:hE,backendName:"cpu",kernelFunc:function D_e(n){const{inputs:t,backend:e}=n,{starts:r,limits:s,deltas:i}=t,o=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,[c,u]=pU(o,r.shape,r.dtype,a,s.shape,l,i.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([u.length],r.dtype,u)]}};var zi=Pi;class fv{constructor(t,e,r,s,i,o,a,l,c,u){this.shape=t,this.shapeShape=e,this.values=r,this.valuesShape=s,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=GB(u),this.raggedRank=qB(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===zi.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===zi.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case zi.VALUE_ROWIDS:return fv.getMaxWidthValueRowID(e);case zi.ROW_SPLITS:return fv.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${zi[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let r=0;for(let s=0;s<e-1;++s){const i=t[s+1]-t[s];i>r&&(r=i)}return r}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let r=0,s=t[0],i=0;for(let o=1;o<e;++o){const a=t[o];a!==s&&(s=a,i=Math.max(o-r,i),r=o)}return Math.max(e-r,i)}tensorShapeFromTensor(t,e,r=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return gU(t,r)}calculateOutputSize(t){const e=this.valuesShape;KB(this.defaultValueShape,e);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=jB(this.raggedRank,s,e);o[0]<0&&(o[0]=t);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(t,e,r){const s=Math.min(t,r),i=[];let o=0;for(let a=0;a<s;++a,o+=e)i.push(o);for(let a=s;a<t;++a)i.push(-1);return S(i.length===t,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(t,e,r,s){const i=t.length,o=[];for(let a=0;a<i-1;++a){const l=t[a+1]-t[a];let c=Math.min(s,l),u=e[a];-1===u&&(c=0);for(let d=0;d<c;++d)o.push(u),u+=r;for(let d=0;d<l-c;++d)o.push(-1)}if(i>0&&o.length!==t[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,e,r,s){const i=t.length,o=[];if(0===i)return[];let a=0,l=t[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let c=e[l];o.push(c);for(let u=1;u<i;++u){const d=t[u];if(d===l)c>=0&&(++a,a<s?c+=r:c=-1);else{if(a=0,l=d,d>=e.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${e.length}`);c=e[d]}o.push(c)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,e,r,s){const i=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case zi.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,e,r,s);case zi.ROW_SPLITS:if(i.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(i,e,r,s);default:throw new Error(`Unsupported partition type: ${zi[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case zi.FIRST_DIM_SIZE:return t[0];case zi.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case zi.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${zi[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const i=gU(r,!1),o=Kn(this.valuesDType,X(i));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(e,s[0],r[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,s[c],r[c]);this.setOutput(this.raggedRank,l,o,i)}return[i,o]}setOutput(t,e,r,s){if(0===r.length)return;const i=this.values,o=r;let a=s.slice();a=a.slice(t+1);const l=X(a),c=e.length;let u=this.defaultValue;if(u.length!==l&&1!==u.length){const p=this.defaultValueShape;V(()=>{const m=F(u,p);u=pd(m,a).dataSync()})}let d=0,h=0,f=0;for(let p=0;p<=c;++p){let m=p<c?e[p]:-1;if(m!==f){if(h<f){const g=i.subarray(d*l);mU(o.subarray(h*l),g,(f-h)*l)}if(p>=c&&(m=Math.floor(r.length/l)),m>f)if(1===this.defaultValue.length)o.subarray(f*l,m*l).fill(this.defaultValue[0]),f=m;else for(;m>f;)mU(o.slice(f*l),u,l),++f;m<0?(d=p+1,h=f):(d=p,h=f,f=h+1)}else++f}}}function mU(n,t,e){for(let r=0;r<e;r++)n[r]=t[r]}function gU(n,t){const e=[];for(let r of n){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function yU(n,t,e,r,s,i,o,a,l,c){return new fv(n,t,e,r,s,i,o,a,l,c).compute()}const N_e={kernelName:fE,backendName:"cpu",kernelFunc:function k_e(n){const{inputs:t,backend:e,attrs:r}=n,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=r,c=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values,d=e.data.get(o.dataId).values,h=a.map(g=>e.data.get(g.dataId).values),f=a.map(g=>g.shape),[p,m]=yU(c,s.shape,u,i.shape,i.dtype,d,o.shape,h,f,l);return e.makeTensorInfo(p,i.dtype,m)}};function bU(n,t,e,r){if(n===t||n<t&&e<0||t<n&&e>1)return Br(0,r);const l=Br(Math.abs(Math.ceil((t-n)/e)),r);t<n&&1===e&&(e=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+e;return l}const R_e={kernelName:pE,backendName:"cpu",kernelFunc:function A_e(n){const{backend:t,attrs:e}=n,{start:r,stop:s,dtype:i,step:o}=e,a=bU(r,s,o,i);return t.makeTensorInfo([a.length],i,a)}},M_e=qt(np,n=>1/n),F_e={kernelName:np,backendName:"cpu",kernelFunc:M_e},P_e={kernelName:Tb,backendName:"cpu",kernelFunc:function O_e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r;Te(s,"resizeBilinear");const l=Le(s.shape),[c,u]=a,[d,h,f,p]=s.shape,m=e.data.get(s.dataId).values,g=new Float32Array(X([d,c,u,p])),y=[i&&c>1?h-1:h,i&&u>1?f-1:f],b=[i&&c>1?c-1:c,i&&u>1?u-1:u];let _=0;const v=y[0]/b[0],w=y[1]/b[1];for(let C=0;C<d;C++)for(let I=0;I<c;I++){let D;D=o?v*(I+.5)-.5:v*I;const T=Math.max(0,Math.floor(D)),N=D-T,$=Math.min(h-1,Math.ceil(D)),z=C*l[0]+T*l[1],j=C*l[0]+$*l[1];for(let q=0;q<u;q++){let K;K=o?w*(q+.5)-.5:w*q;const P=Math.max(0,Math.floor(K)),B=K-P,L=Math.min(f-1,Math.ceil(K)),W=z+P*l[2],ne=j+P*l[2],ie=z+L*l[2],de=j+L*l[2];for(let ue=0;ue<p;ue++){const he=m[W+ue],ge=m[ne+ue],Me=he+(m[ie+ue]-he)*B;g[_++]=Me+(ge+(m[de+ue]-ge)*B-Me)*N}}}return e.makeTensorInfo([d,c,u,p],"float32",g)}},L_e={kernelName:yE,backendName:"cpu",kernelFunc:function $_e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r;Te([i,s],"resizeBilinearGrad");const a=Le(s.shape),[l,c,u,d]=s.shape,[,h,f]=i.shape,p=new Float32Array(l*c*u*d),m=[o&&h>1?c-1:c,o&&f>1?u-1:u],g=[o&&h>1?h-1:h,o&&f>1?f-1:f],y=m[0]/g[0],b=m[1]/g[1],_=e.data.get(i.dataId).values;let v=0;for(let w=0;w<l;w++){const C=w*a[0];for(let I=0;I<h;I++){const D=I*y,T=Math.floor(D),N=Math.min(Math.ceil(D),c-1),$=C+T*a[1],z=C+N*a[1],j=D-T,q=1-j;for(let K=0;K<f;K++){const P=K*b,B=Math.floor(P),L=Math.min(Math.ceil(P),u-1),W=P-B,ne=1-W,ie=$+B*a[2],de=$+L*a[2],ue=z+B*a[2],he=z+L*a[2],ge=q*ne,Ee=q*W,_e=j*ne,Me=j*W;for(let ke=0;ke<d;ke++){const Ze=_[v++];p[ie+ke]+=Ze*ge,p[de+ke]+=Ze*Ee,p[ue+ke]+=Ze*_e,p[he+ke]+=Ze*Me}}}}return e.makeTensorInfo([l,u,c,d],"float32",p)}},V_e={kernelName:Db,backendName:"cpu",kernelFunc:function B_e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r;Te(s,"resizeNearestNeighbor");const l=Le(s.shape),[c,u]=a,[d,h,f,p]=s.shape,m=e.data.get(s.dataId).values,g=new Float32Array(d*c*u*p),y=[i&&c>1?h-1:h,i&&u>1?f-1:f],b=[i&&c>1?c-1:c,i&&u>1?u-1:u],_=y[0]/b[0],v=y[1]/b[1];let w=0;for(let C=0;C<d;C++){const I=C*l[0];for(let D=0;D<c;D++){const T=o?_*(D+.5):_*D;let N=Math.min(h-1,i?Math.round(T):Math.floor(T));o&&(N=Math.max(0,N));const $=I+N*l[1];for(let z=0;z<u;z++){const j=o?v*(z+.5):v*z;let q=Math.min(f-1,i?Math.round(j):Math.floor(j));o&&(q=Math.max(0,q));const K=$+q*l[2];for(let P=0;P<p;P++)g[w++]=m[K+P]}}}return e.makeTensorInfo([d,c,u,p],s.dtype,g)}},U_e={kernelName:gE,backendName:"cpu",kernelFunc:function z_e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r;Te([i,s],"resizeNearestNeighborGrad");const a=Le(s.shape),l=Le(i.shape),[c,u,d,h]=s.shape,[,f,p]=i.shape,m=new Float32Array(c*u*d*h),g=e.data.get(i.dataId).values,y=[o&&f>1?u-1:u,o&&p>1?d-1:d],b=[o&&f>1?f-1:f,o&&p>1?p-1:p],_=y[0]/b[0],v=y[1]/b[1],w=1/_,C=1/v,I=2*Math.ceil(w)+2,D=2*Math.ceil(C)+2;for(let T=0;T<c;T++){const N=T*a[0];for(let $=0;$<u;$++){const z=N+$*a[1],j=Math.floor($*w),q=Math.floor(j-I/2);for(let K=0;K<d;K++){const P=z+K*a[2],B=Math.floor(K*C),L=Math.floor(B-D/2);for(let W=0;W<h;W++){let ne=0;for(let ie=0;ie<I;ie++){const de=ie+q;if(de<0||de>=f)continue;const ue=N+de*l[1],he=de*_;if($===Math.min(u-1,o?Math.round(he):Math.floor(he)))for(let Ee=0;Ee<D;Ee++){const _e=Ee+L;if(_e<0||_e>=p)continue;const Me=ue+_e*l[2],ke=_e*v;K===Math.min(d-1,o?Math.round(ke):Math.floor(ke))&&(ne+=g[Me+W])}}m[P+W]=ne}}}}return e.makeTensorInfo(s.shape,s.dtype,m)}},W_e={kernelName:kb,backendName:"cpu",kernelFunc:function H_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:i}=r;Te(s,"reverse");const o=s.shape.length,a=ft(i,s.shape);if(0===o)return Wo({inputs:{x:s},backend:e});const l=new vr(s.shape,s.dtype),c=e.bufferSync(s);for(let u=0;u<l.size;u++){const d=l.indexToLoc(u),h=d.slice();a.forEach(f=>h[f]=s.shape[f]-1-h[f]),l.set(c.get(...h),...d)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}},j_e={kernelName:FE,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=t,a=e,l=br(r.dtype,X(r.shape)),[c,u,d,h]=r.shape,[f,p]=wD(o,u,d),g=Math.sin(s),y=Math.cos(s),b=a.data.get(r.dataId).values;for(let v=0;v<c;v++){const w=v*d*u*h;for(let C=0;C<u;C++){const I=C*(d*h);for(let D=0;D<d;D++){const T=D*h;for(let N=0;N<h;N++){const $=[c,C,D,N],z=$[2],j=$[1];let q=(z-f)*y-(j-p)*g,K=(z-f)*g+(j-p)*y;q=Math.round(q+f),K=Math.round(K+p);let P=i;"number"!=typeof i&&(P=3===N?255:i[N]),q>=0&&q<d&&K>=0&&K<u&&(P=b[w+K*(d*h)+q*h+N]),l[w+I+T+N]=P}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},G_e=qt(ip,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2==0?t:t+1}),q_e={kernelName:ip,backendName:"cpu",kernelFunc:G_e},_U=_l(n=>1/Math.sqrt(n)),K_e=Td(op,_U),X_e={kernelName:op,backendName:"cpu",kernelFunc:K_e};function Rd(n,t,e,r,s,i,o,a,l,c){const u=[r/s,s],d=n.values,h=t.values;if(0===r)return ot(e,t.dtype);const f=ot(u,t.dtype);"string"==typeof l||"number"==typeof l?f.values.fill(l):"boolean"==typeof l&&f.values.fill(+l);for(let p=0;p<i;p++){const m=[];let g=0;for(let y=0;y<o;y++){const b=d[p*o+y];m.push(b),g+=b*a[y]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${e}`);for(let y=0;y<s;y++)c?f.values[g*s+y]+=h[p*s+y]:f.values[g*s+y]=0===t.rank?h[0]:h[p*s+y]}return f}const Z_e={kernelName:bE,backendName:"cpu",kernelFunc:function Y_e(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:i}=t,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=Bp(0,s,o),m=Rd(e.bufferSync(s),e.bufferSync(i),o,d,c,l,a,u,0,!0);return e.makeTensorInfo(o,m.dtype,m.values)}};function Q_e(n,t){let e=0,r=n.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),n[s]<t?e=s+1:r=s;return r}function J_e(n,t){let e=0,r=n.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),n[s]<=t?e=s+1:r=s;return r}const nve={kernelName:_E,backendName:"cpu",kernelFunc:function tve(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:s,values:i}=t,{side:o}=r,c=function eve(n,t,e,r,s,i){const o=Kn("int32",e*s);for(let a=0;a<e;++a){const l=n.slice(a*r,(a+1)*r),c=a*s;for(let u=0;u<s;++u)o[c+u]="left"===i?Q_e(l,t[u+c]):J_e(l,t[u+c])}return o}(e.data.get(s.dataId).values,e.data.get(i.dataId).values,s.shape[0],s.shape[1],i.shape[1],o);return e.makeTensorInfo(i.shape,"int32",c)}},sve={kernelName:Nb,backendName:"cpu",kernelFunc:function rve(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:i}=t;Te([r,s,i],"select");const o=r.shape.length,a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values,u=Fs(s.dtype,i.dtype),d=Br(X(s.shape),u);let h=0;const f=0===o||o>1||1===s.shape.length?1:X(s.shape.slice(1));for(let p=0;p<a.length;p++)for(let m=0;m<f;m++)d[h++]=1===a[p]?l[p]:c[p];return e.makeTensorInfo(s.shape,u,d)}},ive=N_,ove=A_,ave=qt(ap,n=>n>=0?ove*n:ive*(Math.exp(n)-1)),lve={kernelName:ap,backendName:"cpu",kernelFunc:ave},cve=qt(up,n=>n<0?-1:n>0?1:0),uve={kernelName:up,backendName:"cpu",kernelFunc:cve},dve=qt(lp,n=>Math.sin(n)),hve={kernelName:lp,backendName:"cpu",kernelFunc:dve},fve=qt(cp,n=>Math.sinh(n)),pve={kernelName:cp,backendName:"cpu",kernelFunc:fve},vU=Math.log(1.1920928955078125e-7)+2,mve=qt(hp,n=>{const t=n>-vU,e=n<vU,r=Math.exp(n);let s;return s=e?r:t?n:Math.log(1+r),s}),gve={kernelName:hp,backendName:"cpu",kernelFunc:mve},bve={kernelName:Mb,backendName:"cpu",kernelFunc:function yve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,paddings:o}=r;Te([s],"spaceToBatchND");const a=X(i),l=[[0,0]];l.push(...o);for(let C=1+i.length;C<s.shape.length;++C)l.push([0,0]);const c=cU.kernelFunc({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),u=Vp(c.shape,i,a,!1),d=zp(u.length,i.length,!1),h=Up(c.shape,i,a,!1),m=on({inputs:{x:c},backend:e,attrs:{shape:u}}),b=vs({inputs:{x:m},backend:e,attrs:{perm:d}}),w=on({inputs:{x:b},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(b),w}};function xU(n,t,e,r,s,i,o){const a=t[0],l=i[0],c=new Array(l),u=new Array(a),d=t[1];if(0===l){if(0!==a)throw new Error(rV(a));return[Kn(e,0),[0,d],Kn(s,0),c,u]}let h=!0,f=0;const p=new Array(l).fill(0);for(let g=0;g<a;++g){const y=n[g*d];if(y<0)throw new Error(sV(g,y));if(y>=l)throw new Error(iV(g,y,l));++p[y],h=h&&y>=f,f=y}let m=!0;for(let g=0;g<l;++g){const y=0===p[g];c[g]=y,m=m&&!y,p[g]=Math.max(p[g],1),g>0&&(p[g]+=p[g-1])}if(m&&h){const g=n,y=r;for(let b=0;b<a;++b)u[b]=b;return[g,[a,d],y,c,u]}{const g=p[l-1],y=Kn(e,g*d),b=Kn(s,g),_=new Array(l).fill(0);for(let v=0;v<a;++v){const w=n[v*d],I=(0===w?0:p[w-1])+_[w];_[w]++;for(let D=0;D<d;++D)y[I*d+D]=n[v*d+D];b[I]=r[v],u[v]=I}for(let v=0;v<l;++v)if(0===_[v]){const C=0===v?0:p[v-1];y[C*d+0]=v;for(let I=1;I<d;++I)y[C*d+I]=0;b[C]=o}return[y,[g,d],b,c,u]}}const vve={kernelName:vE,backendName:"cpu",kernelFunc:function _ve(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values,u=e.data.get(o.dataId).values[0],[d,h,f,p,m]=xU(a,r.shape,r.dtype,l,s.dtype,c,u);return[e.makeTensorInfo(h,r.dtype,d),e.makeTensorInfo([h[0]],s.dtype,f),e.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),e.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function wU(n,t,e,r,s){const i=X(r),o=t[0],a=s.length,l=[];let c=1,u=-1;for(let g=0;g<a;++g){const y=s[g];if(-1===y){if(-1!==u)throw new Error(oV(u,g));u=g,l.push(1)}else{if(y<0)throw new Error(aV(g,y));c*=y,l.push(y)}}if(-1!==u){if(c<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const g=Math.trunc(i/c);if(c*g!==i)throw new Error(cV(r,l));l[u]=g}if(X(l)!==i)throw new Error(uV(r,l));const h=r.length,f=[];if(h>0){f[h-1]=1;for(let g=h-2;g>=0;--g)f[g]=f[g+1]*r[g+1]}const p=[];if(a>0){p[a-1]=1;for(let g=a-2;g>=0;--g)p[g]=p[g+1]*l[g+1]}const m=Kn(e,o*a);for(let g=0;g<o;++g){let y=0;for(let b=0;b<h;++b)y+=n[g*h+b]*f[b];for(let b=0;b<a;++b)m[g*a+b]=Math.trunc(y/p[b]),y%=p[b]}return[m,[o,a],l]}const wve={kernelName:xE,backendName:"cpu",kernelFunc:function xve(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.data.get(s.dataId).values),a=e.data.get(r.dataId).values,l=Array.from(e.data.get(i.dataId).values),[c,u,d]=wU(a,r.shape,r.dtype,o,l);return[e.makeTensorInfo(u,r.dtype,c),e.makeTensorInfo([d.length],i.dtype,new Int32Array(d))]}};function l1(n,t,e,r,s,i=!1,o=0){const a=r.length,l=[t[0],n.length/t[0]],c=l[1],d=a>0?s[a-1]+1:0;if(d<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=d;const p=Kn(e,h.reduce((_,v)=>_*v,1));if(0===a)return d>0&&p.fill(o),[p,h];if(d<=0)throw new Error("segment ids must be >= 0");let m=0,g=1,y=0,b=s[m];for(;;){let _=0;if(g<a){if(_=s[g],b===_){++g;continue}if(b>=_)throw new Error("segment ids are not increasing")}if(b<0||b>=d)throw new Error(hV(b,d));b>y&&p.fill(o,y*c,b*c);for(let v=m;v<g;++v){const w=r[v];if(w<0||w>=l[0])throw new Error(fV(v,r[v],l[0]));for(let C=0;C<c;C++)p[b*c+C]+=n[w*c+C]}if(i)for(let v=0;v<c;v++)p[b*c+v]/=g-m;if(m=g,++g,y=b+1,b=_,g>a)break}return y<d&&p.fill(o,y*c,d*c),[p,h]}const Sve={kernelName:wE,backendName:"cpu",kernelFunc:function Cve(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,[c,u]=l1(o,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(u,r.dtype,c)}},Ive={kernelName:CE,backendName:"cpu",kernelFunc:function Eve(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,[c,u]=l1(o,r.shape,r.dtype,a,l);return e.makeTensorInfo(u,r.dtype,c)}},Tve={kernelName:SE,backendName:"cpu",kernelFunc:function Dve(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=t,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:h}=Bp(0,s,a),f=!1,p=e.bufferSync(s);let m;switch(i.dtype){case"bool":m=Rd(p,e.bufferSync(i),a,h,u,c,l,d,Boolean(e.data.get(o.dataId).values[0]),f);break;case"float32":case"int32":m=Rd(p,e.bufferSync(i),a,h,u,c,l,d,e.data.get(o.dataId).values[0],f);break;case"string":m=Rd(p,e.bufferSync(i),a,h,u,c,l,d,Qa(e.data.get(o.dataId).values[0]),f);break;default:throw new Error(`Unsupported type ${i.dtype}`)}return e.makeTensorInfo(a,m.dtype,m.values)}},Nve={kernelName:Fb,backendName:"cpu",kernelFunc:function kve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:i,axis:o}=r,a=ft(o,s.shape)[0],l=BD(s,i,a),c=new Array(s.shape.length).fill(0),u=s.shape.slice();return l.map(d=>{const h=[...u];h[a]=d;const f=Nc({inputs:{x:s},backend:e,attrs:{begin:c,size:h}});return c[a]+=d,f})}},Ave=_l(n=>Math.sqrt(n)),Rve=qt(fp,n=>Math.sqrt(n)),Mve={kernelName:fp,backendName:"cpu",kernelFunc:Rve},Fve={kernelName:EE,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,r=t;Te(e,"square");const s=r.data.get(e.dataId).values,i=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];i[a]=l*l}return{dataId:r.write(i,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},CU=Yn((n,t)=>{const e=n-t;return e*e}),Ove=Er(pp,CU),Pve={kernelName:pp,backendName:"cpu",kernelFunc:Ove},$ve=qt(_p,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),Lve={kernelName:_p,backendName:"cpu",kernelFunc:$ve};function SU(n,t,e,r){const s=ot(n,t.dtype);for(let i=0;i<s.size;i++){const o=s.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*e[l]+r[l];s.set(t.get(...a),...o)}return s}const Vve={kernelName:IE,backendName:"cpu",kernelFunc:function Bve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=r;Te(s,"stridedSlice");const{finalShapeSparse:f,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:_,strides:v}=bI(s.shape,i,o,a,l,c,u,d,h);let w;if(m)w=on({inputs:{x:s},backend:e,attrs:{shape:p}});else if(g||y){S(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const C=mI(b,_,v),I=Nc({inputs:{x:s},backend:e,attrs:{begin:b,size:C}});w=on({inputs:{x:I},backend:e,attrs:{shape:p}}),e.disposeIntermediateTensorInfo(I)}else{const I=SU(f,e.bufferSync(s),v,b);w=e.makeTensorInfo(p,I.dtype,I.values)}return w}};class zve{constructor(t,e,r,s,i,o){this.separator=Za(t),this.nGramWidths=e,this.leftPad=Za(r),this.rightPad=Za(s),this.padWidth=i,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const r=this.getPadWidth(e);return Math.max(0,t+2*r-e+1)}createNGrams(t,e,r,s,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),u=Math.max(0,l-(i-(a+1))),d=o-(c+u),h=e+(c>0?0:a-l);let f=0;f+=c*this.leftPad.length;for(let b=0;b<d;++b)f+=t[h+b].length;f+=u*this.rightPad.length,f+=(c+u+d-1)*this.separator.length,r[s+a]=new Uint8Array(f);const m=r[s+a];let g=0;const y=b=>b.forEach(_=>m[g++]=_);for(let b=0;b<c;++b)y(this.leftPad),y(this.separator);for(let b=0;b<d-1;++b)y(t[h+b]),y(this.separator);if(d>0){y(t[h+d-1]);for(let b=0;b<u;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<u-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,e){const r=t.length,s=e.length;if(s>0){let l=e[0];if(0!==l)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<s;++c){let u=e[c]>=l;if(u=u&&e[c]<=r,!u)throw new Error(`Invalid split value ${e[c]}, must be in [${l}, ${r}]`);l=e[c]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const i=s-1,o=Kn("int32",s);if(0===r||0===s){const l=new Array(r);for(let c=0;c<=i;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const c=e[l]-e[l-1];let u=0;this.nGramWidths.forEach(d=>{u+=this.getNumNGrams(c,d)}),this.preserveShort&&c>0&&0===u&&(u=1),o[l]=o[l-1]+u}const a=new Array(o[i]);for(let l=0;l<i;++l){const c=e[l];let u=o[l];if(this.nGramWidths.forEach(d=>{const f=this.getNumNGrams(e[l+1]-e[l],d);this.createNGrams(t,c,a,u,f,d),u+=f}),this.preserveShort&&u===o[l]){const d=e[l+1]-e[l];if(0===d)continue;this.createNGrams(t,c,a,u,1,d+2*this.padWidth)}}return[a,o]}}function EU(n,t,e,r,s,i,o,a){return new zve(e,r,s,i,o,a).compute(n,t)}const Hve={kernelName:DE,backendName:"cpu",kernelFunc:function Uve(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:d}=t,h=e.data.get(u.dataId).values,f=e.data.get(d.dataId).values,[p,m]=EU(h,f,s,i,o,a,l,c);return[e.makeTensorInfo([p.length],"string",p),e.makeTensorInfo(d.shape,"int32",m)]}};function Wve(n,t,e,r){if(!n.length)return;if(0===t.length){for(let i=0;i<n.length;++i)r.push(n.subarray(i,i+1));return}if(1===t.length){const i=t[0];let o=n.indexOf(i);for(;-1!==o;){const a=n.subarray(0,o);(!e||0!==a.length)&&r.push(a),o=(n=n.subarray(o+1)).indexOf(i)}return void((!e||0!==n.length)&&r.push(n))}let s=0;for(let i=0;i<n.length+1;i++)if(i===n.length||-1!==t.indexOf(n[i])){const o=n.subarray(s,i);(!e||0!==o.length)&&r.push(o),s=i+1}}function IU(n,t,e){const r=n.length,s=[];let i=0,o=0;const a=new Array(r);for(let h=0;h<r;++h){const f=s.length;Wve(n[h],t,e,s);const p=s.length-f;a[h]=p,i+=p,o=Math.max(o,p)}const l=Kn("int32",2*i),c=new Array(i),u=[r,o];let d=0;for(let h=0;h<r;++h)for(let f=0;f<a[h];++f)l[2*d]=h,l[2*d+1]=f,c[d]=s[d],++d;return[l,c,u]}const Gve={kernelName:TE,backendName:"cpu",kernelFunc:function jve(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values[0],[c,u,d]=IU(a,l,s),h=u.length;return[e.makeTensorInfo([h,2],"int32",c),e.makeTensorInfo([h],"string",u),e.makeTensorInfo([2],"int32",new Int32Array(d))]}};function DU(n,t){const e=Kn("int32",n.length);for(let r=0;r<n.length;++r)e[r]=Zte(n[r]).modulo(t).getLowBitsUnsigned();return e}const Kve={kernelName:kE,backendName:"cpu",kernelFunc:function qve(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=DU(e.data.get(i.dataId).values,s);return e.makeTensorInfo(i.shape,"int32",a)}},Xve=qt(gp,n=>Math.tan(n)),Yve={kernelName:gp,backendName:"cpu",kernelFunc:Xve},Zve=qt(yp,n=>Math.tanh(n));function TU(n,t){const e=new Array(n.rank);for(let s=0;s<e.length;s++)e[s]=n.shape[s]*t[s];const r=ot(e,n.dtype);for(let s=0;s<r.values.length;++s){const i=r.indexToLoc(s),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%n.shape[l];const a=n.locToIndex(o);r.values[s]=n.values[a]}return r}const im=(n,t)=>{const e=t.value-n.value;return 0===e?n.index-t.index:e};function kU(n,t,e=0,r=n.length-1){for(;r>e;){if(r-e>600){const a=r-e+1,l=t-e+1,c=Math.log(a),u=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2);kU(n,t,Math.max(e,Math.floor(t-l*u/a+d)),Math.min(r,Math.floor(t+(a-l)*u/a+d)))}const s=n[t];let i=e,o=r;for(qa(n,e,t),im(n[r],s)>0&&qa(n,e,r);i<o;){for(qa(n,i,o),i++,o--;im(n[i],s)<0;)i+=1;for(;im(n[o],s)>0;)o-=1}0===im(n[e],s)?qa(n,e,o):(o+=1,qa(n,o,r)),o<=t&&(e=o+1),t<=o&&(r=o-1)}}function NU(n,t,e,r,s){const i=t[t.length-1],[o,a]=[n.length/i,i],l=br(e,o*r),c=br("int32",o*r);for(let d=0;d<o;d++){const h=d*a,f=n.subarray(h,h+a);let p=new Array(f.length);f.forEach((b,_)=>p[_]={value:b,index:_}),r<p.length&&(kU(p,r),p=p.slice(0,r)),s&&p.sort(im);const m=d*r,g=l.subarray(m,m+r),y=c.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=p[b].value,y[b]=p[b].index}const u=t.slice();return u[u.length-1]=r,[ot(u,e,l),ot(u,"int32",c)]}function AU(n,t,e){switch(e){case"reflect":return function ixe(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const r=2*t;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-t?e+r:-e-1}else if(e>t-1)if(t<=1)e=0;else{const r=2*t;e-=r*Math.trunc(e/r),e>=t&&(e=r-e-1)}return uc(0,e,t-1)}(n,t);case"wrap":return function oxe(n,t){let e=n;return e<0?t<=1?e=0:e+=t*(Math.trunc(-e/(t-1))+1):e>t-1&&(t<=1?e=0:e-=t*Math.trunc(e/(t-1))),uc(0,e,t-1)}(n,t);case"nearest":return function lxe(n,t){return uc(0,n,t-1)}(n,t);default:return function axe(n,t){return n}(n)}}function om(n,t,e,r,s,i,o,a,l,c,u){return 0<=a&&a<t&&0<=l&&l<e?n[o*r+a*s+l*i+c]:u}function cxe(n,t,e,r,s,i,o,a,l,c,u){return om(n,t,e,r,s,i,o,Math.round(a),Math.round(l),c,u)}function uxe(n,t,e,r,s,i,o,a,l,c,u){const d=Math.floor(a),h=Math.floor(l),f=d+1,p=h+1;return(f-a)*((p-l)*om(n,t,e,r,s,i,o,d,h,c,u)+(l-h)*om(n,t,e,r,s,i,o,d,p,c,u))+(a-d)*((p-l)*om(n,t,e,r,s,i,o,f,h,c,u)+(l-h)*om(n,t,e,r,s,i,o,f,p,c,u))}function RU(n,t,e,r){const s=ft(t,e)[0],i=[1,e[0],1];for(let p=0;p<s;p++)i[0]*=e[p];i[1]=e[s];for(let p=s+1;p<e.length;p++)i[2]*=e[p];const o={},a=new Int32Array(e[s]),l=new vr(i,r,n),c=[],u=1===i[0]&&1===i[2];for(let p=0;p<e[s];p++){let m;if(u)m=n[p].toString();else{const g=[];for(let y=0;y<i[0];y++)for(let b=0;b<i[2];b++)g.push(l.get(y,p,b));m=g.join(",")}if(void 0!==o[m])a[p]=o[m];else{const g=Object.keys(o).length;o[m]=g,a[p]=g,c.push(p)}}const d=i.slice();d[1]=Object.keys(o).length;const h=new vr(d,r);c.forEach((p,m)=>{for(let g=0;g<i[0];g++)for(let y=0;y<i[2];y++)h.set(l.get(g,p,y),g,m,y)});const f=e.slice();return f[s]=d[1],{outputValues:h.values,outputShape:f,indices:a}}const yxe=[bme,_me,xme,Cme,pme,Eme,Tme,Nme,Rme,Fme,Pme,Lme,Vme,Hme,jme,Kme,Yme,Qme,ege,gme,nge,ige,age,cge,hme,dge,fge,ume,pge,gge,yge,_ge,xge,Cge,Ege,Dge,kge,Age,Mge,Oge,$ge,Bge,zge,Uge,Wge,Gge,Kge,Xge,Yge,Zge,nye,tme,sye,iye,fye,pye,mye,yye,Eye,Iye,Tye,Nye,Mye,Oye,$ye,Bye,zye,Hye,jye,nme,qye,mge,Xye,Zye,Jye,rme,tbe,rbe,ibe,abe,cbe,hbe,pbe,ybe,_be,xbe,wbe,Sbe,Ibe,Tbe,Nbe,Rbe,Fbe,Pbe,Lbe,Vbe,Ube,jbe,Kbe,Jge,Ybe,Jbe,n_e,i_e,a_e,c_e,d_e,h_e,cU,g_e,ime,b_e,I_e,T_e,N_e,R_e,dme,r1,F_e,ome,ame,mme,P_e,L_e,V_e,U_e,W_e,j_e,q_e,X_e,Z_e,nve,sve,lve,cme,uve,hve,pve,rge,Gbe,gve,bve,vve,wve,Sve,Ive,Tve,Nve,Mve,Fve,Pve,Lve,Vve,Hve,Gve,Kve,vye,eye,Yve,{kernelName:yp,backendName:"cpu",kernelFunc:Zve},{kernelName:bp,backendName:"cpu",kernelFunc:function Jve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:i}=r;Te(s,"tile");const o=TU(e.bufferSync(s),i);return e.makeTensorInfo(o.shape,o.dtype,o.values)}},{kernelName:NE,backendName:"cpu",kernelFunc:function txe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:i,sorted:o}=r;Te(s,"topk");const a=e.data.get(s.dataId).values,[l,c]=NU(a,s.shape,s.dtype,i,o);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}},{kernelName:AE,backendName:"cpu",kernelFunc:function rxe(n){const{inputs:t,attrs:e,backend:r}=n,{image:s,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=e,[u,d,h,f]=s.shape,[p,m]=c??[d,h],g=[u,p,m,f],y=Le(s.shape),b=y[0],_=y[1],v=y[2],w=Le(g),C=w[0],I=w[1],D=w[2],T=br(s.dtype,X(g));T.fill(l);const N=r.data.get(s.dataId).values,$=r.data.get(i.dataId).values;for(let j=0;j<u;++j){const q=1===i.shape[0]?$:$.subarray(8*j,8*j+8);for(let K=0;K<p;++K)for(let P=0;P<m;++P)for(let B=0;B<f;++B){let L;const W=q[6]*P+q[7]*K+1;if(0===W)continue;const ie=(q[3]*P+q[4]*K+q[5])/W,de=AU((q[0]*P+q[1]*K+q[2])/W,h,a),ue=AU(ie,d,a);switch(o){case"nearest":L=cxe(N,d,h,b,_,v,j,ue,de,B,l);break;case"bilinear":L=uxe(N,d,h,b,_,v,j,ue,de,B,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}T[j*C+K*I+P*D+B]=L}return r.makeTensorInfo(g,s.dtype,T)}return{dataId:r.write(T,g,s.dtype),shape:s.shape,dtype:s.dtype}}},Ime,{kernelName:RE,backendName:"cpu",kernelFunc:function dxe(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:i}=t;Te(i,"unique");const o=r.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:c}=RU(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},{kernelName:Pb,backendName:"cpu",kernelFunc:function fxe(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s.shape.length,a=s.shape[i],l=new Array(o-1);let c=0;for(let f=0;f<o;f++)f!==i&&(l[c++]=s.shape[f]);const u=new Array(o).fill(0),d=s.shape.slice();d[i]=1;const h=new Array(a);for(let f=0;f<h.length;f++){u[i]=f;const p=Nc({inputs:{x:s},backend:e,attrs:{begin:u,size:d}});h[f]=on({inputs:{x:p},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(p)}return h}},{kernelName:$b,backendName:"cpu",kernelFunc:function mxe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:i}=t,{numSegments:o}=r;Te(s,"unsortedSegmentSum");const c=[],u=[],d=s.shape.length-i.shape.length;let h=i;for(let p=0;p<d;++p){const m=dv({inputs:{input:h},backend:e,attrs:{dim:p+1}});h=m,u.push(m)}for(let p=0;p<o;++p){const m=Ya(p,"int32"),g=e.makeTensorInfo([],"int32",m),y=B3({inputs:{a:g,b:h},backend:e}),b=vl({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),_=uv({inputs:{a:b,b:s},backend:e}),v=sm({inputs:{x:_},backend:e,attrs:{axis:0,keepDims:!1}});c.push(v),u.push(g),u.push(y),u.push(b),u.push(_),u.push(v)}const f=lU({inputs:c,backend:e,attrs:{axis:0}});return u.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}},u_e];for(const n of yxe)$E(n);const xl={},pv={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function go(n,t){if(!(n in xl)||null!=t){const r=function vxe(n,t){if(1!==n&&2!==n)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??function _xe(n){if(typeof OffscreenCanvas<"u"&&2===n)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(n);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete xl[n]},!1),G().getBool("SOFTWARE_WEBGL_ENABLED")&&(pv.failIfMajorPerformanceCaveat=!1),1===n?e.getContext("webgl",pv)||e.getContext("experimental-webgl",pv):e.getContext("webgl2",pv)}(n,t);if(null===r)return console.log("Could not get context for WebGL version",n),null;xl[n]=r}const e=xl[n];return null==e||e.isContextLost()?(delete xl[n],go(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),xl[n])}var Md=(()=>{return(n=Md||(Md={}))[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH",Md;var n})(),Vs=(()=>{return(n=Vs||(Vs={}))[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD",Vs;var n})(),Ir=(()=>{return(n=Ir||(Ir={}))[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",Ir;var n})();function am(n,t){return[t,n]}function mv(n){const t=X(n);return xS(Math.ceil(t/4))}function Fd(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function c1(n,t){const e=n;let r,s,i,o,a,l,c,u,d,h;return 2===G().getNumber("WEBGL_VERSION")?(r=e.R32F,s=e.R16F,i=e.RGBA16F,o=e.RGBA32F,a=e.RED,c=4,u=1,d=e.HALF_FLOAT,h=e.FLOAT,l=e.RGBA8):(r=n.RGBA,s=n.RGBA,i=n.RGBA,o=e.RGBA,a=n.RGBA,c=4,u=4,d=null!=t?t.HALF_FLOAT_OES:null,h=n.FLOAT,l=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:h}}function ye(n,t){const e=t();return G().getBool("DEBUG")&&function Cxe(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+function Dxe(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(n,t))}(n),e}function Ixe(n){return!!(G().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||5.96e-8<Math.abs(n)&&Math.abs(n)<65504)}function gv(n,t){return Da(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const Nxe=/ERROR: [0-9]+:([0-9]+):/g;function MU(n,t){const e=Nxe.exec(t);if(null==e)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(n);const r=+e[1],s=n.split("\n"),i=s.length.toString().length+2,o=s.map((d,h)=>Qu((h+1).toString(),i)+d);let a=0;for(let d=0;d<o.length;d++)a=Math.max(o[d].length,a);const l=o.slice(0,r-1),c=o.slice(r-1,r),u=o.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Qu(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function u1(n,t){if(ye(n,()=>n.validateProgram(t)),!1===n.getProgramParameter(t,n.VALIDATE_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function FU(n,t,e,r,s,i,o){const a=n.getAttribLocation(t,e);return-1!==a&&(ye(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),ye(n,()=>n.vertexAttribPointer(a,s,n.FLOAT,!1,i,o)),ye(n,()=>n.enableVertexAttribArray(a)),!0)}function zxe(n,t,e,r){ye(n,()=>function Lxe(n,t,e){(function PU(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+n.TEXTURE0;if(r<n.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(n,e),ye(n,()=>n.activeTexture(n.TEXTURE0+e)),ye(n,()=>n.bindTexture(n.TEXTURE_2D,t))}(n,t,r)),ye(n,()=>n.uniform1i(e,r))}function d1(n,t,e){ye(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),ye(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function OU(n,t){ye(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),ye(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function yv(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function Uxe(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(n,t))}function Da(n,t,e){const r=ye(n,()=>t());if(null==r)throw new Error(e);return r}function Od(n,t=2){return X(n.slice(0,n.length-t))}function Pd(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function bv(n){let t=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(t=[Od(n),...Pd(n)]),t}function _v(n){return n%2==0}function vv(n,t){if(It(n=n.slice(-2),t=t.slice(-2))||!n.length||!t.length||0===n[0]||0===n[1]||0===t[0]||0===t[1])return!0;if(n.length!==t.length){const e=n.slice(-1)[0],r=t.slice(-1)[0];if(e===r||_v(e)&&_v(r)&&(1===n[0]||1===t[0]))return!0}return n[1]===t[1]&&_v(n[0])&&_v(t[0])}let xv,wv;function Ui(n,t){return null!=n.getExtension(t)}function $U(n){try{if(null!=go(n))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function h1(n){const t=c1(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(i),o}function lm(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&S("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const Re=G();function es(){let n,t,e,r,s,i,o,a,l,c;return 2===G().getNumber("WEBGL_VERSION")?(n="#version 300 es",t="in",e="out",r="in",s="texture",i="outputColor",o="out vec4 outputColor;",a=G().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(n="",t="attribute",e="varying",r="varying",s="texture2D",i="gl_FragColor",o="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:n,attribute:t,varyingVs:e,varyingFs:r,texture2D:s,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}function Ac(n,t,e="index"){const r=Le(t);return r.map((s,i)=>`int ${n[i]} = ${e} / ${s}; ${i===r.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * ${s}`:`index -= ${n[i]} * ${s}`};`).join("")}function Cv(n,t,e="index"){const r=Le(t);return r.map((s,i)=>`int ${n[i]} = ${e} / outShapeStrides[${i}]; ${i===r.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`};`).join("")}function f1(n){const t=Le(n).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Re.registerFlag("HAS_WEBGL",()=>Re.getNumber("WEBGL_VERSION")>0),Re.registerFlag("WEBGL_VERSION",()=>$U(2)?2:$U(1)?1:0),Re.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Re.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===Re.get("WEBGL_VERSION")),Re.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Re.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Re.registerFlag("WEBGL_PACK",()=>Re.getBool("HAS_WEBGL")),Re.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_CLIP",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_PACK_REDUCE",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_LAZILY_UNPACK",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_CONV_IM2COL",()=>Re.getBool("WEBGL_PACK")),Re.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function Wxe(n){if(null==xv){const t=go(n);xv=t.getParameter(t.MAX_TEXTURE_SIZE)}return xv}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function jxe(n){if(null==wv){const t=go(n);wv=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,wv)}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Re.getNumber("WEBGL_VERSION");return 0===n?0:function Gxe(n){if(0===n)return 0;let t;const e=go(n);return t=Ui(e,"EXT_disjoint_timer_query_webgl2")&&2===n?2:Ui(e,"EXT_disjoint_timer_query")?1:0,t}(n)}),Re.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Re.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!X$()),Re.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function qxe(n){if(0===n)return!1;const t=go(n);if(1===n){if(!Ui(t,"OES_texture_float"))return!1}else if(!Ui(t,"EXT_color_buffer_float"))return!1;return h1(t)}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Re.getBool("WEBGL_FORCE_F16_TEXTURES")&&Re.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Re.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function Kxe(n){if(0===n)return!1;const t=go(n);if(1!==n){if(Ui(t,"EXT_color_buffer_float"))return h1(t);const r="EXT_color_buffer_half_float";if(Ui(t,r)){const s=t.getExtension(r);return function Xxe(n,t){const e=c1(n,t),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(o),a}(t,s)}return!1}return!(!Ui(t,"OES_texture_float")||!Ui(t,"WEBGL_color_buffer_float"))&&h1(t)}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function Yxe(n){return 2===n&&null!=go(n).fenceSync}(Re.getNumber("WEBGL_VERSION"))),Re.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Re.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Re.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),Re.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>X$()?1:-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)}),Re.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),Re.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),Re.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),Re.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),Re.registerFlag("WEBGL_EXP_CONV",()=>!1),Re.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Re.getBool("IS_TEST")),Re.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),Re.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),Re.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),Re.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const LU="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:BU}=lt;function Jxe(n,t,e){const r=[];if(n.forEach(f=>{const p=X(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?r.push(`uniform float ${f.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${f.name};`),r.push(`uniform int offset${f.name};`)),e.enableShapeUniforms){const{uniformShape:m}=m1(e.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${f.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${f.name}Shape;`)}r.push(`uniform ivec2 ${f.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(f=>{r.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});const s=r.join("\n"),i=n.map(f=>function e0e(n,t,e=!1,r){let s="";return s+=e?VU(n,r):$d(n,r),n.shapeInfo.logicalShape.length<=t.logicalShape.length&&(s+=e?function M0e(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=t.logicalShape.length,a=BU(n.shapeInfo.logicalShape,t.logicalShape),l=an(o),c=o-i;let u;const d=["x","y","z","w","u","v"];u=0===i?"":o<2&&a.length>=1?"coords = 0;":a.map(b=>`coords.${d[b+c]} = 0;`).join("\n");let h="";h=o<2&&i>0?"coords":n.shapeInfo.logicalShape.map((b,_)=>`coords.${d[_+c]}`).join(", ");let f="return outputValue;";const m=1===X(n.shapeInfo.logicalShape),y=1===X(t.logicalShape);if(1!==i||m||y){if(m&&!y)f=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const b=i-2,_=i-1;a.indexOf(b)>-1&&a.indexOf(_)>-1?f="return vec4(outputValue.x);":a.indexOf(b)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(_)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${u}\n      vec4 outputValue = get${r}(${h});\n      ${f}\n    }\n  `}(n,t):function F0e(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",a=n.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&null==n.shapeInfo.flatOffset&&It(n.shapeInfo.texShape,t.texShape))return`\n      float ${s}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const c=an(l),u=BU(n.shapeInfo.logicalShape,t.logicalShape),d=l-a;let h;const f=["x","y","z","w","u","v"];h=0===a?"":l<2&&u.length>=1?"coords = 0;":u.map(m=>`coords.${f[m+d]} = 0;`).join("\n");let p="";return p=l<2&&a>0?"coords":n.shapeInfo.logicalShape.map((m,g)=>`coords.${f[g+d]}`).join(", "),`\n    float ${s}() {\n      ${c} coords = getOutputCoords();\n      ${h}\n      return get${r}(${p});\n    }\n  `}(n,t)),s}(f,t,e.packedInputs,e.enableShapeUniforms)).join("\n"),o=t.texShape,a=es(),l=function r0e(n){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let c,u,d=function o0e(n){return`${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${a0e}\n    ${l0e}\n    ${c0e}\n  `}(a);return t.isPacked?(c=function t0e(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function d0e(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,e);case 2:return function _0e(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(It(n,t))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(n[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function f0e(n,t,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[2]/2),i=s*Math.ceil(n[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(n,t,e);default:return function m0e(n,t,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[n.length-1]/2),i=s*Math.ceil(n[n.length-2]/2);let o=i,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`\n      int b${c} = index / ${o};\n      index -= b${c} * ${o};\n    `+a,l=`b${c}, `+l;return`\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${n.length}(${l});\n    }\n  `}(n,t,e)}}(t.logicalShape,o,e.enableShapeUniforms),u=function i0e(n){return`\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `}(a)):(c=function n0e(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function h0e(n,t,e){return 1===t[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,e);case 2:return function v0e(n,t,e){return It(n,t)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===n[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function p0e(n,t,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${Cv(["r","c","d"],n)}\n    return ivec3(r, c, d);\n  }\n`;const r=Ac(["r","c","d"],n);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(n,t,e);case 4:return function g0e(n,t,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${Cv(["r","c","d","d2"],n)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=Ac(["r","c","d","d2"],n);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(n,t,e);case 5:return function y0e(n,t){const e=Ac(["r","c","d","d2","d3"],n);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(n,t);case 6:return function b0e(n,t){const e=Ac(["r","c","d","d2","d3","d4"],n);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}(t.logicalShape,o,e.enableShapeUniforms),u=function s0e(n){return`\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),e.packedInputs&&(d+=u0e),[d,l,u,s,c,i,e.userCode].join("\n")}function $d(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return function w0e(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[s,i]=n.shapeInfo.texShape;if(1===s&&1===i)return`\n      float ${r}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=Rc(e);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[a,l]=n.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${l}, ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 1:return function S0e(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Ld(n)}\n      }\n    `;const s=n.shapeInfo.texShape,i=s[0],o=s[1];if(1===o&&1===i)return`\n      float ${r}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=Rc(e);return 1===o?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 2:return function I0e(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape;if(null!=i&&It(e,i))return t?`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${i[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:o,keptDims:a}=Ka(e);if(o.length<e.length){const f=["row","col"];return`\n      ${$d(Bd(n,o),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${Vd(f,a)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Ld(n)}\n      }\n    `;const c=i[0],u=i[1],d=Rc(r);return 1===u?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===c?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${c}, ${u}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(n,t);case 3:return function T0e(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e[1]*e[2],o=e[2],{newShape:a,keptDims:l}=Ka(e);if(a.length<e.length){const g=["row","col","depth"];return`\n        ${$d(Bd(n,a),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${Vd(g,l)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${o}, 1)));\n        ${Ld(n)}\n      }\n    `;const u=n.shapeInfo.texShape,d=u[0],h=u[1],f=n.shapeInfo.flatOffset;if(h===i&&null==f)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===o&&null==f)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const p=Rc(r);return t?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${p};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${o} + depth + ${p};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(n,t);case 4:return function N0e(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e[3],o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:c}=Ka(e);if(l.length<e.length){const _=["row","col","depth","depth2"];return`\n      ${$d(Bd(n,l),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${Vd(_,c)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${o}, ${i}, 1)));\n        ${Ld(n)}\n      }\n    `;const u=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],f=d[1],p=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(f===a&&null==u)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${p}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(f===i&&null==u)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=Rc(r);return t?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${p}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${f}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(n,t);case 5:return function A0e(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t[4],i=t[3]*s,o=t[2]*i,a=t[1]*o,{newShape:l,keptDims:c}=Ka(t);if(l.length<t.length){const g=["row","col","depth","depth2","depth3"];return`\n      ${$d(Bd(n,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Vd(g,c)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${o}, ${i}, ${s})) +\n          depth3;\n        ${Ld(n)}\n      }\n    `;const u=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],f=d[1];if(f===a&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(f===s&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} + depth * ${i} +\n          depth2 * ${s} + depth3 + ${Rc(e)};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 6:return function R0e(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:s,keptDims:i}=Ka(t);if(s.length<t.length){const y=["row","col","depth","depth2","depth3","depth4"];return`\n      ${$d(Bd(n,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Vd(y,i)});\n      }\n    `}const o=t[5],a=t[4]*o,l=t[3]*a,c=t[2]*l,u=t[1]*c;if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${c}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${Ld(n)}\n      }\n    `;const d=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],p=h[1];if(p===u&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${l}, ${a}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(p===o&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${c} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${o} + depth4 + ${Rc(e)};\n      vec2 uv = uvFromFlat(${f}, ${p}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function VU(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return function x0e(n){const t=n.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${es().texture2D}(${t}, halfCR);\n    }\n  `}(n);case 1:return function C0e(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n.shapeInfo.texShape,i=es();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `;const o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `}(n,t);case 2:return function E0e(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=i[0],a=i[1],l=es();if(null!=i&&It(e,i))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${c[0]}, ${c[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(n,t);case 3:return function D0e(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===e[0]){const f=[1,2],m=["b","row","col"];return`\n        ${VU(Bd(n,e.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${Vd(m,f)});\n        }\n      `}const a=es();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `;const l=o[0],c=o[1],u=Math.ceil(e[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${c}, ${u*Math.ceil(e[1]/2)}, ${u}, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `}(n,t);default:return function k0e(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=es();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${e}, uv);\n    }\n  `;const i=n.shapeInfo.logicalShape,o=i.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],d=Math.ceil(i[o-1]/2);let h=d*Math.ceil(i[o-2]/2),f="int b, int row, int col",p=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<o-1;m++)f=`int b${m}, `+f,h*=i[o-m-1],p=`b${m} * ${h} + `+p;return`\n    vec4 ${r}(${f}) {\n      int index = ${p};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(n,t)}}const a0e="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",l0e="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",c0e="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",u0e="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function Rc(n){return`offset${n}`}function Ld(n){const t=n.name,e=X(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function an(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function m1(n,t,e){const{newShape:r,keptDims:s}=Ka(t),i=t.length,o=n&&3===i&&1===t[0],a=o?t.slice(1):r,l=!n&&i>1&&!It(t,e)&&r.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:t,keptDims:s}}function Bd(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function Vd(n,t){return t.map(e=>n[e]).join(", ")}function UU(n,t,e){const r={},s={},i={},o=[];let a,l,c,u=null,d=null;d=n.getUniformLocation(e,"NAN",!1),1===G().getNumber("WEBGL_VERSION")&&(u=n.getUniformLocation(e,"INFINITY",!1));const h=!1;for(let f=0;f<t.variableNames.length;f++){const p=t.variableNames[f];r[p]=n.getUniformLocation(e,p,h),r[`offset${p}`]=n.getUniformLocation(e,`offset${p}`,h),t.enableShapeUniforms&&(s[`${p}Shape`]=n.getUniformLocation(e,`${p}Shape`,h),i[`${p}TexShape`]=n.getUniformLocation(e,`${p}TexShape`,h))}return t.enableShapeUniforms&&(a=n.getUniformLocation(e,"outShape",h),c=n.getUniformLocation(e,"outShapeStrides",h),l=n.getUniformLocation(e,"outTexShape",h)),t.customUniforms&&t.customUniforms.forEach((f,p)=>{o[p]=n.getUniformLocation(e,f.name,h)}),{uniformLocations:r,customUniformLocations:o,infLoc:u,nanLoc:d,inShapesLocations:s,inTexShapesLocations:i,outShapeLocation:a,outShapeStridesLocation:c,outTexShapeLocation:l}}function HU(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,r)=>{const s=e.logicalShape,i=t[r],o=i.shape;if(!It(s,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${o} must match`);if(e.isUniform&&i.isUniform)return;const a=e.texShape,l=i.isUniform?null:i.texData.texShape;if(!It(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function ts(n){return G().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class L0e{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Md.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=es();this.outputShape=t,this.enableShapeUniforms=ts(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Cv(["r","c","d"],t):Ac(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class B0e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Md.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=es();this.outputShape=t,this.enableShapeUniforms=ts(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Cv(["r","c","d"],t):Ac(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class V0e{constructor(t){this.variableNames=["A"],this.outTexUsage=Vs.DOWNLOAD;const e=es();this.outputShape=t,this.userCode=`\n      ${LU}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class z0e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Vs.DOWNLOAD;const e=es();this.outputShape=t,this.userCode=`\n      ${LU}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const U0e={R:0,G:1,B:2,A:3};class WU{constructor(t,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=es();this.outputShape=t,this.enableShapeUniforms=ts(this.outputShape.length);let i="result";e&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<r.length;a++)o+=`\n          if(offset == ${a}) {\n            result = values[${U0e[r[a]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":f1(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${r.length});\n\n        flatIndex = idiv(flatIndex, ${r.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${s.texture2D}(A, uv);\n          ${o}\n        }\n        ${s.output} = vec4(${i}, 0., 0., 0.);\n      }\n    `}}class H0e{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=es();this.outputShape=t,this.enableShapeUniforms=ts(this.outputShape.length);let s="",i="result";e&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=2*o+a;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${o};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${l}] = values[0];\n            } else if (offset == 1) {\n              result[${l}] = values[1];\n            } else if (offset == 2) {\n              result[${l}] = values[2];\n            } else {\n              result[${l}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":f1(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${r.output} = ${i};\n        }\n    `}}function cm(n,t,e,r,s,i){!function Pxe(n,t){const e=G().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0)throw new Error(`Requested texture size [${n}x${t}] is invalid.`);if(n>e||t>e)throw new Error(`Requested texture size [${n}x${t}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(t,e);const o=function Oxe(n){return Da(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}(n),a=n.TEXTURE_2D;return ye(n,()=>n.bindTexture(a,o)),ye(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),ye(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),ye(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),ye(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),1===G().getNumber("WEBGL_VERSION")?ye(n,()=>n.texImage2D(a,0,r,t,e,0,s,i,null)):ye(n,()=>n.texStorage2D(a,1,r,t,e)),ye(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[e,t]}}function jU(n){return n.internalFormatFloat}function GU(n){return n.internalFormatHalfFloat}function qU(n){return n.downloadTextureFormat}function KU(n){return n.internalFormatPackedFloat}function XU(n){return n.internalFormatPackedHalfFloat}class g1{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=G().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function bxe(n,t){xl[n]=t}(e,t)):this.gl=go(e),t=this.gl,2===G().getNumber("WEBGL_VERSION")){const i=t;this.createVertexArray=()=>ye(i,()=>i.createVertexArray()),this.bindVertexArray=o=>ye(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>ye(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>ye(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(null!=t){const i=t.getExtension("OES_vertex_array_object");if(null==i)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ye(t,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>ye(t,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>ye(t,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>ye(t,()=>t.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===G().getNumber("WEBGL_VERSION")){const o="OES_texture_half_float";if(this.textureFloatExtension=gv(this.gl,"OES_texture_float"),Ui(this.gl,o))this.textureHalfFloatExtension=gv(this.gl,o);else if(G().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Ui(this.gl,s))this.colorBufferHalfFloatExtension=gv(this.gl,s);else if(G().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Ui(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!Ui(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function j0e(n){return function Mxe(n,t){const e=Da(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ye(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),ye(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function G0e(n){return function Fxe(n,t){const e=Da(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ye(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),ye(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function $xe(n){return Da(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=c1(this.gl,this.textureHalfFloatExtension)}get debug(){return G().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;ye(t,()=>t.finish()),ye(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),ye(t,()=>t.deleteFramebuffer(this.framebuffer)),ye(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),ye(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),ye(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function q0e(n,t,e,r){const[s,i]=am(t,e);return cm(n,s,i,jU(r),r.textureFormatFloat,n.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function K0e(n,t,e,r){const[s,i]=am(t,e);return cm(n,s,i,GU(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function X0e(n,t,e,r){const[s,i]=am(t,e);return cm(n,s,i,qU(r),n.RGBA,n.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function ewe(n,t,e){ye(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?2===G().getNumber("WEBGL_VERSION")?ye(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):ye(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):2===G().getNumber("WEBGL_VERSION")?ye(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):ye(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),ye(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,r,s){this.throwIfDisposed(),function J0e(n,t,e,r,s,i){let o,a,l;ye(n,()=>n.bindTexture(n.TEXTURE_2D,t)),s instanceof Uint8Array?(o=new Uint8Array(e*r*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(e*r*4),a=n.FLOAT,l=i.internalFormatPackedFloat),o.set(s),2===G().getNumber("WEBGL_VERSION")?ye(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,r,n.RGBA,a,o)):ye(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,e,r,0,n.RGBA,a,o)),ye(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function Z0e(n,t,e,r){const[s,i]=Fd(t,e);return cm(n,s,i,XU(r),n.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function Y0e(n,t,e,r){const[s,i]=Fd(t,e);return cm(n,s,i,KU(r),n.RGBA,n.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(OU(this.gl,this.framebuffer),this.outputTexture=null),ye(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function rwe(n,t,e,r){const[s,i]=am(t,e),a=new Uint8Array(function xxe(n,t){return n*t}(t*e,4));return ye(n,()=>n.readPixels(0,0,s,i,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,r,s,i,o){return function swe(n,t,e,r,s,i,o,a){const l=n,c=new Float32Array(function wxe(n,t){const[e,r]=Fd(n,t);return e*r*4}(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}(this.gl,t,0,0,0,i,o)}downloadFloat32MatrixFromBuffer(t,e){return function nwe(n,t,e){const r=n,s=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,t,e)}createBufferFromTexture(t,e,r){this.bindTextureToFrameBuffer(t);const s=function twe(n,t,e,r){const s=n.createBuffer();ye(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const a=16*t*e;return ye(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),ye(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),ye(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,r;if(G().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,i=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{const o=s.clientWaitSync(i,0,0);return o===s.ALREADY_SIGNALED||o===s.CONDITION_SATISFIED},e=i}else G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function iwe(n,t,e){const r=new Float32Array(t*e*4);return ye(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,r)),r}(this.gl,e,r))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function W0e(n){const t=es();return function Txe(n,t){const e=Da(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ye(n,()=>n.shaderSource(e,t)),ye(n,()=>n.compileShader(e)),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(n,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const r=function Axe(n){return Da(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}(e);let s;return ye(e,()=>e.attachShader(r,this.vertexShader)),ye(e,()=>e.attachShader(r,t)),function Rxe(n,t){if(ye(n,()=>n.linkProgram(t)),!G().get("ENGINE_COMPILE_ONLY")&&!1===n.getProgramParameter(t,n.LINK_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(e,r),s=Object.assign(r,{vao:this.createVertexArray()}),this.bindVertexArray(s.vao),ye(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(function Q0e(n,t,e){return ye(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),FU(n,t,"clipSpacePos",e,3,20,0)&&FU(n,t,"uv",e,2,20,12)}(e,s,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&u1(e,s),this.setProgram(s),s}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(ye(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&(this.bindVertexArray(this.program.vao),this.debug&&u1(this.gl,this.program)),ye(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,r=!0){return this.throwIfDisposed(),r?function Bxe(n,t,e){return Da(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}(this.gl,t,e):function Vxe(n,t,e){return n.getUniformLocation(t,e)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),ye(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),zxe(this.gl,t,e,r)}setOutputMatrixTexture(t,e,r){this.setOutputMatrixTextureDriver(t,r,e)}setOutputPackedMatrixTexture(t,e,r){this.throwIfDisposed();const[s,i]=Fd(e,r);this.setOutputMatrixTextureDriver(t,s,i)}setOutputMatrixWriteRegion(t,e,r,s){this.setOutputMatrixWriteRegionDriver(r,t,s,e)}setOutputPackedMatrixWriteRegion(t,e,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&u1(this.gl,this.program),yv(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ye(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ye(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=gv(this.gl,2===G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,i),i}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return ee(function*(){return yield k$(()=>e.disposed||e.isQueryAvailable(t,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function owe(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in G().platform&&(r=G().platform.setTimeoutCustom.bind(G().platform)),k$(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),d1(this.gl,t,this.framebuffer),this.debug&&yv(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(d1(this.gl,this.outputTexture,this.framebuffer),this.debug&&yv(this.gl)):OU(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,e,r){this.throwIfDisposed();const s=this.gl;d1(s,t,this.framebuffer),this.debug&&yv(s),this.outputTexture=t,ye(s,()=>s.viewport(0,0,e,r)),ye(s,()=>s.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(t,e,r,s){this.throwIfDisposed(),ye(this.gl,()=>this.gl.scissor(t,e,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:awe,bincountImpl:YU,bincountReduceImpl:lwe,castImpl:cwe,ceilImpl:uwe,concatImpl:dwe,equalImpl:hwe,expImpl:fwe,expm1Impl:pwe,floorImpl:mwe,gatherNdImpl:gwe,gatherV2Impl:ywe,greaterImpl:bwe,greaterEqualImpl:_we,lessImpl:vwe,lessEqualImpl:xwe,linSpaceImpl:wwe,logImpl:Cwe,maxImpl:Swe,maximumImpl:Ewe,minimumImpl:Iwe,multiplyImpl:Dwe,negImpl:Twe,notEqualImpl:kwe,prodImpl:Nwe,raggedGatherImpl:Awe,raggedRangeImpl:Rwe,raggedTensorToTensorImpl:Mwe,rangeImpl:Fwe,rsqrtImpl:Owe,scatterImpl:Pwe,sigmoidImpl:$we,simpleAbsImpl:ZU,sliceImpl:Lwe,sparseFillEmptyRowsImpl:Bwe,sparseReshapeImpl:Vwe,sparseSegmentReductionImpl:QU,sqrtImpl:zwe,stridedSliceImpl:Uwe,stringNGramsImpl:Hwe,stringSplitImpl:Wwe,stringToHashBucketFastImpl:jwe,subImpl:Gwe,tileImpl:qwe,topKImpl:Kwe,transposeImpl:y1,uniqueImpl:Xwe}=k;function JU(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function ns(n,t){return 1===t?[n]:JU(n,t)}class Zwe{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=ts(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=ns("rc",this.rank),r=an(this.rank),s=this.getOutOfBoundsCondition(e),i=this.getSetup(e),o=this.getOutput(e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let i=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${t[t.length-1-o]},`+i;e.push(i)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class e4{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=ts(this.outputShape.length);let r="";for(let s=0;s<4;s++){let i="thisRC = rc;";s%2==1&&(i+="thisRC.z += 1;"),s>1&&(i+="thisRC.y += 1;"),r+=`\n        ${i}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}this.userCode=`\n      ${function Qwe(n,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?function Qxe(n,t,e="index"){const s=function Zxe(n,t){const e=n.length,r=n.map(i=>`${t}[${i}]`),s=new Array(e-1);s[e-2]=r[e-1];for(let i=e-3;i>=0;--i)s[i]=`(${s[i+1]} * ${r[i+1]})`;return s}(n.map((i,o)=>o),t);return s.map((i,o)=>`int ${n[o]} = ${e} / ${s[o]}; ${o===s.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${s[o]}`:`index -= ${n[o]} * ${s[o]}`};`).join("")}(["r","c","d"],"inputShape"):Ac(["r","c","d"],n)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":f1(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class Jwe{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,r){const s=n4(e,r),i=r4(t,s,r);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=t4(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].shift();return this.usedTextures[i].push(l),l}let a;return s===Ir.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===Ir.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===Ir.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===Ir.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===Ir.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(t,e,r,s){if(null==this.freeTextures)return;const i=n4(r,s),o=r4(e,i,s);o in this.freeTextures||(this.freeTextures[o]=[]);const a=t4(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=G().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],u=c.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(u,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function t4(n,t,e,r,s){const i=function tCe(n,t){switch(n){case Ir.PACKED_2X2_FLOAT32:return KU(t);case Ir.PACKED_2X2_FLOAT16:return XU(t);case Ir.UNPACKED_FLOAT32:return jU(t);case Ir.UNPACKED_FLOAT16:return GU(t);case Ir.PACKED_4X1_UNSIGNED_BYTE:return qU(t);default:throw new Error(`Unknown physical texture type ${n}`)}}(t,r);let o;if(s){const[l,c]=Fd(n[0],n[1]);o=l*c}else{const[l,c]=am(n[0],n[1]);o=l*c}const a=function eCe(n,t){if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(e,i);return o*a}function n4(n,t){if(n===Vs.UPLOAD)return Ir.PACKED_2X2_FLOAT32;if(n===Vs.RENDER||null==n)return function nCe(n){return G().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Ir.PACKED_2X2_FLOAT32:Ir.UNPACKED_FLOAT32:n?Ir.PACKED_2X2_FLOAT16:Ir.UNPACKED_FLOAT16}(t);if(n===Vs.DOWNLOAD||n===Vs.PIXELS)return Ir.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function r4(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class jo{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=ts(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const s4="return abs(x);",wl="return x;";class Cl{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=ts(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class fCe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=ts(this.outputShape.length);const e=t.length,r=ns("rc",e),s=an(e),i=function Ywe(n,t){if(1===n)return"rc";let e="";for(let r=0;r<n;r++)e+=t[r],r<n-1&&(e+=",");return e}(e,r),o=r.slice(-2),a=e<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${i});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const pCe=eD,Ev={},bCe=G().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let xCe=(()=>{class n extends _S{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!G().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=e){if(e instanceof g1)r=e;else{const s=go(G().getNumber("WEBGL_VERSION"),e);r=new g1(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=go(G().getNumber("WEBGL_VERSION"));r=new g1(s),this.binaryCache=function yCe(n){return n in Ev||(Ev[n]={}),Ev[n]}(G().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Jwe(this.gpgpu),this.numMBBeforeWarning=function vCe(){return null==G().global.screen?1024:G().global.screen.height*G().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new D$(this,Mo())}nextDataId(){return n.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,s,i,o,a){const l=this.makeTensorInfo(r,s),c=this.texData.get(l.dataId);c.isPacked=!1,c.texture={texture:e,texShape:[i,o]},c.texShape=[i,o];const u=bv(r),d=new WU(u,!1,a),h=this.runWebGLProgram(d,[l],s,[[i,o]]);return h.shape=r,c.texture=null,this.disposeIntermediateTensorInfo(l),h.dataId}write(e,r,s){if((G().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||G().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===s&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:r,dtype:s,values:e,usage:Vs.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,s,i,o){if(G().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===i)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:i,values:r,usage:Vs.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:s,dtype:i,complexTensorInfos:o,slice:a,shape:l,isPacked:c}=r;if(null!=a){let f;f=c?new Cl(l,wl):new jo(l,wl);const p=this.runWebGLProgram(f,[{dataId:e,shape:l,dtype:i}],i),m=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),m}if(null!=s)return this.convertAndCacheOnCPU(e);if("string"===i)return s;const u=null!=this.activeTimers;let d,h;return u&&(d=ps()),h="complex64"===i?wa(this.readSync(o.real.dataId),this.readSync(o.imag.dataId)):this.getValuesFromTexture(e),u&&(this.downloadWaitMs+=ps()-d),this.convertAndCacheOnCPU(e,h)}read(e){var r=this;return ee(function*(){if(r.pendingRead.has(e)){const g=r.pendingRead.get(e);return new Promise(y=>g.push(y))}const s=r.texData.get(e),{values:i,shape:o,slice:a,dtype:l,complexTensorInfos:c,isPacked:u}=s;if(null!=a){let g;g=u?new Cl(o,wl):new jo(o,wl);const y=r.runWebGLProgram(g,[{dataId:e,shape:o,dtype:l}],l),b=r.read(y.dataId);return r.disposeIntermediateTensorInfo(y),b}if(null!=i)return r.convertAndCacheOnCPU(e);if(G().getBool("DEBUG")&&!G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===G().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h,f,d=null;if("complex64"!==l&&G().get("WEBGL_BUFFER_SUPPORTED")){h=r.decode(e);const g=r.texData.get(h.dataId);d=r.gpgpu.createBufferFromTexture(g.texture.texture,...mv(o))}if(r.pendingRead.set(e,[]),"complex64"!==l&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===l){const g=yield Promise.all([r.read(c.real.dataId),r.read(c.imag.dataId)]);f=wa(g[0],g[1])}else if(null==d)f=r.getValuesFromTexture(e);else{const g=X(o);f=r.gpgpu.downloadFloat32MatrixFromBuffer(d,g)}if(null!=h&&r.disposeIntermediateTensorInfo(h),null!=d){const g=r.gpgpu.gl;ye(g,()=>g.deleteBuffer(d))}const p=r.convertAndCacheOnCPU(e,f),m=r.pendingRead.get(e);return r.pendingRead.delete(e),m.forEach(g=>g(p)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&Mo().removeDataId(e,r),r.pendingDeletes--),p})()}readToGPU(e,r={}){const s=this.texData.get(e),{values:i,shape:o,slice:a,dtype:l,isPacked:c,texture:u}=s;if("complex64"===l)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let p;p=c?new Cl(o,wl):new jo(o,wl);const m=this.runWebGLProgram(p,[{dataId:e,shape:o,dtype:l}],l),g=this.readToGPU(m,r);return this.disposeIntermediateTensorInfo(m),g}if(null==u)throw null!=i?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,r.customTexShape),h=Mo().makeTensorFromTensorInfo(d),f=this.texData.get(d.dataId);return Object.assign({tensorRef:h},f.texture)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(i=>Qa(i));return ot(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ot(e.shape,e.dtype,r)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const s=e[r];if(!Ixe(s))throw G().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:s,isPacked:i}=this.texData.get(e),o=X(r);if(G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),p=this.texData.get(f.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...mv(r)).subarray(0,o);return this.disposeIntermediateTensorInfo(f),m}const a=G().getBool("WEBGL_PACK")&&!0===i,l=a?bv(r):r,c=a?new z0e(l):new V0e(l),u=this.runWebGLProgram(c,[{shape:l,dtype:s,dataId:e}],"float32"),d=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;const s=this.activeTimers,i=[];let o=!1;null==this.programTimersStack?(this.programTimersStack=i,o=!0):this.activeTimers.push(i),this.activeTimers=i,e();const a=Yu(this.activeTimers.map(u=>u.query)).filter(u=>null!=u),l=Yu(this.activeTimers.map(u=>u.name)).filter(u=>null!=u);this.activeTimers=s,o&&(this.programTimersStack=null);const c={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return ee(function*(){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=yield Promise.all(a);c.kernelMs=function Ate(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}(u),c.getExtraProfileInfo=()=>u.map((d,h)=>({name:l[h],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else c.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,c})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ps(),endMs:null}}endTimer(e){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=ps(),e)}getQueryTime(e){var r=this;return ee(function*(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return null!=s&&(this.disposeData(s.real.dataId,r),this.disposeData(s.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:s,texShape:i,usage:o,isPacked:a,slice:l}=this.texData.get(e),c=l&&l.origDataId||e,u=this.dataRefCount.get(c);u>1?this.dataRefCount.set(c,u-1):(this.dataRefCount.delete(c),null!=r&&(this.numBytesInGPU-=this.computeBytes(i,s),this.textureManager.releaseTexture(r,i,o,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=bCe){return G().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>null==this.texData.get(s.dataId).texture&&X(s.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){si("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return pCe(e.shape,r)}packedUnaryOp(e,r,s){const i=new Cl(e.shape,r),o=this.compileAndRun(i,[e],s);return Mo().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const i=ZU(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(G().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,s4,e.dtype);const r=new jo(e.shape,s4),s=this.compileAndRun(r,[e]);return Mo().makeTensorFromTensorInfo(s)}makeTensorInfo(e,r,s){let i;if("string"===r&&null!=s&&s.length>0&&Cf(s[0])){const o=s.map(a=>Za(a));i=this.write(o,e,r)}else i=this.write(s,e,r);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:r}}makeOutput(e,r,s){return Mo().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,s),this)}unpackTensor(e){const r=new fCe(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new Zwe(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const s=[Od(e.shape),...Pd(e.shape)],i={dtype:e.dtype,shape:s,dataId:e.dataId},o=[Od(r),...Pd(r)],a=new e4(o,s),u=this.runWebGLProgram(a,[i],e.dtype,[s],!0);return{dataId:u.dataId,shape:r,dtype:u.dtype}}decode(e,r){const s=this.texData.get(e),{isPacked:i,shape:o,dtype:a}=s;null!=r&&S(X(o)<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const l=bv(o);let c;c=i?new B0e(l):new L0e(l);const d=[r??mv(l)];return{dtype:a,shape:o,dataId:this.runWebGLProgram(c,[{shape:l,dtype:a,dataId:e}],a,d,!0,r).dataId}}runWebGLProgram(e,r,s,i,o=!1,a){const l=this.makeTensorInfo(e.outputShape,s),c=this.texData.get(l.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===Md.DENSE){const b=a??mv(e.outputShape);c.texShape=b.map(_=>2*_)}if(null!=e.outTexUsage&&(c.usage=e.outTexUsage),0===X(l.shape))return c.values=br(l.dtype,0),l;const u=[],d=r.map(b=>{if("complex64"===b.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let _=this.texData.get(b.dataId);if(null==_.texture){if(!e.packedInputs&&X(b.shape)<=G().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:_.values};e.packedInputs&&(_.isPacked=!0,_.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!_.isPacked!=!!e.packedInputs)b=_.isPacked?this.unpackTensor(b):this.packTensor(b),u.push(b),_=this.texData.get(b.dataId);else if(_.isPacked&&!vv(_.shape,b.shape)){const v=b,w=b.shape;b.shape=_.shape,b=this.packedReshape(b,w),u.push(b),_=this.texData.get(b.dataId),v.shape=w}return{shape:b.shape,texData:_,isUniform:!1}});this.uploadToGPU(l.dataId);const h={shape:l.shape,texData:c,isUniform:!1},f=function $0e(n,t,e){let r="";t.concat(e).forEach(o=>{const a=null!=o.texData&&null!=o.texData.slice&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:d}=m1(n.packedInputs,o.shape,l);let h="",f="",p="";if(1===u.length&&n.packedInputs){const w=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${w[0]>1}_${w[1]>1}`}else if(2!==u.length||n.packedInputs){if(u.length>2&&!n.packedInputs){const w=Le(u);p=`${w[0]===l[1]}_${w[w.length-1]===l[1]}`}}else f=`${u[0]>1}_${u[1]>1}`;const m=o.shape.length,g=2===u.length&&It(o.shape,l),y=1===X(o.shape),b=cd(o.shape,e.shape),_=!n.packedInputs&&m===e.shape.length&&It(l,e.texData.texShape);r+=`${m}_${_}_${c?d:""}_${u.length}_${y}_${b}_${g}_${h}_${f}_${p}_${n.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`}_${a}`}else r+=`${o.shape}_${o.isUniform?"uniform":o.texData.texShape}_${a}`});let i=n.constructor.name;return i+="_"+r+"_"+n.userCode+`${G().getNumber("WEBGL_VERSION")}`,i}(e,d,h),p=this.getAndSaveBinary(f,()=>function O0e(n,t,e,r){const s=e.map((u,d)=>{const h={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:!u.isUniform&&u.texData.isPacked,flatOffset:null};return null!=u.texData&&null!=u.texData.slice&&u.texData.slice.flatOffset>0&&(h.flatOffset=u.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:h}}),i=s.map(u=>u.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=Jxe(s,o,t),l=function kxe(n,t){const e=Da(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ye(n,()=>n.shaderSource(e,t)),ye(n,()=>n.compileShader(e)),G().get("ENGINE_COMPILE_ONLY"))return e;if(!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw MU(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(n.gl,a),c=n.createProgram(l);return G().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o},UU(n,t,c))}(this.gpgpu,e,d,h)),m=null!=this.activeTimers;let g;m&&(g=this.startTimer()),G().get("ENGINE_COMPILE_ONLY")||function P0e(n,t,e,r,s){t.program.enableShapeUniforms||(HU(t.inShapeInfos,e),HU([t.outShapeInfo],[r]));const i=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(t.webGLProgram),1===G().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&n.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&n.gl.uniform1f(t.nanLoc,NaN),e.forEach((l,c)=>{const u=t.program.variableNames[c],d=t.uniformLocations[u],h=t.uniformLocations[`offset${u}`],f=t.inShapesLocations[`${u}Shape`],p=t.inTexShapesLocations[`${u}TexShape`];if(f){const{uniformShape:m}=m1(t.program.packedInputs,l.shape,l.texData.texShape);switch(m.length){case 1:n.gl.uniform1iv(f,new Int32Array(m));break;case 2:n.gl.uniform2iv(f,new Int32Array(m));break;case 3:n.gl.uniform3iv(f,new Int32Array(m));break;case 4:n.gl.uniform4iv(f,new Int32Array(m))}}if(p&&n.gl.uniform2i(p,l.texData.texShape[0],l.texData.texShape[1]),null!=d){if(l.isUniform){if(X(l.shape)<2)n.gl.uniform1f(d,l.uniformValues[0]);else{let m=l.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),n.gl.uniform1fv(d,m)}return}null!=l.texData.slice&&null!=h&&n.gl.uniform1i(h,l.texData.slice.flatOffset),n.setInputMatrixTexture(l.texData.texture.texture,d,c)}});const a=t.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const l=Le(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l))}}t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s&&t.program.customUniforms.forEach((l,c)=>{const u=t.customUniformLocations[c],d=s[c];if("float"===l.type)n.gl.uniform1fv(u,d);else if("vec2"===l.type)n.gl.uniform2fv(u,d);else if("vec3"===l.type)n.gl.uniform3fv(u,d);else if("vec4"===l.type)n.gl.uniform4fv(u,d);else if("int"===l.type)n.gl.uniform1iv(u,d);else if("ivec2"===l.type)n.gl.uniform2iv(u,d);else if("ivec3"===l.type)n.gl.uniform3iv(u,d);else{if("ivec4"!==l.type)throw Error(`uniform type ${l.type} is not supported yet.`);n.gl.uniform4iv(u,d)}}),n.executeProgram()}(this.gpgpu,p,d,h,i),u.forEach(b=>this.disposeIntermediateTensorInfo(b)),m&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const y=G().get("WEBGL_FLUSH_THRESHOLD");if(y>0){const b=ps();b-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!G().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&!1===o){const b=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),b}return l}compileAndRun(e,r,s,i,o=!1){return this.runWebGLProgram(e,r,s=s||r[0].dtype,i,o)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(G().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=V(()=>{if(!G().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=G().getBool("DEBUG");G().set("DEBUG",!1);const r=this.abs(Be(1e-8)).dataSync()[0];if(G().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:s,dtype:i,values:o,texture:a,usage:l,isPacked:c}=r;if(null!=a)return;const u=null!=this.activeTimers;let d;u&&(d=ps());let h=r.texShape;if(null==h&&(h=function Hxe(n,t=!1){let e=G().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=G().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&G().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),t&&(e*=2,r*=2,1===(n=n.map((a,l)=>l>=n.length-2?vS(n[l]):n[l])).length&&(n=[2,n[0]])),2!==n.length&&(n=Ka(n).newShape);let s=X(n),i=null;n.length<=1&&s<=e?i=[1,s]:2===n.length&&n[0]<=e&&n[1]<=e?i=n:3===n.length&&n[0]*n[1]<=e&&n[2]<=e?i=[n[0]*n[1],n[2]]:3===n.length&&n[0]<=e&&n[1]*n[2]<=e?i=[n[0],n[1]*n[2]]:4===n.length&&n[0]*n[1]*n[2]<=e&&n[3]<=e?i=[n[0]*n[1]*n[2],n[3]]:4===n.length&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(i=[n[0],n[1]*n[2]*n[3]]);const o=null!=i&&Math.max(...i)>r&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(null==i||o)if(t){const a=Od(n);let l=2,c=2;n.length&&([l,c]=Pd(n)),s=a*(l/2)*(c/2),i=xS(s).map(u=>2*u)}else i=xS(s);return i}(s,c),r.texShape=h),null!=o){const f=bv(s);let p,m=h[1],g=h[0];const y=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(c||!y)&&([m,g]=Fd(h[0],h[1])),p=c?new H0e(f,y):new WU(f,y);const b=y?[g,m]:h,_=this.makeTensorInfo(b,i),v=this.texData.get(_.dataId);v.usage=y?Vs.PIXELS:Vs.UPLOAD,v.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(_.dataId),m,g,o);const I=this.runWebGLProgram(p,[_],i,[[g,m]],!0),D=this.texData.get(I.dataId);r.texShape=D.texShape,r.isPacked=D.isPacked,r.usage=D.usage,G().get("ENGINE_COMPILE_ONLY")?this.disposeData(I.dataId):(r.texture=D.texture,r.values=null,this.texData.delete(I.dataId)),this.disposeIntermediateTensorInfo(_),u&&(this.uploadWaitMs+=ps()-d)}else{const f=this.acquireTexture(h,l,i,c);r.texture=f}}convertAndCacheOnCPU(e,r){const s=this.texData.get(e),{dtype:i}=s;return null!=r&&(s.values=function wCe(n,t){if("float32"===t||"complex64"===t)return n;if("int32"===t||"bool"===t){const e="int32"===t?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<e.length;++r)e[r]=Math.round(n[r]);return e}throw new Error(`Unknown dtype ${t}`)}(r,i)),s.values}acquireTexture(e,r,s,i){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,i)}computeBytes(e,r){return e[0]*e[1]*wS(r)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return ee(function*(){const r=[];if(e.gpgpu.parallelCompilationExtension){for(const[,s]of Object.entries(e.binaryCache))r.push(e.checkCompletionAsync_(s));return Promise.all(r)}for(const[,s]of Object.entries(e.binaryCache)){const i=new Promise(o=>{try{e.checkCompletion_(s),o(!0)}catch(a){throw a}});r.push(i)}return Promise.all(r)})()}checkCompletionAsync_(e){var r=this;return ee(function*(){return r.gpgpu.gl.getProgramParameter(e.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(e):(yield WB(),r.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(MU(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:r,customUniformLocations:s,infLoc:i,nanLoc:o,inShapesLocations:a,inTexShapesLocations:l,outShapeLocation:c,outShapeStridesLocation:u,outTexShapeLocation:d}=UU(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=r,e.customUniformLocations=s,e.infLoc=i,e.nanLoc=o,e.inShapesLocations=a,e.inTexShapesLocations=l,e.outShapeLocation=c,e.outShapeStridesLocation=u,e.outTexShapeLocation=d}}createTensorFromTexture(e,r,s){const{texture:i,height:o,width:a,channels:l}=e,c=Mo().backend;if(!c.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=c.writeTexture(i,r,s,o,a,l);return Mo().makeTensorFromDataId(u,r,s,c)}}return n.nextDataId=0,n})();Y$()&&FL("webgl",()=>new xCe,2);class zd{constructor(t,e,r){this.variableNames=["A","B"],this.outputShape=et(e,r),this.enableShapeUniforms=ts(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class dm{constructor(t,e,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=et(e,r);const i=this.outputShape.length;this.enableShapeUniforms=ts(i);let o="";if(s)if(0===i||1===X(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(o=`\n          ${an(i)} coords = getOutputCoords();\n        `,1===i)o+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const l=ns("coords",i);o+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${l[i-2]} + 1) >= outShape[${i} - 2];\n            bool nextColOutOfBounds =\n              (${l[i-1]} + 1) >= outShape[${i} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};\n            bool nextColOutOfBounds =\n              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${o}\n\n        setOutput(result);\n      }\n    `}}function zs(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const ECe={kernelName:jf,backendName:"webgl",kernelFunc:zs};function Sl(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,i=e.makeTensorInfo(r.shape,"complex64"),o=e.texData.get(i.dataId),a=zs({inputs:{x:r},backend:e}),l=zs({inputs:{x:s},backend:e});return o.complexTensorInfos={real:a,imag:l},i}const ICe={kernelName:OS,backendName:"webgl",kernelFunc:Sl},o4="return (a < 0.) ? b * a : a;",a4="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",TCe={kernelName:ib,backendName:"webgl",kernelFunc:function DCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:i}=r,o=e.makeTensorInfo([],"float32",Ya(i,"float32")),a=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new dm(a4,s.shape,o.shape):new zd(o4,s.shape,o.shape),l=e.runWebGLProgram(a,[s,o],"float32");return e.disposeIntermediateTensorInfo(o),l}},l4="return (a < 0.) ? b * a : a;",c4="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",NCe={kernelName:Sb,backendName:"webgl",kernelFunc:function kCe(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t,i=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new dm(c4,r.shape,s.shape):new zd(l4,r.shape,s.shape);return e.runWebGLProgram(i,[r,s],"float32")}};function Nt({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:r}){return({inputs:s,backend:i})=>{const{x:o}=s,a=i,l=r||o.dtype;if(a.shouldExecuteOnCPU([o])&&null!=e){const d=a.texData.get(o.dataId),h=e(d.values,l);return a.makeTensorInfo(o.shape,l,h)}let u;return u=G().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new Cl(o.shape,t):new jo(o.shape,n),a.runWebGLProgram(u,[o],l)}}function Rr({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(r&&"complex64"===l.dtype){const p=u.texData.get(l.dataId),m=u.texData.get(c.dataId),[g,y]=[[p.complexTensorInfos.real,m.complexTensorInfos.real],[p.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(_=>{const[v,w]=_,C={dataId:v.dataId,dtype:v.dtype,shape:l.shape},I={dataId:w.dataId,dtype:w.dtype,shape:c.shape},D=new zd(n,l.shape,c.shape);return u.runWebGLProgram(D,[C,I],Fs(v.dtype,w.dtype))}),b=Sl({inputs:{real:g,imag:y},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(y),b}const d=i||Fs(l.dtype,c.dtype);if(("string"===l.dtype||"string"===c.dtype||u.shouldExecuteOnCPU([l,c]))&&null!=s){const p=u.texData.get(l.dataId).values,m=u.texData.get(c.dataId).values,g="string"===l.dtype?xc(p):p,y="string"===l.dtype?xc(m):m,[b,_]=s(l.shape,c.shape,g,y,d),v=u.makeTensorInfo(_,d);return u.texData.get(v.dataId).values=b,v}let f;return f=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new dm(t,l.shape,c.shape,e):new zd(n,l.shape,c.shape),u.runWebGLProgram(f,[l,c],d)}}function hm(n,t=!1){if("linear"===n)return"return x;";if("relu"===n)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===n)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===n)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===n)return t?c4:l4;if("leakyrelu"===n)return t?a4:o4;if("sigmoid"===n)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class u4{constructor(t,e,r,s=!1,i=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=ts(this.outputShape.length);const d=Math.ceil((s?t[1]:t[2])/2),h=s?"i * 2, rc.y":"rc.y, i * 2",f=i?"rc.z, i * 2":"i * 2, rc.z",p=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";a&&(g=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:c?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,y="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let _="rc.x",v="rc.x";t[0]<e[0]?_=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(v=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`\n      ${g}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${d}; i++) {\n          int batchA = ${_};\n          int batchB = ${v};\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${f});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${m[0]});\n          result += (${p[1]} * ${m[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${y}\n\n        setOutput(result);\n      }\n    `}}class h4{constructor(t,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=et(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const f4="return a * b;";function _1(n){const{inputs:t,backend:e}=n,{a:r,b:s}=t,i=Fs(r.dtype,s.dtype);if("complex64"===r.dtype){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),c=new h4("return areal * breal - aimag * bimag;",r.shape,s.shape),u=new h4("return areal * bimag + aimag * breal;",r.shape,s.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],h=e.runWebGLProgram(c,d,"float32"),f=e.runWebGLProgram(u,d,"float32"),p=Sl({inputs:{real:h,imag:f},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}if(e.shouldExecuteOnCPU([r,s])){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),[c,u]=Dwe(r.shape,s.shape,a.values,l.values,i),d=e.makeTensorInfo(u,i);return e.texData.get(d.dataId).values=c,d}let o;return o=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new dm(f4,r.shape,s.shape):new zd(f4,r.shape,s.shape),e.runWebGLProgram(o,[r,s],i)}const ACe={kernelName:ep,backendName:"webgl",kernelFunc:_1};function xe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:i}=r,o=e,a=X(s.shape),l=N$(i,a),c=X(l);S(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const u=o.texData.get(s.dataId);return!u.isPacked||vv(s.shape,l)||null!==u.texture&&vv(u.shape,l)?(o.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function RCe(n,t,e){const r=[Od(n.shape),...Pd(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},i=[Od(t),...Pd(t)],o=new e4(i,r),c=e.runWebGLProgram(o,[s],n.dtype,[r],!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(s,l,o)}const MCe={kernelName:Ib,backendName:"webgl",kernelFunc:xe};class p4{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=t;this.outputShape=[s,o];const a=4*Math.floor(r/4),l=r%4;let c="sumValue += dot(values, ones);";if(null!=e){const d=1/e;c=`sumValue += dot(values * ${Zu(d)?d.toPrecision(2):d}, ones);`}let u="";i%r>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${c}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${c}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}class FCe{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=t;this.outputShape=[s,o];let a="0.0",l="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",l="min"):"max"===e&&(a="-1.0 / 1e-20",l="max");let c=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?c="sumValue":"prod"===e?c="prodValue":"all"===e?c="allValue":"any"===e&&(c="anyValue");const u=4*Math.floor(r/4),d=r%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${l}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${l}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,f="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",f="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",f="bvec4");let p="";i%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${c});\n      }\n    `}}function Mc(n,t,e,r){const s=function OCe(n){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const e=t.length?t[t.length-1].outSize:n[1],r=k_(e);t.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return t}(n.shape);let i=n;for(let o=0;o<s.length;o++){const{inSize:a,windowSize:l,outSize:c}=s[o];let u,d;u="mean"===e?0===o?new p4({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new p4({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):new FCe({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},e),d=i,i=r.runWebGLProgram(u,[i],t),d.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(d)}return i}class PCe{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let o=0;o<r.length;o++)r[o]=t[e[o]];this.outputShape=r,this.rank=r.length;const s=an(this.rank),i=function $Ce(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<n.length;s++)r[n[s]]=e[s];return r.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${i}));\n    }\n    `}}class LCe{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(t.length);for(let u=0;u<r.length;u++)r[u]=t[e[u]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=an(this.rank),i=JU("rc",this.rank),o=new Array(this.rank);for(let u=0;u<e.length;u++)o[e[u]]=i[u];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${l}) {\n        result[1] = ${c};\n      }\n      --${i[this.rank-1]};\n      if(++${i[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${c};\n        if(${l}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Iv(n,t,e){const r=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new LCe(n.shape,t):new PCe(n.shape,t);return e.runWebGLProgram(r,[n],n.dtype)}function Dv(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;return function BCe(n,t,e,r){const i=n.shape.length,o=ft(t,n.shape);let a=o;const l=Dn(a,i),c=null!=l;let u=n;c&&(u=Iv(n,l,r),a=zn(a.length,i)),Ar("sum",a,i);const[d,h]=Cr(u.shape,a);let f=d;e&&(f=Vn(d,o));const p=X(h),y=xe({inputs:{x:u},attrs:{shape:[X(n.shape)/p,p]},backend:r}),_=Mc(y,zE(n.dtype),"sum",r),v=xe({inputs:{x:_},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(_),c&&r.disposeIntermediateTensorInfo(u),v}(s,i,o,e)}const VCe={kernelName:Rb,backendName:"webgl",kernelFunc:Dv};function rs(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{perm:i}=r,o=e,l=new Array(s.shape.length);for(let u=0;u<l.length;u++)l[u]=s.shape[i[u]];let c;if(o.shouldExecuteOnCPU([s])){const d=o.texData.get(s.dataId).values,h=y1(d,s.shape,s.dtype,i,l);c=o.makeTensorInfo(l,s.dtype),o.texData.get(c.dataId).values=h}else c=Iv(s,i,o);return c}const zCe={kernelName:nd,backendName:"webgl",kernelFunc:rs};function Tv({a:n,b:t,transposeA:e,transposeB:r,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=t.shape.length,d=e?n.shape[c-2]:n.shape[c-1],h=r?t.shape[u-1]:t.shape[u-2],f=e?n.shape[c-1]:n.shape[c-2],p=r?t.shape[u-2]:t.shape[u-1],m=n.shape.slice(0,-2),g=t.shape.slice(0,-2),y=X(m),b=X(g),v=et(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,p]);S(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${r} must match.`);const w=e?[y,d,f]:[y,f,d],C=r?[b,p,h]:[b,h,p],I=xe({inputs:{x:n},backend:s,attrs:{shape:w}}),D=xe({inputs:{x:t},backend:s,attrs:{shape:C}}),T=[I,D],N=Math.max(y,b),$=e?I.shape[1]:I.shape[2],z=null!=i,j=null!=o,q="leakyrelu"===l,K=null!=l?hm(l,!0):null;let B;if((1===f||1===p)&&$>1e3&&!1===(z||j||q||null!=K)){let W=I,ne=D;e&&(W=rs({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),T.push(W)),r&&(ne=rs({inputs:{x:D},backend:s,attrs:{perm:[0,2,1]}}),T.push(ne));const de=1===p;let ue=W;1!==p&&(ue=xe({inputs:{x:W},backend:s,attrs:{shape:[N,$,1]}}),T.push(ue));const he=1===p?2:1;let ge=ne;de&&(ge=xe({inputs:{x:ne},backend:s,attrs:{shape:[N,1,$]}}),T.push(ge));const Ee=_1({inputs:{a:ue,b:ge},backend:s});B=Dv({inputs:{x:Ee},backend:s,attrs:{axis:he,keepDims:!0}}),T.push(Ee)}else{const W=Fs(n.dtype,t.dtype),ne=new u4(w,C,[N,f,p],e,r,z,K,j,q),ie=[I,D];if(null!=i&&ie.push(i),j&&ie.push(o),q){const de=s.makeTensorInfo([],"float32",Ya(a,"float32"));ie.push(de),T.push(de)}B=s.runWebGLProgram(ne,ie,W)}const L=xe({inputs:{x:B},backend:s,attrs:{shape:v}});T.push(B);for(const W of T)s.disposeIntermediateTensorInfo(W);return L}const HCe={kernelName:Bb,backendName:"webgl",kernelFunc:function UCe(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:d}=r;return Tv({a:s,b:i,transposeA:l,transposeB:c,backend:e,bias:o,preluActivationWeights:a,leakyreluAlpha:d,activation:u})}},g4="return abs(x);",jCe={kernelName:Ly,backendName:"webgl",kernelFunc:function WCe(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const i=e.texData.get(r.dataId),o=ZU(i.values);return e.makeTensorInfo(r.shape,r.dtype,o)}let s;return s=G().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Cl(r.shape,g4):new jo(r.shape,g4),e.runWebGLProgram(s,[r],r.dtype)}},qCe=Nt({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),KCe={kernelName:Ef,backendName:"webgl",kernelFunc:qCe},YCe=Nt({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),ZCe={kernelName:If,backendName:"webgl",kernelFunc:YCe},y4="return a + b;",QCe=Rr({opSnippet:y4,packedOpSnippet:y4,supportsComplex:!0,cpuKernelImpl:awe}),JCe={kernelName:td,backendName:"webgl",kernelFunc:QCe};class eSe{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`float v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class tSe{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`vec4 v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const nSe={kernelName:By,backendName:"webgl",kernelFunc:function kv(n){const{inputs:t,backend:e}=n,r=t;if(1===r.length)return zs({inputs:{x:r[0]},backend:e});if(r.length>G().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),c=kv({inputs:r.slice(0,l),backend:e}),u=kv({inputs:r.slice(l),backend:e});return kv({inputs:[c,u],backend:e})}const s=r.map(l=>l.dtype).reduce((l,c)=>Fs(l,c)),i=r.map(l=>l.shape),a=G().getBool("WEBGL_PACK")?new tSe(r[0].shape,i):new eSe(r[0].shape,i);return e.runWebGLProgram(a,r,s)}},sSe={kernelName:"All",backendName:"webgl",kernelFunc:function rSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,l=ft(i,s.shape);let c=l;const u=Dn(c,a);let d=s;null!=u&&(d=rs({inputs:{x:s},backend:e,attrs:{perm:u}}),c=zn(c.length,a)),Ar("all",c,a);const[h,f]=Cr(d.shape,c),m=xe({inputs:{x:d},backend:e,attrs:{shape:[-1,X(f)]}}),g=Mc(m,m.dtype,"all",e);let y;return y=xe(o?{inputs:{x:g},backend:e,attrs:{shape:Vn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=u&&e.disposeIntermediateTensorInfo(d),y}},oSe={kernelName:"Any",backendName:"webgl",kernelFunc:function iSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,l=ft(i,s.shape);let c=l;const u=Dn(c,a);let d=s;null!=u&&(d=rs({inputs:{x:s},backend:e,attrs:{perm:u}}),c=zn(c.length,a)),Ar("any",c,a);const[h,f]=Cr(d.shape,c),m=xe({inputs:{x:d},backend:e,attrs:{shape:[-1,X(f)]}}),g=Mc(m,m.dtype,"any",e);let y;return y=xe(o?{inputs:{x:g},backend:e,attrs:{shape:Vn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=u&&e.disposeIntermediateTensorInfo(d),y}};class aSe{constructor(t,e,r){this.variableNames=["A"];const{windowSize:s,batchSize:i,outSize:o}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class lSe{constructor(t,e,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,S(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),o>1&&this.outputShape.push(o),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=an(l),u=ns("coords",l);let d,h;if(1===o){h=l+1;const D=an(h);d=`\n        ${D} sourceLocR = ${D}(${u.join()}, 0);\n        ++${u[l-1]};\n        ${D} sourceLocG = ${D}(${u.join()}, 0);\n        ++${u[l-2]};\n        ${D} sourceLocA = ${D}(${u.join()}, 0);\n        --${u[l-1]};\n        ${D} sourceLocB = ${D}(${u.join()}, 0);\n        --${u[l-2]};`}else h=l,d=`\n        ${c} sourceLocR = coords;\n        ++${u[l-1]};\n        ${c} sourceLocG = coords;\n        ++${u[l-2]};\n        ${c} sourceLocA = coords;\n        --${u[l-1]};\n        ${c} sourceLocB = coords;\n        --${u[l-2]};`;const f=["x","y","z","w","u","v"].slice(0,h),p="."+f[h-1],m=f.map(D=>"int "+D),g=ns("sourceLocR",h-1).concat("inIdx.r"),y=ns("sourceLocG",h-1).concat("inIdx.g"),b=ns("sourceLocB",h-1).concat("inIdx.b"),_=ns("sourceLocA",h-1).concat("inIdx.a"),v="max"===r?"greaterThan":"lessThan",w=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${_.join()})));`,C=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${y.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${_.join()}) : 0.)`,I=s?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${f.join()}),\n                                          vec2(${f.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${f.join()}),\n                               vec2(${f.slice(-2).join()}));\n      }\n      ${I}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};\n        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${C};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${C};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function b4(n,t,e,r=null){let s=t.shape[0],i=t.shape[1];null!=r&&(s=r.shape[0],i=r.shape[1]);const o=k_(i),a={windowSize:o,inSize:i,batchSize:s,outSize:Math.ceil(i/o)},l=new aSe(a,e,null==r),c=[t];null!=r&&c.push(r);const u=n.runWebGLProgram(l,c,"int32");if(1===u.shape[1])return u;const d=b4(n,t,e,u);return n.disposeIntermediateTensorInfo(u),d}function _4(n,t,e,r=null){const s=null!=r?r.shape:t.shape,o=k_(s[s.length-1]),a=new lSe(s,o,e,null==r),c=n.runWebGLProgram(a,null==r?[t]:[t,r],"int32");if(c.shape.length===t.shape.length){const u=_4(n,t,e,c);return n.disposeIntermediateTensorInfo(c),u}return c}function v4(n,t,e,r){const s=[e];if(Ar("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!G().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const i=[],o=n.texData.get(t.dataId);let l=t;null!==o&&o.isPacked&&(l=n.unpackTensor(t),i.push(l));const[c,u]=Cr(l.shape,s),d=X(u),h=xe({inputs:{x:l},backend:n,attrs:{shape:[-1,d]}});i.push(h);const f=b4(n,h,r);i.push(f);const p=xe({inputs:{x:f},backend:n,attrs:{shape:c}});return i.forEach(m=>n.disposeIntermediateTensorInfo(m)),p}return _4(n,t,r)}const uSe={kernelName:Vy,backendName:"webgl",kernelFunc:function cSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;let o=ft(i,s.shape);const a=Dn(o,s.shape.length);let l=s;const c=[];null!=a&&(l=rs({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),o=zn(o.length,l.shape.length)),Ar("argMax",[o[0]],l.shape.length);const u=v4(e,l,o[0],"max");return c.forEach(d=>e.disposeIntermediateTensorInfo(d)),u}},hSe={kernelName:zy,backendName:"webgl",kernelFunc:function dSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;let o=ft(i,s.shape);const a=Dn(o,s.shape.length);let l=s;const c=[];null!=a&&(l=rs({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),o=zn(o.length,l.shape.length)),Ar("argMin",[o[0]],l.shape.length);const u=v4(e,l,o[0],"min");return c.forEach(d=>e.disposeIntermediateTensorInfo(d)),u}},pSe=Nt({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),mSe={kernelName:Df,backendName:"webgl",kernelFunc:pSe},ySe=Nt({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),bSe={kernelName:Tf,backendName:"webgl",kernelFunc:ySe},vSe=Nt({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),xSe={kernelName:kf,backendName:"webgl",kernelFunc:vSe},SSe=Rr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),ESe={kernelName:Af,backendName:"webgl",kernelFunc:SSe},DSe=Nt({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),TSe={kernelName:Nf,backendName:"webgl",kernelFunc:DSe};class fm{constructor(t,e,r,s=!1,i=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,u=t.dilationWidth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,f=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const m="avg"===e;let b="0.0";if(m||(b="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${l});\n        const ivec2 pads = ivec2(${f}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?i?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let v=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(v="avgValue / count");const w=4*Math.floor(o/4),C=o%4,I=`\n      if (${m}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${f}, ${p});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${c}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${w}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${I}\n          }\n\n          int xC = xCCorner + ${w};\n          if (${1===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${I}\n          } else if (${2===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${I}\n          } else if (${3===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${I}\n          }\n        }\n        setOutput(${v});\n      }\n    `}}class v1{constructor(t,e,r,s=!1,i=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideDepth,l=t.strideHeight,c=t.strideWidth,u=t.dilationDepth,d=t.dilationHeight,h=t.dilationWidth,f=t.effectiveFilterDepth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth,g=t.padInfo.front,y=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const _="avg"===e;let v="0.0";if(_||(v="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${l}, ${c});\n        const ivec3 pads = ivec3(${g}, ${y}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${f};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${m};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?i?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${m} +\n                      wR * ${m} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let C=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(C="avgValue / count");const I=4*Math.floor(o/4),D=o%4,T=`\n      if (${_}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${l}, ${c});\n      const ivec3 pads = ivec3(${g}, ${y}, ${b});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${f};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${I}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${T}\n            }\n\n            int xC = xCCorner + ${I};\n            if (${1===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${T}\n            } else if (${2===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${T}\n            } else if (${3===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${T}\n            }\n          }\n          setOutput(${C});\n        }\n      }\n    `}}const NSe={kernelName:Uy,backendName:"webgl",kernelFunc:function kSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;lm(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r;S(Nr(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=Ai(s.shape,i,o,1,a,l);if(1===u.filterWidth&&1===u.filterHeight&&It(u.inShape,u.outShape))return zs({inputs:{x:s},backend:e});const d=new fm(u,"avg",!1);return e.runWebGLProgram(d,[s],"float32")}},RSe={kernelName:Hy,backendName:"webgl",kernelFunc:function ASe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r,d=ya(s.shape,i,o,[1,1,1],a,l,c),h=new v1(d,"avg",!1);return e.runWebGLProgram(h,[s],"float32")}};class MSe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const l=t.effectiveFilterHeight,c=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${l-1-t.padInfo.top}, ${c-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${c};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class FSe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const d=t.effectiveFilterDepth,h=t.effectiveFilterHeight,f=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${d-1-t.padInfo.front}, ${h-1-t.padInfo.top}, ${f-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${f};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const PSe={kernelName:RS,backendName:"webgl",kernelFunc:function OSe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=ya(o.shape,a,l,[1,1,1],c,u),f=new FSe(h);return e.runWebGLProgram(f,[s],o.dtype)}},LSe={kernelName:AS,backendName:"webgl",kernelFunc:function $Se(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i;lm([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=Ai(o.shape,a,l,1,c),d=new MSe(u);return e.runWebGLProgram(d,[s],o.dtype)}},VSe={kernelName:Wy,backendName:"webgl",kernelFunc:function BSe(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i}=t,{transposeA:o,transposeB:a}=r;return Tv({a:s,b:i,transposeA:o,transposeB:a,backend:e})}};class zSe{constructor(t,e,r,s,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],et(t,e),et(t,r);let a="0.0";null!=s&&(et(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";null!=i&&(et(t,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${o}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class USe{constructor(t,e,r,s,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],et(t,e),et(t,r);let a="vec4(0.0)";null!=s&&(et(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=i&&(et(t,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${o}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const HSe={kernelName:nb,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,mean:s,variance:i,offset:o,scale:a}=n;S(s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==o||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;null==l&&(l=.001);const c=[r,s,i];let u=null;null!=o&&(u=o.shape,c.push(o));let d=null;null!=a&&(d=a.shape,c.push(a));const h=G().getBool("WEBGL_PACK_NORMALIZATION")?new USe(r.shape,s.shape,i.shape,u,d,l):new zSe(r.shape,s.shape,i.shape,u,d,l);return t.runWebGLProgram(h,c,c[0].dtype)}};class WSe{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=an(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function jSe(n){if(1===n)return"sourceLoc";if(n<=6)return x1.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}(this.rank);let s;s=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((o,a)=>`sourceLoc.${x1[a]} = start[${a}] + coords.${x1[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}}const x1=["x","y","z","w","u","v"];class GSe{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=an(this.rank),r=ns("coords",this.rank),s=ns("sourceLoc",this.rank),i=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,o=`getChannel(getSource(${s.join()}), ${i})`,a=`\n      result.x = ${o};\n      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${o};\n        --${s[this.rank-1]};\n      }\n    `,l=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${o};\n        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,c=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((u,d)=>`start[${d}]`).join()});`:t.map((u,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${c}\n        vec4 result = vec4(0.);\n        ${a}\n        ${l}\n        setOutput(result);\n      }\n    `}}function Hd(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,size:o}=r,[a,l]=t_(s,i,o);if(pI(s,a,l),0===X(l))return e.makeTensorInfo(l,s.dtype,[]);if(e.shouldExecuteOnCPU([s])||"string"===s.dtype){const d=e.texData.get(s.dataId),h=Lwe(d.values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,h)}const{isPacked:c}=e.texData.get(s.dataId),u=gI(s.shape,a,l);if(c||!u){const d=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new GSe(l):new WSe(l);return e.runWebGLProgram(d,[s],s.dtype,[a])}return e.uploadToGPU(s.dataId),function qSe(n,t,e,r){const s=r.texData.get(n.dataId),i=r.makeTensorInfo(e,n.dtype),o=r.texData.get(i.dataId);Object.assign(o,s),o.refCount=1,o.shape=e,o.dtype=n.dtype;let a=yI(t,Le(n.shape));s.slice&&(a+=s.slice.flatOffset),o.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||n.dataId};const l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),i}(s,a,l,e)}const KSe={kernelName:Ab,backendName:"webgl",kernelFunc:Hd},XSe={kernelName:jy,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,crops:o}=r;S(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((b,_)=>b*_),l=Vp(s.shape,i,a),c=zp(l.length,i.length),u=Up(s.shape,i,a),d=CD(o,i.length),h=SD(u,o,i.length),f=[],p=xe({inputs:{x:s},backend:e,attrs:{shape:l}}),m=rs({inputs:{x:p},backend:e,attrs:{perm:c}}),g=xe({inputs:{x:m},backend:e,attrs:{shape:u}}),y=Hd({inputs:{x:g},backend:e,attrs:{begin:d,size:h}});return f.push(p),f.push(m),f.push(g),f.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}},ZSe={kernelName:MS,backendName:"webgl",kernelFunc:function YSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o}=r,a=e.readSync(s.dataId),l=e.readSync(i.dataId),c=YU(a,l,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,c)}},JSe={kernelName:FS,backendName:"webgl",kernelFunc:function QSe(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,i=e.readSync(r.dataId),o=e.readSync(s.dataId),a=et(Array.from(i),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},x4=Rr({opSnippet:"return float(a != b);",cpuKernelImpl:kwe,dtype:"bool"}),eEe={kernelName:_b,backendName:"webgl",kernelFunc:x4};function pm(n){const{inputs:t,backend:e}=n,{input:r}=t;return zs({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const tEe={kernelName:mE,backendName:"webgl",kernelFunc:pm},sEe={kernelName:Rf,backendName:"webgl",kernelFunc:function w1(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:i}=r;if("complex64"===i){if("complex64"===s.dtype)return zs({inputs:{x:s},backend:e});const o=sr(s.shape),a=w1({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),l=Sl({inputs:{real:a,imag:o},backend:e});return o.dispose(),e.disposeIntermediateTensorInfo(a),l}if("complex64"===s.dtype){const o=pm({inputs:{input:s},backend:e}),a=w1({inputs:{x:o},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(o),a}if(!A$(s.dtype,i)){const o=zs({inputs:{x:s},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(e.shouldExecuteOnCPU([s])){const o=e.texData.get(s.dataId).values,[a,l,c]=cwe(o,s.shape,s.dtype,i);return e.makeTensorInfo(a,l,c)}if("int32"===i)return function rEe(n,t){const e=new jo(n.shape,"return float(int(x));"),r=t.runWebGLProgram(e,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,e);if("bool"===i){const o=e.makeTensorInfo([],"bool",br("bool",1)),l=x4({inputs:{a:s,b:o},backend:e});return e.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}},w4="return ceil(x);",iEe=Nt({opSnippet:w4,packedOpSnippet:w4,cpuKernelImpl:uwe}),oEe={kernelName:Mf,backendName:"webgl",kernelFunc:iEe};class aEe{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class lEe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const uEe={kernelName:Ff,backendName:"webgl",kernelFunc:function cEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{clipValueMin:i,clipValueMax:o}=r;let a;return a=G().getBool("WEBGL_PACK_CLIP")?new lEe(s.shape):new aEe(s.shape),e.runWebGLProgram(a,[s],s.dtype,[[i],[o]])}};class dEe{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function C4(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}const fEe={kernelName:Gy,backendName:"webgl",kernelFunc:function hEe(n){const{inputs:t,backend:e}=n,{x:r}=t,s=e.texData.get(r.dataId),i=new dEe(r.shape),o=[C4(r,s.complexTensorInfos.real),C4(r,s.complexTensorInfos.imag)];return e.runWebGLProgram(i,o,o[0].dtype)}};class pEe{constructor(t){this.outputShape=[],this.outputShape=$o(t,1),this.variableNames=t.map((o,a)=>`T${a}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let o=1;o<e.length;o++)e[o]=e[o-1]+t[o][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<e.length;o++)r.push(`else if (yC < ${e[o]}) setOutput(getT${o}(yR, yC-${e[o-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class mEe{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=$o(t,e);const r=this.outputShape,s=r.length,i=an(s),o=ns("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((m,g)=>`T${g}`);const l=new Array(t.length-1);l[0]=t[0][e];for(let m=1;m<l.length;m++)l[m]=l[m-1]+t[m][e];const c=a[e],u=a.slice(-2),d=a.join();let h=`if (${c} < ${l[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${u.join()}));\n        }`;for(let m=1;m<l.length;m++){const g=l[m-1];h+=`\n        if (${c} < ${l[m]}  && ${c} >= ${l[m-1]}) {\n          return getChannel(\n            getT${m}(${Nv(a,c,g)}),\n            vec2(${Nv(u,c,g)}));\n        }`}const p=l[l.length-1];h+=`\n        return getChannel(\n          getT${l.length}(${Nv(a,c,p)}),\n          vec2(${Nv(u,c,p)}));`,this.userCode=`\n      float getValue(${a.map(m=>"int "+m)}) {\n        ${h}\n      }\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${o}), 0., 0., 0.);\n\n        ${o[s-1]} = ${o[s-1]} + 1;\n        if (${o[s-1]} < ${r[s-1]}) {\n          result.g = getValue(${o});\n        }\n\n        ${o[s-2]} = ${o[s-2]} + 1;\n        if (${o[s-2]} < ${r[s-2]}) {\n          result.a = getValue(${o});\n        }\n\n        ${o[s-1]} = ${o[s-1]} - 1;\n        if (${o[s-2]} < ${r[s-2]} &&\n            ${o[s-1]} < ${r[s-1]}) {\n          result.b = getValue(${o});\n        }\n        setOutput(result);\n      }\n    `}}function Nv(n,t,e){const r=n.indexOf(t);return n.map((i,o)=>o===r?`${i} - ${e}`:i).join()}function Av(n){const{inputs:t,backend:e}=n,{input:r}=t;return zs({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const gEe={kernelName:tE,backendName:"webgl",kernelFunc:Av};function mm(n,t,e){const r=n[0].dtype;if("complex64"===r){const f=n.map(b=>pm({inputs:{input:b},backend:e})),p=n.map(b=>Av({inputs:{input:b},backend:e})),m=mm(f,t,e),g=mm(p,t,e),y=Sl({inputs:{real:m,imag:g},backend:e});return f.forEach(b=>e.disposeIntermediateTensorInfo(b)),p.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),y}let s=e.shouldExecuteOnCPU(n);if("string"===r&&(s=!0),s){const f=n.map(v=>{const C=[-1,X(v.shape.slice(t))];return xe({inputs:{x:v},backend:e,attrs:{shape:C}})}),p=f.map(v=>({vals:e.readSync(v.dataId),shape:v.shape})),m=$o(f.map(v=>v.shape),1),y=dwe(p,m,r,1===f[0].shape[0]),b=$o(n.map(v=>v.shape),t),_=e.makeTensorInfo(b,r,y);return f.forEach(v=>e.disposeIntermediateTensorInfo(v)),_}const i=n.filter(f=>X(f.shape)>0),o=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(1===i.length){const f=o?new jo(n[0].shape,wl):new Cl(n[0].shape,wl);return e.runWebGLProgram(f,n,r)}const a=G().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const f=[];for(let m=0;m<i.length;m+=a){const g=i.slice(m,m+a);f.push(mm(g,t,e))}const p=mm(f,t,e);for(const m of f)e.disposeIntermediateTensorInfo(m);return p}if(o){const f=new mEe(i.map(p=>p.shape),t);return e.runWebGLProgram(f,i,r)}const{tensors2D:l,outShape:c}=function yEe(n,t,e){const r=$o(n.map(i=>i.shape),t);return{tensors2D:n.map(i=>xe({inputs:{x:i},attrs:{shape:[-1,X(i.shape.slice(t))]},backend:e})),outShape:r}}(i,t,e),u=new pEe(l.map(f=>f.shape)),d=e.runWebGLProgram(u,l,r);l.forEach(f=>e.disposeIntermediateTensorInfo(f));const h=xe({inputs:{x:d},attrs:{shape:c},backend:e});return e.disposeIntermediateTensorInfo(d),h}function S4(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,i=ft(s,t[0].shape)[0];vD(t.map(c=>c.shape),i);const a=$o(t.map(c=>c.shape),i);if(0===X(a))return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(c=>X(c.shape)>0);return 1===l.length?zs({inputs:{x:l[0]},backend:e}):mm(l,i,e)}const bEe={kernelName:qy,backendName:"webgl",kernelFunc:S4};class E4{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,c=t.strideWidth,u=t.dilationHeight,d=t.dilationWidth,h=t.filterHeight,f=t.filterWidth,p=4*Math.floor(t.inChannels/4),m=t.inChannels%4,g="channelsLast"===t.dataFormat,y=g?1:2,b=g?2:3,_=g?3:1;let v="",w="";r&&(v=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,w="result = activation(result);");const C=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${_}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${y}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${g}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===m}) {\n\n              if (${g}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===m}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===m}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${C}\n        ${w}\n        setOutput(result);\n      }\n    `}}class _Ee{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,r=t.padInfo.top,s=t.padInfo.left,i=t.strideDepth,o=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,u=t.dilationWidth,d=t.filterDepth,h=t.filterHeight,f=t.filterWidth,p=4*Math.floor(t.inChannels/4),m=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${i}, ${o}, ${a});\n      const ivec3 pads = ivec3(${e}, ${r}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${l};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${c};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${f}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===m}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class I4{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ts(this.outputShape.length);const o=t.padInfo.left,a=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,u=t.filterWidth,d=u;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<u;g++)h+=`\n           vec4 xTexelC${2*g};\n           int xTexelC${2*g}Ready;\n           vec4 xTexelC${2*g+1};\n           int xTexelC${2*g+1}Ready;\n           vec4 xC${g};`;h+=`\n     for (int r = 0; r < ${c}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let g=0;g<u;g++)h+=`\n           xTexelC${2*g} = vec4(0.0);\n           xTexelC${2*g}Ready = 0;\n           xTexelC${2*g+1} = vec4(0.0);\n           xTexelC${2*g+1}Ready = 0;\n           xC${g} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let g=0;g<(d+1)/2;g++){const y=2*g;if(h+=`\n           xC = xCCorner + ${y*l};\n           `,1===a){if(y<u&&(o%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n               `,h+=1===l&&y>0?`\n                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);\n                   } else {\n                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xC${y} = xTexelC${y};\n                 `,y+1<u)){const b=o%2==0?vS(l):l;l%2==0&&o%2==1||l%2!=0&&o%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${b};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${y+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${y+1}Ready = 1;\n                   }\n                   `,h+=l>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);\n                     } else {\n                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);\n                     }\n                     `:`\n                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);\n                     `):h+=1===b?`\n                     xC${y+1} = xTexelC${y};\n                     `:`\n                     xCOffset = xC + ${b};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${y+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${y+1}Ready = 1;\n                     }\n\n                     xC${y+1} = xTexelC${y+1};\n                     `}}else y<u&&(o%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n               `,y+1<u&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(\n                   xTexelC${y}.xy, xTexelC${y+1}.xy);\n               `,y+1<u&&(h+=`\n                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n                 `)));y<u&&(h+=`\n             wTexel = getW(r, ${y}, d1, d2);\n             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,y+1<u&&(h+=`\n               wTexel = getW(r, ${y+1}, d1, d2);\n               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let f="",p="";r&&(f=s?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${r}\n         }`:i?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${r}\n         }`:`vec4 activation(vec4 x) {\n           ${r}\n         }`,p="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${f}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${m}\n         ${p}\n         setOutput(result);\n       }\n     `}}class vEe{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=ts(this.outputShape.length);const{dataFormat:r}=e,s=es(),i="channelsLast"===r,o=i?1:2,a=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let c="";for(let u=0;u<=1;u++)for(let d=0;d<=1;d++)c+=`\n          blockIndex = rc.z + ${d};\n          pos = rc.y + ${u};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${o}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${i}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+d}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+d}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${c}\n\n        ${s.output} = result;\n      }\n    `}}function Rv(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&1===e&&n[0]>1?[n[0],1]:null}function D4({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,c=r.texData.get(n.dataId),u=e.inChannels,d=l[0]*l[1]*l[2],h=e.outChannels,f="channelsLast"===e.dataFormat;let g;const y=[];if(null!=i){const v=Rv(i.shape,f);null!=v&&(i=xe({inputs:{x:i},backend:r,attrs:{shape:v}}),y.push(i))}if(null!=s){const v=Rv(s.shape,f);null!=v&&(s=xe({inputs:{x:s},backend:r,attrs:{shape:v}}),y.push(s))}if((1!==d&&1!==h||!(u>1e3))&&c.isPacked&&f&&null!=c.texture&&l[2]%2!=0&&It(c.shape.slice(-3),l.slice(-3))){const w={dataId:n.dataId,shape:[1,l[0]*l[1]*(l[2]+1),e.inChannels],dtype:n.dtype},C=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,S(vv(c.shape,w.shape),()=>`packed reshape ${c.shape} to ${w.shape} isn't free`);const I=xe({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(I);const D=Tv({a:w,b:I,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),T=r.texData.get(D.dataId);S(T.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=C,T.shape=e.outShape,g=zs({inputs:{x:D},backend:r}),g.shape=e.outShape,y.push(D)}else{const v=e.outHeight*e.outWidth,w=xe({inputs:{x:n},backend:r,attrs:{shape:f?[e.batchSize,v,e.inChannels]:[e.batchSize,e.inChannels,v]}}),C=xe({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),I=Tv({a:f?w:C,b:f?C:w,transposeA:!f,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o});g=xe({inputs:{x:I},backend:r,attrs:{shape:e.outShape}}),y.push(w),y.push(C),y.push(I)}for(const v of y)r.disposeIntermediateTensorInfo(v);return g}function T4({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:d,outHeight:h,dataFormat:f}=e,p="channelsLast"===f,m=l*c*u,g=h*d,y=[e.batchSize,m,g],v=[];if(null!=i){const L=Rv(i.shape,p);null!=L&&(i=xe({inputs:{x:i},backend:r,attrs:{shape:L}}),v.push(i))}if(null!=s){const L=Rv(s.shape,p);null!=L&&(s=xe({inputs:{x:s},backend:r,attrs:{shape:L}}),v.push(s))}const w=xe({inputs:{x:t},backend:r,attrs:{shape:[1,m,X(t.shape)/m]}});v.push(w);const C=new vEe(y,e),D=r.runWebGLProgram(C,[n],"float32",[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),T=xe({inputs:{x:D},backend:r,attrs:{shape:y}});v.push(D),v.push(T);const N=null!=s,$=null!=i,z="leakyrelu"===a,j=a?hm(a,!0):null,q=new u4(p?T.shape:w.shape,p?w.shape:T.shape,p?[e.batchSize,g,e.outChannels]:[e.batchSize,e.outChannels,g],!0,!1,N,j,$,z),K=p?[T,w]:[w,T];if(s&&K.push(s),$&&K.push(i),z){const L=r.makeTensorInfo([],"float32",Ya(o,"float32"));K.push(L),v.push(L)}const P=r.runWebGLProgram(q,K,"float32"),B=xe({inputs:{x:P},backend:r,attrs:{shape:e.outShape}});v.push(P);for(const L of v)r.disposeIntermediateTensorInfo(L);return B}const wEe={kernelName:Ky,backendName:"webgl",kernelFunc:function xEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r,d=ba(l),h=wr(s.shape,i.shape,o,c,a,u,!1,d);let f;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&G().getBool("WEBGL_EXP_CONV")){const m=new I4(h);f=e.runWebGLProgram(m,[s,i],"float32",[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]])}else if(G().getBool("WEBGL_CONV_IM2COL"))f=T4({x:s,filter:i,convInfo:h,backend:e});else{const m=new E4(h);f=e.runWebGLProgram(m,[s,i],"float32")}else f=D4({x:s,filter:i,convInfo:h,backend:e});const p=xe({inputs:{x:f},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(f),p}};class CEe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===t.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class SEe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,o="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${o?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${o?1:2}], coords[${o?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${o}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class EEe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class IEe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,r=t.filterHeight,s=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${r-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const TEe={kernelName:PS,backendName:"webgl",kernelFunc:function DEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,d=ba(l),h=wr(s.shape,u,o,1,a,c,!1,d),f=new CEe(h);return e.runWebGLProgram(f,[s,i],"float32")}},NEe={kernelName:Xy,backendName:"webgl",kernelFunc:function kEe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r,d=ba(c),h=wr(o,i.shape,a,1,l,u,!1,d),f=new SEe(h);return e.runWebGLProgram(f,[s,i],"float32")}},REe={kernelName:Yy,backendName:"webgl",kernelFunc:function AEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l}=r,c=sl(s.shape,i.shape,o,l,a),u=new _Ee(c);return e.runWebGLProgram(u,[s,i],"float32")}},FEe={kernelName:$S,backendName:"webgl",kernelFunc:function MEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,filterShape:l}=r,c=sl(s.shape,l,o,1,a),u=new EEe(c);return e.runWebGLProgram(u,[s,i],"float32")}},PEe={kernelName:LS,backendName:"webgl",kernelFunc:function OEe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{pad:o,strides:a,inputShape:l}=r,c=sl(l,i.shape,a,1,o),u=new IEe(c);return e.runWebGLProgram(u,[s,i],"float32")}},LEe=Nt({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),BEe={kernelName:Of,backendName:"webgl",kernelFunc:LEe},VEe=Nt({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),zEe={kernelName:Pf,backendName:"webgl",kernelFunc:VEe};class UEe{constructor(t,e,r,s,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=t,[u]=e,[d,h]=r;this.outputShape=[u,d,h,c];const f="bilinear"===s?1:0,[p,m]=[a-1+".0",l-1+".0"],[g,y,b]=d>1?[""+(a-1)/(d-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[_,v,w]=h>1?[""+(l-1)/(h-1),"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${_});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${y};\n        float width_scale = ${v};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${i}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${m} ) {\n          setOutput(float(${i}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${f} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const HEe={kernelName:VS,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:i,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:c}=r,u=new UEe(s.shape,i.shape,a,l,c);return e.runWebGLProgram(u,[s,i,o],"float32")}};var Wd=(()=>{return(n=Wd||(Wd={})).Prod="*",n.Sum="+",Wd;var n})();class k4{constructor(t,e,r,s){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,a=r?this.op===Wd.Prod?"1.0":"0.0":`getX(${N4(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",u="";r?(c=s?"end != "+(l-1):"end != 0",u=s?"end + 1":"end - 1"):(c=s?`end + pow2 < ${l}`:"end >= pow2",u=s?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${an(i)} coords = getOutputCoords();\n        int end = ${A4(i,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${c}) {\n          int idx = ${u};\n          ${A4(i,"coords",this.op)} = idx;\n          val ${this.op}= getX(${N4(i,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function N4(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.x, ${t}.y`;if(3===n)return`${t}.x, ${t}.y, ${t}.z`;if(4===n)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function A4(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.y`;if(3===n)return`${t}.z`;if(4===n)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function R4(n,t,e,r,s,i){const o=t.shape.length,a=Dn([r],o);let l=t;null!=a&&(l=rs({inputs:{x:t},backend:e,attrs:{perm:a}}));const c=zn(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const u=l.shape[c];let d=zs({inputs:{x:l},backend:e});for(let h=0;h<=Math.ceil(Math.log2(u))-1;h++){const f=new k4(n,l.shape,!1,i),m=d;d=e.runWebGLProgram(f,[d],d.dtype,[[h]]),e.disposeIntermediateTensorInfo(m)}if(s){const h=new k4(n,l.shape,s,i),f=d;d=e.runWebGLProgram(h,[d],d.dtype),e.disposeIntermediateTensorInfo(f)}if(null!=a){const f=rs({inputs:{x:d},backend:e,attrs:{perm:al(a)}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(l),f}return d}const jEe={kernelName:BS,backendName:"webgl",kernelFunc:function WEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;return R4(Wd.Prod,s,e,i,o,a)}},qEe={kernelName:Zy,backendName:"webgl",kernelFunc:function GEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;return R4(Wd.Sum,s,e,i,o,a)}},XEe={kernelName:zS,backendName:"webgl",kernelFunc:function KEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o,binaryOutput:a}=r;if(1===s.shape.length){const l=e.readSync(s.dataId),c=e.readSync(i.dataId),u=YU(l,c,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,u)}if(2===s.shape.length){const l=e.bufferSync(s),c=e.bufferSync(i),u=lwe(l,c,o,a);return e.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class YEe{constructor(t,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const QEe={kernelName:US,backendName:"webgl",kernelFunc:function ZEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:i,dataFormat:o}=r,a=s.shape[0],d=("NHWC"===o?s.shape[1]:s.shape[2])*i,h=("NHWC"===o?s.shape[2]:s.shape[3])*i,f=("NHWC"===o?s.shape[3]:s.shape[1])/(i*i),m=new YEe("NHWC"===o?[a,d,h,f]:[a,f,d,h],i,o);return e.runWebGLProgram(m,[s],s.dtype)}};class M4{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ts(this.outputShape.length);const o=t.filterHeight,a=t.filterWidth,l=t.outChannels/t.inChannels;let c="",u="";r&&(c=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,u="result = activation(result);");const d=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${c}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${o}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${d}\n        ${u}\n        setOutput(result);\n      }\n    `}}class F4{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ts(this.outputShape.length);const o=t.outChannels/t.inChannels,a=t.padInfo.left,l=t.strideWidth,c=t.dilationWidth,u=t.filterHeight,d=t.filterWidth,h=d;let f="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let y=0;y<d;y++)f+=`\n          vec4 xTexelC${2*y};\n          int xTexelC${2*y}Ready;\n          vec4 xTexelC${2*y+1};\n          int xTexelC${2*y+1}Ready;\n          vec4 xC${y};`;f+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let y=0;y<d;y++)f+=`\n          xTexelC${2*y} = vec4(0.0);\n          xTexelC${2*y}Ready = 0;\n          xTexelC${2*y+1} = vec4(0.0);\n          xTexelC${2*y+1}Ready = 0;\n          xC${y} = vec4(0.0);`;f+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let y=0;y<(h+1)/2;y++){const b=2*y;if(f+=`\n          xC = xCCorner + ${b*c};\n          `,1===l){if(b<d&&(a%2==1?(f+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n              `,f+=1===c&&b>0?`\n                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);\n                  } else {\n                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);\n                  }\n                  `):f+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xC${b} = xTexelC${b};\n                `,b+1<d)){const _=a%2==0?vS(c):c;c%2==0&&a%2==1||c%2!=0&&a%2!=1?(f+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${_};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${b+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${b+1}Ready = 1;\n                  }\n                  `,f+=c>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);\n                    } else {\n                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);\n                    }\n                    `:`\n                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);\n                    `):f+=1===_?`\n                    xC${b+1} = xTexelC${b};\n                    `:`\n                    xCOffset = xC + ${_};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${b+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${b+1}Ready = 1;\n                    }\n\n                    xC${b+1} = xTexelC${b+1};\n                    `}}else b<d&&(a%2==1?(f+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n              `,b+1<d&&(f+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);\n                `)):(f+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(\n                  xTexelC${b}.xy, xTexelC${b+1}.xy);\n              `,b+1<d&&(f+=`\n                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n                `)));b<d&&(f+=`\n            wTexel = getW(r, ${b}, d1, q);\n            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);\n          `,b+1<d&&(f+=`\n              wTexel = getW(r, ${b+1}, d1, q);\n              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}f+="\n    }\n  ",f+="\n      }\n    ";let p="",m="";r&&(p=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:i?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,m="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${f}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${g}\n        ${m}\n        setOutput(result);\n      }\n    `}}const eIe={kernelName:Qy,backendName:"webgl",kernelFunc:function JEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;let u=l;null==u&&(u=[1,1]),S(Nr(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const d=wr(s.shape,i.shape,o,u,a,c,!0);let h;return h=G().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new F4(d):new M4(d),e.runWebGLProgram(h,[s,i],"float32",[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]])}};class tIe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class nIe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,l=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${l}; dm++) {\n              int d2 = d1 * ${l} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const sIe={kernelName:HS,backendName:"webgl",kernelFunc:function rIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r,d=wr(s.shape,u,o,a,l,c,!0),h=new tIe(d);return e.runWebGLProgram(h,[s,i],"float32")}},oIe={kernelName:WS,backendName:"webgl",kernelFunc:function iIe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r,d=wr(u,i.shape,o,a,l,c,!0),h=new nIe(d);return e.runWebGLProgram(h,[s,i],"float32")}};class aIe{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const cIe={kernelName:jS,backendName:"webgl",kernelFunc:function lIe(n){const{inputs:t,backend:e}=n,{x:r}=t,s=[...r.shape,...r.shape],i=X(r.shape),o=xe({inputs:{x:r},backend:e,attrs:{shape:[i]}}),a=new aIe(i),l=e.runWebGLProgram(a,[o],o.dtype),c=xe({inputs:{x:l},backend:e,attrs:{shape:s}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}};class uIe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:r,padInfo:s,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=t,{top:d,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${c};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${l}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const hIe={kernelName:Jy,backendName:"webgl",kernelFunc:function dIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l}=r,c=Ep(s.shape,i.shape,o,a,"NHWC",l);let u;const d=new uIe(c);u=e.runWebGLProgram(d,[s,i],"float32");const h=xe({inputs:{x:u},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(u),h}},pIe={kernelName:KS,backendName:"webgl",kernelFunc:function fIe(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,i=t,{allDims:o,summedDims:a,idDims:l}=FD(s,i.length);PD(o.length,l,i);const{path:c,steps:u}=$D(a,l),d=u.length;let h=null,f=o.length;const p=[];for(let m=0;m<d;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=OD(f,l[g]);let _;LD(y)?_=i[g]:(_=rs({inputs:{x:i[g]},backend:e,attrs:{perm:y}}),p.push(_));const v=_.shape.slice();for(let w=0;w<b.length;++w)v.splice(b[w],0,1);It(_.shape,v)||(_=xe({inputs:{x:_},backend:e,attrs:{shape:v}}),p.push(_)),null===h?h=_:(h=_1({inputs:{a:_,b:h},backend:e}),p.push(h))}m<d-1&&(c[m]>=0&&(h=Dv({inputs:{x:h},backend:e,attrs:{axis:c[m]-(o.length-f),keepDims:!1}}),p.push(h)),f--)}for(const m of p)m!==h&&e.disposeIntermediateTensorInfo(m);return h}},mIe=Nt({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),gIe={kernelName:Lf,backendName:"webgl",kernelFunc:mIe},_Ie={kernelName:XS,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e}=n,{dy:r,y:s}=t,i=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new dm("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new zd("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,s.shape);return e.runWebGLProgram(i,[r,s],r.dtype)}},vIe=Rr({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:hwe}),xIe={kernelName:eb,backendName:"webgl",kernelFunc:vIe},CIe=Nt({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${ID};\n  float a1 = ${DD};\n  float a2 = ${TD};\n  float a3 = ${kD};\n  float a4 = ${ND};\n  float a5 = ${AD};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),SIe={kernelName:Bf,backendName:"webgl",kernelFunc:CIe},O4=Nt({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:fwe,dtype:"float32"}),IIe={kernelName:Vf,backendName:"webgl",kernelFunc:O4};function C1(n){const{inputs:t,attrs:e,backend:r}=n,{dim:s}=e,{input:i}=t,o=i.shape.length,a=i.shape.slice();let l=s;return s<0&&(S(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+s+1),a.splice(l,0,1),xe({inputs:{x:i},backend:r,attrs:{shape:a}})}const DIe={kernelName:tb,backendName:"webgl",kernelFunc:C1},P4="return exp(x) - 1.0;",TIe=Nt({opSnippet:P4,packedOpSnippet:P4,cpuKernelImpl:pwe}),kIe={kernelName:zf,backendName:"webgl",kernelFunc:TIe};class $4{constructor(t,e,r){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const i=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${s}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${i};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function L4(n,t,e){const r=e.texData.get(n.dataId),s=X(n.shape),i=n.shape[n.shape.length-1],a=xe({inputs:{x:n},backend:e,attrs:{shape:[s/i,i]}}),l=a.shape,c=new $4("real",l,t),u=new $4("imag",l,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=e.runWebGLProgram(c,d,"float32"),f=e.runWebGLProgram(u,d,"float32"),p=Sl({inputs:{real:h,imag:f},backend:e});e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f);const m=xe({inputs:{x:p},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(p),m}const AIe={kernelName:"FFT",backendName:"webgl",kernelFunc:function NIe(n){const{inputs:t,backend:e}=n,{input:r}=t;return L4(r,!1,e)}};class RIe{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function gm(n){const{backend:t,attrs:e}=n,{shape:r,value:s}=e;let{dtype:i}=e;if(i=i||Sf(s),"string"===i){const o=Kn(i,X(r));return o.fill(s),t.makeTensorInfo(r,i,o)}{const o=new RIe(r,s);return t.runWebGLProgram(o,[],i,[[s]])}}const MIe={kernelName:ZS,backendName:"webgl",kernelFunc:gm};class FIe{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const OIe={kernelName:QS,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,r=t,s=new FIe(e.shape);return r.runWebGLProgram(s,[e],e.dtype)}},B4="return floor(x);",PIe=Nt({opSnippet:B4,packedOpSnippet:B4,cpuKernelImpl:mwe}),$Ie={kernelName:Uf,backendName:"webgl",kernelFunc:PIe},LIe=Rr({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),BIe={kernelName:Hf,backendName:"webgl",kernelFunc:LIe};class VIe{constructor(t){this.variableNames=["A"];const e=es(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class zIe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=es(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const UIe={kernelName:ME,backendName:"webgl",kernelFunc:function HIe(n){const{inputs:t,backend:e,attrs:r}=n;let{pixels:s}=t;const{numChannels:i}=r,o=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,c]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],u=[c,l],d=[c,l,i];if(a||o){const m=G().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==jd||m!==S1)&&(S1=m,jd=document.createElement("canvas").getContext("2d",{willReadFrequently:S1})),jd.canvas.width=l,jd.canvas.height=c,jd.drawImage(s,0,0,l,c),s=jd.canvas}const h=e.makeTensorInfo(u,"int32");e.texData.get(h.dataId).usage=Vs.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId),s);const f=G().getBool("WEBGL_PACK")?new zIe(d):new VIe(d),p=e.runWebGLProgram(f,[h],"int32");return e.disposeData(h.dataId),p}};let jd,S1=G().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const jIe={kernelName:Vb,backendName:"webgl",kernelFunc:function WIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r,m=ba(u),g=wr(s.shape,i.shape,l,d,c,h,!1,m);let y;const b=[],_=null!=o,v=null!=a,w="leakyrelu"===f,C=()=>{const D=[s,i],T=(N,$)=>{if("NCHW"===$&&1===N.shape.length&&1!==N.shape[0]){const z=xe({inputs:{x:N},backend:e,attrs:{shape:[N.shape[0],1,1]}});return b.push(z),z}return N};if(_&&D.push(T(o,u)),v&&D.push(T(a,u)),w){const N=e.makeTensorInfo([],"float32",Ya(p,"float32"));D.push(N),b.push(N)}return D};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&G().getBool("WEBGL_EXP_CONV")){const D=f?hm(f,!0):null,T=new I4(g,_,D,v,w),N=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],$=C();y=e.runWebGLProgram(T,$,"float32",N)}else if(G().getBool("WEBGL_CONV_IM2COL"))y=T4({x:s,filter:i,convInfo:g,backend:e,bias:o,activation:f,preluActivationWeights:a,leakyreluAlpha:p});else{const D=f?hm(f,!1):null,T=new E4(g,_,D,v,w),N=C();y=e.runWebGLProgram(T,N,"float32")}else y=D4({x:s,filter:i,convInfo:g,backend:e,bias:o,activation:f,preluActivationWeights:a,leakyreluAlpha:p});const I=xe({inputs:{x:y},backend:e,attrs:{shape:g.outShape}});return b.push(y),b.forEach(D=>e.disposeIntermediateTensorInfo(D)),I}},qIe={kernelName:zb,backendName:"webgl",kernelFunc:function GIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dilations:u,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,p=[];let m=u;null==m&&(m=[1,1]),S(Nr(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=wr(s.shape,i.shape,l,m,c,d,!0),y=G().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,b=h?hm(h,y):null,_=[s,i],v=null!=o,w=null!=a,C="leakyrelu"===h;if(v&&_.push(o),w&&_.push(a),C){const N=e.makeTensorInfo([],"float32",Ya(f,"float32"));_.push(N),p.push(N)}let I;I=y?new F4(g,v,b,w,C):new M4(g,v,b,w,C);const T=e.runWebGLProgram(I,_,"float32",[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]]);return p.forEach(N=>e.disposeIntermediateTensorInfo(N)),T}};class KIe{constructor(t,e,r,s){this.sliceDim=t,this.strides=e,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const i=an(r.length);let o="\n    int index;";for(let a=0;a<this.sliceDim;a++)o+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${i} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${o}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const YIe={kernelName:JS,backendName:"webgl",kernelFunc:function XIe(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,i=s.shape,o=i[i.length-1],a=X(r.shape),[l,c,u,d]=ED(r,s),h=xe({inputs:{x:s},backend:e,attrs:{shape:[c,o]}}),f=xe({inputs:{x:r},backend:e,attrs:{shape:[X(r.shape)/u,u]}});if(e.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const y=e.readSync(s.dataId),b=e.bufferSync(r),_=gwe(y,b,r.dtype,c,o,u,d,r.shape,a);return e.makeTensorInfo(l,r.dtype,_.values)}const p=new KIe(o,d,[c,u],r.shape),m=e.runWebGLProgram(p,[f,h],f.dtype),g=xe({inputs:{x:m},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),g}};class ZIe{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=an(this.rank),s=function QIe(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)r.push(2===s?"index":`${e[s]}`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}function V4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:i}=t,{axis:o,batchDims:a}=r,l=ft(o,s.shape)[0];if(G().get("DEBUG")){const b=e.readSync(i.dataId),_=s.shape[l];for(let v=0;v<b.length;++v){const w=b[v];S(w<=_-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${_-1}]`)}}const c=zD(s,i,l,a),u=X(i.shape),d=[],h=xe({inputs:{x:s},backend:e,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),f=xe({inputs:{x:i},backend:e,attrs:{shape:[c.batchSize,u/c.batchSize]}});d.push(h),d.push(f);const p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(e.shouldExecuteOnCPU([s,i])||"string"===s.dtype){const b=e.bufferSync(f),_=e.bufferSync(h),v=ywe(_,b,p);return d.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.makeTensorInfo(c.outputShape,v.dtype,v.values)}const m=new ZIe(h.shape,p),g=e.runWebGLProgram(m,[h,f],h.dtype);d.push(g);const y=xe({inputs:{x:g},backend:e,attrs:{shape:c.outputShape}});return d.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}const JIe={kernelName:rb,backendName:"webgl",kernelFunc:V4},eDe=Rr({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:bwe,dtype:"bool"}),tDe={kernelName:sb,backendName:"webgl",kernelFunc:eDe},nDe=Rr({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:_we}),rDe={kernelName:Wf,backendName:"webgl",kernelFunc:nDe},iDe={kernelName:eE,backendName:"webgl",kernelFunc:function sDe(n){const{inputs:t,backend:e}=n,{input:r}=t;return L4(r,!0,e)}},oDe=Nt({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),aDe={kernelName:Gf,backendName:"webgl",kernelFunc:oDe},lDe=Nt({opSnippet:"return float(isinf(x));",dtype:"bool"}),cDe={kernelName:qf,backendName:"webgl",kernelFunc:lDe},uDe=Nt({opSnippet:"return float(isnan(x));",dtype:"bool"}),dDe={kernelName:Kf,backendName:"webgl",kernelFunc:uDe},hDe=Rr({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:vwe,dtype:"bool"}),fDe={kernelName:ob,backendName:"webgl",kernelFunc:hDe},pDe=Rr({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:xwe,dtype:"bool"}),mDe={kernelName:ab,backendName:"webgl",kernelFunc:pDe},yDe={kernelName:nE,backendName:"webgl",kernelFunc:function gDe(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:i}=e,o=wwe(r,s,i);return t.makeTensorInfo([o.length],"float32",o)}},_De=Nt({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:Cwe}),vDe={kernelName:Xf,backendName:"webgl",kernelFunc:_De},wDe=Nt({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"}),CDe={kernelName:Yf,backendName:"webgl",kernelFunc:wDe},SDe=Rr({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),EDe={kernelName:lb,backendName:"webgl",kernelFunc:SDe},IDe=Nt({opSnippet:"return float(!(x >= 1.0));"}),DDe={kernelName:cb,backendName:"webgl",kernelFunc:IDe},TDe=Rr({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),kDe={kernelName:ub,backendName:"webgl",kernelFunc:TDe};class NDe{constructor(t,e,r,s,i){this.variableNames=["x"],this.outputShape=[];const o=e,a=t[3]-1;let l;this.outputShape=t;const c=`float(${r}) + float(${s}) * sum`;l=.5===i?`inversesqrt(${c})`:1===i?`1.0/(${c})`:`exp(log(${c}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${l};\n        setOutput(val);\n      }\n    `}}class ADe{constructor(t,e,r,s,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=e,a=t[3]-1;let l;this.outputShape=t;const c=`float(${r}) + float(${s}) * sum`;l=.5===i?`inversesqrt(${c})`:1===i?`1.0/(${c})`:`exp(log(${c}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${l};\n        setOutput(result);\n      }\n    `}}const RDe={kernelName:db,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:i,bias:o,alpha:a,beta:l}=r,c=G().getBool("WEBGL_PACK_NORMALIZATION")?new ADe(s.shape,i,o,a,l):new NDe(s.shape,i,o,a,l);return e.runWebGLProgram(c,[s],s.dtype)}};class MDe{constructor(t,e,r,s,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=r,this.alpha=s,this.beta=i,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${i})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${i});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const FDe={kernelName:rE,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s,y:i,dy:o}=t,{depthRadius:a,bias:l,alpha:c,beta:u}=r,d=new MDe(s.shape,a,l,c,u);return e.runWebGLProgram(d,[s,i,o],s.dtype)}};function z4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:i,keepDims:o}=r,a=s.shape.length,l=ft(i,s.shape);let c=l;const u=Dn(c,a),d=null!=u,h=e.shouldExecuteOnCPU([s]);let f=s;if(d){if(h){const _=e.texData.get(f.dataId).values,v=new Array(a);for(let I=0;I<v.length;I++)v[I]=s.shape[u[I]];const w=y1(_,s.shape,s.dtype,u,v);f=e.makeTensorInfo(v,s.dtype),e.texData.get(f.dataId).values=w}else f=Iv(s,u,e);c=zn(c.length,a)}Ar("max",c,a);const[p,m]=Cr(f.shape,c);let y,g=p;if(o&&(g=Vn(p,l)),h){const _=e.texData.get(f.dataId).values,v=Swe(_,X(m),g,s.dtype);y=e.makeTensorInfo(g,s.dtype),e.texData.get(y.dataId).values=v}else y=function ODe(n,t,e,r){const s=X(t),a=xe({inputs:{x:n},attrs:{shape:[X(n.shape)/s,s]},backend:r}),l=Mc(a,n.dtype,"max",r),c=xe({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}(f,m,g,e);return d&&e.disposeIntermediateTensorInfo(f),y}const PDe={kernelName:hb,backendName:"webgl",kernelFunc:z4},BDe=Rr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Ewe}),VDe={kernelName:Zf,backendName:"webgl",kernelFunc:BDe},UDe={kernelName:fb,backendName:"webgl",kernelFunc:function zDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;lm(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r;S(Nr(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=Ai(s.shape,i,o,1,a,l);if(1===u.filterWidth&&1===u.filterHeight&&It(u.inShape,u.outShape))return zs({inputs:{x:s},backend:e});const d=new fm(u,"max",!1);return e.runWebGLProgram(d,[s],s.dtype)}},WDe={kernelName:pb,backendName:"webgl",kernelFunc:function HDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,d=ya(s.shape,i,o,[1,1,1],a,c,l),h=new v1(d,"max",!1);return e.runWebGLProgram(h,[s],s.dtype)}};class jDe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const i=t.effectiveFilterHeight,o=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${i-1-t.padInfo.top}, ${o-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${i*o-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${o} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class GDe{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,u=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${l-1-t.padInfo.front}, ${c-1-t.padInfo.top}, ${u-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${l*c*u-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${c} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const KDe={kernelName:iE,backendName:"webgl",kernelFunc:function qDe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=ya(o.shape,a,l,[1,1,1],c,u),f=new v1(h,"max",!0),p=e.runWebGLProgram(f,[o],o.dtype),m=new GDe(h),g=e.runWebGLProgram(m,[s,p],o.dtype);return e.disposeIntermediateTensorInfo(p),g}},YDe={kernelName:sE,backendName:"webgl",kernelFunc:function XDe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i,output:o}=t,a=i;lm([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=r,h=Ai(a.shape,l,c,1,u,d),p=new fm(h,"max",!0),m=e.runWebGLProgram(p,[a],a.dtype),g=new jDe(h),y=e.runWebGLProgram(g,[s,m],a.dtype);return e.disposeIntermediateTensorInfo(m),y}},QDe={kernelName:oE,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=t,l=e;S(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];S(Nr(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const u=Ai(r.shape,s,i,c,o),[d,h]=function ZDe(n,t,e,r){let s=new fm(e,"max",!1);const i=r.runWebGLProgram(s,[n],"float32");return s=new fm(e,"max",!0,!0,t),[i,r.runWebGLProgram(s,[n],"float32")]}(r,a,u,l);return[d,h]}},eTe={kernelName:mb,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{keepDims:s,axis:i}=t,o=e,a=r.shape.length,l=ft(i,r.shape);let c=l;const u=Dn(c,a),d=null!=u,h=o.shouldExecuteOnCPU([r]),f=[];let p=r;if(d){if(h){const v=o.texData.get(p.dataId).values,w=new Array(a);for(let D=0;D<w.length;D++)w[D]=r.shape[u[D]];const C=y1(v,r.shape,r.dtype,u,w);p=o.makeTensorInfo(w,r.dtype),o.texData.get(p.dataId).values=C}else p=Iv(r,u,o);f.push(p),c=zn(c.length,a)}Ar("sum",c,a);const[m,g]=Cr(p.shape,c);let y=m;s&&(y=Vn(m,l));const b=function JDe(n,t,e,r){const s=X(t),a=xe({inputs:{x:n},attrs:{shape:[X(n.shape)/s,s]},backend:r}),l=Mc(a,"float32","mean",r),c=xe({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}(p,g,y,o);for(const _ of f)o.disposeIntermediateTensorInfo(_);return b}},nTe={kernelName:gb,backendName:"webgl",kernelFunc:function tTe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,l=ft(i,s.shape);let c=l;const u=Dn(c,a);let d=s;null!=u&&(d=rs({inputs:{x:s},backend:e,attrs:{perm:u}}),c=zn(c.length,s.shape.length)),Ar("min",c,a);const[h,f]=Cr(d.shape,c),m=xe({inputs:{x:d},backend:e,attrs:{shape:[-1,X(f)]}}),g=Mc(m,m.dtype,"min",e);let y;return y=xe(o?{inputs:{x:g},backend:e,attrs:{shape:Vn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=u&&e.disposeIntermediateTensorInfo(d),y}},iTe=Rr({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Iwe}),oTe={kernelName:Qf,backendName:"webgl",kernelFunc:iTe};class aTe{constructor(t,e,r){this.variableNames=["x"],this.outputShape=e.map((u,d)=>u[0]+t[d]+u[1]);const s=t.length,i=an(s),o=e.map(u=>u[0]).join(","),a=e.map((u,d)=>u[0]+t[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c="reflect"===r?0:1;this.userCode=1!==s?`\n      ${i} start = ${i}(${o});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${c};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};\n          }\n        }\n        ${i} coords = outC - start;\n        setOutput(getX(${l}));\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${c};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${c};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class lTe{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((p,m)=>p[0]+t[m]+p[1]);const s=t.length,i=an(s),o=e.map(p=>p[0]).join(","),a=e.map((p,m)=>p[0]+t[m]).join(","),l=ns("rc",s),c=ns("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${c.slice(-2).join()})`,h="reflect"===r?0:1;let f="";if(1===s){const p=`\n        ${i} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;f=`\n        ${i} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${c.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${u}) {\n          ${p}\n          result[1] = getChannel(getX(${c.join()}), ${d});\n        }\n      `}else{const p=`\n        ${i} source = rc;\n        ${i} lt = ${i}(lessThan(source, start));\n        ${i} gte = ${i}(greaterThanEqual(source, end));\n        ${i} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;f=`\n        ${i} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${c.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${u}) {\n          ${p}\n          result[1] = getChannel(getX(${c.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${l[s-2]} += 1;\n        if(${l[s-2]} < ${this.outputShape[s-2]}) {\n          ${p}\n          result[2] = getChannel(getX(${c.join()}), ${d});\n          ${l[s-1]} += 1;\n          if(${u}) {\n            ${p}\n            result[3] = getChannel(getX(${c.join()}), ${d});\n          }\n        }\n      `}this.userCode=`\n      const ${i} start = ${i}(${o});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}const cTe={kernelName:yb,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r}=n,{paddings:s,mode:i}=e,o=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lTe(r.shape,s,i):new aTe(r.shape,s,i);return t.runWebGLProgram(o,[r],r.dtype)}},hTe=Rr({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),fTe={kernelName:Jf,backendName:"webgl",kernelFunc:hTe};class pTe{constructor(t,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const U4=Rr({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),mTe={kernelName:$f,backendName:"webgl",kernelFunc:U4},H4="return a - b;",W4=Rr({opSnippet:H4,packedOpSnippet:H4,supportsComplex:!0,cpuKernelImpl:Gwe}),gTe={kernelName:mp,backendName:"webgl",kernelFunc:W4};function j4(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:i}=r,o=ft([i],s.shape),a=z4({inputs:{x:s},backend:e,attrs:{reductionIndices:o,keepDims:!1}}),l=Vn(a.shape,o),c=xe({inputs:{x:a},backend:e,attrs:{shape:l}}),u=W4({inputs:{a:s,b:c},backend:e}),d=O4({inputs:{x:u},backend:e}),h=Dv({inputs:{x:d},backend:e,attrs:{axis:o,keepDims:!1}}),f=xe({inputs:{x:h},backend:e,attrs:{shape:l}}),p=U4({inputs:{a:d,b:f},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}const yTe={kernelName:Ob,backendName:"webgl",kernelFunc:j4},_Te={kernelName:aE,backendName:"webgl",kernelFunc:function bTe(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:i,seed:o,normalized:a}=r,l=a?s:j4({inputs:{logits:s},backend:e,attrs:{dim:s.shape.length-1}}),d=new pTe(l.shape[0],l.shape[1],i),f=e.runWebGLProgram(d,[l],"int32",[[o]]);return a||e.disposeIntermediateTensorInfo(l),f}},CTe={kernelName:bb,backendName:"webgl",kernelFunc:function wTe(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])){const i=e.texData.get(r.dataId),[o,a]=Twe(i.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,o)}let s;return s=G().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Cl(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new jo(r.shape,"if (isnan(x)) return x;\n  return -x;\n"),e.runWebGLProgram(s,[r],r.dtype)}},STe=aD,ITe={kernelName:lE,backendName:"webgl",kernelFunc:function ETe(n){si("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r,c=e.readSync(s.dataId),u=e.readSync(i.dataId),{selectedIndices:d}=STe(c,u,o,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},DTe=lD,kTe={kernelName:cE,backendName:"webgl",kernelFunc:function TTe(n){si("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r,u=e.readSync(s.dataId),d=e.readSync(i.dataId),{selectedIndices:h,validOutputs:f}=DTe(u,d,o,a,l,c);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},NTe=cD,RTe={kernelName:uE,backendName:"webgl",kernelFunc:function ATe(n){si("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,u=e.readSync(s.dataId),d=e.readSync(i.dataId),h=o,f=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=NTe(u,d,h,f,p,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class MTe{constructor(t,e,r,s){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const FTe={kernelName:xb,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{dtype:i,depth:o,onValue:a,offValue:l}=r,c=X(s.shape),u=new MTe(c,o,a,l),d=xe({inputs:{x:s},backend:e,attrs:{shape:[c]}}),h=e.runWebGLProgram(u,[d],i);e.disposeIntermediateTensorInfo(d);const p=xe({inputs:{x:h},backend:e,attrs:{shape:[...s.shape,o]}});return e.disposeIntermediateTensorInfo(h),p}};function Mv(n){const{inputs:t,backend:e}=n,{x:r}=t;if("complex64"===r.dtype){const s=pm({inputs:{input:r},backend:e}),i=Mv({inputs:{x:s},backend:e}),o=Av({inputs:{input:r},backend:e}),a=Mv({inputs:{x:o},backend:e}),l=Sl({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return gm({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const OTe={kernelName:Lb,backendName:"webgl",kernelFunc:Mv},PTe={kernelName:vb,backendName:"webgl",kernelFunc:function G4(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const s=pm({inputs:{input:r},backend:e}),i=G4({inputs:{x:s},backend:e}),o=Av({inputs:{input:r},backend:e}),a=Mv({inputs:{x:o},backend:e}),l=Sl({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return gm({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},LTe={kernelName:wb,backendName:"webgl",kernelFunc:function $Te(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return C1({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const i=t[0].shape,o=t[0].dtype;t.forEach(u=>{Ms(i,u.shape,"All tensors passed to stack must have matching shapes"),S(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=S4({inputs:t.map(u=>{const d=C1({inputs:{input:u},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(u=>e.disposeIntermediateTensorInfo(u)),c}};class BTe{constructor(t,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((c,u)=>c[0]+t[u]+c[1]);const s=t.length,i=an(s),o=e.map(c=>c[0]).join(","),a=e.map((c,u)=>c[0]+t[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${i} start = ${i}(${o});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${i} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class VTe{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((m,g)=>m[0]+t[g]+m[1]);const s=t.length,i=an(s),o=e.map(m=>m[0]).join(","),a=e.map((m,g)=>m[0]+t[g]).join(","),l=ns("rc",s),c=ns("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${c.slice(-2).join()})`,h=[`${i} rc = outputLoc;`,`${l[s-1]} += 1;\n       if(${u}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${l[s-2]} += 1;\n       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${l[s-1]} += 1;\n         if(${u}) {`],f=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let m=0,g=1===s?2:4;m<g;m++)p+=`\n        ${h[m]}\n        if (${f}) {\n          result[${m}] = float(value);\n        } else {\n          ${i} source = rc - start;\n          result[${m}] = getChannel(getX(${c.join()}), ${d});\n        }\n      `;p+=1===s?"} ":"}}",this.userCode=`\n      const ${i} start = ${i}(${o});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const q4=n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:i,constantValue:o}=r;if(0===X(s.shape))return gm({backend:e,attrs:{shape:i.map((u,d)=>u[0]+s.shape[d]+u[1]),value:o,dtype:s.dtype}});const a=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new VTe(s.shape,i,o):new BTe(s.shape,i,o);return e.runWebGLProgram(a,[s],s.dtype,[[o]])},zTe={kernelName:Cb,backendName:"webgl",kernelFunc:q4},WTe=Rr({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),jTe={kernelName:tp,backendName:"webgl",kernelFunc:WTe},qTe={kernelName:Eb,backendName:"webgl",kernelFunc:function GTe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,l=[],c=ft(i,s.shape);let u=c;const d=Dn(u,a);let f,h=s;if(null!=d&&(h=rs({inputs:{x:s},backend:e,attrs:{perm:d}}),u=zn(u.length,a),l.push(h)),Ar("prod",u,a),e.shouldExecuteOnCPU([h])){const p=e.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:y}=Nwe(h.shape,h.dtype,p,u);f=e.makeTensorInfo(g,y,m)}else{const[p,m]=Cr(h.shape,u),g=X(m),y=xe({inputs:{x:h},backend:e,attrs:{shape:[-1,g]}}),_=Mc(y,zE(s.dtype),"prod",e);f=xe({inputs:{x:_},backend:e,attrs:{shape:p}}),l.push(y),l.push(_)}if(o){l.push(f);const p=Vn(f.shape,c);f=xe({inputs:{x:f},backend:e,attrs:{shape:p}})}return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}},XTe={kernelName:dE,backendName:"webgl",kernelFunc:function KTe(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=t,{outputRaggedRank:a}=r,l=s.map(y=>e.readSync(y.dataId)),c=s.map(y=>y.shape),u=e.readSync(i.dataId),d=e.readSync(o.dataId),[h,f,p]=Awe(l,c,u,i.shape,i.dtype,d,o.shape,a),m=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),g=e.makeTensorInfo(p,i.dtype,f);return m.concat([g])}},ZTe={kernelName:hE,backendName:"webgl",kernelFunc:function YTe(n){const{inputs:t,backend:e}=n,{starts:r,limits:s,deltas:i}=t,o=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(i.dataId),[c,u]=Rwe(o,r.shape,r.dtype,a,s.shape,l,i.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([u.length],r.dtype,u)]}},JTe={kernelName:fE,backendName:"webgl",kernelFunc:function QTe(n){const{inputs:t,backend:e,attrs:r}=n,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=r,c=e.readSync(s.dataId),u=e.readSync(i.dataId),d=e.readSync(o.dataId),h=a.map(g=>e.readSync(g.dataId)),f=a.map(g=>g.shape),[p,m]=Mwe(c,s.shape,u,i.shape,i.dtype,d,o.shape,h,f,l);return e.makeTensorInfo(p,i.dtype,m)}},K4=n=>{const{backend:t,attrs:e}=n,{start:r,stop:s,step:i,dtype:o}=e,a=Fwe(r,s,i,o);return t.makeTensorInfo([a.length],o,a)},e1e={kernelName:pE,backendName:"webgl",kernelFunc:K4},t1e=Nt({opSnippet:"return 1.0 / x;"}),n1e={kernelName:np,backendName:"webgl",kernelFunc:t1e},s1e=Nt({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),i1e={kernelName:rp,backendName:"webgl",kernelFunc:s1e},a1e=Nt({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),l1e={kernelName:sp,backendName:"webgl",kernelFunc:a1e};class c1e{constructor(t,e,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=i?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class u1e{constructor(t,e,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=i?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]},\n          ${u[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const h1e={kernelName:Tb,backendName:"webgl",kernelFunc:function d1e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=G().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new u1e(s.shape,l,c,i,o):new c1e(s.shape,l,c,i,o);return e.runWebGLProgram(u,[s],"float32")}};class f1e{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,i]=e,[,o,a]=t,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],d=l[1]/c[1],h=1/u,f=1/d,p=2*Math.ceil(h)+2,m=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const m1e={kernelName:yE,backendName:"webgl",kernelFunc:function p1e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r,a=new f1e(i.shape,s.shape,o);return e.runWebGLProgram(a,[i],i.dtype)}};class g1e{constructor(t,e,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let f;f=i?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class y1e{constructor(t,e,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let f;f=i?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]},\n          ${u[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const _1e={kernelName:Db,backendName:"webgl",kernelFunc:function b1e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=G().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new y1e(s.shape,l,c,i,o):new g1e(s.shape,l,c,i,o);return e.runWebGLProgram(u,[s],s.dtype)}};class v1e{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,i]=e,[,o,a]=t,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],d=l[1]/c[1],h=1/u,f=1/d,p=2*Math.ceil(h)+2,m=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${l[0]}) *\n                (float(dyR) / float(${c[0]}));\n\n            float sourceFracCol =\n                float(${l[1]}) *\n                  (float(dyC) / float(${c[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${i}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const w1e={kernelName:gE,backendName:"webgl",kernelFunc:function x1e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r,a=new v1e(i.shape,s.shape,o);return e.runWebGLProgram(a,[i],i.dtype)}};class C1e{constructor(t,e){this.variableNames=["x"];const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const i=t.map((a,l)=>(a=>-1!==e.indexOf(a)&&1!==t[a]?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`)(l)).join(","),o=an(r);this.userCode=`\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}class S1e{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;const s=ns("rc",r),i=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,o=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=an(r);function h(p){const m=t.map((b,_)=>function f(p,m){return-1!==e.indexOf(p)&&1!==t[p]?`${t[p]} - ${m[p]} - 1`:`${m[p]}`}(_,p));return`getChannel(getX(${m.join(",")}), vec2(${m.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${i}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function l(p){return h(p)}(s.slice())};\n          if(${i}){\n            result.g = ${function c(p){return p[r-1]="("+p[r-1]+" + 1)",h(p)}(s.slice())};\n          }\n          if(${o}) {\n            result.b = ${function u(p){return p[r-2]="("+p[r-2]+" + 1)",h(p)}(s.slice())};\n            if(${i}) {\n              result.a = ${function d(p){return p[r-1]="("+p[r-1]+" + 1)",p[r-2]="("+p[r-2]+" + 1)",h(p)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const I1e={kernelName:kb,backendName:"webgl",kernelFunc:function E1e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:i}=r,o=s.shape.length,a=ft(i,s.shape);if(0===o)return zs({inputs:{x:s},backend:e});const l=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new S1e(s.shape,a):new C1e(s.shape,a);return e.runWebGLProgram(l,[s],s.dtype)}};class D1e{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=t[1],s=t[2];this.outputShape=t;let i="";i="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${i}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const T1e={kernelName:FE,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=t,a=e,l=new D1e(r.shape,i),[c,u]=wD(o,r.shape[1],r.shape[2]),d=[[c,u,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,d)}},k1e=Nt({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),N1e={kernelName:ip,backendName:"webgl",kernelFunc:k1e},A1e=Nt({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Owe}),R1e={kernelName:op,backendName:"webgl",kernelFunc:A1e};class X4{constructor(t,e,r,s,i,o,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const l=an(i.length),c=an(o.length);let u="";1===r?u="i":2===r&&(u="i, j");let h="";1===s?h="i":2===s&&(h="i, coords[1]"),this.userCode=`\n        ${l} strides = ${l}(${i});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${u}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${h});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const F1e={kernelName:bE,backendName:"webgl",kernelFunc:function M1e(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:i}=t,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=Bp(0,s,o),h=[d/c,c];if(0===d)return e.makeTensorInfo(o,s.dtype);const f=xe({inputs:{x:s},backend:e,attrs:{shape:[l,a]}}),p=xe({inputs:{x:i},backend:e,attrs:{shape:[l,c]}}),m=e.makeTensorInfo([],"float32",new Float32Array([0])),g=new X4(l,a,f.shape.length,p.shape.length,u,h),y=e.runWebGLProgram(g,[p,f,m],p.dtype),b=xe({inputs:{x:y},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(m),b}};class O1e{constructor(t,e,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,r];const o=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=2===G().getNumber("WEBGL_VERSION")?"while (left < right) {":o;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===s?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const $1e={kernelName:_E,backendName:"webgl",kernelFunc:function P1e(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:s,values:i}=t,{side:o}=r,a=new O1e(s.shape[0],s.shape[1],i.shape[1],o);return e.runWebGLProgram(a,[s,i],"int32",[[s.shape[1]]])}};class L1e{constructor(t,e,r){let s,i;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)i="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<e.length;u++)c.push(`${a[u]}`),u<t&&l.push(`${a[u]}`);s=l.join(),i=c.join()}const o=an(r);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${i}));\n        } else {\n          setOutput(getB(${i}));\n        }\n      }\n    `}}const V1e={kernelName:Nb,backendName:"webgl",kernelFunc:function B1e(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:i}=t,o=new L1e(r.shape.length,s.shape,s.shape.length);return e.runWebGLProgram(o,[r,s,i],Fs(s.dtype,i.dtype))}},U1e=Nt({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${N_};\n  float scale = ${A_};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),H1e={kernelName:ap,backendName:"webgl",kernelFunc:U1e},j1e=Nt({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:$we}),G1e={kernelName:dp,backendName:"webgl",kernelFunc:j1e},q1e=Nt({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),K1e={kernelName:up,backendName:"webgl",kernelFunc:q1e},Y1e=Nt({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),Z1e={kernelName:lp,backendName:"webgl",kernelFunc:Y1e},Q1e=Nt({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),J1e={kernelName:cp,backendName:"webgl",kernelFunc:Q1e},eke=Nt({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),tke={kernelName:hp,backendName:"webgl",kernelFunc:eke},nke={kernelName:Mb,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,paddings:o}=r;S(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((y,b)=>y*b),l=[[0,0]];l.push(...o);for(let y=1+i.length;y<s.shape.length;++y)l.push([0,0]);const c=[],u=q4({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),d=Vp(u.shape,i,a,!1),h=zp(d.length,i.length,!1),f=Up(u.shape,i,a,!1),p=xe({inputs:{x:u},backend:e,attrs:{shape:d}}),m=rs({inputs:{x:p},backend:e,attrs:{perm:h}}),g=xe({inputs:{x:m},backend:e,attrs:{shape:f}});return c.push(u),c.push(p),c.push(m),c.forEach(y=>e.disposeIntermediateTensorInfo(y)),g}},ske={kernelName:vE,backendName:"webgl",kernelFunc:function rke(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.readSync(r.dataId),l=e.readSync(s.dataId),c=e.readSync(i.dataId),u=e.readSync(o.dataId)[0],[d,h,f,p,m]=Bwe(a,r.shape,r.dtype,l,s.dtype,c,u);return[e.makeTensorInfo(h,r.dtype,d),e.makeTensorInfo([h[0]],s.dtype,f),e.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),e.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},oke={kernelName:xE,backendName:"webgl",kernelFunc:function ike(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.readSync(s.dataId)),a=e.readSync(r.dataId),l=Array.from(e.readSync(i.dataId)),[c,u,d]=Vwe(a,r.shape,r.dtype,o,l);return[e.makeTensorInfo(u,r.dtype,c),e.makeTensorInfo([d.length],i.dtype,new Int32Array(d))]}},lke={kernelName:wE,backendName:"webgl",kernelFunc:function ake(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${i.shape}`);const o=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(i.dataId),[c,u]=QU(o,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(u,r.dtype,c)}},uke={kernelName:CE,backendName:"webgl",kernelFunc:function cke(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${i.shape}`);const o=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(i.dataId),[c,u]=QU(o,r.shape,r.dtype,a,l);return e.makeTensorInfo(u,r.dtype,c)}},hke={kernelName:SE,backendName:"webgl",kernelFunc:function dke(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=t,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:h}=Bp(0,s,a);if("string"===i.dtype){const y=e.bufferSync(s),b=e.bufferSync(i),_=Qa(e.readSync(o.dataId)[0]),v=Pwe(y,b,a,h,u,c,l,d,_,!1);return e.makeTensorInfo(a,v.dtype,v.values)}const p=new X4(c,l,s.shape.length,i.shape.length,d,[h,1],!1),m=e.runWebGLProgram(p,[i,s,o],i.dtype),g=xe({inputs:{x:m},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(m),g}},pke={kernelName:Fb,backendName:"webgl",kernelFunc:function fke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:i,axis:o}=r,a=ft(o,s.shape)[0],l=BD(s,i,a),u=new Array(s.shape.length).fill(0),d=s.shape.slice();return l.map(h=>{const f=[...d];f[a]=h;const p=Hd({inputs:{x:s},backend:e,attrs:{begin:u,size:f}});return u[a]+=h,p})}},Y4="return sqrt(x);",mke=Nt({opSnippet:Y4,packedOpSnippet:Y4,cpuKernelImpl:zwe}),gke={kernelName:fp,backendName:"webgl",kernelFunc:mke},bke={kernelName:EE,backendName:"webgl",kernelFunc:Nt({opSnippet:"return x * x;"})},Z4="return (a - b) * (a - b);",_ke=Rr({opSnippet:Z4,packedOpSnippet:Z4}),vke={kernelName:pp,backendName:"webgl",kernelFunc:_ke},wke={kernelName:_p,backendName:"webgl",kernelFunc:function xke({inputs:n,attrs:t,backend:e}){const{x:r}=n,i=new jo(r.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return e.runWebGLProgram(i,[r],r.dtype)}};class Cke{constructor(t,e,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,i=an(r.length),o=an(r.length);let a="";if(1===s)a="coords * strides + begin";else{let l=0;a=r.map((c,u)=>(l++,1===r.length?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`\n      ${i} begin = ${i}(${t});\n      ${i} strides = ${i}(${e});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const Eke={kernelName:IE,backendName:"webgl",kernelFunc:function Ske(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:f,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:_,strides:v}=bI(s.shape,i,o,a,l,c,u,d,h);let w;if(m)w=xe({inputs:{x:s},backend:e,attrs:{shape:p}});else if(g||y){S(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const I=mI(b,_,v),D=Hd({inputs:{x:s},backend:e,attrs:{begin:b,size:I}});w=xe({inputs:{x:D},backend:e,attrs:{shape:p}}),e.disposeIntermediateTensorInfo(D)}else if(e.shouldExecuteOnCPU([s])){const D=e.readSync(s.dataId),T=ot(s.shape,s.dtype,D),N=Uwe(f,T,v,b);w=e.makeTensorInfo(p,s.dtype,N.values)}else{const D=new Cke(b,v,f);w=e.runWebGLProgram(D,[s],s.dtype)}const C=xe({inputs:{x:w},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(w),C}},Dke={kernelName:DE,backendName:"webgl",kernelFunc:function Ike(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:d}=t,h=e.readSync(u.dataId),f=e.readSync(d.dataId),[p,m]=Hwe(h,f,s,i,o,a,l,c);return[e.makeTensorInfo([p.length],"string",p),e.makeTensorInfo(d.shape,"int32",m)]}},kke={kernelName:TE,backendName:"webgl",kernelFunc:function Tke(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.readSync(i.dataId),l=e.readSync(o.dataId)[0],[c,u,d]=Wwe(a,l,s),h=u.length;return[e.makeTensorInfo([h,2],"int32",c),e.makeTensorInfo([h],"string",u),e.makeTensorInfo([2],"int32",new Int32Array(d))]}},Ake={kernelName:kE,backendName:"webgl",kernelFunc:function Nke(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const o=e.readSync(i.dataId),a=jwe(o,s);return e.makeTensorInfo(i.shape,"int32",a)}},Rke=Nt({opSnippet:"return tan(x);"}),Mke={kernelName:gp,backendName:"webgl",kernelFunc:Rke},Fke=Nt({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),Oke={kernelName:yp,backendName:"webgl",kernelFunc:Fke};class Pke{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let o=0;o<r.length;o++)r[o]=t[o]*e[o];this.outputShape=r,this.rank=r.length;const s=an(this.rank),i=function $ke(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${e[s]}, ${n[s]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}function Q4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:i}=r;if("string"===s.dtype||s.shape.length>5){const l=e.readSync(s.dataId),c="string"===s.dtype?l.map(h=>Qa(h)):l,u=ot(s.shape,s.dtype,c),d=qwe(u,i);return e.makeTensorInfo(d.shape,d.dtype,d.values)}const o=new Pke(s.shape,i);return e.runWebGLProgram(o,[s],s.dtype)}const Lke={kernelName:bp,backendName:"webgl",kernelFunc:Q4};class Bke{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class Vke{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function Fc(n,t){null!==t&&n.disposeIntermediateTensorInfo(t)}function J4(n){let t=1;for(;t<n;)t*=2;return t}const Uke={kernelName:NE,backendName:"webgl",kernelFunc:function zke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:i,sorted:o}=r,a=G().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=G().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,u=c[c.length-1];if(e.shouldExecuteOnCPU([s])||u<a||i>l){const N=e.readSync(s.dataId),[$,z]=Kwe(N,c,s.dtype,i,o);return[e.makeTensorInfo($.shape,$.dtype,$.values),e.makeTensorInfo(z.shape,z.dtype,z.values)]}if(0===i)return c[c.length-1]=0,[e.makeTensorInfo(c,s.dtype,[]),e.makeTensorInfo(c,"int32",[])];if(1===u)return[s,gm({attrs:{shape:c,dtype:"int32",value:0},backend:e})];const d=e.texData.get(s.dataId),h=null!==d&&d.isPacked,f=h?e.unpackTensor(s):s,m=X(c)/u,g=xe({inputs:{x:f},attrs:{shape:[m,u]},backend:e});h&&Fc(e,f);const y=J4(i),b=J4(u);let _=null;const v=()=>null===_?[g,g]:[g,_],w=(N,$,z)=>{const j=v(),q=new Bke(z),B=_;_=e.runWebGLProgram(q,j,"int32",[[u],[null===_?1:0],[Number.NEGATIVE_INFINITY],[N],[$]]),Fc(e,B)};for(let N=1;N<y;N*=2){const $=2*N;for(let z=N;z>=1;z/=2)w($,z,[m,b])}for(let N=b;N>y;N/=2){const $=v(),z=new Vke([m,N/2]),K=_;_=e.runWebGLProgram(z,$,"int32",[[u],[null===_?1:0],[y]]),Fc(e,K);const P=y/2,B=2*P;for(let L=P;L>=1;L/=2)w(B,L,_.shape)}let C=_;_=Hd({inputs:{x:_},backend:e,attrs:{begin:0,size:[m,i]}}),Fc(e,C);let I=V4({inputs:{x:g,indices:_},backend:e,attrs:{axis:1,batchDims:1}});Fc(e,g);const D=c.slice(0,-1);D.push(i),C=_,_=xe({inputs:{x:_},attrs:{shape:D},backend:e}),Fc(e,C);const T=I;return I=xe({inputs:{x:I},attrs:{shape:D},backend:e}),Fc(e,T),[I,_]}};class Hke{constructor(t,e,r,s,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a="nearest"===r?1:2;let l;switch(s){case"constant":default:l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${l} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${i});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${i});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const jke={kernelName:AE,backendName:"webgl",kernelFunc:function Wke(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=r,[u,d,h,f]=s.shape,[p,m]=c??[d,h],y=new Hke(d,h,o,a,l,[u,p,m,f]);return e.runWebGLProgram(y,[s,i],"float32")}},qke={kernelName:RE,backendName:"webgl",kernelFunc:function Gke(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:i}=t;lm(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(i.dataId),{outputValues:a,outputShape:l,indices:c}=Xwe(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},Xke={kernelName:Pb,backendName:"webgl",kernelFunc:function Kke(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s,a=o.shape.length,l=s.shape[i],c=new Array(a-1);let u=0;for(let m=0;m<a;m++)m!==i&&(c[u++]=o.shape[m]);const d=[],h=new Array(a).fill(0),f=o.shape.slice();f[i]=1;const p=new Array(l);for(let m=0;m<p.length;m++){h[i]=m;const g=Hd({inputs:{x:o},backend:e,attrs:{begin:h,size:f}}),y=xe({inputs:{x:g},backend:e,attrs:{shape:c}});p[m]=y,d.push(g)}return d.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}};class Yke{constructor(t,e){this.variableNames=["x","segmentIds"];const r=t.windowSize,s=t.batchSize,i=t.inSize,o=t.numSegments,a=o*Math.ceil(i/r);this.outputShape=[s,a];const u=4*Math.floor(r/4),d=r%4,h="\n        sumValue += dot(values, segFilter);\n    ";let f="";i%r>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `);let p="";i%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${p}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}const Jke=[HCe,jCe,KCe,ZCe,JCe,nSe,sSe,oSe,uSe,hSe,mSe,bSe,xSe,ESe,TSe,NSe,RSe,PSe,LSe,VSe,HSe,XSe,ZSe,JSe,sEe,oEe,uEe,ICe,fEe,bEe,wEe,TEe,NEe,REe,FEe,PEe,BEe,zEe,HEe,jEe,qEe,XEe,QEe,eIe,sIe,oIe,cIe,hIe,pIe,gIe,_Ie,xIe,SIe,IIe,DIe,kIe,AIe,MIe,OIe,$Ie,BIe,UIe,jIe,qIe,YIe,JIe,tDe,rDe,ECe,iDe,gEe,aDe,cDe,dDe,TCe,fDe,mDe,yDe,vDe,CDe,EDe,DDe,kDe,RDe,FDe,PDe,VDe,UDe,WDe,KDe,YDe,QDe,eTe,nTe,oTe,cTe,fTe,_Te,ACe,CTe,ITe,kTe,RTe,eEe,FTe,PTe,LTe,zTe,jTe,NCe,qTe,XTe,ZTe,JTe,e1e,tEe,mTe,n1e,i1e,l1e,MCe,h1e,m1e,_1e,w1e,I1e,T1e,N1e,R1e,F1e,$1e,V1e,H1e,G1e,K1e,Z1e,J1e,KSe,yTe,tke,nke,ske,oke,lke,uke,hke,pke,gke,bke,vke,wke,Eke,Dke,kke,Ake,gTe,VCe,Mke,Oke,Lke,Uke,jke,zCe,qke,Xke,{kernelName:$b,backendName:"webgl",kernelFunc:function Zke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:i}=t,{numSegments:o}=r,a=s.shape.length,l=[];let c=0;const u=Dn([c],a);let d=s;null!=u&&(d=rs({inputs:{x:s},backend:e,attrs:{perm:u}}),l.push(d),c=zn(1,a)[0]);const h=mV(d.shape,c,o),f=X([d.shape[c]]),p=xe({inputs:{x:d},backend:e,attrs:{shape:[-1,f]}});l.push(p);const m=zE(s.dtype),g=(v,w,C,I,D)=>{const T=v.shape[0],N=v.shape[1],$=pV(N,D),j=new Yke({windowSize:$,inSize:N,batchSize:T,numSegments:D},w),q=e.compileAndRun(j,[v,C],I);if(l.push(q),q.shape[1]===D)return q;const K=K4({backend:e,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),P=Q4({inputs:{x:K},backend:e,attrs:{reps:[N/$]}});return l.push(K),l.push(P),g(q,w,P,I,D)},b=xe({inputs:{x:g(p,"unsortedSegmentSum",i,m,o)},backend:e,attrs:{shape:h}});let _=b;if(null!=u){l.push(b);const v=al(u);_=rs({inputs:{x:_},backend:e,attrs:{perm:v}})}return l.forEach(v=>e.disposeIntermediateTensorInfo(v)),_}},OTe];for(const n of Jke)$E(n);function E1(n,t){const e=new Map;for(let r=0;r<t.length;r++){let s=n.findIndex(i=>i===t[r]);-1!==s&&e.set(s,t[r])}return e}const eH=["Person","Sneakers","Chair","Other Shoes","Hat","Car","Lamp","Glasses","Bottle","Desk","Cup","Street Lights","Cabinet/shelf","Handbag/Satchel","Bracelet","Plate","Picture/Frame","Helmet","Book","Gloves","Storage box","Boat","Leather Shoes","Flower","Bench","Potted Plant","Bowl/Basin","Flag","Pillow","Boots","Vase","Microphone","Necklace","Ring","SUV","Wine Glass","Belt","Monitor/TV","Backpack","Umbrella","Traffic Light","Speaker","Watch","Tie","Trash bin Can","Slippers","Bicycle","Stool","Barrel/bucket","Van","Couch","Sandals","Basket","Drum","Pen/Pencil","Bus","Wild Bird","High Heels","Motorcycle","Guitar","Carpet","Cell Phone","Bread","Camera","Canned","Truck","Traffic cone","Cymbal","Lifesaver","Towel","Stuffed Toy","Candle","Sailboat","Laptop","Awning","Bed","Faucet","Tent","Horse","Mirror","Power outlet","Sink","Apple","Air Conditioner","Knife","Hockey Stick","Paddle","Pickup Truck","Fork","Traffic Sign","Balloon","Tripod","Dog","Spoon","Clock","Pot","Cow","Cake","Dinning Table","Sheep","Hanger","Blackboard/Whiteboard","Napkin","Other Fish","Orange/Tangerine","Toiletry","Keyboard","Tomato","Lantern","Machinery Vehicle","Fan","Green Vegetables","Banana","Baseball Glove","Airplane","Mouse","Train","Pumpkin","Soccer","Skiboard","Luggage","Nightstand","Tea pot","Telephone","Trolley","Head Phone","Sports Car","Stop Sign","Dessert","Scooter","Stroller","Crane","Remote","Refrigerator","Oven","Lemon","Duck","Baseball Bat","Surveillance Camera","Cat","Jug","Broccoli","Piano","Pizza","Elephant","Skateboard","Surfboard","Gun","Skating and Skiing shoes","Gas stove","Donut","Bow Tie","Carrot","Toilet","Kite","Strawberry","Other Balls","Shovel","Pepper","Computer Box","Toilet Paper","Cleaning Products","Chopsticks","Microwave","Pigeon","Baseball","Cutting/chopping Board","Coffee Table","Side Table","Scissors","Marker","Pie","Ladder","Snowboard","Cookies","Radiator","Fire Hydrant","Basketball","Zebra","Grape","Giraffe","Potato","Sausage","Tricycle","Violin","Egg","Fire Extinguisher","Candy","Fire Truck","Billiards","Converter","Bathtub","Wheelchair","Golf Club","Briefcase","Cucumber","Cigar/Cigarette","Paint Brush","Pear","Heavy Truck","Hamburger","Extractor","Extension Cord","Tong","Tennis Racket","Folder","American Football","earphone","Mask","Kettle","Tennis","Ship","Swing","Coffee Machine","Slide","Carriage","Onion","Green beans","Projector","Frisbee","Washing Machine/Drying Machine","Chicken","Printer","Watermelon","Saxophone","Tissue","Toothbrush","Ice cream","Hot-air balloon","Cello","French Fries","Scale","Trophy","Cabbage","Hot dog","Blender","Peach","Rice","Wallet/Purse","Volleyball","Deer","Goose","Tape","Tablet","Cosmetics","Trumpet","Pineapple","Golf Ball","Ambulance","Parking meter","Mango","Key","Hurdle","Fishing Rod","Medal","Flute","Brush","Penguin","Megaphone","Corn","Lettuce","Garlic","Swan","Helicopter","Green Onion","Sandwich","Nuts","Speed Limit Sign","Induction Cooker","Broom","Trombone","Plum","Rickshaw","Goldfish","Kiwi fruit","Router/modem","Poker Card","Toaster","Shrimp","Sushi","Cheese","Notepaper","Cherry","Pliers","CD","Pasta","Hammer","Cue","Avocado","Hamimelon","Flask","Mushroom","Screwdriver","Soap","Recorder","Bear","Eggplant","Board Eraser","Coconut","Tape Measure/Ruler","Pig","Showerhead","Globe","Chips","Steak","Crosswalk Sign","Stapler","Camel","Formula 1","Pomegranate","Dishwasher","Crab","Hoverboard","Meat ball","Rice Cooker","Tuba","Calculator","Papaya","Antelope","Parrot","Seal","Butterfly","Dumbbell","Donkey","Lion","Urinal","Dolphin","Electric Drill","Hair Dryer","Egg tart","Jellyfish","Treadmill","Lighter","Grapefruit","Game board","Mop","Radish","Baozi","Target","French","Spring Rolls","Monkey","Rabbit","Pencil Case","Yak","Red Cabbage","Binoculars","Asparagus","Barbell","Scallop","Noddles","Comb","Dumpling","Oyster","Table Tennis paddle","Cosmetics Brush/Eyeliner Pencil","Chainsaw","Eraser","Lobster","Durian","Okra","Lipstick","Cosmetics Mirror","Curling","Table Tennis"],tNe=["Person","Sneakers","Chair","Other Shoes","Hat","Car","Lamp","Glasses","Bottle","Desk","Cup","Street Lights","Cabinet/shelf","Handbag/Satchel","Bracelet","Plate","Picture/Frame","Helmet"],tH=["Person","Bicycle","Car","Motorcycle","Airplane","Bus","Train","Truck","Boat","Traffic light","Fire hydrant","Stop sign","Parking meter","Bench","Bird","Cat","Dog","Horse","Sheep","Cow","Elephant","Bear","Zebra","Giraffe","Backpack","Umbrella","Handbag","Tie","Suitcase","Frisbee","Skis","Snowboard","Sports ball","Kite","Baseball bat","Baseball glove","Skateboard","Surfboard","Tennis racket","Bottle","Wine glass","Cup","Fork","Knife","Spoon","Bowl","Banana","Apple","Sandwich","Orange","Broccoli","Carrot","Hot dog","Pizza","Donut","Cake","Chair","Couch","Potted plant","Bed","Dining table","Toilet","Tv","Laptop","Mouse","Remote","Keyboard","Cell phone","Microwave","Oven","Toaster","Sink","Refrigerator","Book","Clock","Vase","Scissors","Teddy bear","Hair drier","Toothbrush"],nNe=["Person","Bicycle","Car","Motorcycle","Airplane","Bus","Train","Truck","Boat","Traffic light","Fire hydrant","Stop sign","Parking meter","Bench","Bird","Cat","Dog","Horse"];class Fv{constructor(){this.modelLoaded=!0,this.modelLoaded$=new kt,this.classMap=new Map,this.font="10px sans-serif";let t="assets/model/model.json";this.classMap=E1(eH,tNe),this.checkiOS()&&(console.log("iOS detected, load simple model"),t="assets/model_simple/model.json",this.classMap=E1(tH,nNe)),this.model$=Pn(function Cpe(n){return WT.apply(this,arguments)}(t)).pipe(ze(e=>(e?.inputs[0]?.shape&&([this.modelWidth,this.modelHeight]=e.inputs[0].shape.slice(1,3)),e)),To(e=>(console.log(e),Oe(-1))),$r(1)),this.modelSubscription=this.model$.pipe($r(1)).subscribe(e=>{this.graphModel=e,e?.inputs[0]?.shape&&([this.modelWidth,this.modelHeight]=e.inputs[0].shape.slice(1,3),console.log("model loaded"),this.modelLoaded=!0,this.modelLoaded$.next(!0))}),this.modelLoaded$.pipe($r(1)).subscribe(()=>this.modelSubscription.unsubscribe())}ngOnDestroy(){this.modelSubscription.unsubscribe()}isModelLoaded(){return this.modelLoaded}checkiOS(){return["iPad Simulator","iPhone Simulator","iPod Simulator","iPad","iPhone","iPod"].includes(navigator.platform)}predict(t,e,r,s,i,o){return gy(()=>{let a=t.getContext("2d");if(o&&i){let c=this.getScaledImageRect(i,t);this.drawImageOnCanvas(i,e,[0,0,i.width,i.height],c)}else s&&a.drawImage(s,0,0,s.videoWidth,s.videoHeight);const l=V(()=>xa.resizeBilinear(hre(t),[this.modelWidth,this.modelHeight]).div(255).expandDims(0));return Pn(this.graphModel.executeAsync(l)).pipe(ze(c=>{r.drawImage(t,0,0,640,640),r.font=this.font,r.textBaseline="top";const[u,d,h,f]=c,p=u.dataSync(),m=d.dataSync(),g=h.dataSync(),y=f.dataSync()[0];var b;for(Qe(c),Qe(l),b=0;b<y;++b){const _=m[b].toFixed(2);if(!this.classMap.get(g[b])||_<.5)continue;let[v,w,C,I]=p.slice(4*b,4*(b+1));v*=t.width,C*=t.width,w*=t.height,I*=t.height;const D=C-v,T=I-w,N=this.classMap.get(g[b]);r.strokeStyle="#00FFFF",r.lineWidth=1,r.strokeRect(v,w,D,T),r.fillStyle="#00FFFF";const $=r.measureText(N+":"+_).width,z=parseInt(this.font,10);r.fillRect(v,w,$+4,z+1)}for(b=0;b<y;++b){const _=m[b].toFixed(2);if(!this.classMap.get(g[b])||_<.5)continue;let[v,w,,]=p.slice(4*b,4*(b+1));v*=t.width,w*=t.height;const C=this.classMap.get(g[b]);r.fillStyle="#000000",r.fillText(C+":"+_,v,w)}return Qe(p),Qe(m),Qe(g),Qe(y),Oe(1)}),$r(1))})}getClassNames(){return this.classMap}setClassNames(t){const e=this.checkiOS()?tH:eH;this.classMap=E1(e,t)}getScaledImageRect(t,e){const r=Math.min(e.width/t.naturalWidth,e.height/t.naturalHeight),s=Math.round(t.naturalWidth*r),i=Math.round(t.naturalHeight*r);return[(e.width-s)/2,(e.height-i)/2,s,i]}drawImageOnCanvas(t,e,r,s){const[i,o,a,l]=r,[c,u,d,h]=s;e.fillStyle="#000000",e.fillRect(0,0,e.canvas.width,e.canvas.height),e.drawImage(t,i,o,a,l,c,u,d,h)}static#e=this.\u0275fac=function(e){return new(e||Fv)};static#t=this.\u0275cmp=is({type:Fv,selectors:[["app-model-import"]],decls:0,vars:0,template:function(e,r){}})}let I1;try{I1=typeof Intl<"u"&&Intl.v8BreakIterator}catch{I1=!1}let ym,Oc,D1,Us=(()=>{class n{constructor(e){this._platformId=e,this.isBrowser=this._platformId?function UZ(n){return n===P2}(this._platformId):"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!I1)&&typeof CSS<"u"&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return n.\u0275fac=function(e){return new(e||n)(Z(aC))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function Ov(n){return function iNe(){if(null==ym&&typeof window<"u")try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>ym=!0}))}finally{ym=ym||!1}return ym}()?n:!!n.capture}function oNe(){if(null==Oc){if("object"!=typeof document||!document||"function"!=typeof Element||!Element)return Oc=!1,Oc;if("scrollBehavior"in document.documentElement.style)Oc=!0;else{const n=Element.prototype.scrollTo;Oc=!!n&&!/\{\s*\[native code\]\s*\}/.test(n.toString())}}return Oc}function Pc(n){return n.composedPath?n.composedPath()[0]:n.target}function T1(){return typeof __karma__<"u"&&!!__karma__||typeof jasmine<"u"&&!!jasmine||typeof jest<"u"&&!!jest||typeof Mocha<"u"&&!!Mocha}function bm(n,...t){return t.length?t.some(e=>n[e]):n.altKey||n.shiftKey||n.ctrlKey||n.metaKey}class CNe extends He{constructor(t,e){super()}schedule(t,e=0){return this}}const $v={setInterval(n,t,...e){const{delegate:r}=$v;return r?.setInterval?r.setInterval(n,t,...e):setInterval(n,t,...e)},clearInterval(n){const{delegate:t}=$v;return(t?.clearInterval||clearInterval)(n)},delegate:void 0};class M1 extends CNe{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){var r;if(this.closed)return this;this.state=t;const s=this.id,i=this.scheduler;return null!=s&&(this.id=this.recycleAsyncId(i,s,e)),this.pending=!0,this.delay=e,this.id=null!==(r=this.id)&&void 0!==r?r:this.requestAsyncId(i,this.id,e),this}requestAsyncId(t,e,r=0){return $v.setInterval(t.flush.bind(t,this),r)}recycleAsyncId(t,e,r=0){if(null!=r&&this.delay===r&&!1===this.pending)return e;null!=e&&$v.clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const r=this._execute(t,e);if(r)return r;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let s,r=!1;try{this.work(t)}catch(i){r=!0,s=i||new Error("Scheduled action threw falsy error")}if(r)return this.unsubscribe(),s}unsubscribe(){if(!this.closed){const{id:t,scheduler:e}=this,{actions:r}=e;this.work=this.state=this.scheduler=null,this.pending=!1,ct(r,this),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null,super.unsubscribe()}}}const aH={now:()=>(aH.delegate||Date).now(),delegate:void 0};class _m{constructor(t,e=_m.now){this.schedulerActionCtor=t,this.now=e}schedule(t,e=0,r){return new this.schedulerActionCtor(this,t).schedule(r,e)}}_m.now=aH.now;class F1 extends _m{constructor(t,e=_m.now){super(t,e),this.actions=[],this._active=!1}flush(t){const{actions:e}=this;if(this._active)return void e.push(t);let r;this._active=!0;do{if(r=t.execute(t.state,t.delay))break}while(t=e.shift());if(this._active=!1,r){for(;t=e.shift();)t.unsubscribe();throw r}}}const O1=new F1(M1),SNe=O1;function lH(n,t=O1){return On((e,r)=>{let s=null,i=null,o=null;const a=()=>{if(s){s.unsubscribe(),s=null;const c=i;i=null,r.next(c)}};function l(){const c=o+n,u=t.now();if(u<c)return s=this.schedule(void 0,c-u),void r.add(s);a()}e.subscribe(Sn(r,c=>{i=c,o=t.now(),s||(s=t.schedule(l,n),r.add(s))},()=>{a(),r.complete()},void 0,()=>{i=s=null}))})}function cH(n){return As((t,e)=>n<=e)}function uH(n,t=Fa){return n=n??ENe,On((e,r)=>{let s,i=!0;e.subscribe(Sn(r,o=>{const a=t(o);(i||!n(s,a))&&(i=!1,s=a,r.next(o))}))})}function ENe(n,t){return n===t}function Go(n){return On((t,e)=>{Cs(n).subscribe(Sn(e,()=>e.complete(),Or)),!e.closed&&t.subscribe(e)})}function Hi(n){return null!=n&&"false"!=`${n}`}function vm(n,t=0){return function INe(n){return!isNaN(parseFloat(n))&&!isNaN(Number(n))}(n)?Number(n):t}function Lv(n){return Array.isArray(n)?n:[n]}function cr(n){return null==n?"":"string"==typeof n?n:`${n}px`}function qd(n){return n instanceof hn?n.nativeElement:n}const dH=new Set;let Kd,DNe=(()=>{class n{constructor(e){this._platform=e,this._matchMedia=this._platform.isBrowser&&window.matchMedia?window.matchMedia.bind(window):kNe}matchMedia(e){return(this._platform.WEBKIT||this._platform.BLINK)&&function TNe(n){if(!dH.has(n))try{Kd||(Kd=document.createElement("style"),Kd.setAttribute("type","text/css"),document.head.appendChild(Kd)),Kd.sheet&&(Kd.sheet.insertRule(`@media ${n} {body{ }}`,0),dH.add(n))}catch(t){console.error(t)}}(e),this._matchMedia(e)}}return n.\u0275fac=function(e){return new(e||n)(Z(Us))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function kNe(n){return{matches:"all"===n||""===n,media:n,addListener:()=>{},removeListener:()=>{}}}let P1=(()=>{class n{constructor(e,r){this._mediaMatcher=e,this._zone=r,this._queries=new Map,this._destroySubject=new kt}ngOnDestroy(){this._destroySubject.next(),this._destroySubject.complete()}isMatched(e){return hH(Lv(e)).some(s=>this._registerQuery(s).mql.matches)}observe(e){let i=jC(hH(Lv(e)).map(o=>this._registerQuery(o).observable));return i=my(i.pipe($r(1)),i.pipe(cH(1),lH(0))),i.pipe(ze(o=>{const a={matches:!1,breakpoints:{}};return o.forEach(({matches:l,query:c})=>{a.matches=a.matches||l,a.breakpoints[c]=l}),a}))}_registerQuery(e){if(this._queries.has(e))return this._queries.get(e);const r=this._mediaMatcher.matchMedia(e),i={observable:new Cn(o=>{const a=l=>this._zone.run(()=>o.next(l));return r.addListener(a),()=>{r.removeListener(a)}}).pipe(yy(r),ze(({matches:o})=>({query:e,matches:o})),Go(this._destroySubject)),mql:r};return this._queries.set(e,i),i}}return n.\u0275fac=function(e){return new(e||n)(Z(DNe),Z(yt))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function hH(n){return n.map(t=>t.split(",")).reduce((t,e)=>t.concat(e)).map(t=>t.trim())}class MNe{constructor(t){this._items=t,this._activeItemIndex=-1,this._activeItem=null,this._wrap=!1,this._letterKeyStream=new kt,this._typeaheadSubscription=He.EMPTY,this._vertical=!0,this._allowedModifierKeys=[],this._homeAndEnd=!1,this._pageUpAndDown={enabled:!1,delta:10},this._skipPredicateFn=e=>e.disabled,this._pressedLetters=[],this.tabOut=new kt,this.change=new kt,t instanceof Yh&&(this._itemChangesSubscription=t.changes.subscribe(e=>{if(this._activeItem){const s=e.toArray().indexOf(this._activeItem);s>-1&&s!==this._activeItemIndex&&(this._activeItemIndex=s)}}))}skipPredicate(t){return this._skipPredicateFn=t,this}withWrap(t=!0){return this._wrap=t,this}withVerticalOrientation(t=!0){return this._vertical=t,this}withHorizontalOrientation(t){return this._horizontal=t,this}withAllowedModifierKeys(t){return this._allowedModifierKeys=t,this}withTypeAhead(t=200){return this._typeaheadSubscription.unsubscribe(),this._typeaheadSubscription=this._letterKeyStream.pipe(tr(e=>this._pressedLetters.push(e)),lH(t),As(()=>this._pressedLetters.length>0),ze(()=>this._pressedLetters.join(""))).subscribe(e=>{const r=this._getItemsArray();for(let s=1;s<r.length+1;s++){const i=(this._activeItemIndex+s)%r.length,o=r[i];if(!this._skipPredicateFn(o)&&0===o.getLabel().toUpperCase().trim().indexOf(e)){this.setActiveItem(i);break}}this._pressedLetters=[]}),this}cancelTypeahead(){return this._pressedLetters=[],this}withHomeAndEnd(t=!0){return this._homeAndEnd=t,this}withPageUpDown(t=!0,e=10){return this._pageUpAndDown={enabled:t,delta:e},this}setActiveItem(t){const e=this._activeItem;this.updateActiveItem(t),this._activeItem!==e&&this.change.next(this._activeItemIndex)}onKeydown(t){const e=t.keyCode,s=["altKey","ctrlKey","metaKey","shiftKey"].every(i=>!t[i]||this._allowedModifierKeys.indexOf(i)>-1);switch(e){case 9:return void this.tabOut.next();case 40:if(this._vertical&&s){this.setNextItemActive();break}return;case 38:if(this._vertical&&s){this.setPreviousItemActive();break}return;case 39:if(this._horizontal&&s){"rtl"===this._horizontal?this.setPreviousItemActive():this.setNextItemActive();break}return;case 37:if(this._horizontal&&s){"rtl"===this._horizontal?this.setNextItemActive():this.setPreviousItemActive();break}return;case 36:if(this._homeAndEnd&&s){this.setFirstItemActive();break}return;case 35:if(this._homeAndEnd&&s){this.setLastItemActive();break}return;case 33:if(this._pageUpAndDown.enabled&&s){const i=this._activeItemIndex-this._pageUpAndDown.delta;this._setActiveItemByIndex(i>0?i:0,1);break}return;case 34:if(this._pageUpAndDown.enabled&&s){const i=this._activeItemIndex+this._pageUpAndDown.delta,o=this._getItemsArray().length;this._setActiveItemByIndex(i<o?i:o-1,-1);break}return;default:return void((s||bm(t,"shiftKey"))&&(t.key&&1===t.key.length?this._letterKeyStream.next(t.key.toLocaleUpperCase()):(e>=65&&e<=90||e>=48&&e<=57)&&this._letterKeyStream.next(String.fromCharCode(e))))}this._pressedLetters=[],t.preventDefault()}get activeItemIndex(){return this._activeItemIndex}get activeItem(){return this._activeItem}isTyping(){return this._pressedLetters.length>0}setFirstItemActive(){this._setActiveItemByIndex(0,1)}setLastItemActive(){this._setActiveItemByIndex(this._items.length-1,-1)}setNextItemActive(){this._activeItemIndex<0?this.setFirstItemActive():this._setActiveItemByDelta(1)}setPreviousItemActive(){this._activeItemIndex<0&&this._wrap?this.setLastItemActive():this._setActiveItemByDelta(-1)}updateActiveItem(t){const e=this._getItemsArray(),r="number"==typeof t?t:e.indexOf(t);this._activeItem=e[r]??null,this._activeItemIndex=r}destroy(){this._typeaheadSubscription.unsubscribe(),this._itemChangesSubscription?.unsubscribe(),this._letterKeyStream.complete(),this.tabOut.complete(),this.change.complete(),this._pressedLetters=[]}_setActiveItemByDelta(t){this._wrap?this._setActiveInWrapMode(t):this._setActiveInDefaultMode(t)}_setActiveInWrapMode(t){const e=this._getItemsArray();for(let r=1;r<=e.length;r++){const s=(this._activeItemIndex+t*r+e.length)%e.length;if(!this._skipPredicateFn(e[s]))return void this.setActiveItem(s)}}_setActiveInDefaultMode(t){this._setActiveItemByIndex(this._activeItemIndex+t,t)}_setActiveItemByIndex(t,e){const r=this._getItemsArray();if(r[t]){for(;this._skipPredicateFn(r[t]);)if(!r[t+=e])return;this.setActiveItem(t)}}_getItemsArray(){return this._items instanceof Yh?this._items.toArray():this._items}}class FNe extends MNe{setActiveItem(t){this.activeItem&&this.activeItem.setInactiveStyles(),super.setActiveItem(t),this.activeItem&&this.activeItem.setActiveStyles()}}function gH(n){return 0===n.buttons||0===n.offsetX&&0===n.offsetY}function yH(n){const t=n.touches&&n.touches[0]||n.changedTouches&&n.changedTouches[0];return!(!t||-1!==t.identifier||null!=t.radiusX&&1!==t.radiusX||null!=t.radiusY&&1!==t.radiusY)}const VNe=new me("cdk-input-modality-detector-options"),zNe={ignoreKeys:[18,17,224,91,16]},Xd=Ov({passive:!0,capture:!0});let UNe=(()=>{class n{constructor(e,r,s,i){this._platform=e,this._mostRecentTarget=null,this._modality=new Di(null),this._lastTouchMs=0,this._onKeydown=o=>{this._options?.ignoreKeys?.some(a=>a===o.keyCode)||(this._modality.next("keyboard"),this._mostRecentTarget=Pc(o))},this._onMousedown=o=>{Date.now()-this._lastTouchMs<650||(this._modality.next(gH(o)?"keyboard":"mouse"),this._mostRecentTarget=Pc(o))},this._onTouchstart=o=>{yH(o)?this._modality.next("keyboard"):(this._lastTouchMs=Date.now(),this._modality.next("touch"),this._mostRecentTarget=Pc(o))},this._options={...zNe,...i},this.modalityDetected=this._modality.pipe(cH(1)),this.modalityChanged=this.modalityDetected.pipe(uH()),e.isBrowser&&r.runOutsideAngular(()=>{s.addEventListener("keydown",this._onKeydown,Xd),s.addEventListener("mousedown",this._onMousedown,Xd),s.addEventListener("touchstart",this._onTouchstart,Xd)})}get mostRecentModality(){return this._modality.value}ngOnDestroy(){this._modality.complete(),this._platform.isBrowser&&(document.removeEventListener("keydown",this._onKeydown,Xd),document.removeEventListener("mousedown",this._onMousedown,Xd),document.removeEventListener("touchstart",this._onTouchstart,Xd))}}return n.\u0275fac=function(e){return new(e||n)(Z(Us),Z(yt),Z(vt),Z(VNe,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const HNe=new me("liveAnnouncerElement",{providedIn:"root",factory:function WNe(){return null}}),jNe=new me("LIVE_ANNOUNCER_DEFAULT_OPTIONS");let $1=(()=>{class n{constructor(e,r,s,i){this._ngZone=r,this._defaultOptions=i,this._document=s,this._liveElement=e||this._createLiveElement()}announce(e,...r){const s=this._defaultOptions;let i,o;return 1===r.length&&"number"==typeof r[0]?o=r[0]:[i,o]=r,this.clear(),clearTimeout(this._previousTimeout),i||(i=s&&s.politeness?s.politeness:"polite"),null==o&&s&&(o=s.duration),this._liveElement.setAttribute("aria-live",i),this._ngZone.runOutsideAngular(()=>(this._currentPromise||(this._currentPromise=new Promise(a=>this._currentResolve=a)),clearTimeout(this._previousTimeout),this._previousTimeout=setTimeout(()=>{this._liveElement.textContent=e,"number"==typeof o&&(this._previousTimeout=setTimeout(()=>this.clear(),o)),this._currentResolve(),this._currentPromise=this._currentResolve=void 0},100),this._currentPromise))}clear(){this._liveElement&&(this._liveElement.textContent="")}ngOnDestroy(){clearTimeout(this._previousTimeout),this._liveElement?.remove(),this._liveElement=null,this._currentResolve?.(),this._currentPromise=this._currentResolve=void 0}_createLiveElement(){const e="cdk-live-announcer-element",r=this._document.getElementsByClassName(e),s=this._document.createElement("div");for(let i=0;i<r.length;i++)r[i].remove();return s.classList.add(e),s.classList.add("cdk-visually-hidden"),s.setAttribute("aria-atomic","true"),s.setAttribute("aria-live","polite"),this._document.body.appendChild(s),s}}return n.\u0275fac=function(e){return new(e||n)(Z(HNe,8),Z(yt),Z(vt),Z(jNe,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const GNe=new me("cdk-focus-monitor-default-options"),Bv=Ov({passive:!0,capture:!0});let qNe=(()=>{class n{constructor(e,r,s,i,o){this._ngZone=e,this._platform=r,this._inputModalityDetector=s,this._origin=null,this._windowFocused=!1,this._originFromTouchInteraction=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=window.setTimeout(()=>this._windowFocused=!1)},this._stopInputModalityDetector=new kt,this._rootNodeFocusAndBlurListener=a=>{for(let c=Pc(a);c;c=c.parentElement)"focus"===a.type?this._onFocus(a,c):this._onBlur(a,c)},this._document=i,this._detectionMode=o?.detectionMode||0}monitor(e,r=!1){const s=qd(e);if(!this._platform.isBrowser||1!==s.nodeType)return Oe(null);const i=function lNe(n){if(function aNe(){if(null==D1){const n=typeof document<"u"?document.head:null;D1=!(!n||!n.createShadowRoot&&!n.attachShadow)}return D1}()){const t=n.getRootNode?n.getRootNode():null;if(typeof ShadowRoot<"u"&&ShadowRoot&&t instanceof ShadowRoot)return t}return null}(s)||this._getDocument(),o=this._elementInfo.get(s);if(o)return r&&(o.checkChildren=!0),o.subject;const a={checkChildren:r,subject:new kt,rootNode:i};return this._elementInfo.set(s,a),this._registerGlobalListeners(a),a.subject}stopMonitoring(e){const r=qd(e),s=this._elementInfo.get(r);s&&(s.subject.complete(),this._setClasses(r),this._elementInfo.delete(r),this._removeGlobalListeners(s))}focusVia(e,r,s){const i=qd(e);i===this._getDocument().activeElement?this._getClosestElementsInfo(i).forEach(([a,l])=>this._originChanged(a,r,l)):(this._setOrigin(r),"function"==typeof i.focus&&i.focus(s))}ngOnDestroy(){this._elementInfo.forEach((e,r)=>this.stopMonitoring(r))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_getFocusOrigin(e){return this._origin?this._originFromTouchInteraction?this._shouldBeAttributedToTouch(e)?"touch":"program":this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:e&&this._isLastInteractionFromInputLabel(e)?"mouse":"program"}_shouldBeAttributedToTouch(e){return 1===this._detectionMode||!!e?.contains(this._inputModalityDetector._mostRecentTarget)}_setClasses(e,r){e.classList.toggle("cdk-focused",!!r),e.classList.toggle("cdk-touch-focused","touch"===r),e.classList.toggle("cdk-keyboard-focused","keyboard"===r),e.classList.toggle("cdk-mouse-focused","mouse"===r),e.classList.toggle("cdk-program-focused","program"===r)}_setOrigin(e,r=!1){this._ngZone.runOutsideAngular(()=>{this._origin=e,this._originFromTouchInteraction="touch"===e&&r,0===this._detectionMode&&(clearTimeout(this._originTimeoutId),this._originTimeoutId=setTimeout(()=>this._origin=null,this._originFromTouchInteraction?650:1))})}_onFocus(e,r){const s=this._elementInfo.get(r),i=Pc(e);!s||!s.checkChildren&&r!==i||this._originChanged(r,this._getFocusOrigin(i),s)}_onBlur(e,r){const s=this._elementInfo.get(r);!s||s.checkChildren&&e.relatedTarget instanceof Node&&r.contains(e.relatedTarget)||(this._setClasses(r),this._emitOrigin(s,null))}_emitOrigin(e,r){e.subject.observers.length&&this._ngZone.run(()=>e.subject.next(r))}_registerGlobalListeners(e){if(!this._platform.isBrowser)return;const r=e.rootNode,s=this._rootNodeFocusListenerCount.get(r)||0;s||this._ngZone.runOutsideAngular(()=>{r.addEventListener("focus",this._rootNodeFocusAndBlurListener,Bv),r.addEventListener("blur",this._rootNodeFocusAndBlurListener,Bv)}),this._rootNodeFocusListenerCount.set(r,s+1),1==++this._monitoredElementCount&&(this._ngZone.runOutsideAngular(()=>{this._getWindow().addEventListener("focus",this._windowFocusListener)}),this._inputModalityDetector.modalityDetected.pipe(Go(this._stopInputModalityDetector)).subscribe(i=>{this._setOrigin(i,!0)}))}_removeGlobalListeners(e){const r=e.rootNode;if(this._rootNodeFocusListenerCount.has(r)){const s=this._rootNodeFocusListenerCount.get(r);s>1?this._rootNodeFocusListenerCount.set(r,s-1):(r.removeEventListener("focus",this._rootNodeFocusAndBlurListener,Bv),r.removeEventListener("blur",this._rootNodeFocusAndBlurListener,Bv),this._rootNodeFocusListenerCount.delete(r))}--this._monitoredElementCount||(this._getWindow().removeEventListener("focus",this._windowFocusListener),this._stopInputModalityDetector.next(),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._originTimeoutId))}_originChanged(e,r,s){this._setClasses(e,r),this._emitOrigin(s,r),this._lastFocusOrigin=r}_getClosestElementsInfo(e){const r=[];return this._elementInfo.forEach((s,i)=>{(i===e||s.checkChildren&&i.contains(e))&&r.push([i,s])}),r}_isLastInteractionFromInputLabel(e){const{_mostRecentTarget:r,mostRecentModality:s}=this._inputModalityDetector;if("mouse"!==s||!r||r===e||"INPUT"!==e.nodeName&&"TEXTAREA"!==e.nodeName||e.disabled)return!1;const i=e.labels;if(i)for(let o=0;o<i.length;o++)if(i[o].contains(r))return!0;return!1}}return n.\u0275fac=function(e){return new(e||n)(Z(yt),Z(Us),Z(UNe),Z(vt,8),Z(GNe,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const _H="cdk-high-contrast-black-on-white",vH="cdk-high-contrast-white-on-black",L1="cdk-high-contrast-active";let KNe=(()=>{class n{constructor(e,r){this._platform=e,this._document=r,this._breakpointSubscription=Ot(P1).observe("(forced-colors: active)").subscribe(()=>{this._hasCheckedHighContrastMode&&(this._hasCheckedHighContrastMode=!1,this._applyBodyHighContrastModeCssClasses())})}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const e=this._document.createElement("div");e.style.backgroundColor="rgb(1,2,3)",e.style.position="absolute",this._document.body.appendChild(e);const r=this._document.defaultView||window,s=r&&r.getComputedStyle?r.getComputedStyle(e):null,i=(s&&s.backgroundColor||"").replace(/ /g,"");switch(e.remove(),i){case"rgb(0,0,0)":case"rgb(45,50,54)":case"rgb(32,32,32)":return 2;case"rgb(255,255,255)":case"rgb(255,250,239)":return 1}return 0}ngOnDestroy(){this._breakpointSubscription.unsubscribe()}_applyBodyHighContrastModeCssClasses(){if(!this._hasCheckedHighContrastMode&&this._platform.isBrowser&&this._document.body){const e=this._document.body.classList;e.remove(L1,_H,vH),this._hasCheckedHighContrastMode=!0;const r=this.getHighContrastMode();1===r?e.add(L1,_H):2===r&&e.add(L1,vH)}}}return n.\u0275fac=function(e){return new(e||n)(Z(Us),Z(vt))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const XNe=new me("cdk-dir-doc",{providedIn:"root",factory:function YNe(){return Ot(vt)}}),ZNe=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;let B1=(()=>{class n{constructor(e){if(this.value="ltr",this.change=new Rt,e){const s=e.documentElement?e.documentElement.dir:null;this.value=function QNe(n){const t=n?.toLowerCase()||"";return"auto"===t&&typeof navigator<"u"&&navigator?.language?ZNe.test(navigator.language)?"rtl":"ltr":"rtl"===t?"rtl":"ltr"}((e.body?e.body.dir:null)||s||"ltr")}}ngOnDestroy(){this.change.complete()}}return n.\u0275fac=function(e){return new(e||n)(Z(XNe,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),xm=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({}),n})();function JNe(n,t){if(1&n&&kr(0,"mat-pseudo-checkbox",4),2&n){const e=ei();Gt("state",e.selected?"checked":"unchecked")("disabled",e.disabled)}}function eAe(n,t){if(1&n&&(Lt(0,"span",5),la(1),Qt()),2&n){const e=ei();Pt(1),Au("(",e.group.label,")")}}const tAe=["*"],rAe=new me("mat-sanity-checks",{providedIn:"root",factory:function nAe(){return!0}});let zr=(()=>{class n{constructor(e,r,s){this._sanityChecks=r,this._document=s,this._hasDoneGlobalChecks=!1,e._applyBodyHighContrastModeCssClasses(),this._hasDoneGlobalChecks||(this._hasDoneGlobalChecks=!0)}_checkIsEnabled(e){return!T1()&&("boolean"==typeof this._sanityChecks?this._sanityChecks:!!this._sanityChecks[e])}}return n.\u0275fac=function(e){return new(e||n)(Z(KNe),Z(rAe,8),Z(vt))},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({imports:[xm,xm]}),n})();function CH(n){return class extends n{constructor(...t){super(...t),this._disabled=!1}get disabled(){return this._disabled}set disabled(t){this._disabled=Hi(t)}}}function V1(n,t){return class extends n{constructor(...e){super(...e),this.defaultColor=t,this.color=t}get color(){return this._color}set color(e){const r=e||this.defaultColor;r!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),r&&this._elementRef.nativeElement.classList.add(`mat-${r}`),this._color=r)}}}function SH(n){return class extends n{constructor(...t){super(...t),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=Hi(t)}}}function sAe(n,t=0){return class extends n{constructor(...e){super(...e),this._tabIndex=t,this.defaultTabIndex=t}get tabIndex(){return this.disabled?-1:this._tabIndex}set tabIndex(e){this._tabIndex=null!=e?vm(e):this.defaultTabIndex}}}function iAe(n){return class extends n{constructor(...t){super(...t),this.errorState=!1}updateErrorState(){const t=this.errorState,i=(this.errorStateMatcher||this._defaultErrorStateMatcher).isErrorState(this.ngControl?this.ngControl.control:null,this._parentFormGroup||this._parentForm);i!==t&&(this.errorState=i,this.stateChanges.next())}}}let aAe=(()=>{class n{isErrorState(e,r){return!!(e&&e.invalid&&(e.touched||r&&r.submitted))}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class lAe{constructor(t,e,r,s=!1){this._renderer=t,this.element=e,this.config=r,this._animationForciblyDisabledThroughCss=s,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const EH={enterDuration:225,exitDuration:150},z1=Ov({passive:!0}),IH=["mousedown","touchstart"],DH=["mouseup","mouseleave","touchend","touchcancel"];class uAe{constructor(t,e,r,s){this._target=t,this._ngZone=e,this._isPointerDown=!1,this._activeRipples=new Map,this._pointerUpEventsRegistered=!1,s.isBrowser&&(this._containerElement=qd(r))}fadeInRipple(t,e,r={}){const s=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),i={...EH,...r.animation};r.centered&&(t=s.left+s.width/2,e=s.top+s.height/2);const o=r.radius||function dAe(n,t,e){const r=Math.max(Math.abs(n-e.left),Math.abs(n-e.right)),s=Math.max(Math.abs(t-e.top),Math.abs(t-e.bottom));return Math.sqrt(r*r+s*s)}(t,e,s),a=t-s.left,l=e-s.top,c=i.enterDuration,u=document.createElement("div");u.classList.add("mat-ripple-element"),u.style.left=a-o+"px",u.style.top=l-o+"px",u.style.height=2*o+"px",u.style.width=2*o+"px",null!=r.color&&(u.style.backgroundColor=r.color),u.style.transitionDuration=`${c}ms`,this._containerElement.appendChild(u);const d=window.getComputedStyle(u),f=d.transitionDuration,p="none"===d.transitionProperty||"0s"===f||"0s, 0s"===f,m=new lAe(this,u,r,p);u.style.transform="scale3d(1, 1, 1)",m.state=0,r.persistent||(this._mostRecentTransientRipple=m);let g=null;return!p&&(c||i.exitDuration)&&this._ngZone.runOutsideAngular(()=>{const y=()=>this._finishRippleTransition(m),b=()=>this._destroyRipple(m);u.addEventListener("transitionend",y),u.addEventListener("transitioncancel",b),g={onTransitionEnd:y,onTransitionCancel:b}}),this._activeRipples.set(m,g),(p||!c)&&this._finishRippleTransition(m),m}fadeOutRipple(t){if(2===t.state||3===t.state)return;const e=t.element,r={...EH,...t.config.animation};e.style.transitionDuration=`${r.exitDuration}ms`,e.style.opacity="0",t.state=2,(t._animationForciblyDisabledThroughCss||!r.exitDuration)&&this._finishRippleTransition(t)}fadeOutAll(){this._getActiveRipples().forEach(t=>t.fadeOut())}fadeOutAllNonPersistent(){this._getActiveRipples().forEach(t=>{t.config.persistent||t.fadeOut()})}setupTriggerEvents(t){const e=qd(t);!e||e===this._triggerElement||(this._removeTriggerEvents(),this._triggerElement=e,this._registerEvents(IH))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._registerEvents(DH),this._pointerUpEventsRegistered=!0)}_finishRippleTransition(t){0===t.state?this._startFadeOutTransition(t):2===t.state&&this._destroyRipple(t)}_startFadeOutTransition(t){const e=t===this._mostRecentTransientRipple,{persistent:r}=t.config;t.state=1,!r&&(!e||!this._isPointerDown)&&t.fadeOut()}_destroyRipple(t){const e=this._activeRipples.get(t)??null;this._activeRipples.delete(t),this._activeRipples.size||(this._containerRect=null),t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),t.state=3,null!==e&&(t.element.removeEventListener("transitionend",e.onTransitionEnd),t.element.removeEventListener("transitioncancel",e.onTransitionCancel)),t.element.remove()}_onMousedown(t){const e=gH(t),r=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;!this._target.rippleDisabled&&!e&&!r&&(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&&!yH(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let r=0;r<e.length;r++)this.fadeInRipple(e[r].clientX,e[r].clientY,this._target.rippleConfig)}}_onPointerUp(){!this._isPointerDown||(this._isPointerDown=!1,this._getActiveRipples().forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_registerEvents(t){this._ngZone.runOutsideAngular(()=>{t.forEach(e=>{this._triggerElement.addEventListener(e,this,z1)})})}_getActiveRipples(){return Array.from(this._activeRipples.keys())}_removeTriggerEvents(){this._triggerElement&&(IH.forEach(t=>{this._triggerElement.removeEventListener(t,this,z1)}),this._pointerUpEventsRegistered&&DH.forEach(t=>{this._triggerElement.removeEventListener(t,this,z1)}))}}const hAe=new me("mat-ripple-global-options");let Cm=(()=>{class n{constructor(e,r,s,i,o){this._elementRef=e,this._animationMode=o,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=i||{},this._rippleRenderer=new uAe(this,r,e,s)}get disabled(){return this._disabled}set disabled(e){e&&this.fadeOutAllNonPersistent(),this._disabled=e,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(e){this._trigger=e,this._setupTriggerEventsIfEnabled()}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}fadeOutAllNonPersistent(){this._rippleRenderer.fadeOutAllNonPersistent()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:{...this._globalOptions.animation,..."NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{},...this.animation},terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(e,r=0,s){return"number"==typeof e?this._rippleRenderer.fadeInRipple(e,r,{...this.rippleConfig,...s}):this._rippleRenderer.fadeInRipple(0,0,{...this.rippleConfig,...e})}}return n.\u0275fac=function(e){return new(e||n)(H(hn),H(yt),H(Us),H(hAe,8),H(ca,8))},n.\u0275dir=$e({type:n,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(e,r){2&e&&ds("mat-ripple-unbounded",r.unbounded)},inputs:{color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],radius:["matRippleRadius","radius"],animation:["matRippleAnimation","animation"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"]},exportAs:["matRipple"]}),n})(),U1=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({imports:[zr,zr]}),n})(),fAe=(()=>{class n{constructor(e){this._animationMode=e,this.state="unchecked",this.disabled=!1}}return n.\u0275fac=function(e){return new(e||n)(H(ca,8))},n.\u0275cmp=is({type:n,selectors:[["mat-pseudo-checkbox"]],hostAttrs:[1,"mat-pseudo-checkbox"],hostVars:8,hostBindings:function(e,r){2&e&&ds("mat-pseudo-checkbox-indeterminate","indeterminate"===r.state)("mat-pseudo-checkbox-checked","checked"===r.state)("mat-pseudo-checkbox-disabled",r.disabled)("_mat-animation-noopable","NoopAnimations"===r._animationMode)},inputs:{state:"state",disabled:"disabled"},decls:0,vars:0,template:function(e,r){},styles:['.mat-pseudo-checkbox{border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border-color:rgba(0,0,0,0)}.mat-pseudo-checkbox._mat-animation-noopable{transition:none !important;animation:none !important}.mat-pseudo-checkbox._mat-animation-noopable::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{left:1px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{left:1px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}.mat-pseudo-checkbox{width:18px;height:18px}.mat-pseudo-checkbox-indeterminate::after{top:6px;width:12px}.mat-pseudo-checkbox-checked::after{top:2.7px;width:10px;height:4px}'],encapsulation:2,changeDetection:0}),n})(),pAe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({imports:[zr]}),n})();const TH=new me("MAT_OPTION_PARENT_COMPONENT"),kH=new me("MatOptgroup");let mAe=0;class gAe{constructor(t,e=!1){this.source=t,this.isUserInput=e}}let yAe=(()=>{class n{constructor(e,r,s,i){this._element=e,this._changeDetectorRef=r,this._parent=s,this.group=i,this._selected=!1,this._active=!1,this._disabled=!1,this._mostRecentViewValue="",this.id="mat-option-"+mAe++,this.onSelectionChange=new Rt,this._stateChanges=new kt}get multiple(){return this._parent&&this._parent.multiple}get selected(){return this._selected}get disabled(){return this.group&&this.group.disabled||this._disabled}set disabled(e){this._disabled=Hi(e)}get disableRipple(){return!(!this._parent||!this._parent.disableRipple)}get active(){return this._active}get viewValue(){return(this._getHostElement().textContent||"").trim()}select(){this._selected||(this._selected=!0,this._changeDetectorRef.markForCheck(),this._emitSelectionChangeEvent())}deselect(){this._selected&&(this._selected=!1,this._changeDetectorRef.markForCheck(),this._emitSelectionChangeEvent())}focus(e,r){const s=this._getHostElement();"function"==typeof s.focus&&s.focus(r)}setActiveStyles(){this._active||(this._active=!0,this._changeDetectorRef.markForCheck())}setInactiveStyles(){this._active&&(this._active=!1,this._changeDetectorRef.markForCheck())}getLabel(){return this.viewValue}_handleKeydown(e){(13===e.keyCode||32===e.keyCode)&&!bm(e)&&(this._selectViaInteraction(),e.preventDefault())}_selectViaInteraction(){this.disabled||(this._selected=!this.multiple||!this._selected,this._changeDetectorRef.markForCheck(),this._emitSelectionChangeEvent(!0))}_getAriaSelected(){return this.selected||!this.multiple&&null}_getTabIndex(){return this.disabled?"-1":"0"}_getHostElement(){return this._element.nativeElement}ngAfterViewChecked(){if(this._selected){const e=this.viewValue;e!==this._mostRecentViewValue&&(this._mostRecentViewValue=e,this._stateChanges.next())}}ngOnDestroy(){this._stateChanges.complete()}_emitSelectionChangeEvent(e=!1){this.onSelectionChange.emit(new gAe(this,e))}}return n.\u0275fac=function(e){Nh()},n.\u0275dir=$e({type:n,inputs:{value:"value",id:"id",disabled:"disabled"},outputs:{onSelectionChange:"onSelectionChange"}}),n})(),NH=(()=>{class n extends yAe{constructor(e,r,s,i){super(e,r,s,i)}}return n.\u0275fac=function(e){return new(e||n)(H(hn),H(nc),H(TH,8),H(kH,8))},n.\u0275cmp=is({type:n,selectors:[["mat-option"]],hostAttrs:["role","option",1,"mat-mdc-option","mat-mdc-focus-indicator","mdc-list-item"],hostVars:12,hostBindings:function(e,r){1&e&&Ln("click",function(){return r._selectViaInteraction()})("keydown",function(i){return r._handleKeydown(i)}),2&e&&(Bw("id",r.id),yn("tabindex",r._getTabIndex())("aria-selected",r._getAriaSelected())("aria-disabled",r.disabled.toString()),ds("mdc-list-item--selected",r.selected)("mat-mdc-option-multiple",r.multiple)("mat-mdc-option-active",r.active)("mdc-list-item--disabled",r.disabled))},exportAs:["matOption"],features:[dt],ngContentSelectors:tAe,decls:5,vars:4,consts:[["class","mat-mdc-option-pseudo-checkbox",3,"state","disabled",4,"ngIf"],[1,"mdc-list-item__primary-text"],["class","cdk-visually-hidden",4,"ngIf"],["mat-ripple","",1,"mat-mdc-option-ripple",3,"matRippleTrigger","matRippleDisabled"],[1,"mat-mdc-option-pseudo-checkbox",3,"state","disabled"],[1,"cdk-visually-hidden"]],template:function(e,r){1&e&&(Jl(),us(0,JNe,1,2,"mat-pseudo-checkbox",0),Lt(1,"span",1),Si(2),Qt(),us(3,eAe,2,1,"span",2),kr(4,"div",3)),2&e&&(Gt("ngIf",r.multiple),Pt(3),Gt("ngIf",r.group&&r.group._inert),Pt(1),Gt("matRippleTrigger",r._getHostElement())("matRippleDisabled",r.disabled||r.disableRipple))},dependencies:[Cm,oy,fAe],styles:['.mat-mdc-option{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:16px;padding-right:16px;-webkit-user-select:none;user-select:none;cursor:pointer;min-height:48px}.mat-mdc-option:focus{outline:none}[dir=rtl] .mat-mdc-option,.mat-mdc-option[dir=rtl]{padding-left:16px;padding-right:16px}.mat-mdc-option.mdc-list-item{align-items:center}.mat-mdc-option.mdc-list-item--disabled{opacity:.38;cursor:default}.mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:32px}[dir=rtl] .mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:16px;padding-right:32px}.mat-mdc-option .mat-pseudo-checkbox{margin-right:16px}[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox{margin-right:0;margin-left:16px}.mat-mdc-option .mat-mdc-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-mdc-option .mdc-list-item__primary-text{white-space:normal;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit}.cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}[dir=rtl] .cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{right:auto;left:16px}.mat-mdc-option-active::before{content:""}'],encapsulation:2,changeDetection:0}),n})(),AH=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({imports:[U1,ic,zr,pAe]}),n})();const vAe=["mat-button",""],RH=[[["",8,"material-icons",3,"iconPositionEnd",""],["mat-icon",3,"iconPositionEnd",""],["","matButtonIcon","",3,"iconPositionEnd",""]],"*",[["","iconPositionEnd","",8,"material-icons"],["mat-icon","iconPositionEnd",""],["","matButtonIcon","","iconPositionEnd",""]]],MH=[".material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])","*",".material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]"],wAe=["mat-mini-fab",""],SAe=["mat-icon-button",""],EAe=["*"],IAe=[{selector:"mat-button",mdcClasses:["mdc-button","mat-mdc-button"]},{selector:"mat-flat-button",mdcClasses:["mdc-button","mdc-button--unelevated","mat-mdc-unelevated-button"]},{selector:"mat-raised-button",mdcClasses:["mdc-button","mdc-button--raised","mat-mdc-raised-button"]},{selector:"mat-stroked-button",mdcClasses:["mdc-button","mdc-button--outlined","mat-mdc-outlined-button"]},{selector:"mat-fab",mdcClasses:["mdc-fab","mat-mdc-fab"]},{selector:"mat-mini-fab",mdcClasses:["mdc-fab","mdc-fab--mini","mat-mdc-mini-fab"]},{selector:"mat-icon-button",mdcClasses:["mdc-icon-button","mat-mdc-icon-button"]}],DAe=V1(CH(SH(class{constructor(n){this._elementRef=n}})));let H1=(()=>{class n extends DAe{constructor(e,r,s,i){super(e),this._platform=r,this._ngZone=s,this._animationMode=i,this._focusMonitor=Ot(qNe),this._isFab=!1;const o=e.nativeElement.classList;for(const a of IAe)this._hasHostAttributes(a.selector)&&a.mdcClasses.forEach(l=>{o.add(l)})}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(e="program",r){e?this._focusMonitor.focusVia(this._elementRef.nativeElement,e,r):this._elementRef.nativeElement.focus(r)}_hasHostAttributes(...e){return e.some(r=>this._elementRef.nativeElement.hasAttribute(r))}_isRippleDisabled(){return this.disableRipple||this.disabled}}return n.\u0275fac=function(e){Nh()},n.\u0275dir=$e({type:n,viewQuery:function(e,r){if(1&e&&Eo(Cm,5),2&e){let s;Ts(s=ks())&&(r.ripple=s.first)}},features:[dt]}),n})(),kAe=(()=>{class n extends H1{constructor(e,r,s,i){super(e,r,s,i)}}return n.\u0275fac=function(e){return new(e||n)(H(hn),H(Us),H(yt),H(ca,8))},n.\u0275cmp=is({type:n,selectors:[["button","mat-button",""],["button","mat-raised-button",""],["button","mat-flat-button",""],["button","mat-stroked-button",""]],hostVars:7,hostBindings:function(e,r){2&e&&(yn("disabled",r.disabled||null),ds("_mat-animation-noopable","NoopAnimations"===r._animationMode)("mat-unthemed",!r.color)("mat-mdc-button-base",!0))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[dt],attrs:vAe,ngContentSelectors:MH,decls:8,vars:6,consts:[[1,"mat-mdc-button-persistent-ripple"],[1,"mdc-button__label"],[1,"mat-mdc-focus-indicator"],["matRipple","",1,"mat-mdc-button-ripple",3,"matRippleDisabled","matRippleTrigger"],[1,"mat-mdc-button-touch-target"]],template:function(e,r){1&e&&(Jl(RH),kr(0,"span",0),Si(1),Lt(2,"span",1),Si(3,1),Qt(),Si(4,2),kr(5,"span",2)(6,"span",3)(7,"span",4)),2&e&&(ds("mdc-button__ripple",!r._isFab)("mdc-fab__ripple",r._isFab),Pt(6),Gt("matRippleDisabled",r._isRippleDisabled())("matRippleTrigger",r._elementRef.nativeElement))},dependencies:[Cm],styles:['.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button{position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;border:none;outline:none;line-height:inherit;user-select:none;-webkit-appearance:none;overflow:visible;vertical-align:middle;background:rgba(0,0,0,0)}.mdc-button .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{cursor:default;pointer-events:none}.mdc-button[hidden]{display:none}.mdc-button .mdc-button__icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top}[dir=rtl] .mdc-button .mdc-button__icon,.mdc-button .mdc-button__icon[dir=rtl]{margin-left:8px;margin-right:0}.mdc-button .mdc-button__progress-indicator{font-size:0;position:absolute;transform:translate(-50%, -50%);top:50%;left:50%}.mdc-button .mdc-button__label{position:relative}.mdc-button .mdc-button__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(\n      100% + 4px\n    );width:calc(\n      100% + 4px\n    );display:none}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring{border-color:CanvasText}}.mdc-button .mdc-button__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring::after{border-color:CanvasText}}@media screen and (forced-colors: active){.mdc-button.mdc-ripple-upgraded--background-focused .mdc-button__focus-ring,.mdc-button:not(.mdc-ripple-upgraded):focus .mdc-button__focus-ring{display:block}}.mdc-button .mdc-button__touch{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mdc-button__label+.mdc-button__icon{margin-left:8px;margin-right:0}[dir=rtl] .mdc-button__label+.mdc-button__icon,.mdc-button__label+.mdc-button__icon[dir=rtl]{margin-left:0;margin-right:8px}svg.mdc-button__icon{fill:currentColor}.mdc-button--touch{margin-top:6px;margin-bottom:6px}.mdc-button{padding:0 8px 0 8px}.mdc-button--unelevated{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--unelevated.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--unelevated.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--raised{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--raised.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--raised.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--outlined{border-style:solid;transition:border 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button--outlined .mdc-button__ripple{border-style:solid;border-color:rgba(0,0,0,0)}.mat-mdc-button{height:var(--mdc-text-button-container-height, 36px);border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-button:not(:disabled){color:var(--mdc-text-button-label-text-color, inherit)}.mat-mdc-button:disabled{color:var(--mdc-text-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-button .mdc-button__ripple{border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button{height:var(--mdc-filled-button-container-height, 36px);border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button:not(:disabled){background-color:var(--mdc-filled-button-container-color, transparent)}.mat-mdc-unelevated-button:disabled{background-color:var(--mdc-filled-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-unelevated-button:not(:disabled){color:var(--mdc-filled-button-label-text-color, inherit)}.mat-mdc-unelevated-button:disabled{color:var(--mdc-filled-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-unelevated-button .mdc-button__ripple{border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button{height:var(--mdc-protected-button-container-height, 36px);border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px));box-shadow:var(--mdc-protected-button-container-elevation, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){background-color:var(--mdc-protected-button-container-color, transparent)}.mat-mdc-raised-button:disabled{background-color:var(--mdc-protected-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){color:var(--mdc-protected-button-label-text-color, inherit)}.mat-mdc-raised-button:disabled{color:var(--mdc-protected-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-raised-button .mdc-button__ripple{border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button.mdc-ripple-upgraded--background-focused,.mat-mdc-raised-button:not(.mdc-ripple-upgraded):focus{box-shadow:var(--mdc-protected-button-focus-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:hover{box-shadow:var(--mdc-protected-button-hover-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled):active{box-shadow:var(--mdc-protected-button-pressed-container-elevation, 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:disabled{box-shadow:var(--mdc-protected-button-disabled-container-elevation, 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button{height:var(--mdc-outlined-button-container-height, 36px);border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px));padding:0 15px 0 15px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button:not(:disabled){color:var(--mdc-outlined-button-label-text-color, inherit)}.mat-mdc-outlined-button:disabled{color:var(--mdc-outlined-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-outlined-button .mdc-button__ripple{border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-outlined-button:not(:disabled){border-color:var(--mdc-outlined-button-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button:disabled{border-color:var(--mdc-outlined-button-disabled-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button.mdc-button--icon-trailing{padding:0 11px 0 15px}.mat-mdc-outlined-button.mdc-button--icon-leading{padding:0 15px 0 11px}.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button .mdc-button__touch{left:calc(-1 * var(--mdc-outlined-button-outline-width, 1px));width:calc(100% + 2 * var(--mdc-outlined-button-outline-width, 1px))}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-button .mat-ripple-element,.mat-mdc-unelevated-button .mat-ripple-element,.mat-mdc-raised-button .mat-ripple-element,.mat-mdc-outlined-button .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-button .mdc-button__label,.mat-mdc-unelevated-button .mdc-button__label,.mat-mdc-raised-button .mdc-button__label,.mat-mdc-outlined-button .mdc-button__label{z-index:1}.mat-mdc-button .mat-mdc-focus-indicator,.mat-mdc-unelevated-button .mat-mdc-focus-indicator,.mat-mdc-raised-button .mat-mdc-focus-indicator,.mat-mdc-outlined-button .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-unelevated-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-raised-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-outlined-button:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-button[disabled],.mat-mdc-unelevated-button[disabled],.mat-mdc-raised-button[disabled],.mat-mdc-outlined-button[disabled]{cursor:default;pointer-events:none}.mat-mdc-button .mat-mdc-button-touch-target,.mat-mdc-unelevated-button .mat-mdc-button-touch-target,.mat-mdc-raised-button .mat-mdc-button-touch-target,.mat-mdc-outlined-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mat-mdc-button._mat-animation-noopable,.mat-mdc-unelevated-button._mat-animation-noopable,.mat-mdc-raised-button._mat-animation-noopable,.mat-mdc-outlined-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem}[dir=rtl] .mat-mdc-button>.mat-icon,.mat-mdc-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}.mat-mdc-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-button .mdc-button__label+.mat-icon,.mat-mdc-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:0;margin-right:8px}.mat-mdc-unelevated-button>.mat-icon,.mat-mdc-raised-button>.mat-icon,.mat-mdc-outlined-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem;margin-left:-4px;margin-right:8px}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:-4px}.mat-mdc-unelevated-button .mdc-button__label+.mat-icon,.mat-mdc-raised-button .mdc-button__label+.mat-icon,.mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:-4px}[dir=rtl] .mat-mdc-unelevated-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-raised-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-outlined-button .mdc-button__label+.mat-icon,.mat-mdc-unelevated-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-raised-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-outlined-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:-4px;margin-right:8px}.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:-1px}.mat-mdc-unelevated-button .mat-mdc-focus-indicator::before,.mat-mdc-raised-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-outlined-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 3px) * -1)}',".cdk-high-contrast-active .mat-mdc-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-unelevated-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-raised-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-outlined-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-icon-button{outline:solid 1px}"],encapsulation:2,changeDetection:0}),n})();const NAe=new me("mat-mdc-fab-default-options",{providedIn:"root",factory:FH});function FH(){return{color:"accent"}}const OH=FH();let AAe=(()=>{class n extends H1{constructor(e,r,s,i,o){super(e,r,s,i),this._options=o,this._isFab=!0,this._options=this._options||OH,this.color=this.defaultColor=this._options.color||OH.color}}return n.\u0275fac=function(e){return new(e||n)(H(hn),H(Us),H(yt),H(ca,8),H(NAe,8))},n.\u0275cmp=is({type:n,selectors:[["button","mat-mini-fab",""]],hostVars:7,hostBindings:function(e,r){2&e&&(yn("disabled",r.disabled||null),ds("_mat-animation-noopable","NoopAnimations"===r._animationMode)("mat-unthemed",!r.color)("mat-mdc-button-base",!0))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[dt],attrs:wAe,ngContentSelectors:MH,decls:8,vars:6,consts:[[1,"mat-mdc-button-persistent-ripple"],[1,"mdc-button__label"],[1,"mat-mdc-focus-indicator"],["matRipple","",1,"mat-mdc-button-ripple",3,"matRippleDisabled","matRippleTrigger"],[1,"mat-mdc-button-touch-target"]],template:function(e,r){1&e&&(Jl(RH),kr(0,"span",0),Si(1),Lt(2,"span",1),Si(3,1),Qt(),Si(4,2),kr(5,"span",2)(6,"span",3)(7,"span",4)),2&e&&(ds("mdc-button__ripple",!r._isFab)("mdc-fab__ripple",r._isFab),Pt(6),Gt("matRippleDisabled",r._isRippleDisabled())("matRippleTrigger",r._elementRef.nativeElement))},dependencies:[Cm],styles:['.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-fab{position:relative;display:inline-flex;position:relative;align-items:center;justify-content:center;box-sizing:border-box;width:56px;height:56px;padding:0;border:none;fill:currentColor;text-decoration:none;cursor:pointer;user-select:none;-moz-appearance:none;-webkit-appearance:none;overflow:visible;transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),opacity 15ms linear 30ms,transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-fab .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-fab[hidden]{display:none}.mdc-fab::-moz-focus-inner{padding:0;border:0}.mdc-fab .mdc-fab__focus-ring{position:absolute}.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(\n      100% + 4px\n    );width:calc(\n      100% + 4px\n    )}@media screen and (forced-colors: active){.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{border-color:CanvasText}}.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{border-color:CanvasText}}.mdc-fab:active,.mdc-fab:focus{outline:none}.mdc-fab:hover{cursor:pointer}.mdc-fab>svg{width:100%}.mdc-fab--mini{width:40px;height:40px}.mdc-fab--extended{border-radius:24px;padding-left:20px;padding-right:20px;width:auto;max-width:100%;height:48px;line-height:normal}.mdc-fab--extended .mdc-fab__ripple{border-radius:24px}.mdc-fab--extended .mdc-fab__icon{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mdc-fab--extended .mdc-fab__icon,.mdc-fab--extended .mdc-fab__icon[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mdc-fab--extended .mdc-fab__label+.mdc-fab__icon{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mdc-fab--extended .mdc-fab__label+.mdc-fab__icon,.mdc-fab--extended .mdc-fab__label+.mdc-fab__icon[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mdc-fab--touch{margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}.mdc-fab--touch .mdc-fab__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mdc-fab::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-fab::before{border-color:CanvasText}}.mdc-fab__label{justify-content:flex-start;text-overflow:ellipsis;white-space:nowrap;overflow-x:hidden;overflow-y:visible}.mdc-fab__icon{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mdc-fab .mdc-fab__icon{display:inline-flex;align-items:center;justify-content:center}.mdc-fab--exited{transform:scale(0);opacity:0;transition:opacity 15ms linear 150ms,transform 180ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-fab--exited .mdc-fab__icon{transform:scale(0);transition:transform 135ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-fab .mdc-fab__icon{width:24px;height:24px;font-size:24px}.mdc-fab:not(.mdc-fab--extended){border-radius:50%}.mdc-fab:not(.mdc-fab--extended) .mdc-fab__ripple{border-radius:50%}.mat-mdc-fab,.mat-mdc-mini-fab{background-color:var(--mdc-fab-container-color, transparent);box-shadow:0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12);color:var(--mat-mdc-fab-color, inherit);flex-shrink:0}.mat-mdc-fab .mat-mdc-button-ripple,.mat-mdc-fab .mat-mdc-button-persistent-ripple,.mat-mdc-fab .mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab .mat-mdc-button-ripple,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-fab .mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-fab .mat-ripple-element,.mat-mdc-mini-fab .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-fab .mdc-button__label,.mat-mdc-mini-fab .mdc-button__label{z-index:1}.mat-mdc-fab .mat-mdc-focus-indicator,.mat-mdc-mini-fab .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-fab:focus .mat-mdc-focus-indicator::before,.mat-mdc-mini-fab:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-fab .mat-mdc-button-touch-target,.mat-mdc-mini-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mat-mdc-fab._mat-animation-noopable,.mat-mdc-mini-fab._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-fab:not(:disabled) .mdc-fab__icon,.mat-mdc-mini-fab:not(:disabled) .mdc-fab__icon{color:var(--mdc-fab-icon-color, inherit)}.mat-mdc-fab:not(.mdc-fab--extended),.mat-mdc-mini-fab:not(.mdc-fab--extended){border-radius:var(--mdc-fab-container-shape, 50%)}.mat-mdc-fab:not(.mdc-fab--extended) .mdc-fab__ripple,.mat-mdc-mini-fab:not(.mdc-fab--extended) .mdc-fab__ripple{border-radius:var(--mdc-fab-container-shape, 50%)}.mat-mdc-fab:hover,.mat-mdc-fab:focus,.mat-mdc-mini-fab:hover,.mat-mdc-mini-fab:focus{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12)}.mat-mdc-fab:active,.mat-mdc-fab:focus:active,.mat-mdc-mini-fab:active,.mat-mdc-mini-fab:focus:active{box-shadow:0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 12px 17px 2px rgba(0, 0, 0, 0.14), 0px 5px 22px 4px rgba(0, 0, 0, 0.12)}.mat-mdc-fab[disabled],.mat-mdc-mini-fab[disabled]{cursor:default;pointer-events:none;box-shadow:0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12)}.mat-mdc-fab:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-mini-fab:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}.mat-mdc-fab .mat-icon,.mat-mdc-fab .material-icons,.mat-mdc-mini-fab .mat-icon,.mat-mdc-mini-fab .material-icons{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mat-mdc-fab .mat-mdc-focus-indicator::before,.mat-mdc-mini-fab .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-extended-fab{border-radius:24px;padding-left:20px;padding-right:20px;width:auto;max-width:100%;height:48px;line-height:normal}.mat-mdc-extended-fab .mdc-fab__ripple{border-radius:24px}.mat-mdc-extended-fab .mdc-fab__icon{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mat-mdc-extended-fab .mdc-fab__icon,.mat-mdc-extended-fab .mdc-fab__icon[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mat-mdc-extended-fab .mdc-fab__label+.mdc-fab__icon{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mat-mdc-extended-fab .mdc-fab__label+.mdc-fab__icon,.mat-mdc-extended-fab .mdc-fab__label+.mdc-fab__icon[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mat-mdc-extended-fab>.mat-icon,.mat-mdc-extended-fab>.material-icons{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mat-mdc-extended-fab>.mat-icon,[dir=rtl] .mat-mdc-extended-fab>.material-icons,.mat-mdc-extended-fab>.mat-icon[dir=rtl],.mat-mdc-extended-fab>.material-icons[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mat-mdc-extended-fab .mdc-button__label+.mat-icon,.mat-mdc-extended-fab .mdc-button__label+.material-icons{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.material-icons,.mat-mdc-extended-fab .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-extended-fab .mdc-button__label+.material-icons[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mat-mdc-extended-fab .mat-mdc-button-touch-target{width:100%}'],encapsulation:2,changeDetection:0}),n})(),RAe=(()=>{class n extends H1{constructor(e,r,s,i){super(e,r,s,i)}}return n.\u0275fac=function(e){return new(e||n)(H(hn),H(Us),H(yt),H(ca,8))},n.\u0275cmp=is({type:n,selectors:[["button","mat-icon-button",""]],hostVars:7,hostBindings:function(e,r){2&e&&(yn("disabled",r.disabled||null),ds("_mat-animation-noopable","NoopAnimations"===r._animationMode)("mat-unthemed",!r.color)("mat-mdc-button-base",!0))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[dt],attrs:SAe,ngContentSelectors:EAe,decls:5,vars:3,consts:[[1,"mat-mdc-button-persistent-ripple","mdc-icon-button__ripple"],[1,"mat-mdc-focus-indicator"],["matRipple","",1,"mat-mdc-button-ripple",3,"matRippleDisabled","matRippleCentered","matRippleTrigger"],[1,"mat-mdc-button-touch-target"]],template:function(e,r){1&e&&(Jl(),kr(0,"span",0),Si(1),kr(2,"span",1)(3,"span",2)(4,"span",3)),2&e&&(Pt(3),Gt("matRippleDisabled",r._isRippleDisabled())("matRippleCentered",!0)("matRippleTrigger",r._elementRef.nativeElement))},dependencies:[Cm],styles:['.mdc-icon-button{font-size:24px;width:48px;height:48px;padding:12px}.mdc-icon-button .mdc-icon-button__focus-ring{max-height:48px;max-width:48px}.mdc-icon-button.mdc-icon-button--reduced-size .mdc-icon-button__ripple{width:40px;height:40px;margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}.mdc-icon-button.mdc-icon-button--reduced-size .mdc-icon-button__focus-ring{max-height:40px;max-width:40px}.mdc-icon-button .mdc-icon-button__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mdc-icon-button svg,.mdc-icon-button img{width:24px;height:24px}.mdc-icon-button{display:inline-block;position:relative;box-sizing:border-box;border:none;outline:none;background-color:rgba(0,0,0,0);fill:currentColor;color:inherit;text-decoration:none;cursor:pointer;user-select:none;z-index:0;overflow:visible}.mdc-icon-button .mdc-icon-button__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}@media screen and (forced-colors: active){.mdc-icon-button.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring,.mdc-icon-button:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring{display:block}}.mdc-icon-button:disabled{cursor:default;pointer-events:none}.mdc-icon-button[hidden]{display:none}.mdc-icon-button--display-flex{align-items:center;display:inline-flex;justify-content:center}.mdc-icon-button__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:100%;width:100%;display:none}@media screen and (forced-colors: active){.mdc-icon-button__focus-ring{border-color:CanvasText}}.mdc-icon-button__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-icon-button__focus-ring::after{border-color:CanvasText}}.mdc-icon-button__icon{display:inline-block}.mdc-icon-button__icon.mdc-icon-button__icon--on{display:none}.mdc-icon-button--on .mdc-icon-button__icon{display:none}.mdc-icon-button--on .mdc-icon-button__icon.mdc-icon-button__icon--on{display:inline-block}.mdc-icon-button__link{height:100%;left:0;outline:none;position:absolute;top:0;width:100%}.mat-mdc-icon-button{height:var(--mdc-icon-button-state-layer-size, 48px);width:var(--mdc-icon-button-state-layer-size, 48px);color:var(--mdc-icon-button-icon-color, inherit);border-radius:50%;flex-shrink:0}.mat-mdc-icon-button .mdc-button__icon{font-size:var(--mdc-icon-button-icon-size, 24px)}.mat-mdc-icon-button svg,.mat-mdc-icon-button img{width:var(--mdc-icon-button-icon-size, 24px);height:var(--mdc-icon-button-icon-size, 24px)}.mat-mdc-icon-button:disabled{opacity:var(--mdc-icon-button-disabled-icon-opacity, 0.38)}.mat-mdc-icon-button:disabled{color:var(--mdc-icon-button-disabled-icon-color, #000)}.mat-mdc-icon-button[disabled]{cursor:default;pointer-events:none;opacity:1}.mat-mdc-icon-button .mat-mdc-button-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-icon-button .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-icon-button .mdc-button__label{z-index:1}.mat-mdc-icon-button .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-icon-button:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-icon-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mat-mdc-icon-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple{border-radius:50%}.mat-mdc-icon-button.mat-unthemed:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-primary:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-accent:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-warn:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}',".cdk-high-contrast-active .mat-mdc-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-unelevated-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-raised-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-outlined-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-icon-button{outline:solid 1px}"],encapsulation:2,changeDetection:0}),n})(),PH=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({imports:[zr,U1,zr]}),n})();class $H{}class MAe{}const Ta="*";function Yd(n,t){return{type:7,name:n,definitions:t,options:{}}}function El(n,t=null){return{type:4,styles:t,timings:n}}function LH(n,t=null){return{type:2,steps:n,options:t}}function xs(n){return{type:6,styles:n,offset:null}}function Zd(n,t,e){return{type:0,name:n,styles:t,options:e}}function ka(n,t,e=null){return{type:1,expr:n,animation:t,options:e}}function FAe(n=null){return{type:9,options:n}}function OAe(n,t,e=null){return{type:11,selector:n,animation:t,options:e}}function BH(n){Promise.resolve().then(n)}class Sm{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._originalOnDoneFns=[],this._originalOnStartFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){BH(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this._started=!1,this._finished=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class VH{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,r=0,s=0;const i=this.players.length;0==i?BH(()=>this._onFinish()):this.players.forEach(o=>{o.onDone(()=>{++e==i&&this._onFinish()}),o.onDestroy(()=>{++r==i&&this._onDestroy()}),o.onStart(()=>{++s==i&&this._onStart()})}),this.totalTime=this.players.reduce((o,a)=>Math.max(o,a.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(r=>{const s=r.totalTime?Math.min(1,e/r.totalTime):1;r.setPosition(s)})}getPosition(){const t=this.players.reduce((e,r)=>null===e||r.totalTime>e.totalTime?r:e,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class j1{attach(t){return this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null!=t&&(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class G1 extends j1{constructor(t,e,r,s,i){super(),this.component=t,this.viewContainerRef=e,this.injector=r,this.componentFactoryResolver=s,this.projectableNodes=i}}class q1 extends j1{constructor(t,e,r,s){super(),this.templateRef=t,this.viewContainerRef=e,this.context=r,this.injector=s}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class PAe extends j1{constructor(t){super(),this.element=t instanceof hn?t.nativeElement:t}}class K1{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t instanceof G1?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof q1?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&&t instanceof PAe?(this._attachedPortal=t,this.attachDomPortal(t)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class $Ae extends K1{constructor(t,e,r,s,i){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=r,this._defaultInjector=s,this.attachDomPortal=o=>{const a=o.element,l=this._document.createComment("dom-portal");a.parentNode.insertBefore(l,a),this.outletElement.appendChild(a),this._attachedPortal=o,super.setDisposeFn(()=>{l.parentNode&&l.parentNode.replaceChild(a,l)})},this._document=i}attachComponentPortal(t){const r=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let s;return t.viewContainerRef?(s=t.viewContainerRef.createComponent(r,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector,t.projectableNodes||void 0),this.setDisposeFn(()=>s.destroy())):(s=r.create(t.injector||this._defaultInjector||pr.NULL),this._appRef.attachView(s.hostView),this.setDisposeFn(()=>{this._appRef.viewCount>0&&this._appRef.detachView(s.hostView),s.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(s)),this._attachedPortal=t,s}attachTemplatePortal(t){let e=t.viewContainerRef,r=e.createEmbeddedView(t.templateRef,t.context,{injector:t.injector});return r.rootNodes.forEach(s=>this.outletElement.appendChild(s)),r.detectChanges(),this.setDisposeFn(()=>{let s=e.indexOf(r);-1!==s&&e.remove(s)}),this._attachedPortal=t,r}dispose(){super.dispose(),this.outletElement.remove()}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let zH=(()=>{class n extends K1{constructor(e,r,s){super(),this._componentFactoryResolver=e,this._viewContainerRef=r,this._isInitialized=!1,this.attached=new Rt,this.attachDomPortal=i=>{const o=i.element,a=this._document.createComment("dom-portal");i.setAttachedHost(this),o.parentNode.insertBefore(a,o),this._getRootNode().appendChild(o),this._attachedPortal=i,super.setDisposeFn(()=>{a.parentNode&&a.parentNode.replaceChild(o,a)})},this._document=s}get portal(){return this._attachedPortal}set portal(e){this.hasAttached()&&!e&&!this._isInitialized||(this.hasAttached()&&super.detach(),e&&super.attach(e),this._attachedPortal=e||null)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedRef=this._attachedPortal=null}attachComponentPortal(e){e.setAttachedHost(this);const r=null!=e.viewContainerRef?e.viewContainerRef:this._viewContainerRef,i=(e.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(e.component),o=r.createComponent(i,r.length,e.injector||r.injector,e.projectableNodes||void 0);return r!==this._viewContainerRef&&this._getRootNode().appendChild(o.hostView.rootNodes[0]),super.setDisposeFn(()=>o.destroy()),this._attachedPortal=e,this._attachedRef=o,this.attached.emit(o),o}attachTemplatePortal(e){e.setAttachedHost(this);const r=this._viewContainerRef.createEmbeddedView(e.templateRef,e.context,{injector:e.injector});return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=e,this._attachedRef=r,this.attached.emit(r),r}_getRootNode(){const e=this._viewContainerRef.element.nativeElement;return e.nodeType===e.ELEMENT_NODE?e:e.parentNode}}return n.\u0275fac=function(e){return new(e||n)(H(Xl),H(ti),H(vt))},n.\u0275dir=$e({type:n,selectors:[["","cdkPortalOutlet",""]],inputs:{portal:["cdkPortalOutlet","portal"]},outputs:{attached:"attached"},exportAs:["cdkPortalOutlet"],features:[dt]}),n})(),UH=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({}),n})();const LAe=["addListener","removeListener"],BAe=["addEventListener","removeEventListener"],VAe=["on","off"];function X1(n,t,e,r){if(ae(e)&&(r=e,e=void 0),r)return X1(n,t,e).pipe(WC(r));const[s,i]=function HAe(n){return ae(n.addEventListener)&&ae(n.removeEventListener)}(n)?BAe.map(o=>a=>n[o](t,a,e)):function zAe(n){return ae(n.addListener)&&ae(n.removeListener)}(n)?LAe.map(HH(n,t)):function UAe(n){return ae(n.on)&&ae(n.off)}(n)?VAe.map(HH(n,t)):[];if(!s&&Rx(n))return Dr(o=>X1(o,t,e))(Cs(n));if(!s)throw new TypeError("Invalid event target");return new Cn(o=>{const a=(...l)=>o.next(1<l.length?l:l[0]);return s(a),()=>i(a)})}function HH(n,t){return e=>r=>n[e](t,r)}const Em={schedule(n){let t=requestAnimationFrame,e=cancelAnimationFrame;const{delegate:r}=Em;r&&(t=r.requestAnimationFrame,e=r.cancelAnimationFrame);const s=t(i=>{e=void 0,n(i)});return new He(()=>e?.(s))},requestAnimationFrame(...n){const{delegate:t}=Em;return(t?.requestAnimationFrame||requestAnimationFrame)(...n)},cancelAnimationFrame(...n){const{delegate:t}=Em;return(t?.cancelAnimationFrame||cancelAnimationFrame)(...n)},delegate:void 0};new class jAe extends F1{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let s;t=t||r.shift();do{if(s=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,s){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw s}}}(class WAe extends M1{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=Em.requestAnimationFrame(()=>t.flush(void 0))))}recycleAsyncId(t,e,r=0){var s;if(null!=r?r>0:this.delay>0)return super.recycleAsyncId(t,e,r);const{actions:i}=t;null!=e&&(null===(s=i[i.length-1])||void 0===s?void 0:s.id)!==e&&(Em.cancelAnimationFrame(e),t._scheduled=void 0)}});let Y1,qAe=1;const Vv={};function WH(n){return n in Vv&&(delete Vv[n],!0)}const KAe={setImmediate(n){const t=qAe++;return Vv[t]=!0,Y1||(Y1=Promise.resolve()),Y1.then(()=>WH(t)&&n()),t},clearImmediate(n){WH(n)}},{setImmediate:XAe,clearImmediate:YAe}=KAe,zv={setImmediate(...n){const{delegate:t}=zv;return(t?.setImmediate||XAe)(...n)},clearImmediate(n){const{delegate:t}=zv;return(t?.clearImmediate||YAe)(n)},delegate:void 0};new class QAe extends F1{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let s;t=t||r.shift();do{if(s=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,s){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw s}}}(class ZAe extends M1{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=zv.setImmediate(t.flush.bind(t,void 0))))}recycleAsyncId(t,e,r=0){var s;if(null!=r?r>0:this.delay>0)return super.recycleAsyncId(t,e,r);const{actions:i}=t;null!=e&&(null===(s=i[i.length-1])||void 0===s?void 0:s.id)!==e&&(zv.clearImmediate(e),t._scheduled=void 0)}});function jH(n,t=O1){return function eRe(n){return On((t,e)=>{let r=!1,s=null,i=null,o=!1;const a=()=>{if(i?.unsubscribe(),i=null,r){r=!1;const c=s;s=null,e.next(c)}o&&e.complete()},l=()=>{i=null,o&&e.complete()};t.subscribe(Sn(e,c=>{r=!0,s=c,i||Cs(n(c)).subscribe(i=Sn(e,a,l))},()=>{o=!0,(!r||!i||i.closed)&&e.complete()}))})}(()=>function nRe(n=0,t,e=SNe){let r=-1;return null!=t&&(bN(t)?e=t:r=t),new Cn(s=>{let i=function tRe(n){return n instanceof Date&&!isNaN(n)}(n)?+n-e.now():n;i<0&&(i=0);let o=0;return e.schedule(function(){s.closed||(s.next(o++),0<=r?this.schedule(void 0,r):s.complete())},i)})}(n,t))}let sRe=(()=>{class n{constructor(e,r,s){this._ngZone=e,this._platform=r,this._scrolled=new kt,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=s}register(e){this.scrollContainers.has(e)||this.scrollContainers.set(e,e.elementScrolled().subscribe(()=>this._scrolled.next(e)))}deregister(e){const r=this.scrollContainers.get(e);r&&(r.unsubscribe(),this.scrollContainers.delete(e))}scrolled(e=20){return this._platform.isBrowser?new Cn(r=>{this._globalSubscription||this._addGlobalListener();const s=e>0?this._scrolled.pipe(jH(e)).subscribe(r):this._scrolled.subscribe(r);return this._scrolledCount++,()=>{s.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):Oe()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((e,r)=>this.deregister(r)),this._scrolled.complete()}ancestorScrolled(e,r){const s=this.getAncestorScrollContainers(e);return this.scrolled(r).pipe(As(i=>!i||s.indexOf(i)>-1))}getAncestorScrollContainers(e){const r=[];return this.scrollContainers.forEach((s,i)=>{this._scrollableContainsElement(i,e)&&r.push(i)}),r}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(e,r){let s=qd(r),i=e.getElementRef().nativeElement;do{if(s==i)return!0}while(s=s.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>X1(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return n.\u0275fac=function(e){return new(e||n)(Z(yt),Z(Us),Z(vt,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Z1=(()=>{class n{constructor(e,r,s){this._platform=e,this._change=new kt,this._changeListener=i=>{this._change.next(i)},this._document=s,r.runOutsideAngular(()=>{if(e.isBrowser){const i=this._getWindow();i.addEventListener("resize",this._changeListener),i.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._viewportSize=null)})}ngOnDestroy(){if(this._platform.isBrowser){const e=this._getWindow();e.removeEventListener("resize",this._changeListener),e.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const e={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),e}getViewportRect(){const e=this.getViewportScrollPosition(),{width:r,height:s}=this.getViewportSize();return{top:e.top,left:e.left,bottom:e.top+s,right:e.left+r,height:s,width:r}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const e=this._document,r=this._getWindow(),s=e.documentElement,i=s.getBoundingClientRect();return{top:-i.top||e.body.scrollTop||r.scrollY||s.scrollTop||0,left:-i.left||e.body.scrollLeft||r.scrollX||s.scrollLeft||0}}change(e=20){return e>0?this._change.pipe(jH(e)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const e=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:e.innerWidth,height:e.innerHeight}:{width:0,height:0}}}return n.\u0275fac=function(e){return new(e||n)(Z(Us),Z(yt),Z(vt,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Uv=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({}),n})(),GH=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({imports:[xm,Uv,xm,Uv]}),n})();const qH=oNe();class oRe{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||"",this._previousHTMLStyles.top=t.style.top||"",t.style.left=cr(-this._previousScrollPosition.left),t.style.top=cr(-this._previousScrollPosition.top),t.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,r=t.style,s=this._document.body.style,i=r.scrollBehavior||"",o=s.scrollBehavior||"";this._isEnabled=!1,r.left=this._previousHTMLStyles.left,r.top=this._previousHTMLStyles.top,t.classList.remove("cdk-global-scrollblock"),qH&&(r.scrollBehavior=s.scrollBehavior="auto"),window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),qH&&(r.scrollBehavior=i,s.scrollBehavior=o)}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const e=this._document.body,r=this._viewportRuler.getViewportSize();return e.scrollHeight>r.height||e.scrollWidth>r.width}}class aRe{constructor(t,e,r,s){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=r,this._config=s,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(t){this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0);this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=>{const e=this._viewportRuler.getViewportScrollPosition().top;Math.abs(e-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class KH{enable(){}disable(){}attach(){}}function Q1(n,t){return t.some(e=>n.bottom<e.top||n.top>e.bottom||n.right<e.left||n.left>e.right)}function XH(n,t){return t.some(e=>n.top<e.top||n.bottom>e.bottom||n.left<e.left||n.right>e.right)}class lRe{constructor(t,e,r,s){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=r,this._config=s,this._scrollSubscription=null}attach(t){this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const e=this._overlayRef.overlayElement.getBoundingClientRect(),{width:r,height:s}=this._viewportRuler.getViewportSize();Q1(e,[{width:r,height:s,bottom:s,right:r,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let cRe=(()=>{class n{constructor(e,r,s,i){this._scrollDispatcher=e,this._viewportRuler=r,this._ngZone=s,this.noop=()=>new KH,this.close=o=>new aRe(this._scrollDispatcher,this._ngZone,this._viewportRuler,o),this.block=()=>new oRe(this._viewportRuler,this._document),this.reposition=o=>new lRe(this._scrollDispatcher,this._viewportRuler,this._ngZone,o),this._document=i}}return n.\u0275fac=function(e){return new(e||n)(Z(sRe),Z(Z1),Z(yt),Z(vt))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class J1{constructor(t){if(this.scrollStrategy=new KH,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,t){const e=Object.keys(t);for(const r of e)void 0!==t[r]&&(this[r]=t[r])}}}class uRe{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}let YH=(()=>{class n{constructor(e){this._attachedOverlays=[],this._document=e}ngOnDestroy(){this.detach()}add(e){this.remove(e),this._attachedOverlays.push(e)}remove(e){const r=this._attachedOverlays.indexOf(e);r>-1&&this._attachedOverlays.splice(r,1),0===this._attachedOverlays.length&&this.detach()}}return n.\u0275fac=function(e){return new(e||n)(Z(vt))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),dRe=(()=>{class n extends YH{constructor(e,r){super(e),this._ngZone=r,this._keydownListener=s=>{const i=this._attachedOverlays;for(let o=i.length-1;o>-1;o--)if(i[o]._keydownEvents.observers.length>0){const a=i[o]._keydownEvents;this._ngZone?this._ngZone.run(()=>a.next(s)):a.next(s);break}}}add(e){super.add(e),this._isAttached||(this._ngZone?this._ngZone.runOutsideAngular(()=>this._document.body.addEventListener("keydown",this._keydownListener)):this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return n.\u0275fac=function(e){return new(e||n)(Z(vt),Z(yt,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),hRe=(()=>{class n extends YH{constructor(e,r,s){super(e),this._platform=r,this._ngZone=s,this._cursorStyleIsSet=!1,this._pointerDownListener=i=>{this._pointerDownEventTarget=Pc(i)},this._clickListener=i=>{const o=Pc(i),a="click"===i.type&&this._pointerDownEventTarget?this._pointerDownEventTarget:o;this._pointerDownEventTarget=null;const l=this._attachedOverlays.slice();for(let c=l.length-1;c>-1;c--){const u=l[c];if(u._outsidePointerEvents.observers.length<1||!u.hasAttached())continue;if(u.overlayElement.contains(o)||u.overlayElement.contains(a))break;const d=u._outsidePointerEvents;this._ngZone?this._ngZone.run(()=>d.next(i)):d.next(i)}}}add(e){if(super.add(e),!this._isAttached){const r=this._document.body;this._ngZone?this._ngZone.runOutsideAngular(()=>this._addEventListeners(r)):this._addEventListeners(r),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=r.style.cursor,r.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0}}detach(){if(this._isAttached){const e=this._document.body;e.removeEventListener("pointerdown",this._pointerDownListener,!0),e.removeEventListener("click",this._clickListener,!0),e.removeEventListener("auxclick",this._clickListener,!0),e.removeEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(e.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1}}_addEventListeners(e){e.addEventListener("pointerdown",this._pointerDownListener,!0),e.addEventListener("click",this._clickListener,!0),e.addEventListener("auxclick",this._clickListener,!0),e.addEventListener("contextmenu",this._clickListener,!0)}}return n.\u0275fac=function(e){return new(e||n)(Z(vt),Z(Us),Z(yt,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),ZH=(()=>{class n{constructor(e,r){this._platform=r,this._document=e}ngOnDestroy(){this._containerElement?.remove()}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const e="cdk-overlay-container";if(this._platform.isBrowser||T1()){const s=this._document.querySelectorAll(`.${e}[platform="server"], .${e}[platform="test"]`);for(let i=0;i<s.length;i++)s[i].remove()}const r=this._document.createElement("div");r.classList.add(e),T1()?r.setAttribute("platform","test"):this._platform.isBrowser||r.setAttribute("platform","server"),this._document.body.appendChild(r),this._containerElement=r}}return n.\u0275fac=function(e){return new(e||n)(Z(vt),Z(Us))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class fRe{constructor(t,e,r,s,i,o,a,l,c,u=!1){this._portalOutlet=t,this._host=e,this._pane=r,this._config=s,this._ngZone=i,this._keyboardDispatcher=o,this._document=a,this._location=l,this._outsideClickDispatcher=c,this._animationsDisabled=u,this._backdropElement=null,this._backdropClick=new kt,this._attachments=new kt,this._detachments=new kt,this._locationChanges=He.EMPTY,this._backdropClickHandler=d=>this._backdropClick.next(d),this._backdropTransitionendHandler=d=>{this._disposeBackdrop(d.target)},this._keydownEvents=new kt,this._outsidePointerEvents=new kt,s.scrollStrategy&&(this._scrollStrategy=s.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=s.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host);const e=this._portalOutlet.attach(t);return this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.pipe($r(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher.add(this),"function"==typeof e?.onDestroy&&e.onDestroy(()=>{this.hasAttached()&&this._ngZone.runOutsideAngular(()=>Promise.resolve().then(()=>this.detach()))}),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher.remove(this),t}dispose(){const t=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this._disposeBackdrop(this._backdropElement),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher.remove(this),this._host?.remove(),this._previousHostParent=this._pane=this._host=null,t&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&&(t.attach(this),this.updatePosition()))}updateSize(t){this._config={...this._config,...t},this._updateElementSize()}setDirection(t){this._config={...this._config,direction:t},this._updateElementDirection()}addPanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?"string"==typeof t?t:t.value:"ltr"}updateScrollStrategy(t){t!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&&(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=cr(this._config.width),t.height=cr(this._config.height),t.minWidth=cr(this._config.minWidth),t.minHeight=cr(this._config.minHeight),t.maxWidth=cr(this._config.maxWidth),t.maxHeight=cr(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?"":"none"}_attachBackdrop(){const t="cdk-overlay-backdrop-showing";this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._animationsDisabled&&this._backdropElement.classList.add("cdk-overlay-backdrop-noop-animation"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),!this._animationsDisabled&&typeof requestAnimationFrame<"u"?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add(t)})}):this._backdropElement.classList.add(t)}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){const t=this._backdropElement;if(t){if(this._animationsDisabled)return void this._disposeBackdrop(t);t.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{t.addEventListener("transitionend",this._backdropTransitionendHandler)}),t.style.pointerEvents="none",this._backdropTimeout=this._ngZone.runOutsideAngular(()=>setTimeout(()=>{this._disposeBackdrop(t)},500))}}_toggleClasses(t,e,r){const s=Lv(e||[]).filter(i=>!!i);s.length&&(r?t.classList.add(...s):t.classList.remove(...s))}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const t=this._ngZone.onStable.pipe(Go(ih(this._attachments,this._detachments))).subscribe(()=>{(!this._pane||!this._host||0===this._pane.children.length)&&(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._host.remove()),t.unsubscribe())})})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&&(t.disable(),t.detach&&t.detach())}_disposeBackdrop(t){t&&(t.removeEventListener("click",this._backdropClickHandler),t.removeEventListener("transitionend",this._backdropTransitionendHandler),t.remove(),this._backdropElement===t&&(this._backdropElement=null)),this._backdropTimeout&&(clearTimeout(this._backdropTimeout),this._backdropTimeout=void 0)}}const QH="cdk-overlay-connected-position-bounding-box",pRe=/([A-Za-z%]+)$/;class mRe{constructor(t,e,r,s,i){this._viewportRuler=e,this._document=r,this._platform=s,this._overlayContainer=i,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new kt,this._resizeSubscription=He.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(t)}get positions(){return this._preferredPositions}attach(t){this._validatePositions(),t.hostElement.classList.add(QH),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const t=this._originRect,e=this._overlayRect,r=this._viewportRect,s=this._containerRect,i=[];let o;for(let a of this._preferredPositions){let l=this._getOriginPoint(t,s,a),c=this._getOverlayPoint(l,e,a),u=this._getOverlayFit(c,e,r,a);if(u.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(a,l);this._canFitWithFlexibleDimensions(u,c,r)?i.push({position:a,origin:l,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(l,a)}):(!o||o.overlayFit.visibleArea<u.visibleArea)&&(o={overlayFit:u,overlayPoint:c,originPoint:l,position:a,overlayRect:e})}if(i.length){let a=null,l=-1;for(const c of i){const u=c.boundingBoxRect.width*c.boundingBoxRect.height*(c.position.weight||1);u>l&&(l=u,a=c)}return this._isPushed=!1,void this._applyPosition(a.position,a.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(o.position,o.originPoint);this._applyPosition(o.position,o.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&$c(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove(QH),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(this._isDisposed||!this._platform.isBrowser)return;const t=this._lastPosition;if(t){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const e=this._getOriginPoint(this._originRect,this._containerRect,t);this._applyPosition(t,e)}else this.apply()}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e,r){let s,i;if("center"==r.originX)s=t.left+t.width/2;else{const o=this._isRtl()?t.right:t.left,a=this._isRtl()?t.left:t.right;s="start"==r.originX?o:a}return e.left<0&&(s-=e.left),i="center"==r.originY?t.top+t.height/2:"top"==r.originY?t.top:t.bottom,e.top<0&&(i-=e.top),{x:s,y:i}}_getOverlayPoint(t,e,r){let s,i;return s="center"==r.overlayX?-e.width/2:"start"===r.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,i="center"==r.overlayY?-e.height/2:"top"==r.overlayY?0:-e.height,{x:t.x+s,y:t.y+i}}_getOverlayFit(t,e,r,s){const i=eW(e);let{x:o,y:a}=t,l=this._getOffset(s,"x"),c=this._getOffset(s,"y");l&&(o+=l),c&&(a+=c);let h=0-a,f=a+i.height-r.height,p=this._subtractOverflows(i.width,0-o,o+i.width-r.width),m=this._subtractOverflows(i.height,h,f),g=p*m;return{visibleArea:g,isCompletelyWithinViewport:i.width*i.height===g,fitsInViewportVertically:m===i.height,fitsInViewportHorizontally:p==i.width}}_canFitWithFlexibleDimensions(t,e,r){if(this._hasFlexibleDimensions){const s=r.bottom-e.y,i=r.right-e.x,o=JH(this._overlayRef.getConfig().minHeight),a=JH(this._overlayRef.getConfig().minWidth),c=t.fitsInViewportHorizontally||null!=a&&a<=i;return(t.fitsInViewportVertically||null!=o&&o<=s)&&c}return!1}_pushOverlayOnScreen(t,e,r){if(this._previousPushAmount&&this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const s=eW(e),i=this._viewportRect,o=Math.max(t.x+s.width-i.width,0),a=Math.max(t.y+s.height-i.height,0),l=Math.max(i.top-r.top-t.y,0),c=Math.max(i.left-r.left-t.x,0);let u=0,d=0;return u=s.width<=i.width?c||-o:t.x<this._viewportMargin?i.left-r.left-t.x:0,d=s.height<=i.height?l||-a:t.y<this._viewportMargin?i.top-r.top-t.y:0,this._previousPushAmount={x:u,y:d},{x:t.x+u,y:t.y+d}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&&this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const r=this._getScrollVisibility(),s=new uRe(t,r);this._positionChanges.next(s)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let r,s=t.overlayY;r="center"===t.overlayX?"center":this._isRtl()?"start"===t.overlayX?"right":"left":"start"===t.overlayX?"left":"right";for(let i=0;i<e.length;i++)e[i].style.transformOrigin=`${r} ${s}`}_calculateBoundingBoxRect(t,e){const r=this._viewportRect,s=this._isRtl();let i,o,a,u,d,h;if("top"===e.overlayY)o=t.y,i=r.height-o+this._viewportMargin;else if("bottom"===e.overlayY)a=r.height-t.y+2*this._viewportMargin,i=r.height-a+this._viewportMargin;else{const f=Math.min(r.bottom-t.y+r.top,t.y),p=this._lastBoundingBoxSize.height;i=2*f,o=t.y-f,i>p&&!this._isInitialRender&&!this._growAfterOpen&&(o=t.y-p/2)}if("end"===e.overlayX&&!s||"start"===e.overlayX&&s)h=r.width-t.x+this._viewportMargin,u=t.x-this._viewportMargin;else if("start"===e.overlayX&&!s||"end"===e.overlayX&&s)d=t.x,u=r.right-t.x;else{const f=Math.min(r.right-t.x+r.left,t.x),p=this._lastBoundingBoxSize.width;u=2*f,d=t.x-f,u>p&&!this._isInitialRender&&!this._growAfterOpen&&(d=t.x-p/2)}return{top:o,left:d,bottom:a,right:h,width:u,height:i}}_setBoundingBoxStyles(t,e){const r=this._calculateBoundingBoxRect(t,e);!this._isInitialRender&&!this._growAfterOpen&&(r.height=Math.min(r.height,this._lastBoundingBoxSize.height),r.width=Math.min(r.width,this._lastBoundingBoxSize.width));const s={};if(this._hasExactPosition())s.top=s.left="0",s.bottom=s.right=s.maxHeight=s.maxWidth="",s.width=s.height="100%";else{const i=this._overlayRef.getConfig().maxHeight,o=this._overlayRef.getConfig().maxWidth;s.height=cr(r.height),s.top=cr(r.top),s.bottom=cr(r.bottom),s.width=cr(r.width),s.left=cr(r.left),s.right=cr(r.right),s.alignItems="center"===e.overlayX?"center":"end"===e.overlayX?"flex-end":"flex-start",s.justifyContent="center"===e.overlayY?"center":"bottom"===e.overlayY?"flex-end":"flex-start",i&&(s.maxHeight=cr(i)),o&&(s.maxWidth=cr(o))}this._lastBoundingBoxSize=r,$c(this._boundingBox.style,s)}_resetBoundingBoxStyles(){$c(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){$c(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(t,e){const r={},s=this._hasExactPosition(),i=this._hasFlexibleDimensions,o=this._overlayRef.getConfig();if(s){const u=this._viewportRuler.getViewportScrollPosition();$c(r,this._getExactOverlayY(e,t,u)),$c(r,this._getExactOverlayX(e,t,u))}else r.position="static";let a="",l=this._getOffset(e,"x"),c=this._getOffset(e,"y");l&&(a+=`translateX(${l}px) `),c&&(a+=`translateY(${c}px)`),r.transform=a.trim(),o.maxHeight&&(s?r.maxHeight=cr(o.maxHeight):i&&(r.maxHeight="")),o.maxWidth&&(s?r.maxWidth=cr(o.maxWidth):i&&(r.maxWidth="")),$c(this._pane.style,r)}_getExactOverlayY(t,e,r){let s={top:"",bottom:""},i=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,r)),"bottom"===t.overlayY?s.bottom=this._document.documentElement.clientHeight-(i.y+this._overlayRect.height)+"px":s.top=cr(i.y),s}_getExactOverlayX(t,e,r){let o,s={left:"",right:""},i=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,r)),o=this._isRtl()?"end"===t.overlayX?"left":"right":"end"===t.overlayX?"right":"left","right"===o?s.right=this._document.documentElement.clientWidth-(i.x+this._overlayRect.width)+"px":s.left=cr(i.x),s}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),r=this._scrollables.map(s=>s.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:XH(t,r),isOriginOutsideView:Q1(t,r),isOverlayClipped:XH(e,r),isOverlayOutsideView:Q1(e,r)}}_subtractOverflows(t,...e){return e.reduce((r,s)=>r-Math.max(s,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,r=this._viewportRuler.getViewportScrollPosition();return{top:r.top+this._viewportMargin,left:r.left+this._viewportMargin,right:r.left+t-this._viewportMargin,bottom:r.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return"x"===e?t.offsetX??this._offsetX:t.offsetY??this._offsetY}_validatePositions(){}_addPanelClasses(t){this._pane&&Lv(t).forEach(e=>{""!==e&&-1===this._appliedPanelClasses.indexOf(e)&&(this._appliedPanelClasses.push(e),this._pane.classList.add(e))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(t=>{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof hn)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,r=t.height||0;return{top:t.y,bottom:t.y+r,left:t.x,right:t.x+e,height:r,width:e}}}function $c(n,t){for(let e in t)t.hasOwnProperty(e)&&(n[e]=t[e]);return n}function JH(n){if("number"!=typeof n&&null!=n){const[t,e]=n.split(pRe);return e&&"px"!==e?null:parseFloat(t)}return n||null}function eW(n){return{top:Math.floor(n.top),right:Math.floor(n.right),bottom:Math.floor(n.bottom),left:Math.floor(n.left),width:Math.floor(n.width),height:Math.floor(n.height)}}const tW="cdk-global-overlay-wrapper";class gRe{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._alignItems="",this._xPosition="",this._xOffset="",this._width="",this._height="",this._isDisposed=!1}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&&!e.width&&t.updateSize({width:this._width}),this._height&&!e.height&&t.updateSize({height:this._height}),t.hostElement.classList.add(tW),this._isDisposed=!1}top(t=""){return this._bottomOffset="",this._topOffset=t,this._alignItems="flex-start",this}left(t=""){return this._xOffset=t,this._xPosition="left",this}bottom(t=""){return this._topOffset="",this._bottomOffset=t,this._alignItems="flex-end",this}right(t=""){return this._xOffset=t,this._xPosition="right",this}start(t=""){return this._xOffset=t,this._xPosition="start",this}end(t=""){return this._xOffset=t,this._xPosition="end",this}width(t=""){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=""){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=""){return this.left(t),this._xPosition="center",this}centerVertically(t=""){return this.top(t),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,r=this._overlayRef.getConfig(),{width:s,height:i,maxWidth:o,maxHeight:a}=r,l=!("100%"!==s&&"100vw"!==s||o&&"100%"!==o&&"100vw"!==o),c=!("100%"!==i&&"100vh"!==i||a&&"100%"!==a&&"100vh"!==a),u=this._xPosition,d=this._xOffset,h="rtl"===this._overlayRef.getConfig().direction;let f="",p="",m="";l?m="flex-start":"center"===u?(m="center",h?p=d:f=d):h?"left"===u||"end"===u?(m="flex-end",f=d):("right"===u||"start"===u)&&(m="flex-start",p=d):"left"===u||"start"===u?(m="flex-start",f=d):("right"===u||"end"===u)&&(m="flex-end",p=d),t.position=this._cssPosition,t.marginLeft=l?"0":f,t.marginTop=c?"0":this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=l?"0":p,e.justifyContent=m,e.alignItems=c?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,r=e.style;e.classList.remove(tW),r.justifyContent=r.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position="",this._overlayRef=null,this._isDisposed=!0}}let yRe=(()=>{class n{constructor(e,r,s,i){this._viewportRuler=e,this._document=r,this._platform=s,this._overlayContainer=i}global(){return new gRe}flexibleConnectedTo(e){return new mRe(e,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return n.\u0275fac=function(e){return new(e||n)(Z(Z1),Z(vt),Z(Us),Z(ZH))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),bRe=0,Lc=(()=>{class n{constructor(e,r,s,i,o,a,l,c,u,d,h,f){this.scrollStrategies=e,this._overlayContainer=r,this._componentFactoryResolver=s,this._positionBuilder=i,this._keyboardDispatcher=o,this._injector=a,this._ngZone=l,this._document=c,this._directionality=u,this._location=d,this._outsideClickDispatcher=h,this._animationsModuleType=f}create(e){const r=this._createHostElement(),s=this._createPaneElement(r),i=this._createPortalOutlet(s),o=new J1(e);return o.direction=o.direction||this._directionality.value,new fRe(i,r,s,o,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher,"NoopAnimations"===this._animationsModuleType)}position(){return this._positionBuilder}_createPaneElement(e){const r=this._document.createElement("div");return r.id="cdk-overlay-"+bRe++,r.classList.add("cdk-overlay-pane"),e.appendChild(r),r}_createHostElement(){const e=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(e),e}_createPortalOutlet(e){return this._appRef||(this._appRef=this._injector.get(Pu)),new $Ae(e,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return n.\u0275fac=function(e){return new(e||n)(Z(cRe),Z(ZH),Z(Xl),Z(yRe),Z(dRe),Z(pr),Z(yt),Z(vt),Z(B1),Z(Yg),Z(hRe),Z(ca,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const _Re=[{originX:"start",originY:"bottom",overlayX:"start",overlayY:"top"},{originX:"start",originY:"top",overlayX:"start",overlayY:"bottom"},{originX:"end",originY:"top",overlayX:"end",overlayY:"bottom"},{originX:"end",originY:"bottom",overlayX:"end",overlayY:"top"}],nW=new me("cdk-connected-overlay-scroll-strategy");let ek=(()=>{class n{constructor(e){this.elementRef=e}}return n.\u0275fac=function(e){return new(e||n)(H(hn))},n.\u0275dir=$e({type:n,selectors:[["","cdk-overlay-origin",""],["","overlay-origin",""],["","cdkOverlayOrigin",""]],exportAs:["cdkOverlayOrigin"]}),n})(),rW=(()=>{class n{constructor(e,r,s,i,o){this._overlay=e,this._dir=o,this._hasBackdrop=!1,this._lockPosition=!1,this._growAfterOpen=!1,this._flexibleDimensions=!1,this._push=!1,this._backdropSubscription=He.EMPTY,this._attachSubscription=He.EMPTY,this._detachSubscription=He.EMPTY,this._positionSubscription=He.EMPTY,this.viewportMargin=0,this.open=!1,this.disableClose=!1,this.backdropClick=new Rt,this.positionChange=new Rt,this.attach=new Rt,this.detach=new Rt,this.overlayKeydown=new Rt,this.overlayOutsideClick=new Rt,this._templatePortal=new q1(r,s),this._scrollStrategyFactory=i,this.scrollStrategy=this._scrollStrategyFactory()}get offsetX(){return this._offsetX}set offsetX(e){this._offsetX=e,this._position&&this._updatePositionStrategy(this._position)}get offsetY(){return this._offsetY}set offsetY(e){this._offsetY=e,this._position&&this._updatePositionStrategy(this._position)}get hasBackdrop(){return this._hasBackdrop}set hasBackdrop(e){this._hasBackdrop=Hi(e)}get lockPosition(){return this._lockPosition}set lockPosition(e){this._lockPosition=Hi(e)}get flexibleDimensions(){return this._flexibleDimensions}set flexibleDimensions(e){this._flexibleDimensions=Hi(e)}get growAfterOpen(){return this._growAfterOpen}set growAfterOpen(e){this._growAfterOpen=Hi(e)}get push(){return this._push}set push(e){this._push=Hi(e)}get overlayRef(){return this._overlayRef}get dir(){return this._dir?this._dir.value:"ltr"}ngOnDestroy(){this._attachSubscription.unsubscribe(),this._detachSubscription.unsubscribe(),this._backdropSubscription.unsubscribe(),this._positionSubscription.unsubscribe(),this._overlayRef&&this._overlayRef.dispose()}ngOnChanges(e){this._position&&(this._updatePositionStrategy(this._position),this._overlayRef.updateSize({width:this.width,minWidth:this.minWidth,height:this.height,minHeight:this.minHeight}),e.origin&&this.open&&this._position.apply()),e.open&&(this.open?this._attachOverlay():this._detachOverlay())}_createOverlay(){(!this.positions||!this.positions.length)&&(this.positions=_Re);const e=this._overlayRef=this._overlay.create(this._buildConfig());this._attachSubscription=e.attachments().subscribe(()=>this.attach.emit()),this._detachSubscription=e.detachments().subscribe(()=>this.detach.emit()),e.keydownEvents().subscribe(r=>{this.overlayKeydown.next(r),27===r.keyCode&&!this.disableClose&&!bm(r)&&(r.preventDefault(),this._detachOverlay())}),this._overlayRef.outsidePointerEvents().subscribe(r=>{this.overlayOutsideClick.next(r)})}_buildConfig(){const e=this._position=this.positionStrategy||this._createPositionStrategy(),r=new J1({direction:this._dir,positionStrategy:e,scrollStrategy:this.scrollStrategy,hasBackdrop:this.hasBackdrop});return(this.width||0===this.width)&&(r.width=this.width),(this.height||0===this.height)&&(r.height=this.height),(this.minWidth||0===this.minWidth)&&(r.minWidth=this.minWidth),(this.minHeight||0===this.minHeight)&&(r.minHeight=this.minHeight),this.backdropClass&&(r.backdropClass=this.backdropClass),this.panelClass&&(r.panelClass=this.panelClass),r}_updatePositionStrategy(e){const r=this.positions.map(s=>({originX:s.originX,originY:s.originY,overlayX:s.overlayX,overlayY:s.overlayY,offsetX:s.offsetX||this.offsetX,offsetY:s.offsetY||this.offsetY,panelClass:s.panelClass||void 0}));return e.setOrigin(this._getFlexibleConnectedPositionStrategyOrigin()).withPositions(r).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector)}_createPositionStrategy(){const e=this._overlay.position().flexibleConnectedTo(this._getFlexibleConnectedPositionStrategyOrigin());return this._updatePositionStrategy(e),e}_getFlexibleConnectedPositionStrategyOrigin(){return this.origin instanceof ek?this.origin.elementRef:this.origin}_attachOverlay(){this._overlayRef?this._overlayRef.getConfig().hasBackdrop=this.hasBackdrop:this._createOverlay(),this._overlayRef.hasAttached()||this._overlayRef.attach(this._templatePortal),this.hasBackdrop?this._backdropSubscription=this._overlayRef.backdropClick().subscribe(e=>{this.backdropClick.emit(e)}):this._backdropSubscription.unsubscribe(),this._positionSubscription.unsubscribe(),this.positionChange.observers.length>0&&(this._positionSubscription=this._position.positionChanges.pipe(gP(()=>this.positionChange.observers.length>0)).subscribe(e=>{this.positionChange.emit(e),0===this.positionChange.observers.length&&this._positionSubscription.unsubscribe()}))}_detachOverlay(){this._overlayRef&&this._overlayRef.detach(),this._backdropSubscription.unsubscribe(),this._positionSubscription.unsubscribe()}}return n.\u0275fac=function(e){return new(e||n)(H(Lc),H(to),H(ti),H(nW),H(B1,8))},n.\u0275dir=$e({type:n,selectors:[["","cdk-connected-overlay",""],["","connected-overlay",""],["","cdkConnectedOverlay",""]],inputs:{origin:["cdkConnectedOverlayOrigin","origin"],positions:["cdkConnectedOverlayPositions","positions"],positionStrategy:["cdkConnectedOverlayPositionStrategy","positionStrategy"],offsetX:["cdkConnectedOverlayOffsetX","offsetX"],offsetY:["cdkConnectedOverlayOffsetY","offsetY"],width:["cdkConnectedOverlayWidth","width"],height:["cdkConnectedOverlayHeight","height"],minWidth:["cdkConnectedOverlayMinWidth","minWidth"],minHeight:["cdkConnectedOverlayMinHeight","minHeight"],backdropClass:["cdkConnectedOverlayBackdropClass","backdropClass"],panelClass:["cdkConnectedOverlayPanelClass","panelClass"],viewportMargin:["cdkConnectedOverlayViewportMargin","viewportMargin"],scrollStrategy:["cdkConnectedOverlayScrollStrategy","scrollStrategy"],open:["cdkConnectedOverlayOpen","open"],disableClose:["cdkConnectedOverlayDisableClose","disableClose"],transformOriginSelector:["cdkConnectedOverlayTransformOriginOn","transformOriginSelector"],hasBackdrop:["cdkConnectedOverlayHasBackdrop","hasBackdrop"],lockPosition:["cdkConnectedOverlayLockPosition","lockPosition"],flexibleDimensions:["cdkConnectedOverlayFlexibleDimensions","flexibleDimensions"],growAfterOpen:["cdkConnectedOverlayGrowAfterOpen","growAfterOpen"],push:["cdkConnectedOverlayPush","push"]},outputs:{backdropClick:"backdropClick",positionChange:"positionChange",attach:"attach",detach:"detach",overlayKeydown:"overlayKeydown",overlayOutsideClick:"overlayOutsideClick"},exportAs:["cdkConnectedOverlay"],features:[Is]}),n})();const xRe={provide:nW,deps:[Lc],useFactory:function vRe(n){return()=>n.scrollStrategies.reposition()}};let tk=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({providers:[Lc,xRe],imports:[xm,UH,GH,GH]}),n})();function wRe(n,t){if(1&n){const e=Lh();Lt(0,"div",2)(1,"button",3),Ln("click",function(){return eu(e),tu(ei().action())}),la(2),Qt()()}if(2&n){const e=ei();Pt(2),Au(" ",e.data.action," ")}}const CRe=["label"];function SRe(n,t){}const ERe=Math.pow(2,31)-1;class nk{constructor(t,e){this._overlayRef=e,this._afterDismissed=new kt,this._afterOpened=new kt,this._onAction=new kt,this._dismissedByAction=!1,this.containerInstance=t,t._onExit.subscribe(()=>this._finishDismiss())}dismiss(){this._afterDismissed.closed||this.containerInstance.exit(),clearTimeout(this._durationTimeoutId)}dismissWithAction(){this._onAction.closed||(this._dismissedByAction=!0,this._onAction.next(),this._onAction.complete(),this.dismiss()),clearTimeout(this._durationTimeoutId)}closeWithAction(){this.dismissWithAction()}_dismissAfter(t){this._durationTimeoutId=setTimeout(()=>this.dismiss(),Math.min(t,ERe))}_open(){this._afterOpened.closed||(this._afterOpened.next(),this._afterOpened.complete())}_finishDismiss(){this._overlayRef.dispose(),this._onAction.closed||this._onAction.complete(),this._afterDismissed.next({dismissedByAction:this._dismissedByAction}),this._afterDismissed.complete(),this._dismissedByAction=!1}afterDismissed(){return this._afterDismissed}afterOpened(){return this.containerInstance._onEnter}onAction(){return this._onAction}}const sW=new me("MatSnackBarData");class Hv{constructor(){this.politeness="assertive",this.announcementMessage="",this.duration=0,this.data=null,this.horizontalPosition="center",this.verticalPosition="bottom"}}let IRe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=$e({type:n,selectors:[["","matSnackBarLabel",""]],hostAttrs:[1,"mat-mdc-snack-bar-label","mdc-snackbar__label"]}),n})(),DRe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=$e({type:n,selectors:[["","matSnackBarActions",""]],hostAttrs:[1,"mat-mdc-snack-bar-actions","mdc-snackbar__actions"]}),n})(),TRe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=$e({type:n,selectors:[["","matSnackBarAction",""]],hostAttrs:[1,"mat-mdc-snack-bar-action","mdc-snackbar__action"]}),n})(),kRe=(()=>{class n{constructor(e,r){this.snackBarRef=e,this.data=r}action(){this.snackBarRef.dismissWithAction()}get hasAction(){return!!this.data.action}}return n.\u0275fac=function(e){return new(e||n)(H(nk),H(sW))},n.\u0275cmp=is({type:n,selectors:[["simple-snack-bar"]],hostAttrs:[1,"mat-mdc-simple-snack-bar"],exportAs:["matSnackBar"],decls:3,vars:2,consts:[["matSnackBarLabel",""],["matSnackBarActions","",4,"ngIf"],["matSnackBarActions",""],["mat-button","","matSnackBarAction","",3,"click"]],template:function(e,r){1&e&&(Lt(0,"div",0),la(1),Qt(),us(2,wRe,3,1,"div",1)),2&e&&(Pt(1),Au(" ",r.data.message,"\n"),Pt(1),Gt("ngIf",r.hasAction))},dependencies:[oy,kAe,IRe,DRe,TRe],styles:[".mat-mdc-simple-snack-bar{display:flex}"],encapsulation:2,changeDetection:0}),n})();const NRe={snackBarState:Yd("state",[Zd("void, hidden",xs({transform:"scale(0.8)",opacity:0})),Zd("visible",xs({transform:"scale(1)",opacity:1})),ka("* => visible",El("150ms cubic-bezier(0, 0, 0.2, 1)")),ka("* => void, * => hidden",El("75ms cubic-bezier(0.4, 0.0, 1, 1)",xs({opacity:0})))])};let ARe=(()=>{class n extends K1{constructor(e,r,s,i,o){super(),this._ngZone=e,this._elementRef=r,this._changeDetectorRef=s,this._platform=i,this.snackBarConfig=o,this._announceDelay=150,this._destroyed=!1,this._onAnnounce=new kt,this._onExit=new kt,this._onEnter=new kt,this._animationState="void",this.attachDomPortal=a=>{this._assertNotAttached();const l=this._portalOutlet.attachDomPortal(a);return this._afterPortalAttached(),l},this._live="assertive"!==o.politeness||o.announcementMessage?"off"===o.politeness?"off":"polite":"assertive",this._platform.FIREFOX&&("polite"===this._live&&(this._role="status"),"assertive"===this._live&&(this._role="alert"))}attachComponentPortal(e){this._assertNotAttached();const r=this._portalOutlet.attachComponentPortal(e);return this._afterPortalAttached(),r}attachTemplatePortal(e){this._assertNotAttached();const r=this._portalOutlet.attachTemplatePortal(e);return this._afterPortalAttached(),r}onAnimationEnd(e){const{fromState:r,toState:s}=e;if(("void"===s&&"void"!==r||"hidden"===s)&&this._completeExit(),"visible"===s){const i=this._onEnter;this._ngZone.run(()=>{i.next(),i.complete()})}}enter(){this._destroyed||(this._animationState="visible",this._changeDetectorRef.detectChanges(),this._screenReaderAnnounce())}exit(){return this._ngZone.run(()=>{this._animationState="hidden",this._elementRef.nativeElement.setAttribute("mat-exit",""),clearTimeout(this._announceTimeoutId)}),this._onExit}ngOnDestroy(){this._destroyed=!0,this._completeExit()}_completeExit(){this._ngZone.onMicrotaskEmpty.pipe($r(1)).subscribe(()=>{this._ngZone.run(()=>{this._onExit.next(),this._onExit.complete()})})}_afterPortalAttached(){const e=this._elementRef.nativeElement,r=this.snackBarConfig.panelClass;r&&(Array.isArray(r)?r.forEach(s=>e.classList.add(s)):e.classList.add(r))}_assertNotAttached(){this._portalOutlet.hasAttached()}_screenReaderAnnounce(){this._announceTimeoutId||this._ngZone.runOutsideAngular(()=>{this._announceTimeoutId=setTimeout(()=>{const e=this._elementRef.nativeElement.querySelector("[aria-hidden]"),r=this._elementRef.nativeElement.querySelector("[aria-live]");if(e&&r){let s=null;this._platform.isBrowser&&document.activeElement instanceof HTMLElement&&e.contains(document.activeElement)&&(s=document.activeElement),e.removeAttribute("aria-hidden"),r.appendChild(e),s?.focus(),this._onAnnounce.next(),this._onAnnounce.complete()}},this._announceDelay)})}}return n.\u0275fac=function(e){return new(e||n)(H(yt),H(hn),H(nc),H(Us),H(Hv))},n.\u0275dir=$e({type:n,viewQuery:function(e,r){if(1&e&&Eo(zH,7),2&e){let s;Ts(s=ks())&&(r._portalOutlet=s.first)}},features:[dt]}),n})(),RRe=(()=>{class n extends ARe{_afterPortalAttached(){super._afterPortalAttached();const e=this._label.nativeElement,r="mdc-snackbar__label";e.classList.toggle(r,!e.querySelector(`.${r}`))}}return n.\u0275fac=function(){let t;return function(r){return(t||(t=hr(n)))(r||n)}}(),n.\u0275cmp=is({type:n,selectors:[["mat-snack-bar-container"]],viewQuery:function(e,r){if(1&e&&Eo(CRe,7),2&e){let s;Ts(s=ks())&&(r._label=s.first)}},hostAttrs:[1,"mdc-snackbar","mat-mdc-snack-bar-container","mdc-snackbar--open"],hostVars:1,hostBindings:function(e,r){1&e&&Pw("@state.done",function(i){return r.onAnimationEnd(i)}),2&e&&Vw("@state",r._animationState)},features:[dt],decls:6,vars:2,consts:[[1,"mdc-snackbar__surface"],[1,"mat-mdc-snack-bar-label"],["label",""],["aria-hidden","true"],["cdkPortalOutlet",""]],template:function(e,r){1&e&&(Lt(0,"div",0)(1,"div",1,2)(3,"div",3),us(4,SRe,0,0,"ng-template",4),Qt(),kr(5,"div"),Qt()()),2&e&&(Pt(5),yn("aria-live",r._live)("role",r._role))},dependencies:[zH],styles:['.mdc-snackbar{display:none;position:fixed;right:0;bottom:0;left:0;align-items:center;justify-content:center;box-sizing:border-box;pointer-events:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mdc-snackbar--opening,.mdc-snackbar--open,.mdc-snackbar--closing{display:flex}.mdc-snackbar--open .mdc-snackbar__label,.mdc-snackbar--open .mdc-snackbar__actions{visibility:visible}.mdc-snackbar__surface{padding-left:0;padding-right:8px;display:flex;align-items:center;justify-content:flex-start;box-sizing:border-box;transform:scale(0.8);opacity:0}.mdc-snackbar__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-snackbar__surface::before{border-color:CanvasText}}[dir=rtl] .mdc-snackbar__surface,.mdc-snackbar__surface[dir=rtl]{padding-left:8px;padding-right:0}.mdc-snackbar--open .mdc-snackbar__surface{transform:scale(1);opacity:1;pointer-events:auto}.mdc-snackbar--closing .mdc-snackbar__surface{transform:scale(1)}.mdc-snackbar__label{padding-left:16px;padding-right:8px;width:100%;flex-grow:1;box-sizing:border-box;margin:0;visibility:hidden;padding-top:14px;padding-bottom:14px}[dir=rtl] .mdc-snackbar__label,.mdc-snackbar__label[dir=rtl]{padding-left:8px;padding-right:16px}.mdc-snackbar__label::before{display:inline;content:attr(data-mdc-snackbar-label-text)}.mdc-snackbar__actions{display:flex;flex-shrink:0;align-items:center;box-sizing:border-box;visibility:hidden}.mdc-snackbar__action+.mdc-snackbar__dismiss{margin-left:8px;margin-right:0}[dir=rtl] .mdc-snackbar__action+.mdc-snackbar__dismiss,.mdc-snackbar__action+.mdc-snackbar__dismiss[dir=rtl]{margin-left:0;margin-right:8px}.mat-mdc-snack-bar-container{margin:8px;position:static}.mat-mdc-snack-bar-container .mdc-snackbar__surface{min-width:344px}@media(max-width: 480px),(max-width: 344px){.mat-mdc-snack-bar-container .mdc-snackbar__surface{min-width:100%}}.mat-mdc-snack-bar-container .mdc-snackbar__surface{max-width:672px}.mat-mdc-snack-bar-container .mdc-snackbar__surface{box-shadow:0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12)}.mat-mdc-snack-bar-container .mdc-snackbar__dismiss .mdc-button__icon{font-size:var(--mdc-icon-button-icon-size, 24px)}.mat-mdc-snack-bar-container .mdc-snackbar__dismiss svg,.mat-mdc-snack-bar-container .mdc-snackbar__dismiss img{width:var(--mdc-icon-button-icon-size, 24px);height:var(--mdc-icon-button-icon-size, 24px)}.mat-mdc-snack-bar-container .mdc-snackbar__surface{background-color:var(--mdc-snackbar-container-color, inherit)}.mat-mdc-snack-bar-container .mdc-snackbar__surface{border-radius:var(--mdc-snackbar-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-snack-bar-container .mdc-snackbar__label{color:var(--mdc-snackbar-supporting-text-color, inherit)}.mat-mdc-snack-bar-container .mdc-snackbar__label{font-size:var(--mdc-snackbar-supporting-text-size, inherit);font-family:var(--mdc-snackbar-supporting-text-font, inherit);font-weight:var(--mdc-snackbar-supporting-text-weight, inherit);line-height:var(--mdc-snackbar-supporting-text-line-height, inherit)}.cdk-high-contrast-active .mat-mdc-snack-bar-container{border:solid 1px}.mat-mdc-snack-bar-container .mat-mdc-button.mat-mdc-snack-bar-action:not(:disabled){color:var(--mat-mdc-snack-bar-button-color, transparent);--mat-mdc-button-persistent-ripple-color: currentColor}.mat-mdc-snack-bar-container .mat-mdc-button.mat-mdc-snack-bar-action:not(:disabled) .mat-ripple-element{background-color:currentColor;opacity:.1}.mat-mdc-snack-bar-handset,.mat-mdc-snack-bar-container,.mat-mdc-snack-bar-label{flex:1 1 auto}.mat-mdc-snack-bar-handset .mdc-snackbar__surface{width:100%}'],encapsulation:2,data:{animation:[NRe.snackBarState]}}),n})(),iW=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({imports:[tk,UH,ic,PH,zr,zr]}),n})();const oW=new me("mat-snack-bar-default-options",{providedIn:"root",factory:function MRe(){return new Hv}});let FRe=(()=>{class n{constructor(e,r,s,i,o,a){this._overlay=e,this._live=r,this._injector=s,this._breakpointObserver=i,this._parentSnackBar=o,this._defaultConfig=a,this._snackBarRefAtThisLevel=null}get _openedSnackBarRef(){const e=this._parentSnackBar;return e?e._openedSnackBarRef:this._snackBarRefAtThisLevel}set _openedSnackBarRef(e){this._parentSnackBar?this._parentSnackBar._openedSnackBarRef=e:this._snackBarRefAtThisLevel=e}openFromComponent(e,r){return this._attach(e,r)}openFromTemplate(e,r){return this._attach(e,r)}open(e,r="",s){const i={...this._defaultConfig,...s};return i.data={message:e,action:r},i.announcementMessage===e&&(i.announcementMessage=void 0),this.openFromComponent(this.simpleSnackBarComponent,i)}dismiss(){this._openedSnackBarRef&&this._openedSnackBarRef.dismiss()}ngOnDestroy(){this._snackBarRefAtThisLevel&&this._snackBarRefAtThisLevel.dismiss()}_attachSnackBarContainer(e,r){const i=pr.create({parent:r&&r.viewContainerRef&&r.viewContainerRef.injector||this._injector,providers:[{provide:Hv,useValue:r}]}),o=new G1(this.snackBarContainerComponent,r.viewContainerRef,i),a=e.attach(o);return a.instance.snackBarConfig=r,a.instance}_attach(e,r){const s={...new Hv,...this._defaultConfig,...r},i=this._createOverlay(s),o=this._attachSnackBarContainer(i,s),a=new nk(o,i);if(e instanceof to){const l=new q1(e,null,{$implicit:s.data,snackBarRef:a});a.instance=o.attachTemplatePortal(l)}else{const l=this._createInjector(s,a),c=new G1(e,void 0,l),u=o.attachComponentPortal(c);a.instance=u.instance}return this._breakpointObserver.observe("(max-width: 599.98px) and (orientation: portrait)").pipe(Go(i.detachments())).subscribe(l=>{i.overlayElement.classList.toggle(this.handsetCssClass,l.matches)}),s.announcementMessage&&o._onAnnounce.subscribe(()=>{this._live.announce(s.announcementMessage,s.politeness)}),this._animateSnackBar(a,s),this._openedSnackBarRef=a,this._openedSnackBarRef}_animateSnackBar(e,r){e.afterDismissed().subscribe(()=>{this._openedSnackBarRef==e&&(this._openedSnackBarRef=null),r.announcementMessage&&this._live.clear()}),this._openedSnackBarRef?(this._openedSnackBarRef.afterDismissed().subscribe(()=>{e.containerInstance.enter()}),this._openedSnackBarRef.dismiss()):e.containerInstance.enter(),r.duration&&r.duration>0&&e.afterOpened().subscribe(()=>e._dismissAfter(r.duration))}_createOverlay(e){const r=new J1;r.direction=e.direction;let s=this._overlay.position().global();const i="rtl"===e.direction,o="left"===e.horizontalPosition||"start"===e.horizontalPosition&&!i||"end"===e.horizontalPosition&&i,a=!o&&"center"!==e.horizontalPosition;return o?s.left("0"):a?s.right("0"):s.centerHorizontally(),"top"===e.verticalPosition?s.top("0"):s.bottom("0"),r.positionStrategy=s,this._overlay.create(r)}_createInjector(e,r){return pr.create({parent:e&&e.viewContainerRef&&e.viewContainerRef.injector||this._injector,providers:[{provide:nk,useValue:r},{provide:sW,useValue:e.data}]})}}return n.\u0275fac=function(e){return new(e||n)(Z(Lc),Z($1),Z(pr),Z(P1),Z(n,12),Z(oW))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})(),ORe=(()=>{class n extends FRe{constructor(e,r,s,i,o,a){super(e,r,s,i,o,a),this.simpleSnackBarComponent=kRe,this.snackBarContainerComponent=RRe,this.handsetCssClass="mat-mdc-snack-bar-handset"}}return n.\u0275fac=function(e){return new(e||n)(Z(Lc),Z($1),Z(pr),Z(P1),Z(n,12),Z(oW))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:iW}),n})();const PRe=["determinateSpinner"];function $Re(n,t){if(1&n&&(mh(),Lt(0,"svg",11),kr(1,"circle",12),Qt()),2&n){const e=ei();yn("viewBox",e._viewBox()),Pt(1),Vh("stroke-dasharray",e._strokeCircumference(),"px")("stroke-dashoffset",e._strokeCircumference()/2,"px")("stroke-width",e._circleStrokeWidth(),"%"),yn("r",e._circleRadius())}}const LRe=V1(class{constructor(n){this._elementRef=n}},"primary"),BRe=new me("mat-progress-spinner-default-options",{providedIn:"root",factory:function VRe(){return{diameter:aW}}}),aW=100;let URe=(()=>{class n extends LRe{constructor(e,r,s){super(e),this.mode="mat-spinner"===this._elementRef.nativeElement.nodeName.toLowerCase()?"indeterminate":"determinate",this._value=0,this._diameter=aW,this._noopAnimations="NoopAnimations"===r&&!!s&&!s._forceAnimations,s&&(s.color&&(this.color=this.defaultColor=s.color),s.diameter&&(this.diameter=s.diameter),s.strokeWidth&&(this.strokeWidth=s.strokeWidth))}get value(){return"determinate"===this.mode?this._value:0}set value(e){this._value=Math.max(0,Math.min(100,vm(e)))}get diameter(){return this._diameter}set diameter(e){this._diameter=vm(e)}get strokeWidth(){return this._strokeWidth??this.diameter/10}set strokeWidth(e){this._strokeWidth=vm(e)}_circleRadius(){return(this.diameter-10)/2}_viewBox(){const e=2*this._circleRadius()+this.strokeWidth;return`0 0 ${e} ${e}`}_strokeCircumference(){return 2*Math.PI*this._circleRadius()}_strokeDashOffset(){return"determinate"===this.mode?this._strokeCircumference()*(100-this._value)/100:null}_circleStrokeWidth(){return this.strokeWidth/this.diameter*100}}return n.\u0275fac=function(e){return new(e||n)(H(hn),H(ca,8),H(BRe))},n.\u0275cmp=is({type:n,selectors:[["mat-progress-spinner"],["mat-spinner"]],viewQuery:function(e,r){if(1&e&&Eo(PRe,5),2&e){let s;Ts(s=ks())&&(r._determinateCircle=s.first)}},hostAttrs:["role","progressbar","tabindex","-1",1,"mat-mdc-progress-spinner","mdc-circular-progress"],hostVars:12,hostBindings:function(e,r){2&e&&(yn("aria-valuemin",0)("aria-valuemax",100)("aria-valuenow","determinate"===r.mode?r.value:null)("mode",r.mode),Vh("width",r.diameter,"px")("height",r.diameter,"px"),ds("_mat-animation-noopable",r._noopAnimations)("mdc-circular-progress--indeterminate","indeterminate"===r.mode))},inputs:{color:"color",mode:"mode",value:"value",diameter:"diameter",strokeWidth:"strokeWidth"},exportAs:["matProgressSpinner"],features:[dt],decls:14,vars:11,consts:[["circle",""],["aria-hidden","true",1,"mdc-circular-progress__determinate-container"],["determinateSpinner",""],["xmlns","http://www.w3.org/2000/svg","focusable","false",1,"mdc-circular-progress__determinate-circle-graphic"],["cx","50%","cy","50%",1,"mdc-circular-progress__determinate-circle"],["aria-hidden","true",1,"mdc-circular-progress__indeterminate-container"],[1,"mdc-circular-progress__spinner-layer"],[1,"mdc-circular-progress__circle-clipper","mdc-circular-progress__circle-left"],[3,"ngTemplateOutlet"],[1,"mdc-circular-progress__gap-patch"],[1,"mdc-circular-progress__circle-clipper","mdc-circular-progress__circle-right"],["xmlns","http://www.w3.org/2000/svg","focusable","false",1,"mdc-circular-progress__indeterminate-circle-graphic"],["cx","50%","cy","50%"]],template:function(e,r){if(1&e&&(us(0,$Re,2,8,"ng-template",null,0,mO),Lt(2,"div",1,2),mh(),Lt(4,"svg",3),kr(5,"circle",4),Qt()(),l0(),Lt(6,"div",5)(7,"div",6)(8,"div",7),$h(9,8),Qt(),Lt(10,"div",9),$h(11,8),Qt(),Lt(12,"div",10),$h(13,8),Qt()()()),2&e){const s=Ph(1);Pt(4),yn("viewBox",r._viewBox()),Pt(1),Vh("stroke-dasharray",r._strokeCircumference(),"px")("stroke-dashoffset",r._strokeDashOffset(),"px")("stroke-width",r._circleStrokeWidth(),"%"),yn("r",r._circleRadius()),Pt(4),Gt("ngTemplateOutlet",s),Pt(2),Gt("ngTemplateOutlet",s),Pt(2),Gt("ngTemplateOutlet",s)}},dependencies:[M2],styles:["@keyframes mdc-circular-progress-container-rotate{to{transform:rotate(360deg)}}@keyframes mdc-circular-progress-spinner-layer-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}@keyframes mdc-circular-progress-color-1-fade-in-out{from{opacity:.99}25%{opacity:.99}26%{opacity:0}89%{opacity:0}90%{opacity:.99}to{opacity:.99}}@keyframes mdc-circular-progress-color-2-fade-in-out{from{opacity:0}15%{opacity:0}25%{opacity:.99}50%{opacity:.99}51%{opacity:0}to{opacity:0}}@keyframes mdc-circular-progress-color-3-fade-in-out{from{opacity:0}40%{opacity:0}50%{opacity:.99}75%{opacity:.99}76%{opacity:0}to{opacity:0}}@keyframes mdc-circular-progress-color-4-fade-in-out{from{opacity:0}65%{opacity:0}75%{opacity:.99}90%{opacity:.99}to{opacity:0}}@keyframes mdc-circular-progress-left-spin{from{transform:rotate(265deg)}50%{transform:rotate(130deg)}to{transform:rotate(265deg)}}@keyframes mdc-circular-progress-right-spin{from{transform:rotate(-265deg)}50%{transform:rotate(-130deg)}to{transform:rotate(-265deg)}}.mdc-circular-progress{display:inline-flex;position:relative;direction:ltr;line-height:0;transition:opacity 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-circular-progress__determinate-container,.mdc-circular-progress__indeterminate-circle-graphic,.mdc-circular-progress__indeterminate-container,.mdc-circular-progress__spinner-layer{position:absolute;width:100%;height:100%}.mdc-circular-progress__determinate-container{transform:rotate(-90deg)}.mdc-circular-progress__indeterminate-container{font-size:0;letter-spacing:0;white-space:nowrap;opacity:0}.mdc-circular-progress__determinate-circle-graphic,.mdc-circular-progress__indeterminate-circle-graphic{fill:rgba(0,0,0,0)}.mdc-circular-progress__determinate-circle{transition:stroke-dashoffset 500ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-circular-progress__gap-patch{position:absolute;top:0;left:47.5%;box-sizing:border-box;width:5%;height:100%;overflow:hidden}.mdc-circular-progress__gap-patch .mdc-circular-progress__indeterminate-circle-graphic{left:-900%;width:2000%;transform:rotate(180deg)}.mdc-circular-progress__circle-clipper{display:inline-flex;position:relative;width:50%;height:100%;overflow:hidden}.mdc-circular-progress__circle-clipper .mdc-circular-progress__indeterminate-circle-graphic{width:200%}.mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{left:-100%}.mdc-circular-progress--indeterminate .mdc-circular-progress__determinate-container{opacity:0}.mdc-circular-progress--indeterminate .mdc-circular-progress__indeterminate-container{opacity:1}.mdc-circular-progress--indeterminate .mdc-circular-progress__indeterminate-container{animation:mdc-circular-progress-container-rotate 1568.2352941176ms linear infinite}.mdc-circular-progress--indeterminate .mdc-circular-progress__spinner-layer{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-1{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-1-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-2{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-2-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-3{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-3-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-4{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-4-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-left .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--closed{opacity:0}.mat-mdc-progress-spinner{display:block;overflow:hidden;line-height:0}.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:var(--mdc-circular-progress-active-indicator-color, transparent)}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-1 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-2 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-3 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-4 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}.mat-mdc-progress-spinner._mat-animation-noopable,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__determinate-circle{transition:none}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-circle-graphic,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__spinner-layer,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container{animation:none}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container circle{stroke-dasharray:0 !important}.cdk-high-contrast-active .mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic,.cdk-high-contrast-active .mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle{stroke:currentColor;stroke:CanvasText}"],encapsulation:2,changeDetection:0}),n})(),HRe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({imports:[ic,zr]}),n})();function lW(...n){const t=_N(n),{args:e,keys:r}=cP(n),s=new Cn(i=>{const{length:o}=e;if(!o)return void i.complete();const a=new Array(o);let l=o,c=o;for(let u=0;u<o;u++){let d=!1;Cs(e[u]).subscribe(Sn(i,h=>{d||(d=!0,c--),a[u]=h},()=>l--,void 0,()=>{(!l||!d)&&(c||i.next(r?uP(r,a):a),i.complete())}))}});return t?s.pipe(WC(t)):s}class rk{}class Il{constructor(t){this.normalizedNames=new Map,this.lazyUpdate=null,t?this.lazyInit="string"==typeof t?()=>{this.headers=new Map,t.split("\n").forEach(e=>{const r=e.indexOf(":");if(r>0){const s=e.slice(0,r),i=s.toLowerCase(),o=e.slice(r+1).trim();this.maybeSetNormalizedName(s,i),this.headers.has(i)?this.headers.get(i).push(o):this.headers.set(i,[o])}})}:()=>{this.headers=new Map,Object.keys(t).forEach(e=>{let r=t[e];const s=e.toLowerCase();"string"==typeof r&&(r=[r]),r.length>0&&(this.headers.set(s,r),this.maybeSetNormalizedName(e,s))})}:this.headers=new Map}has(t){return this.init(),this.headers.has(t.toLowerCase())}get(t){this.init();const e=this.headers.get(t.toLowerCase());return e&&e.length>0?e[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(t){return this.init(),this.headers.get(t.toLowerCase())||null}append(t,e){return this.clone({name:t,value:e,op:"a"})}set(t,e){return this.clone({name:t,value:e,op:"s"})}delete(t,e){return this.clone({name:t,value:e,op:"d"})}maybeSetNormalizedName(t,e){this.normalizedNames.has(e)||this.normalizedNames.set(e,t)}init(){this.lazyInit&&(this.lazyInit instanceof Il?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(t=>this.applyUpdate(t)),this.lazyUpdate=null))}copyFrom(t){t.init(),Array.from(t.headers.keys()).forEach(e=>{this.headers.set(e,t.headers.get(e)),this.normalizedNames.set(e,t.normalizedNames.get(e))})}clone(t){const e=new Il;return e.lazyInit=this.lazyInit&&this.lazyInit instanceof Il?this.lazyInit:this,e.lazyUpdate=(this.lazyUpdate||[]).concat([t]),e}applyUpdate(t){const e=t.name.toLowerCase();switch(t.op){case"a":case"s":let r=t.value;if("string"==typeof r&&(r=[r]),0===r.length)return;this.maybeSetNormalizedName(t.name,e);const s=("a"===t.op?this.headers.get(e):void 0)||[];s.push(...r),this.headers.set(e,s);break;case"d":const i=t.value;if(i){let o=this.headers.get(e);if(!o)return;o=o.filter(a=>-1===i.indexOf(a)),0===o.length?(this.headers.delete(e),this.normalizedNames.delete(e)):this.headers.set(e,o)}else this.headers.delete(e),this.normalizedNames.delete(e)}}forEach(t){this.init(),Array.from(this.normalizedNames.keys()).forEach(e=>t(this.normalizedNames.get(e),this.headers.get(e)))}}class WRe{encodeKey(t){return uW(t)}encodeValue(t){return uW(t)}decodeKey(t){return decodeURIComponent(t)}decodeValue(t){return decodeURIComponent(t)}}const GRe=/%(\d[a-f0-9])/gi,qRe={40:"@","3A":":",24:"$","2C":",","3B":";","3D":"=","3F":"?","2F":"/"};function uW(n){return encodeURIComponent(n).replace(GRe,(t,e)=>qRe[e]??t)}function Wv(n){return`${n}`}class Dl{constructor(t={}){if(this.updates=null,this.cloneFrom=null,this.encoder=t.encoder||new WRe,t.fromString){if(t.fromObject)throw new Error("Cannot specify both fromString and fromObject.");this.map=function jRe(n,t){const e=new Map;return n.length>0&&n.replace(/^\?/,"").split("&").forEach(s=>{const i=s.indexOf("="),[o,a]=-1==i?[t.decodeKey(s),""]:[t.decodeKey(s.slice(0,i)),t.decodeValue(s.slice(i+1))],l=e.get(o)||[];l.push(a),e.set(o,l)}),e}(t.fromString,this.encoder)}else t.fromObject?(this.map=new Map,Object.keys(t.fromObject).forEach(e=>{const r=t.fromObject[e],s=Array.isArray(r)?r.map(Wv):[Wv(r)];this.map.set(e,s)})):this.map=null}has(t){return this.init(),this.map.has(t)}get(t){this.init();const e=this.map.get(t);return e?e[0]:null}getAll(t){return this.init(),this.map.get(t)||null}keys(){return this.init(),Array.from(this.map.keys())}append(t,e){return this.clone({param:t,value:e,op:"a"})}appendAll(t){const e=[];return Object.keys(t).forEach(r=>{const s=t[r];Array.isArray(s)?s.forEach(i=>{e.push({param:r,value:i,op:"a"})}):e.push({param:r,value:s,op:"a"})}),this.clone(e)}set(t,e){return this.clone({param:t,value:e,op:"s"})}delete(t,e){return this.clone({param:t,value:e,op:"d"})}toString(){return this.init(),this.keys().map(t=>{const e=this.encoder.encodeKey(t);return this.map.get(t).map(r=>e+"="+this.encoder.encodeValue(r)).join("&")}).filter(t=>""!==t).join("&")}clone(t){const e=new Dl({encoder:this.encoder});return e.cloneFrom=this.cloneFrom||this,e.updates=(this.updates||[]).concat(t),e}init(){null===this.map&&(this.map=new Map),null!==this.cloneFrom&&(this.cloneFrom.init(),this.cloneFrom.keys().forEach(t=>this.map.set(t,this.cloneFrom.map.get(t))),this.updates.forEach(t=>{switch(t.op){case"a":case"s":const e=("a"===t.op?this.map.get(t.param):void 0)||[];e.push(Wv(t.value)),this.map.set(t.param,e);break;case"d":if(void 0===t.value){this.map.delete(t.param);break}{let r=this.map.get(t.param)||[];const s=r.indexOf(Wv(t.value));-1!==s&&r.splice(s,1),r.length>0?this.map.set(t.param,r):this.map.delete(t.param)}}}),this.cloneFrom=this.updates=null)}}class KRe{constructor(){this.map=new Map}set(t,e){return this.map.set(t,e),this}get(t){return this.map.has(t)||this.map.set(t,t.defaultValue()),this.map.get(t)}delete(t){return this.map.delete(t),this}has(t){return this.map.has(t)}keys(){return this.map.keys()}}function dW(n){return typeof ArrayBuffer<"u"&&n instanceof ArrayBuffer}function hW(n){return typeof Blob<"u"&&n instanceof Blob}function fW(n){return typeof FormData<"u"&&n instanceof FormData}class Im{constructor(t,e,r,s){let i;if(this.url=e,this.body=null,this.reportProgress=!1,this.withCredentials=!1,this.responseType="json",this.method=t.toUpperCase(),function XRe(n){switch(n){case"DELETE":case"GET":case"HEAD":case"OPTIONS":case"JSONP":return!1;default:return!0}}(this.method)||s?(this.body=void 0!==r?r:null,i=s):i=r,i&&(this.reportProgress=!!i.reportProgress,this.withCredentials=!!i.withCredentials,i.responseType&&(this.responseType=i.responseType),i.headers&&(this.headers=i.headers),i.context&&(this.context=i.context),i.params&&(this.params=i.params)),this.headers||(this.headers=new Il),this.context||(this.context=new KRe),this.params){const o=this.params.toString();if(0===o.length)this.urlWithParams=e;else{const a=e.indexOf("?");this.urlWithParams=e+(-1===a?"?":a<e.length-1?"&":"")+o}}else this.params=new Dl,this.urlWithParams=e}serializeBody(){return null===this.body?null:dW(this.body)||hW(this.body)||fW(this.body)||function YRe(n){return typeof URLSearchParams<"u"&&n instanceof URLSearchParams}(this.body)||"string"==typeof this.body?this.body:this.body instanceof Dl?this.body.toString():"object"==typeof this.body||"boolean"==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||fW(this.body)?null:hW(this.body)?this.body.type||null:dW(this.body)?null:"string"==typeof this.body?"text/plain":this.body instanceof Dl?"application/x-www-form-urlencoded;charset=UTF-8":"object"==typeof this.body||"number"==typeof this.body||"boolean"==typeof this.body?"application/json":null}clone(t={}){const e=t.method||this.method,r=t.url||this.url,s=t.responseType||this.responseType,i=void 0!==t.body?t.body:this.body,o=void 0!==t.withCredentials?t.withCredentials:this.withCredentials,a=void 0!==t.reportProgress?t.reportProgress:this.reportProgress;let l=t.headers||this.headers,c=t.params||this.params;const u=t.context??this.context;return void 0!==t.setHeaders&&(l=Object.keys(t.setHeaders).reduce((d,h)=>d.set(h,t.setHeaders[h]),l)),t.setParams&&(c=Object.keys(t.setParams).reduce((d,h)=>d.set(h,t.setParams[h]),c)),new Im(e,r,i,{params:c,headers:l,context:u,reportProgress:a,responseType:s,withCredentials:o})}}var Ur=(()=>((Ur=Ur||{})[Ur.Sent=0]="Sent",Ur[Ur.UploadProgress=1]="UploadProgress",Ur[Ur.ResponseHeader=2]="ResponseHeader",Ur[Ur.DownloadProgress=3]="DownloadProgress",Ur[Ur.Response=4]="Response",Ur[Ur.User=5]="User",Ur))();class ZRe{constructor(t,e=200,r="OK"){this.headers=t.headers||new Il,this.status=void 0!==t.status?t.status:e,this.statusText=t.statusText||r,this.url=t.url||null,this.ok=this.status>=200&&this.status<300}}class sk extends ZRe{constructor(t={}){super(t),this.type=Ur.Response,this.body=void 0!==t.body?t.body:null}clone(t={}){return new sk({body:void 0!==t.body?t.body:this.body,headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}function ik(n,t){return{body:t,headers:n.headers,context:n.context,observe:n.observe,params:n.params,reportProgress:n.reportProgress,responseType:n.responseType,withCredentials:n.withCredentials}}let ok=(()=>{class n{constructor(e){this.handler=e}request(e,r,s={}){let i;if(e instanceof Im)i=e;else{let l,c;l=s.headers instanceof Il?s.headers:new Il(s.headers),s.params&&(c=s.params instanceof Dl?s.params:new Dl({fromObject:s.params})),i=new Im(e,r,void 0!==s.body?s.body:null,{headers:l,context:s.context,params:c,reportProgress:s.reportProgress,responseType:s.responseType||"json",withCredentials:s.withCredentials})}const o=Oe(i).pipe(ja(l=>this.handler.handle(l)));if(e instanceof Im||"events"===s.observe)return o;const a=o.pipe(As(l=>l instanceof sk));switch(s.observe||"body"){case"body":switch(i.responseType){case"arraybuffer":return a.pipe(ze(l=>{if(null!==l.body&&!(l.body instanceof ArrayBuffer))throw new Error("Response is not an ArrayBuffer.");return l.body}));case"blob":return a.pipe(ze(l=>{if(null!==l.body&&!(l.body instanceof Blob))throw new Error("Response is not a Blob.");return l.body}));case"text":return a.pipe(ze(l=>{if(null!==l.body&&"string"!=typeof l.body)throw new Error("Response is not a string.");return l.body}));default:return a.pipe(ze(l=>l.body))}case"response":return a;default:throw new Error(`Unreachable: unhandled observe type ${s.observe}}`)}}delete(e,r={}){return this.request("DELETE",e,r)}get(e,r={}){return this.request("GET",e,r)}head(e,r={}){return this.request("HEAD",e,r)}jsonp(e,r){return this.request("JSONP",e,{params:(new Dl).append(r,"JSONP_CALLBACK"),observe:"body",responseType:"json"})}options(e,r={}){return this.request("OPTIONS",e,r)}patch(e,r,s={}){return this.request("PATCH",e,ik(s,r))}post(e,r,s={}){return this.request("POST",e,ik(s,r))}put(e,r,s={}){return this.request("PUT",e,ik(s,r))}}return n.\u0275fac=function(e){return new(e||n)(Z(rk))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();const uMe=["*"];let Gv;function Dm(n){return function dMe(){if(void 0===Gv&&(Gv=null,typeof window<"u")){const n=window;void 0!==n.trustedTypes&&(Gv=n.trustedTypes.createPolicy("angular#components",{createHTML:t=>t}))}return Gv}()?.createHTML(n)||n}function xW(n){return Error(`Unable to find icon with the name "${n}"`)}function wW(n){return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${n}".`)}function CW(n){return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${n}".`)}class Bc{constructor(t,e,r){this.url=t,this.svgText=e,this.options=r}}let qv=(()=>{class n{constructor(e,r,s,i){this._httpClient=e,this._sanitizer=r,this._errorHandler=i,this._svgIconConfigs=new Map,this._iconSetConfigs=new Map,this._cachedIconsByUrl=new Map,this._inProgressUrlFetches=new Map,this._fontCssClassesByAlias=new Map,this._resolvers=[],this._defaultFontSetClass=["material-icons","mat-ligature-font"],this._document=s}addSvgIcon(e,r,s){return this.addSvgIconInNamespace("",e,r,s)}addSvgIconLiteral(e,r,s){return this.addSvgIconLiteralInNamespace("",e,r,s)}addSvgIconInNamespace(e,r,s,i){return this._addSvgIconConfig(e,r,new Bc(s,null,i))}addSvgIconResolver(e){return this._resolvers.push(e),this}addSvgIconLiteralInNamespace(e,r,s,i){const o=this._sanitizer.sanitize(Vt.HTML,s);if(!o)throw CW(s);const a=Dm(o);return this._addSvgIconConfig(e,r,new Bc("",a,i))}addSvgIconSet(e,r){return this.addSvgIconSetInNamespace("",e,r)}addSvgIconSetLiteral(e,r){return this.addSvgIconSetLiteralInNamespace("",e,r)}addSvgIconSetInNamespace(e,r,s){return this._addSvgIconSetConfig(e,new Bc(r,null,s))}addSvgIconSetLiteralInNamespace(e,r,s){const i=this._sanitizer.sanitize(Vt.HTML,r);if(!i)throw CW(r);const o=Dm(i);return this._addSvgIconSetConfig(e,new Bc("",o,s))}registerFontClassAlias(e,r=e){return this._fontCssClassesByAlias.set(e,r),this}classNameForFontAlias(e){return this._fontCssClassesByAlias.get(e)||e}setDefaultFontSetClass(...e){return this._defaultFontSetClass=e,this}getDefaultFontSetClass(){return this._defaultFontSetClass}getSvgIconFromUrl(e){const r=this._sanitizer.sanitize(Vt.RESOURCE_URL,e);if(!r)throw wW(e);const s=this._cachedIconsByUrl.get(r);return s?Oe(Kv(s)):this._loadSvgIconFromConfig(new Bc(e,null)).pipe(tr(i=>this._cachedIconsByUrl.set(r,i)),ze(i=>Kv(i)))}getNamedSvgIcon(e,r=""){const s=SW(r,e);let i=this._svgIconConfigs.get(s);if(i)return this._getSvgFromConfig(i);if(i=this._getIconConfigFromResolvers(r,e),i)return this._svgIconConfigs.set(s,i),this._getSvgFromConfig(i);const o=this._iconSetConfigs.get(r);return o?this._getSvgFromIconSetConfigs(e,o):Lu(xW(s))}ngOnDestroy(){this._resolvers=[],this._svgIconConfigs.clear(),this._iconSetConfigs.clear(),this._cachedIconsByUrl.clear()}_getSvgFromConfig(e){return e.svgText?Oe(Kv(this._svgElementFromConfig(e))):this._loadSvgIconFromConfig(e).pipe(ze(r=>Kv(r)))}_getSvgFromIconSetConfigs(e,r){const s=this._extractIconWithNameFromAnySet(e,r);return s?Oe(s):lW(r.filter(o=>!o.svgText).map(o=>this._loadSvgIconSetFromConfig(o).pipe(To(a=>{const c=`Loading icon set URL: ${this._sanitizer.sanitize(Vt.RESOURCE_URL,o.url)} failed: ${a.message}`;return this._errorHandler.handleError(new Error(c)),Oe(null)})))).pipe(ze(()=>{const o=this._extractIconWithNameFromAnySet(e,r);if(!o)throw xW(e);return o}))}_extractIconWithNameFromAnySet(e,r){for(let s=r.length-1;s>=0;s--){const i=r[s];if(i.svgText&&i.svgText.toString().indexOf(e)>-1){const o=this._svgElementFromConfig(i),a=this._extractSvgIconFromSet(o,e,i.options);if(a)return a}}return null}_loadSvgIconFromConfig(e){return this._fetchIcon(e).pipe(tr(r=>e.svgText=r),ze(()=>this._svgElementFromConfig(e)))}_loadSvgIconSetFromConfig(e){return e.svgText?Oe(null):this._fetchIcon(e).pipe(tr(r=>e.svgText=r))}_extractSvgIconFromSet(e,r,s){const i=e.querySelector(`[id="${r}"]`);if(!i)return null;const o=i.cloneNode(!0);if(o.removeAttribute("id"),"svg"===o.nodeName.toLowerCase())return this._setSvgAttributes(o,s);if("symbol"===o.nodeName.toLowerCase())return this._setSvgAttributes(this._toSvgElement(o),s);const a=this._svgElementFromString(Dm("<svg></svg>"));return a.appendChild(o),this._setSvgAttributes(a,s)}_svgElementFromString(e){const r=this._document.createElement("DIV");r.innerHTML=e;const s=r.querySelector("svg");if(!s)throw Error("<svg> tag not found");return s}_toSvgElement(e){const r=this._svgElementFromString(Dm("<svg></svg>")),s=e.attributes;for(let i=0;i<s.length;i++){const{name:o,value:a}=s[i];"id"!==o&&r.setAttribute(o,a)}for(let i=0;i<e.childNodes.length;i++)e.childNodes[i].nodeType===this._document.ELEMENT_NODE&&r.appendChild(e.childNodes[i].cloneNode(!0));return r}_setSvgAttributes(e,r){return e.setAttribute("fit",""),e.setAttribute("height","100%"),e.setAttribute("width","100%"),e.setAttribute("preserveAspectRatio","xMidYMid meet"),e.setAttribute("focusable","false"),r&&r.viewBox&&e.setAttribute("viewBox",r.viewBox),e}_fetchIcon(e){const{url:r,options:s}=e,i=s?.withCredentials??!1;if(!this._httpClient)throw function hMe(){return Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.")}();if(null==r)throw Error(`Cannot fetch icon from URL "${r}".`);const o=this._sanitizer.sanitize(Vt.RESOURCE_URL,r);if(!o)throw wW(r);const a=this._inProgressUrlFetches.get(o);if(a)return a;const l=this._httpClient.get(o,{responseType:"text",withCredentials:i}).pipe(ze(c=>Dm(c)),_y(()=>this._inProgressUrlFetches.delete(o)),CN());return this._inProgressUrlFetches.set(o,l),l}_addSvgIconConfig(e,r,s){return this._svgIconConfigs.set(SW(e,r),s),this}_addSvgIconSetConfig(e,r){const s=this._iconSetConfigs.get(e);return s?s.push(r):this._iconSetConfigs.set(e,[r]),this}_svgElementFromConfig(e){if(!e.svgElement){const r=this._svgElementFromString(e.svgText);this._setSvgAttributes(r,e.options),e.svgElement=r}return e.svgElement}_getIconConfigFromResolvers(e,r){for(let s=0;s<this._resolvers.length;s++){const i=this._resolvers[s](r,e);if(i)return pMe(i)?new Bc(i.url,null,i.options):new Bc(i,null)}}}return n.\u0275fac=function(e){return new(e||n)(Z(ok,8),Z(HC),Z(vt,8),Z(sa))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function Kv(n){return n.cloneNode(!0)}function SW(n,t){return n+":"+t}function pMe(n){return!(!n.url||!n.options)}const mMe=V1(class{constructor(n){this._elementRef=n}}),gMe=new me("MAT_ICON_DEFAULT_OPTIONS"),yMe=new me("mat-icon-location",{providedIn:"root",factory:function bMe(){const n=Ot(vt),t=n?n.location:null;return{getPathname:()=>t?t.pathname+t.search:""}}}),EW=["clip-path","color-profile","src","cursor","fill","filter","marker","marker-start","marker-mid","marker-end","mask","stroke"],_Me=EW.map(n=>`[${n}]`).join(", "),vMe=/^url\(['"]?#(.*?)['"]?\)$/;let xMe=(()=>{class n extends mMe{constructor(e,r,s,i,o,a){super(e),this._iconRegistry=r,this._location=i,this._errorHandler=o,this._inline=!1,this._previousFontSetClass=[],this._currentIconFetch=He.EMPTY,a&&(a.color&&(this.color=this.defaultColor=a.color),a.fontSet&&(this.fontSet=a.fontSet)),s||e.nativeElement.setAttribute("aria-hidden","true")}get inline(){return this._inline}set inline(e){this._inline=Hi(e)}get svgIcon(){return this._svgIcon}set svgIcon(e){e!==this._svgIcon&&(e?this._updateSvgIcon(e):this._svgIcon&&this._clearSvgElement(),this._svgIcon=e)}get fontSet(){return this._fontSet}set fontSet(e){const r=this._cleanupFontValue(e);r!==this._fontSet&&(this._fontSet=r,this._updateFontIconClasses())}get fontIcon(){return this._fontIcon}set fontIcon(e){const r=this._cleanupFontValue(e);r!==this._fontIcon&&(this._fontIcon=r,this._updateFontIconClasses())}_splitIconName(e){if(!e)return["",""];const r=e.split(":");switch(r.length){case 1:return["",r[0]];case 2:return r;default:throw Error(`Invalid icon name: "${e}"`)}}ngOnInit(){this._updateFontIconClasses()}ngAfterViewChecked(){const e=this._elementsWithExternalReferences;if(e&&e.size){const r=this._location.getPathname();r!==this._previousPath&&(this._previousPath=r,this._prependPathToReferences(r))}}ngOnDestroy(){this._currentIconFetch.unsubscribe(),this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear()}_usingFontIcon(){return!this.svgIcon}_setSvgElement(e){this._clearSvgElement();const r=this._location.getPathname();this._previousPath=r,this._cacheChildrenWithExternalReferences(e),this._prependPathToReferences(r),this._elementRef.nativeElement.appendChild(e)}_clearSvgElement(){const e=this._elementRef.nativeElement;let r=e.childNodes.length;for(this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear();r--;){const s=e.childNodes[r];(1!==s.nodeType||"svg"===s.nodeName.toLowerCase())&&s.remove()}}_updateFontIconClasses(){if(!this._usingFontIcon())return;const e=this._elementRef.nativeElement,r=(this.fontSet?this._iconRegistry.classNameForFontAlias(this.fontSet).split(/ +/):this._iconRegistry.getDefaultFontSetClass()).filter(s=>s.length>0);this._previousFontSetClass.forEach(s=>e.classList.remove(s)),r.forEach(s=>e.classList.add(s)),this._previousFontSetClass=r,this.fontIcon!==this._previousFontIconClass&&!r.includes("mat-ligature-font")&&(this._previousFontIconClass&&e.classList.remove(this._previousFontIconClass),this.fontIcon&&e.classList.add(this.fontIcon),this._previousFontIconClass=this.fontIcon)}_cleanupFontValue(e){return"string"==typeof e?e.trim().split(" ")[0]:e}_prependPathToReferences(e){const r=this._elementsWithExternalReferences;r&&r.forEach((s,i)=>{s.forEach(o=>{i.setAttribute(o.name,`url('${e}#${o.value}')`)})})}_cacheChildrenWithExternalReferences(e){const r=e.querySelectorAll(_Me),s=this._elementsWithExternalReferences=this._elementsWithExternalReferences||new Map;for(let i=0;i<r.length;i++)EW.forEach(o=>{const a=r[i],l=a.getAttribute(o),c=l?l.match(vMe):null;if(c){let u=s.get(a);u||(u=[],s.set(a,u)),u.push({name:o,value:c[1]})}})}_updateSvgIcon(e){if(this._svgNamespace=null,this._svgName=null,this._currentIconFetch.unsubscribe(),e){const[r,s]=this._splitIconName(e);r&&(this._svgNamespace=r),s&&(this._svgName=s),this._currentIconFetch=this._iconRegistry.getNamedSvgIcon(s,r).pipe($r(1)).subscribe(i=>this._setSvgElement(i),i=>{this._errorHandler.handleError(new Error(`Error retrieving icon ${r}:${s}! ${i.message}`))})}}}return n.\u0275fac=function(e){return new(e||n)(H(hn),H(qv),au("aria-hidden"),H(yMe),H(sa),H(gMe,8))},n.\u0275cmp=is({type:n,selectors:[["mat-icon"]],hostAttrs:["role","img",1,"mat-icon","notranslate"],hostVars:8,hostBindings:function(e,r){2&e&&(yn("data-mat-icon-type",r._usingFontIcon()?"font":"svg")("data-mat-icon-name",r._svgName||r.fontIcon)("data-mat-icon-namespace",r._svgNamespace||r.fontSet)("fontIcon",r._usingFontIcon()?r.fontIcon:null),ds("mat-icon-inline",r.inline)("mat-icon-no-color","primary"!==r.color&&"accent"!==r.color&&"warn"!==r.color))},inputs:{color:"color",inline:"inline",svgIcon:"svgIcon",fontSet:"fontSet",fontIcon:"fontIcon"},exportAs:["matIcon"],features:[dt],ngContentSelectors:uMe,decls:1,vars:0,template:function(e,r){1&e&&(Jl(),Si(0))},styles:[".mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}"],encapsulation:2,changeDetection:0}),n})(),wMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({imports:[zr,zr]}),n})(),CMe=(()=>{class n{create(e){return typeof MutationObserver>"u"?null:new MutationObserver(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),SMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({providers:[CMe]}),n})(),AMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=$e({type:n}),n})();const RMe=new me("MatFormField");let MMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({imports:[zr,ic,SMe,zr]}),n})();class FMe{constructor(t=!1,e,r=!0,s){this._multiple=t,this._emitChanges=r,this.compareWith=s,this._selection=new Set,this._deselectedToEmit=[],this._selectedToEmit=[],this.changed=new kt,e&&e.length&&(t?e.forEach(i=>this._markSelected(i)):this._markSelected(e[0]),this._selectedToEmit.length=0)}get selected(){return this._selected||(this._selected=Array.from(this._selection.values())),this._selected}select(...t){this._verifyValueAssignment(t),t.forEach(r=>this._markSelected(r));const e=this._hasQueuedChanges();return this._emitChangeEvent(),e}deselect(...t){this._verifyValueAssignment(t),t.forEach(r=>this._unmarkSelected(r));const e=this._hasQueuedChanges();return this._emitChangeEvent(),e}setSelection(...t){this._verifyValueAssignment(t);const e=this.selected,r=new Set(t);t.forEach(i=>this._markSelected(i)),e.filter(i=>!r.has(i)).forEach(i=>this._unmarkSelected(i));const s=this._hasQueuedChanges();return this._emitChangeEvent(),s}toggle(t){return this.isSelected(t)?this.deselect(t):this.select(t)}clear(t=!0){this._unmarkAll();const e=this._hasQueuedChanges();return t&&this._emitChangeEvent(),e}isSelected(t){if(this.compareWith){for(const e of this._selection)if(this.compareWith(e,t))return!0;return!1}return this._selection.has(t)}isEmpty(){return 0===this._selection.size}hasValue(){return!this.isEmpty()}sort(t){this._multiple&&this.selected&&this._selected.sort(t)}isMultipleSelection(){return this._multiple}_emitChangeEvent(){this._selected=null,(this._selectedToEmit.length||this._deselectedToEmit.length)&&(this.changed.next({source:this,added:this._selectedToEmit,removed:this._deselectedToEmit}),this._deselectedToEmit=[],this._selectedToEmit=[])}_markSelected(t){this.isSelected(t)||(this._multiple||this._unmarkAll(),this.isSelected(t)||this._selection.add(t),this._emitChanges&&this._selectedToEmit.push(t))}_unmarkSelected(t){this.isSelected(t)&&(this._selection.delete(t),this._emitChanges&&this._deselectedToEmit.push(t))}_unmarkAll(){this.isEmpty()||this._selection.forEach(t=>this._unmarkSelected(t))}_verifyValueAssignment(t){}_hasQueuedChanges(){return!(!this._deselectedToEmit.length&&!this._selectedToEmit.length)}}let IW=(()=>{class n{constructor(e,r){this._renderer=e,this._elementRef=r,this.onChange=s=>{},this.onTouched=()=>{}}setProperty(e,r){this._renderer.setProperty(this._elementRef.nativeElement,e,r)}registerOnTouched(e){this.onTouched=e}registerOnChange(e){this.onChange=e}setDisabledState(e){this.setProperty("disabled",e)}}return n.\u0275fac=function(e){return new(e||n)(H(ra),H(hn))},n.\u0275dir=$e({type:n}),n})(),Vc=(()=>{class n extends IW{}return n.\u0275fac=function(){let t;return function(r){return(t||(t=hr(n)))(r||n)}}(),n.\u0275dir=$e({type:n,features:[dt]}),n})();const qo=new me("NgValueAccessor"),PMe={provide:qo,useExisting:cn(()=>lk),multi:!0},LMe=new me("CompositionEventMode");let lk=(()=>{class n extends IW{constructor(e,r,s){super(e,r),this._compositionMode=s,this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function $Me(){const n=Do()?Do().getUserAgent():"";return/android (\d+)/.test(n.toLowerCase())}())}writeValue(e){this.setProperty("value",e??"")}_handleInput(e){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(e)}_compositionStart(){this._composing=!0}_compositionEnd(e){this._composing=!1,this._compositionMode&&this.onChange(e)}}return n.\u0275fac=function(e){return new(e||n)(H(ra),H(hn),H(LMe,8))},n.\u0275dir=$e({type:n,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(e,r){1&e&&Ln("input",function(i){return r._handleInput(i.target.value)})("blur",function(){return r.onTouched()})("compositionstart",function(){return r._compositionStart()})("compositionend",function(i){return r._compositionEnd(i.target.value)})},features:[bn([PMe]),dt]}),n})();function Tl(n){return null==n||("string"==typeof n||Array.isArray(n))&&0===n.length}function TW(n){return null!=n&&"number"==typeof n.length}const ss=new me("NgValidators"),kl=new me("NgAsyncValidators"),VMe=/^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;class zMe{static min(t){return function kW(n){return t=>{if(Tl(t.value)||Tl(n))return null;const e=parseFloat(t.value);return!isNaN(e)&&e<n?{min:{min:n,actual:t.value}}:null}}(t)}static max(t){return function NW(n){return t=>{if(Tl(t.value)||Tl(n))return null;const e=parseFloat(t.value);return!isNaN(e)&&e>n?{max:{max:n,actual:t.value}}:null}}(t)}static required(t){return function AW(n){return Tl(n.value)?{required:!0}:null}(t)}static requiredTrue(t){return function RW(n){return!0===n.value?null:{required:!0}}(t)}static email(t){return function MW(n){return Tl(n.value)||VMe.test(n.value)?null:{email:!0}}(t)}static minLength(t){return function FW(n){return t=>Tl(t.value)||!TW(t.value)?null:t.value.length<n?{minlength:{requiredLength:n,actualLength:t.value.length}}:null}(t)}static maxLength(t){return function OW(n){return t=>TW(t.value)&&t.value.length>n?{maxlength:{requiredLength:n,actualLength:t.value.length}}:null}(t)}static pattern(t){return function PW(n){if(!n)return Xv;let t,e;return"string"==typeof n?(e="","^"!==n.charAt(0)&&(e+="^"),e+=n,"$"!==n.charAt(n.length-1)&&(e+="$"),t=new RegExp(e)):(e=n.toString(),t=n),r=>{if(Tl(r.value))return null;const s=r.value;return t.test(s)?null:{pattern:{requiredPattern:e,actualValue:s}}}}(t)}static nullValidator(t){return null}static compose(t){return UW(t)}static composeAsync(t){return HW(t)}}function Xv(n){return null}function $W(n){return null!=n}function LW(n){return Bh(n)?Pn(n):n}function BW(n){let t={};return n.forEach(e=>{t=null!=e?{...t,...e}:t}),0===Object.keys(t).length?null:t}function VW(n,t){return t.map(e=>e(n))}function zW(n){return n.map(t=>function UMe(n){return!n.validate}(t)?t:e=>t.validate(e))}function UW(n){if(!n)return null;const t=n.filter($W);return 0==t.length?null:function(e){return BW(VW(e,t))}}function ck(n){return null!=n?UW(zW(n)):null}function HW(n){if(!n)return null;const t=n.filter($W);return 0==t.length?null:function(e){return lW(VW(e,t).map(LW)).pipe(ze(BW))}}function uk(n){return null!=n?HW(zW(n)):null}function WW(n,t){return null===n?[t]:Array.isArray(n)?[...n,t]:[n,t]}function jW(n){return n._rawValidators}function GW(n){return n._rawAsyncValidators}function dk(n){return n?Array.isArray(n)?n:[n]:[]}function Yv(n,t){return Array.isArray(n)?n.includes(t):n===t}function qW(n,t){const e=dk(t);return dk(n).forEach(s=>{Yv(e,s)||e.push(s)}),e}function KW(n,t){return dk(t).filter(e=>!Yv(n,e))}class XW{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(t){this._rawValidators=t||[],this._composedValidatorFn=ck(this._rawValidators)}_setAsyncValidators(t){this._rawAsyncValidators=t||[],this._composedAsyncValidatorFn=uk(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(t){this._onDestroyCallbacks.push(t)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(t=>t()),this._onDestroyCallbacks=[]}reset(t){this.control&&this.control.reset(t)}hasError(t,e){return!!this.control&&this.control.hasError(t,e)}getError(t,e){return this.control?this.control.getError(t,e):null}}class ws extends XW{get formDirective(){return null}get path(){return null}}class Na extends XW{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}class YW{constructor(t){this._cd=t}get isTouched(){return!!this._cd?.control?.touched}get isUntouched(){return!!this._cd?.control?.untouched}get isPristine(){return!!this._cd?.control?.pristine}get isDirty(){return!!this._cd?.control?.dirty}get isValid(){return!!this._cd?.control?.valid}get isInvalid(){return!!this._cd?.control?.invalid}get isPending(){return!!this._cd?.control?.pending}get isSubmitted(){return!!this._cd?.submitted}}let ZW=(()=>{class n extends YW{constructor(e){super(e)}}return n.\u0275fac=function(e){return new(e||n)(H(Na,2))},n.\u0275dir=$e({type:n,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(e,r){2&e&&ds("ng-untouched",r.isUntouched)("ng-touched",r.isTouched)("ng-pristine",r.isPristine)("ng-dirty",r.isDirty)("ng-valid",r.isValid)("ng-invalid",r.isInvalid)("ng-pending",r.isPending)},features:[dt]}),n})();const Tm="VALID",Qv="INVALID",eh="PENDING",km="DISABLED";function mk(n){return(Jv(n)?n.validators:n)||null}function gk(n,t){return(Jv(t)?t.asyncValidators:n)||null}function Jv(n){return null!=n&&!Array.isArray(n)&&"object"==typeof n}class tj{constructor(t,e){this._pendingDirty=!1,this._hasOwnPendingAsyncValidator=!1,this._pendingTouched=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._assignValidators(t),this._assignAsyncValidators(e)}get validator(){return this._composedValidatorFn}set validator(t){this._rawValidators=this._composedValidatorFn=t}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(t){this._rawAsyncValidators=this._composedAsyncValidatorFn=t}get parent(){return this._parent}get valid(){return this.status===Tm}get invalid(){return this.status===Qv}get pending(){return this.status==eh}get disabled(){return this.status===km}get enabled(){return this.status!==km}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(t){this._assignValidators(t)}setAsyncValidators(t){this._assignAsyncValidators(t)}addValidators(t){this.setValidators(qW(t,this._rawValidators))}addAsyncValidators(t){this.setAsyncValidators(qW(t,this._rawAsyncValidators))}removeValidators(t){this.setValidators(KW(t,this._rawValidators))}removeAsyncValidators(t){this.setAsyncValidators(KW(t,this._rawAsyncValidators))}hasValidator(t){return Yv(this._rawValidators,t)}hasAsyncValidator(t){return Yv(this._rawAsyncValidators,t)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(t={}){this.touched=!0,this._parent&&!t.onlySelf&&this._parent.markAsTouched(t)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(t=>t.markAllAsTouched())}markAsUntouched(t={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(e=>{e.markAsUntouched({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}markAsDirty(t={}){this.pristine=!1,this._parent&&!t.onlySelf&&this._parent.markAsDirty(t)}markAsPristine(t={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(e=>{e.markAsPristine({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}markAsPending(t={}){this.status=eh,!1!==t.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!t.onlySelf&&this._parent.markAsPending(t)}disable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=km,this.errors=null,this._forEachChild(r=>{r.disable({...t,onlySelf:!0})}),this._updateValue(),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors({...t,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!0))}enable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=Tm,this._forEachChild(r=>{r.enable({...t,onlySelf:!0})}),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent}),this._updateAncestors({...t,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!1))}_updateAncestors(t){this._parent&&!t.onlySelf&&(this._parent.updateValueAndValidity(t),t.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(t){this._parent=t}getRawValue(){return this.value}updateValueAndValidity(t={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),(this.status===Tm||this.status===eh)&&this._runAsyncValidator(t.emitEvent)),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!t.onlySelf&&this._parent.updateValueAndValidity(t)}_updateTreeValidity(t={emitEvent:!0}){this._forEachChild(e=>e._updateTreeValidity(t)),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?km:Tm}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(t){if(this.asyncValidator){this.status=eh,this._hasOwnPendingAsyncValidator=!0;const e=LW(this.asyncValidator(this));this._asyncValidationSubscription=e.subscribe(r=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(r,{emitEvent:t})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(t,e={}){this.errors=t,this._updateControlsErrors(!1!==e.emitEvent)}get(t){let e=t;return null==e||(Array.isArray(e)||(e=e.split(".")),0===e.length)?null:e.reduce((r,s)=>r&&r._find(s),this)}getError(t,e){const r=e?this.get(e):this;return r&&r.errors?r.errors[t]:null}hasError(t,e){return!!this.getError(t,e)}get root(){let t=this;for(;t._parent;)t=t._parent;return t}_updateControlsErrors(t){this.status=this._calculateStatus(),t&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(t)}_initObservables(){this.valueChanges=new Rt,this.statusChanges=new Rt}_calculateStatus(){return this._allControlsDisabled()?km:this.errors?Qv:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(eh)?eh:this._anyControlsHaveStatus(Qv)?Qv:Tm}_anyControlsHaveStatus(t){return this._anyControls(e=>e.status===t)}_anyControlsDirty(){return this._anyControls(t=>t.dirty)}_anyControlsTouched(){return this._anyControls(t=>t.touched)}_updatePristine(t={}){this.pristine=!this._anyControlsDirty(),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}_updateTouched(t={}){this.touched=this._anyControlsTouched(),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}_registerOnCollectionChange(t){this._onCollectionChange=t}_setUpdateStrategy(t){Jv(t)&&null!=t.updateOn&&(this._updateOn=t.updateOn)}_parentMarkedDirty(t){return!t&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}_find(t){return null}_assignValidators(t){this._rawValidators=Array.isArray(t)?t.slice():t,this._composedValidatorFn=function YMe(n){return Array.isArray(n)?ck(n):n||null}(this._rawValidators)}_assignAsyncValidators(t){this._rawAsyncValidators=Array.isArray(t)?t.slice():t,this._composedAsyncValidatorFn=function ZMe(n){return Array.isArray(n)?uk(n):n||null}(this._rawAsyncValidators)}}class yk extends tj{constructor(t,e,r){super(mk(e),gk(r,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}registerControl(t,e){return this.controls[t]?this.controls[t]:(this.controls[t]=e,e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange),e)}addControl(t,e,r={}){this.registerControl(t,e),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}removeControl(t,e={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],this.updateValueAndValidity({emitEvent:e.emitEvent}),this._onCollectionChange()}setControl(t,e,r={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],e&&this.registerControl(t,e),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}contains(t){return this.controls.hasOwnProperty(t)&&this.controls[t].enabled}setValue(t,e={}){(function ej(n,t,e){n._forEachChild((r,s)=>{if(void 0===e[s])throw new te(1002,"")})})(this,0,t),Object.keys(t).forEach(r=>{(function JW(n,t,e){const r=n.controls;if(!(t?Object.keys(r):r).length)throw new te(1e3,"");if(!r[e])throw new te(1001,"")})(this,!0,r),this.controls[r].setValue(t[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){null!=t&&(Object.keys(t).forEach(r=>{const s=this.controls[r];s&&s.patchValue(t[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(t={},e={}){this._forEachChild((r,s)=>{r.reset(t[s],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this._reduceChildren({},(t,e,r)=>(t[r]=e.getRawValue(),t))}_syncPendingControls(){let t=this._reduceChildren(!1,(e,r)=>!!r._syncPendingControls()||e);return t&&this.updateValueAndValidity({onlySelf:!0}),t}_forEachChild(t){Object.keys(this.controls).forEach(e=>{const r=this.controls[e];r&&t(r,e)})}_setUpControls(){this._forEachChild(t=>{t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(t){for(const[e,r]of Object.entries(this.controls))if(this.contains(e)&&t(r))return!0;return!1}_reduceValue(){return this._reduceChildren({},(e,r,s)=>((r.enabled||this.disabled)&&(e[s]=r.value),e))}_reduceChildren(t,e){let r=t;return this._forEachChild((s,i)=>{r=e(r,s,i)}),r}_allControlsDisabled(){for(const t of Object.keys(this.controls))if(this.controls[t].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_find(t){return this.controls.hasOwnProperty(t)?this.controls[t]:null}}const th=new me("CallSetDisabledState",{providedIn:"root",factory:()=>ex}),ex="always";function Nm(n,t,e=ex){bk(n,t),t.valueAccessor.writeValue(n.value),(n.disabled||"always"===e)&&t.valueAccessor.setDisabledState?.(n.disabled),function eFe(n,t){t.valueAccessor.registerOnChange(e=>{n._pendingValue=e,n._pendingChange=!0,n._pendingDirty=!0,"change"===n.updateOn&&nj(n,t)})}(n,t),function nFe(n,t){const e=(r,s)=>{t.valueAccessor.writeValue(r),s&&t.viewToModelUpdate(r)};n.registerOnChange(e),t._registerOnDestroy(()=>{n._unregisterOnChange(e)})}(n,t),function tFe(n,t){t.valueAccessor.registerOnTouched(()=>{n._pendingTouched=!0,"blur"===n.updateOn&&n._pendingChange&&nj(n,t),"submit"!==n.updateOn&&n.markAsTouched()})}(n,t),function JMe(n,t){if(t.valueAccessor.setDisabledState){const e=r=>{t.valueAccessor.setDisabledState(r)};n.registerOnDisabledChange(e),t._registerOnDestroy(()=>{n._unregisterOnDisabledChange(e)})}}(n,t)}function nx(n,t,e=!0){const r=()=>{};t.valueAccessor&&(t.valueAccessor.registerOnChange(r),t.valueAccessor.registerOnTouched(r)),sx(n,t),n&&(t._invokeOnDestroyCallbacks(),n._registerOnCollectionChange(()=>{}))}function rx(n,t){n.forEach(e=>{e.registerOnValidatorChange&&e.registerOnValidatorChange(t)})}function bk(n,t){const e=jW(n);null!==t.validator?n.setValidators(WW(e,t.validator)):"function"==typeof e&&n.setValidators([e]);const r=GW(n);null!==t.asyncValidator?n.setAsyncValidators(WW(r,t.asyncValidator)):"function"==typeof r&&n.setAsyncValidators([r]);const s=()=>n.updateValueAndValidity();rx(t._rawValidators,s),rx(t._rawAsyncValidators,s)}function sx(n,t){let e=!1;if(null!==n){if(null!==t.validator){const s=jW(n);if(Array.isArray(s)&&s.length>0){const i=s.filter(o=>o!==t.validator);i.length!==s.length&&(e=!0,n.setValidators(i))}}if(null!==t.asyncValidator){const s=GW(n);if(Array.isArray(s)&&s.length>0){const i=s.filter(o=>o!==t.asyncValidator);i.length!==s.length&&(e=!0,n.setAsyncValidators(i))}}}const r=()=>{};return rx(t._rawValidators,r),rx(t._rawAsyncValidators,r),e}function nj(n,t){n._pendingDirty&&n.markAsDirty(),n.setValue(n._pendingValue,{emitModelToViewChange:!1}),t.viewToModelUpdate(n._pendingValue),n._pendingChange=!1}function rj(n,t){bk(n,t)}function sj(n,t){n._syncPendingControls(),t.forEach(e=>{const r=e.control;"submit"===r.updateOn&&r._pendingChange&&(e.viewToModelUpdate(r._pendingValue),r._pendingChange=!1)})}const aFe={provide:ws,useExisting:cn(()=>ix)},Am=(()=>Promise.resolve())();let ix=(()=>{class n extends ws{constructor(e,r,s){super(),this.callSetDisabledState=s,this.submitted=!1,this._directives=new Set,this.ngSubmit=new Rt,this.form=new yk({},ck(e),uk(r))}ngAfterViewInit(){this._setUpdateStrategy()}get formDirective(){return this}get control(){return this.form}get path(){return[]}get controls(){return this.form.controls}addControl(e){Am.then(()=>{const r=this._findContainer(e.path);e.control=r.registerControl(e.name,e.control),Nm(e.control,e,this.callSetDisabledState),e.control.updateValueAndValidity({emitEvent:!1}),this._directives.add(e)})}getControl(e){return this.form.get(e.path)}removeControl(e){Am.then(()=>{const r=this._findContainer(e.path);r&&r.removeControl(e.name),this._directives.delete(e)})}addFormGroup(e){Am.then(()=>{const r=this._findContainer(e.path),s=new yk({});rj(s,e),r.registerControl(e.name,s),s.updateValueAndValidity({emitEvent:!1})})}removeFormGroup(e){Am.then(()=>{const r=this._findContainer(e.path);r&&r.removeControl(e.name)})}getFormGroup(e){return this.form.get(e.path)}updateModel(e,r){Am.then(()=>{this.form.get(e.path).setValue(r)})}setValue(e){this.control.setValue(e)}onSubmit(e){return this.submitted=!0,sj(this.form,this._directives),this.ngSubmit.emit(e),"dialog"===e?.target?.method}onReset(){this.resetForm()}resetForm(e){this.form.reset(e),this.submitted=!1}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.form._updateOn=this.options.updateOn)}_findContainer(e){return e.pop(),e.length?this.form.get(e):this.form}}return n.\u0275fac=function(e){return new(e||n)(H(ss,10),H(kl,10),H(th,8))},n.\u0275dir=$e({type:n,selectors:[["form",3,"ngNoForm","",3,"formGroup",""],["ng-form"],["","ngForm",""]],hostBindings:function(e,r){1&e&&Ln("submit",function(i){return r.onSubmit(i)})("reset",function(){return r.onReset()})},inputs:{options:["ngFormOptions","options"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[bn([aFe]),dt]}),n})();function ij(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}function oj(n){return"object"==typeof n&&null!==n&&2===Object.keys(n).length&&"value"in n&&"disabled"in n}const aj=class extends tj{constructor(t=null,e,r){super(mk(e),gk(r,e)),this.defaultValue=null,this._onChange=[],this._pendingChange=!1,this._applyFormState(t),this._setUpdateStrategy(e),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator}),Jv(e)&&(e.nonNullable||e.initialValueIsDefault)&&(this.defaultValue=oj(t)?t.value:t)}setValue(t,e={}){this.value=this._pendingValue=t,this._onChange.length&&!1!==e.emitModelToViewChange&&this._onChange.forEach(r=>r(this.value,!1!==e.emitViewToModelChange)),this.updateValueAndValidity(e)}patchValue(t,e={}){this.setValue(t,e)}reset(t=this.defaultValue,e={}){this._applyFormState(t),this.markAsPristine(e),this.markAsUntouched(e),this.setValue(this.value,e),this._pendingChange=!1}_updateValue(){}_anyControls(t){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(t){this._onChange.push(t)}_unregisterOnChange(t){ij(this._onChange,t)}registerOnDisabledChange(t){this._onDisabledChange.push(t)}_unregisterOnDisabledChange(t){ij(this._onDisabledChange,t)}_forEachChild(t){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(t){oj(t)?(this.value=this._pendingValue=t.value,t.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=t}},uFe={provide:Na,useExisting:cn(()=>wk)},uj=(()=>Promise.resolve())();let wk=(()=>{class n extends Na{constructor(e,r,s,i,o,a){super(),this._changeDetectorRef=o,this.callSetDisabledState=a,this.control=new aj,this._registered=!1,this.update=new Rt,this._parent=e,this._setValidators(r),this._setAsyncValidators(s),this.valueAccessor=function xk(n,t){if(!t)return null;let e,r,s;return Array.isArray(t),t.forEach(i=>{i.constructor===lk?e=i:function iFe(n){return Object.getPrototypeOf(n.constructor)===Vc}(i)?r=i:s=i}),s||r||e||null}(0,i)}ngOnChanges(e){if(this._checkForErrors(),!this._registered||"name"in e){if(this._registered&&(this._checkName(),this.formDirective)){const r=e.name.previousValue;this.formDirective.removeControl({name:r,path:this._getPath(r)})}this._setUpControl()}"isDisabled"in e&&this._updateDisabled(e),function vk(n,t){if(!n.hasOwnProperty("model"))return!1;const e=n.model;return!!e.isFirstChange()||!Object.is(t,e.currentValue)}(e,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._getPath(this.name)}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){Nm(this.control,this,this.callSetDisabledState),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()}_updateValue(e){uj.then(()=>{this.control.setValue(e,{emitViewToModelChange:!1}),this._changeDetectorRef?.markForCheck()})}_updateDisabled(e){const r=e.isDisabled.currentValue,s=0!==r&&function $u(n){return"boolean"==typeof n?n:null!=n&&"false"!==n}(r);uj.then(()=>{s&&!this.control.disabled?this.control.disable():!s&&this.control.disabled&&this.control.enable(),this._changeDetectorRef?.markForCheck()})}_getPath(e){return this._parent?function tx(n,t){return[...t.path,n]}(e,this._parent):[e]}}return n.\u0275fac=function(e){return new(e||n)(H(ws,9),H(ss,10),H(kl,10),H(qo,10),H(nc,8),H(th,8))},n.\u0275dir=$e({type:n,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:["disabled","isDisabled"],model:["ngModel","model"],options:["ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],features:[bn([uFe]),dt,Is]}),n})(),hj=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({}),n})();const Ck=new me("NgModelWithFormControlWarning"),yFe={provide:ws,useExisting:cn(()=>ox)};let ox=(()=>{class n extends ws{constructor(e,r,s){super(),this.callSetDisabledState=s,this.submitted=!1,this._onCollectionChange=()=>this._updateDomValue(),this.directives=[],this.form=null,this.ngSubmit=new Rt,this._setValidators(e),this._setAsyncValidators(r)}ngOnChanges(e){this._checkFormPresent(),e.hasOwnProperty("form")&&(this._updateValidators(),this._updateDomValue(),this._updateRegistrations(),this._oldForm=this.form)}ngOnDestroy(){this.form&&(sx(this.form,this),this.form._onCollectionChange===this._onCollectionChange&&this.form._registerOnCollectionChange(()=>{}))}get formDirective(){return this}get control(){return this.form}get path(){return[]}addControl(e){const r=this.form.get(e.path);return Nm(r,e,this.callSetDisabledState),r.updateValueAndValidity({emitEvent:!1}),this.directives.push(e),r}getControl(e){return this.form.get(e.path)}removeControl(e){nx(e.control||null,e,!1),function oFe(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}(this.directives,e)}addFormGroup(e){this._setUpFormContainer(e)}removeFormGroup(e){this._cleanUpFormContainer(e)}getFormGroup(e){return this.form.get(e.path)}addFormArray(e){this._setUpFormContainer(e)}removeFormArray(e){this._cleanUpFormContainer(e)}getFormArray(e){return this.form.get(e.path)}updateModel(e,r){this.form.get(e.path).setValue(r)}onSubmit(e){return this.submitted=!0,sj(this.form,this.directives),this.ngSubmit.emit(e),"dialog"===e?.target?.method}onReset(){this.resetForm()}resetForm(e){this.form.reset(e),this.submitted=!1}_updateDomValue(){this.directives.forEach(e=>{const r=e.control,s=this.form.get(e.path);r!==s&&(nx(r||null,e),(n=>n instanceof aj)(s)&&(Nm(s,e,this.callSetDisabledState),e.control=s))}),this.form._updateTreeValidity({emitEvent:!1})}_setUpFormContainer(e){const r=this.form.get(e.path);rj(r,e),r.updateValueAndValidity({emitEvent:!1})}_cleanUpFormContainer(e){if(this.form){const r=this.form.get(e.path);r&&function rFe(n,t){return sx(n,t)}(r,e)&&r.updateValueAndValidity({emitEvent:!1})}}_updateRegistrations(){this.form._registerOnCollectionChange(this._onCollectionChange),this._oldForm&&this._oldForm._registerOnCollectionChange(()=>{})}_updateValidators(){bk(this.form,this),this._oldForm&&sx(this._oldForm,this)}_checkFormPresent(){}}return n.\u0275fac=function(e){return new(e||n)(H(ss,10),H(kl,10),H(th,8))},n.\u0275dir=$e({type:n,selectors:[["","formGroup",""]],hostBindings:function(e,r){1&e&&Ln("submit",function(i){return r.onSubmit(i)})("reset",function(){return r.onReset()})},inputs:{form:["formGroup","form"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[bn([yFe]),dt,Is]}),n})(),kj=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({imports:[hj]}),n})(),OFe=(()=>{class n{static withConfig(e){return{ngModule:n,providers:[{provide:th,useValue:e.callSetDisabledState??ex}]}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({imports:[kj]}),n})(),PFe=(()=>{class n{static withConfig(e){return{ngModule:n,providers:[{provide:Ck,useValue:e.warnOnNgModelWithFormControl??"always"},{provide:th,useValue:e.callSetDisabledState??ex}]}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({imports:[kj]}),n})();const LFe=["trigger"],BFe=["panel"];function VFe(n,t){if(1&n&&(Lt(0,"span",10),la(1),Qt()),2&n){const e=ei();Pt(1),Uh(e.placeholder)}}function zFe(n,t){if(1&n&&(Lt(0,"span",14),la(1),Qt()),2&n){const e=ei(2);Pt(1),Uh(e.triggerValue)}}function UFe(n,t){1&n&&Si(0,0,["*ngSwitchCase","true"])}function HFe(n,t){1&n&&(Lt(0,"span",11),us(1,zFe,2,1,"span",12),us(2,UFe,1,0,"ng-content",13),Qt()),2&n&&(Gt("ngSwitch",!!ei().customTrigger),Pt(2),Gt("ngSwitchCase",!0))}function WFe(n,t){if(1&n){const e=Lh();mh(),l0(),Lt(0,"div",15,16),Ln("@transformPanel.done",function(s){return eu(e),tu(ei()._panelDoneAnimatingStream.next(s.toState))})("keydown",function(s){return eu(e),tu(ei()._handleKeydown(s))}),Si(2,1),Qt()}if(2&n){const e=ei();oF("mat-mdc-select-panel mdc-menu-surface mdc-menu-surface--open ",e._getPanelTheme(),""),Gt("ngClass",e.panelClass)("@transformPanel","showing"),yn("id",e.id+"-panel")("aria-multiselectable",e.multiple)("aria-label",e.ariaLabel||null)("aria-labelledby",e._getPanelAriaLabelledby())}}const jFe=[[["mat-select-trigger"]],"*"],GFe=["mat-select-trigger","*"],qFe={transformPanelWrap:Yd("transformPanelWrap",[ka("* => void",OAe("@transformPanel",[FAe()],{optional:!0}))]),transformPanel:Yd("transformPanel",[Zd("void",xs({opacity:0,transform:"scale(1, 0.8)"})),ka("void => showing",El("120ms cubic-bezier(0, 0, 0.2, 1)",xs({opacity:1,transform:"scale(1, 1)"}))),ka("* => void",El("100ms linear",xs({opacity:0})))])};let Nj=0;const Aj=new me("mat-select-scroll-strategy"),XFe=new me("MAT_SELECT_CONFIG"),YFe={provide:Aj,deps:[Lc],useFactory:function KFe(n){return()=>n.scrollStrategies.reposition()}},ZFe=new me("MatSelectTrigger");class QFe{constructor(t,e){this.source=t,this.value=e}}const JFe=SH(sAe(CH(iAe(class{constructor(n,t,e,r,s){this._elementRef=n,this._defaultErrorStateMatcher=t,this._parentForm=e,this._parentFormGroup=r,this.ngControl=s,this.stateChanges=new kt}}))));let eOe=(()=>{class n extends JFe{constructor(e,r,s,i,o,a,l,c,u,d,h,f,p,m){super(o,i,l,c,d),this._viewportRuler=e,this._changeDetectorRef=r,this._ngZone=s,this._dir=a,this._parentFormField=u,this._liveAnnouncer=p,this._defaultOptions=m,this._panelOpen=!1,this._compareWith=(g,y)=>g===y,this._uid="mat-select-"+Nj++,this._triggerAriaLabelledBy=null,this._destroy=new kt,this._onChange=()=>{},this._onTouched=()=>{},this._valueId="mat-select-value-"+Nj++,this._panelDoneAnimatingStream=new kt,this._overlayPanelClass=this._defaultOptions?.overlayPanelClass||"",this._focused=!1,this.controlType="mat-select",this._multiple=!1,this._disableOptionCentering=this._defaultOptions?.disableOptionCentering??!1,this.ariaLabel="",this.optionSelectionChanges=gy(()=>{const g=this.options;return g?g.changes.pipe(yy(g),ni(()=>ih(...g.map(y=>y.onSelectionChange)))):this._ngZone.onStable.pipe($r(1),ni(()=>this.optionSelectionChanges))}),this.openedChange=new Rt,this._openedStream=this.openedChange.pipe(As(g=>g),ze(()=>{})),this._closedStream=this.openedChange.pipe(As(g=>!g),ze(()=>{})),this.selectionChange=new Rt,this.valueChange=new Rt,this.ngControl&&(this.ngControl.valueAccessor=this),null!=m?.typeaheadDebounceInterval&&(this._typeaheadDebounceInterval=m.typeaheadDebounceInterval),this._scrollStrategyFactory=f,this._scrollStrategy=this._scrollStrategyFactory(),this.tabIndex=parseInt(h)||0,this.id=this.id}get focused(){return this._focused||this._panelOpen}get placeholder(){return this._placeholder}set placeholder(e){this._placeholder=e,this.stateChanges.next()}get required(){return this._required??this.ngControl?.control?.hasValidator(zMe.required)??!1}set required(e){this._required=Hi(e),this.stateChanges.next()}get multiple(){return this._multiple}set multiple(e){this._multiple=Hi(e)}get disableOptionCentering(){return this._disableOptionCentering}set disableOptionCentering(e){this._disableOptionCentering=Hi(e)}get compareWith(){return this._compareWith}set compareWith(e){this._compareWith=e,this._selectionModel&&this._initializeSelection()}get value(){return this._value}set value(e){this._assignValue(e)&&this._onChange(e)}get typeaheadDebounceInterval(){return this._typeaheadDebounceInterval}set typeaheadDebounceInterval(e){this._typeaheadDebounceInterval=vm(e)}get id(){return this._id}set id(e){this._id=e||this._uid,this.stateChanges.next()}ngOnInit(){this._selectionModel=new FMe(this.multiple),this.stateChanges.next(),this._panelDoneAnimatingStream.pipe(uH(),Go(this._destroy)).subscribe(()=>this._panelDoneAnimating(this.panelOpen))}ngAfterContentInit(){this._initKeyManager(),this._selectionModel.changed.pipe(Go(this._destroy)).subscribe(e=>{e.added.forEach(r=>r.select()),e.removed.forEach(r=>r.deselect())}),this.options.changes.pipe(yy(null),Go(this._destroy)).subscribe(()=>{this._resetOptions(),this._initializeSelection()})}ngDoCheck(){const e=this._getTriggerAriaLabelledby(),r=this.ngControl;if(e!==this._triggerAriaLabelledBy){const s=this._elementRef.nativeElement;this._triggerAriaLabelledBy=e,e?s.setAttribute("aria-labelledby",e):s.removeAttribute("aria-labelledby")}r&&(this._previousControl!==r.control&&(void 0!==this._previousControl&&null!==r.disabled&&r.disabled!==this.disabled&&(this.disabled=r.disabled),this._previousControl=r.control),this.updateErrorState())}ngOnChanges(e){(e.disabled||e.userAriaDescribedBy)&&this.stateChanges.next(),e.typeaheadDebounceInterval&&this._keyManager&&this._keyManager.withTypeAhead(this._typeaheadDebounceInterval)}ngOnDestroy(){this._keyManager?.destroy(),this._destroy.next(),this._destroy.complete(),this.stateChanges.complete()}toggle(){this.panelOpen?this.close():this.open()}open(){this._canOpen()&&(this._panelOpen=!0,this._keyManager.withHorizontalOrientation(null),this._highlightCorrectOption(),this._changeDetectorRef.markForCheck())}close(){this._panelOpen&&(this._panelOpen=!1,this._keyManager.withHorizontalOrientation(this._isRtl()?"rtl":"ltr"),this._changeDetectorRef.markForCheck(),this._onTouched())}writeValue(e){this._assignValue(e)}registerOnChange(e){this._onChange=e}registerOnTouched(e){this._onTouched=e}setDisabledState(e){this.disabled=e,this._changeDetectorRef.markForCheck(),this.stateChanges.next()}get panelOpen(){return this._panelOpen}get selected(){return this.multiple?this._selectionModel?.selected||[]:this._selectionModel?.selected[0]}get triggerValue(){if(this.empty)return"";if(this._multiple){const e=this._selectionModel.selected.map(r=>r.viewValue);return this._isRtl()&&e.reverse(),e.join(", ")}return this._selectionModel.selected[0].viewValue}_isRtl(){return!!this._dir&&"rtl"===this._dir.value}_handleKeydown(e){this.disabled||(this.panelOpen?this._handleOpenKeydown(e):this._handleClosedKeydown(e))}_handleClosedKeydown(e){const r=e.keyCode,s=40===r||38===r||37===r||39===r,i=13===r||32===r,o=this._keyManager;if(!o.isTyping()&&i&&!bm(e)||(this.multiple||e.altKey)&&s)e.preventDefault(),this.open();else if(!this.multiple){const a=this.selected;o.onKeydown(e);const l=this.selected;l&&a!==l&&this._liveAnnouncer.announce(l.viewValue,1e4)}}_handleOpenKeydown(e){const r=this._keyManager,s=e.keyCode,i=40===s||38===s,o=r.isTyping();if(i&&e.altKey)e.preventDefault(),this.close();else if(o||13!==s&&32!==s||!r.activeItem||bm(e))if(!o&&this._multiple&&65===s&&e.ctrlKey){e.preventDefault();const a=this.options.some(l=>!l.disabled&&!l.selected);this.options.forEach(l=>{l.disabled||(a?l.select():l.deselect())})}else{const a=r.activeItemIndex;r.onKeydown(e),this._multiple&&i&&e.shiftKey&&r.activeItem&&r.activeItemIndex!==a&&r.activeItem._selectViaInteraction()}else e.preventDefault(),r.activeItem._selectViaInteraction()}_onFocus(){this.disabled||(this._focused=!0,this.stateChanges.next())}_onBlur(){this._focused=!1,this._keyManager?.cancelTypeahead(),!this.disabled&&!this.panelOpen&&(this._onTouched(),this._changeDetectorRef.markForCheck(),this.stateChanges.next())}_onAttached(){this._overlayDir.positionChange.pipe($r(1)).subscribe(()=>{this._changeDetectorRef.detectChanges(),this._positioningSettled()})}_getPanelTheme(){return this._parentFormField?`mat-${this._parentFormField.color}`:""}get empty(){return!this._selectionModel||this._selectionModel.isEmpty()}_initializeSelection(){Promise.resolve().then(()=>{this.ngControl&&(this._value=this.ngControl.value),this._setSelectionByValue(this._value),this.stateChanges.next()})}_setSelectionByValue(e){if(this._selectionModel.selected.forEach(r=>r.setInactiveStyles()),this._selectionModel.clear(),this.multiple&&e)Array.isArray(e),e.forEach(r=>this._selectOptionByValue(r)),this._sortValues();else{const r=this._selectOptionByValue(e);r?this._keyManager.updateActiveItem(r):this.panelOpen||this._keyManager.updateActiveItem(-1)}this._changeDetectorRef.markForCheck()}_selectOptionByValue(e){const r=this.options.find(s=>{if(this._selectionModel.isSelected(s))return!1;try{return null!=s.value&&this._compareWith(s.value,e)}catch{return!1}});return r&&this._selectionModel.select(r),r}_assignValue(e){return!!(e!==this._value||this._multiple&&Array.isArray(e))&&(this.options&&this._setSelectionByValue(e),this._value=e,!0)}_initKeyManager(){this._keyManager=new FNe(this.options).withTypeAhead(this._typeaheadDebounceInterval).withVerticalOrientation().withHorizontalOrientation(this._isRtl()?"rtl":"ltr").withHomeAndEnd().withPageUpDown().withAllowedModifierKeys(["shiftKey"]),this._keyManager.tabOut.subscribe(()=>{this.panelOpen&&(!this.multiple&&this._keyManager.activeItem&&this._keyManager.activeItem._selectViaInteraction(),this.focus(),this.close())}),this._keyManager.change.subscribe(()=>{this._panelOpen&&this.panel?this._scrollOptionIntoView(this._keyManager.activeItemIndex||0):!this._panelOpen&&!this.multiple&&this._keyManager.activeItem&&this._keyManager.activeItem._selectViaInteraction()})}_resetOptions(){const e=ih(this.options.changes,this._destroy);this.optionSelectionChanges.pipe(Go(e)).subscribe(r=>{this._onSelect(r.source,r.isUserInput),r.isUserInput&&!this.multiple&&this._panelOpen&&(this.close(),this.focus())}),ih(...this.options.map(r=>r._stateChanges)).pipe(Go(e)).subscribe(()=>{this._changeDetectorRef.markForCheck(),this.stateChanges.next()})}_onSelect(e,r){const s=this._selectionModel.isSelected(e);null!=e.value||this._multiple?(s!==e.selected&&(e.selected?this._selectionModel.select(e):this._selectionModel.deselect(e)),r&&this._keyManager.setActiveItem(e),this.multiple&&(this._sortValues(),r&&this.focus())):(e.deselect(),this._selectionModel.clear(),null!=this.value&&this._propagateChanges(e.value)),s!==this._selectionModel.isSelected(e)&&this._propagateChanges(),this.stateChanges.next()}_sortValues(){if(this.multiple){const e=this.options.toArray();this._selectionModel.sort((r,s)=>this.sortComparator?this.sortComparator(r,s,e):e.indexOf(r)-e.indexOf(s)),this.stateChanges.next()}}_propagateChanges(e){let r=null;r=this.multiple?this.selected.map(s=>s.value):this.selected?this.selected.value:e,this._value=r,this.valueChange.emit(r),this._onChange(r),this.selectionChange.emit(this._getChangeEvent(r)),this._changeDetectorRef.markForCheck()}_highlightCorrectOption(){this._keyManager&&(this.empty?this._keyManager.setFirstItemActive():this._keyManager.setActiveItem(this._selectionModel.selected[0]))}_canOpen(){return!this._panelOpen&&!this.disabled&&this.options?.length>0}focus(e){this._elementRef.nativeElement.focus(e)}_getPanelAriaLabelledby(){if(this.ariaLabel)return null;const e=this._parentFormField?.getLabelId();return this.ariaLabelledby?(e?e+" ":"")+this.ariaLabelledby:e}_getAriaActiveDescendant(){return this.panelOpen&&this._keyManager&&this._keyManager.activeItem?this._keyManager.activeItem.id:null}_getTriggerAriaLabelledby(){if(this.ariaLabel)return null;const e=this._parentFormField?.getLabelId();let r=(e?e+" ":"")+this._valueId;return this.ariaLabelledby&&(r+=" "+this.ariaLabelledby),r}_panelDoneAnimating(e){this.openedChange.emit(e)}setDescribedByIds(e){e.length?this._elementRef.nativeElement.setAttribute("aria-describedby",e.join(" ")):this._elementRef.nativeElement.removeAttribute("aria-describedby")}onContainerClick(){this.focus(),this.open()}get shouldLabelFloat(){return this._panelOpen||!this.empty||this._focused&&!!this._placeholder}}return n.\u0275fac=function(e){return new(e||n)(H(Z1),H(nc),H(yt),H(aAe),H(hn),H(B1,8),H(ix,8),H(ox,8),H(RMe,8),H(Na,10),au("tabindex"),H(Aj),H($1),H(XFe,8))},n.\u0275dir=$e({type:n,viewQuery:function(e,r){if(1&e&&(Eo(LFe,5),Eo(BFe,5),Eo(rW,5)),2&e){let s;Ts(s=ks())&&(r.trigger=s.first),Ts(s=ks())&&(r.panel=s.first),Ts(s=ks())&&(r._overlayDir=s.first)}},inputs:{userAriaDescribedBy:["aria-describedby","userAriaDescribedBy"],panelClass:"panelClass",placeholder:"placeholder",required:"required",multiple:"multiple",disableOptionCentering:"disableOptionCentering",compareWith:"compareWith",value:"value",ariaLabel:["aria-label","ariaLabel"],ariaLabelledby:["aria-labelledby","ariaLabelledby"],errorStateMatcher:"errorStateMatcher",typeaheadDebounceInterval:"typeaheadDebounceInterval",sortComparator:"sortComparator",id:"id"},outputs:{openedChange:"openedChange",_openedStream:"opened",_closedStream:"closed",selectionChange:"selectionChange",valueChange:"valueChange"},features:[dt,Is]}),n})(),tOe=(()=>{class n extends eOe{constructor(){super(...arguments),this._positions=[{originX:"start",originY:"bottom",overlayX:"start",overlayY:"top"},{originX:"start",originY:"top",overlayX:"start",overlayY:"bottom",panelClass:"mat-mdc-select-panel-above"}]}get shouldLabelFloat(){return this.panelOpen||!this.empty||this.focused&&!!this.placeholder}ngOnInit(){super.ngOnInit(),this._viewportRuler.change().pipe(Go(this._destroy)).subscribe(()=>{this.panelOpen&&(this._overlayWidth=this._getOverlayWidth(),this._changeDetectorRef.detectChanges())})}ngAfterViewInit(){this._parentFormField&&(this._preferredOverlayOrigin=this._parentFormField.getConnectedOverlayOrigin())}open(){this._overlayWidth=this._getOverlayWidth(),super.open(),this.stateChanges.next()}close(){super.close(),this.stateChanges.next()}_scrollOptionIntoView(e){const r=this.options.toArray()[e];if(r){const s=this.panel.nativeElement,i=function bAe(n,t,e){if(e.length){let r=t.toArray(),s=e.toArray(),i=0;for(let o=0;o<n+1;o++)r[o].group&&r[o].group===s[i]&&i++;return i}return 0}(e,this.options,this.optionGroups),o=r._getHostElement();s.scrollTop=0===e&&1===i?0:function _Ae(n,t,e,r){return n<e?n:n+t>e+r?Math.max(0,n-r+t):e}(o.offsetTop,o.offsetHeight,s.scrollTop,s.offsetHeight)}}_positioningSettled(){this._scrollOptionIntoView(this._keyManager.activeItemIndex||0)}_getChangeEvent(e){return new QFe(this,e)}_getOverlayWidth(){return(this._preferredOverlayOrigin instanceof ek?this._preferredOverlayOrigin.elementRef:this._preferredOverlayOrigin||this._elementRef).nativeElement.getBoundingClientRect().width}}return n.\u0275fac=function(){let t;return function(r){return(t||(t=hr(n)))(r||n)}}(),n.\u0275cmp=is({type:n,selectors:[["mat-select"]],contentQueries:function(e,r,s){if(1&e&&(Zh(s,ZFe,5),Zh(s,NH,5),Zh(s,kH,5)),2&e){let i;Ts(i=ks())&&(r.customTrigger=i.first),Ts(i=ks())&&(r.options=i),Ts(i=ks())&&(r.optionGroups=i)}},hostAttrs:["role","combobox","aria-autocomplete","none","aria-haspopup","listbox",1,"mat-mdc-select"],hostVars:19,hostBindings:function(e,r){1&e&&Ln("keydown",function(i){return r._handleKeydown(i)})("focus",function(){return r._onFocus()})("blur",function(){return r._onBlur()}),2&e&&(yn("id",r.id)("tabindex",r.tabIndex)("aria-controls",r.panelOpen?r.id+"-panel":null)("aria-expanded",r.panelOpen)("aria-label",r.ariaLabel||null)("aria-required",r.required.toString())("aria-disabled",r.disabled.toString())("aria-invalid",r.errorState)("aria-activedescendant",r._getAriaActiveDescendant()),ds("mat-mdc-select-disabled",r.disabled)("mat-mdc-select-invalid",r.errorState)("mat-mdc-select-required",r.required)("mat-mdc-select-empty",r.empty)("mat-mdc-select-multiple",r.multiple))},inputs:{disabled:"disabled",disableRipple:"disableRipple",tabIndex:"tabIndex"},exportAs:["matSelect"],features:[bn([{provide:AMe,useExisting:n},{provide:TH,useExisting:n}]),dt],ngContentSelectors:GFe,decls:11,vars:11,consts:[["cdk-overlay-origin","",1,"mat-mdc-select-trigger",3,"click"],["fallbackOverlayOrigin","cdkOverlayOrigin","trigger",""],[1,"mat-mdc-select-value",3,"ngSwitch"],["class","mat-mdc-select-placeholder mat-mdc-select-min-line",4,"ngSwitchCase"],["class","mat-mdc-select-value-text",3,"ngSwitch",4,"ngSwitchCase"],[1,"mat-mdc-select-arrow-wrapper"],[1,"mat-mdc-select-arrow"],["viewBox","0 0 24 24","width","24px","height","24px","focusable","false"],["d","M7 10l5 5 5-5z"],["cdk-connected-overlay","","cdkConnectedOverlayLockPosition","","cdkConnectedOverlayHasBackdrop","","cdkConnectedOverlayBackdropClass","cdk-overlay-transparent-backdrop",3,"cdkConnectedOverlayPanelClass","cdkConnectedOverlayScrollStrategy","cdkConnectedOverlayOrigin","cdkConnectedOverlayOpen","cdkConnectedOverlayPositions","cdkConnectedOverlayWidth","backdropClick","attach","detach"],[1,"mat-mdc-select-placeholder","mat-mdc-select-min-line"],[1,"mat-mdc-select-value-text",3,"ngSwitch"],["class","mat-mdc-select-min-line",4,"ngSwitchDefault"],[4,"ngSwitchCase"],[1,"mat-mdc-select-min-line"],["role","listbox","tabindex","-1",3,"ngClass","keydown"],["panel",""]],template:function(e,r){if(1&e&&(Jl(jFe),Lt(0,"div",0,1),Ln("click",function(){return r.toggle()}),Lt(3,"div",2),us(4,VFe,2,1,"span",3),us(5,HFe,3,2,"span",4),Qt(),Lt(6,"div",5)(7,"div",6),mh(),Lt(8,"svg",7),kr(9,"path",8),Qt()()()(),us(10,WFe,3,9,"ng-template",9),Ln("backdropClick",function(){return r.close()})("attach",function(){return r._onAttached()})("detach",function(){return r.close()})),2&e){const s=Ph(1);yn("aria-owns",r.panelOpen?r.id+"-panel":null),Pt(3),Gt("ngSwitch",r.empty),yn("id",r._valueId),Pt(1),Gt("ngSwitchCase",!0),Pt(1),Gt("ngSwitchCase",!1),Pt(5),Gt("cdkConnectedOverlayPanelClass",r._overlayPanelClass)("cdkConnectedOverlayScrollStrategy",r._scrollStrategy)("cdkConnectedOverlayOrigin",r._preferredOverlayOrigin||s)("cdkConnectedOverlayOpen",r.panelOpen)("cdkConnectedOverlayPositions",r._positions)("cdkConnectedOverlayWidth",r._overlayWidth)}},dependencies:[C2,ay,k2,N2,rW,ek],styles:['.mdc-menu-surface{display:none;position:absolute;box-sizing:border-box;max-width:calc(100vw - 32px);max-width:var(--mdc-menu-max-width, calc(100vw - 32px));max-height:calc(100vh - 32px);max-height:var(--mdc-menu-max-height, calc(100vh - 32px));margin:0;padding:0;transform:scale(1);transform-origin:top left;opacity:0;overflow:auto;will-change:transform,opacity;z-index:8;border-radius:4px;border-radius:var(--mdc-shape-medium, 4px);transform-origin-left:top left;transform-origin-right:top right}.mdc-menu-surface:focus{outline:none}.mdc-menu-surface--animating-open{display:inline-block;transform:scale(0.8);opacity:0}.mdc-menu-surface--open{display:inline-block;transform:scale(1);opacity:1}.mdc-menu-surface--animating-closed{display:inline-block;opacity:0}[dir=rtl] .mdc-menu-surface,.mdc-menu-surface[dir=rtl]{transform-origin-left:top right;transform-origin-right:top left}.mdc-menu-surface--anchor{position:relative;overflow:visible}.mdc-menu-surface--fixed{position:fixed}.mdc-menu-surface--fullwidth{width:100%}.mat-mdc-select{display:inline-block;width:100%;outline:none}.mat-mdc-select-trigger{display:inline-flex;align-items:center;cursor:pointer;position:relative;box-sizing:border-box;width:100%}.mat-mdc-select-disabled .mat-mdc-select-trigger{-webkit-user-select:none;user-select:none;cursor:default}.mat-mdc-select-value{width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-mdc-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-mdc-select-arrow-wrapper{height:24px;flex-shrink:0;display:inline-flex;align-items:center}.mat-form-field-appearance-fill .mat-mdc-select-arrow-wrapper{transform:translateY(-8px)}.mat-form-field-appearance-fill .mdc-text-field--no-label .mat-mdc-select-arrow-wrapper{transform:none}.mat-mdc-select-arrow{width:10px;height:5px;position:relative}.mat-mdc-select-arrow svg{fill:currentColor;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}.cdk-high-contrast-active .mat-mdc-select-arrow svg{fill:CanvasText}.mat-mdc-select-disabled .cdk-high-contrast-active .mat-mdc-select-arrow svg{fill:GrayText}.mdc-menu-surface.mat-mdc-select-panel{width:100%;max-height:275px;position:static;outline:0;margin:0;padding:8px 0;list-style-type:none}.mdc-menu-surface.mat-mdc-select-panel:focus{outline:none}.cdk-high-contrast-active .mdc-menu-surface.mat-mdc-select-panel{outline:solid 1px}.cdk-overlay-pane:not(.mat-mdc-select-panel-above) .mdc-menu-surface.mat-mdc-select-panel{border-top-left-radius:0;border-top-right-radius:0;transform-origin:top center}.mat-mdc-select-panel-above .mdc-menu-surface.mat-mdc-select-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:bottom center}.mat-mdc-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable .mat-mdc-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-mdc-select-placeholder{color:rgba(0,0,0,0);-webkit-text-fill-color:rgba(0,0,0,0);transition:none;display:block}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mat-mdc-floating-label{max-width:calc(100% - 18px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 24px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-text-field--label-floating .mdc-notched-outline__notch{max-width:calc(100% - 24px)}.mat-mdc-select-min-line:empty::before{content:" ";white-space:pre;width:1px;display:inline-block;visibility:hidden}'],encapsulation:2,data:{animation:[qFe.transformPanel]},changeDetection:0}),n})(),nOe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({providers:[YFe],imports:[ic,tk,AH,zr,Uv,MMe,AH,zr]}),n})();const rOe=["inferenceCanvas"],sOe=["frameCapture"];function iOe(n,t){1&n&&kr(0,"mat-spinner",16),2&n&&Gt("diameter",40)}function oOe(n,t){if(1&n){const e=Lh();Lt(0,"button",17),Ln("click",function(){return eu(e),ei(),tu(Ph(3).click())}),Lt(1,"mat-icon"),la(2,"add_a_photo"),Qt()()}}function aOe(n,t){1&n&&(Lt(0,"mat-icon",18),la(1,"sort"),Qt())}function lOe(n,t){if(1&n&&(Lt(0,"mat-option",19),la(1),Qt()),2&n){const e=t.$implicit;Gt("value",e.value),Pt(1),Uh(e.value)}}const cOe=function(){return{display:"none"}};class ax{constructor(t){this.snackBar=t,this.FONT_SIZE=12,this.FONT=this.FONT_SIZE+"px comic-sans",this.classNamesMap=new Map,this.currentClassNames=new Map,this.loadingInference=!0,this.streamLoaded=!1,this.RESOLUTION=[640,640],this.showOriginalImage=!1,this.selectedClasses=[],this.importer=new Fv,this.classNamesMap=this.importer.getClassNames(),this.selectedClasses=[...this.classNamesMap.values()]}ngAfterViewInit(){this.ctxFrameCapture=this.frameCapture.nativeElement.getContext("2d"),this.ctx=this.inferenceCanvas.nativeElement.getContext("2d"),this.ctx.font=this.FONT,this.ctx.textBaseline="top";var t=new Image;t.src="assets/factory.jpg",null!=t&&(t.onload=()=>{this.importer.modelLoaded$.pipe(ni(()=>this.importer.predict(this.frameCapture.nativeElement,this.ctxFrameCapture,this.ctx,void 0,t,!0)),$r(1)).subscribe(()=>{this.loadingInference=!1})})}selectChange(t){this.selectedClasses=t,this.importer.setClassNames(t)}inputEvent(t){let e=t.target.files[0];if(e)if(t.target.files[0].type.includes("image/")){this.loadingInference=!0;var r=new FileReader;r.readAsDataURL(e),r.onloadend=s=>{var i=new Image;s.target&&(i.src=s?.target?.result),i.onload=o=>{this.importer.predict(this.frameCapture.nativeElement,this.ctxFrameCapture,this.ctx,void 0,i,!0).pipe($r(1)).subscribe(()=>{this.loadingInference=!1})}}}else this.snackBar.open("Invalid filetype!","OK",{duration:2e3,panelClass:"snackbar-red"});else console.log("No file selected!")}static#e=this.\u0275fac=function(e){return new(e||ax)(H(ORe))};static#t=this.\u0275cmp=is({type:ax,selectors:[["app-root"]],viewQuery:function(e,r){if(1&e&&(Eo(rOe,5),Eo(sOe,5)),2&e){let s;Ts(s=ks())&&(r.inferenceCanvas=s.first),Ts(s=ks())&&(r.frameCapture=s.first)}},decls:17,vars:15,consts:[[2,"width","100%","height","100%"],[1,"content"],["name","imageInput","type","file","accept","image/*",2,"display","none",3,"disabled","change"],["imageInput",""],[2,"width","100%","position","relative"],["style","position: absolute; top: 45%; \n        margin-left: auto; \n        margin-right: auto; \n        left: 0;\n        right: 0;\n        text-align: center; ",3,"diameter",4,"ngIf"],[2,"width","100%",3,"width","height"],["inferenceCanvas",""],["mat-mini-fab","","style","position: absolute; \n        margin-left: auto; \n        margin-right: auto; \n        left: 0;\n        right: 0;\n        text-align: center; \n        bottom: 5%; \n        background-color: white;",3,"click",4,"ngIf"],["mat-icon-button","",2,"position","absolute","top","5%","left","4%",3,"click"],["style","color: white",4,"ngIf"],["multiple","","color","accent",1,"langSelect",3,"ngModel","selectionChange"],["select",""],[3,"value",4,"ngFor","ngForOf"],[2,"width","90%",3,"hidden","ngStyle","width","height"],["frameCapture",""],[2,"position","absolute","top","45%","margin-left","auto","margin-right","auto","left","0","right","0","text-align","center",3,"diameter"],["mat-mini-fab","",2,"position","absolute","margin-left","auto","margin-right","auto","left","0","right","0","text-align","center","bottom","5%","background-color","white",3,"click"],[2,"color","white"],[3,"value"]],template:function(e,r){if(1&e){const s=Lh();Lt(0,"div",0)(1,"div",1)(2,"input",2,3),Ln("change",function(o){return r.inputEvent(o)}),Qt(),Lt(4,"div",4),us(5,iOe,1,1,"mat-spinner",5),kr(6,"canvas",6,7),us(8,oOe,3,0,"button",8),Lt(9,"button",9),Ln("click",function(){return eu(s),tu(Ph(12).open())}),us(10,aOe,2,0,"mat-icon",10),Lt(11,"mat-select",11,12),Ln("selectionChange",function(o){return r.selectChange(o.value)}),us(13,lOe,2,2,"mat-option",13),function iO(n,t){const e=At();let r;const s=n+22;e.firstCreatePass?(r=function e7(n,t){if(t)for(let e=t.length-1;e>=0;e--){const r=t[e];if(n===r.name)return r}}(t,e.pipeRegistry),e.data[s]=r,r.onDestroy&&(e.destroyHooks||(e.destroyHooks=[])).push(s,r.onDestroy)):r=e.data[s];const i=r.factory||(r.factory=Ul(r.type)),o=vi(H);try{const a=rg(!1),l=i();return rg(a),function KK(n,t,e,r){e>=n.data.length&&(n.data[e]=null,n.blueprint[e]=null),t[e]=r}(e,oe(),s,l),l}finally{vi(o)}}(14,"keyvalue"),Qt()()(),kr(15,"canvas",14,15),Qt()()}2&e&&(Pt(2),Gt("disabled",!r.importer.isModelLoaded()||r.loadingInference),Pt(3),Gt("ngIf",r.loadingInference),Pt(1),Gt("width",r.RESOLUTION[0])("height",r.RESOLUTION[1]),Pt(2),Gt("ngIf",!r.loadingInference),Pt(2),Gt("ngIf",!r.loadingInference),Pt(1),Gt("ngModel",r.selectedClasses),Pt(2),Gt("ngForOf",function oO(n,t,e){const r=n+22,s=oe(),i=Jc(s,r);return function Xh(n,t){return n[1].data[t].pure}(s,r)?eO(s,as(),t,i.transform,e,i):i.transform(e)}(14,12,r.classNamesMap)),Pt(2),Gt("hidden",r.showOriginalImage)("ngStyle",function JF(n,t,e){const r=as()+n,s=oe();return s[r]===rt?wo(s,r,e?t.call(e):t()):function Oh(n,t){return n[t]}(s,r)}(14,cOe))("width",r.RESOLUTION[0])("height",r.RESOLUTION[1]))},dependencies:[I2,oy,R2,URe,xMe,RAe,AAe,tOe,NH,ZW,wk,F2],styles:[".langSelect div.mat-mdc-select-arrow-wrapper{display:none}  .langSelect.mat-select{display:inline}  #cdk-overlay-0{width:250px!important}  #mat-select-0{display:none}  .mat-pseudo-checkbox-checked{background:blue}  .mdc-list-item--selected .mdc-list-item__primary-text{color:#000}  .mat-mdc-snack-bar-container .mdc-snackbar__surface{background-color:red!important;color:#fff!important}"]})}const fOe={provide:new me("mat-menu-scroll-strategy"),deps:[Lc],useFactory:function hOe(n){return()=>n.scrollStrategies.reposition()}};let pOe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({providers:[fOe],imports:[ic,U1,zr,tk,Uv,zr]}),n})();function Mj(n){return new te(3e3,!1)}function XOe(){return typeof window<"u"&&typeof window.document<"u"}function kk(){return typeof process<"u"&&"[object process]"==={}.toString.call(process)}function Nl(n){switch(n.length){case 0:return new Sm;case 1:return n[0];default:return new VH(n)}}function Fj(n,t,e,r,s=new Map,i=new Map){const o=[],a=[];let l=-1,c=null;if(r.forEach(u=>{const d=u.get("offset"),h=d==l,f=h&&c||new Map;u.forEach((p,m)=>{let g=m,y=p;if("offset"!==m)switch(g=t.normalizePropertyName(g,o),y){case"!":y=s.get(m);break;case Ta:y=i.get(m);break;default:y=t.normalizeStyleValue(m,g,y,o)}f.set(g,y)}),h||a.push(f),c=f,l=d}),o.length)throw function $Oe(n){return new te(3502,!1)}();return a}function Nk(n,t,e,r){switch(t){case"start":n.onStart(()=>r(e&&Ak(e,"start",n)));break;case"done":n.onDone(()=>r(e&&Ak(e,"done",n)));break;case"destroy":n.onDestroy(()=>r(e&&Ak(e,"destroy",n)))}}function Ak(n,t,e){const i=Rk(n.element,n.triggerName,n.fromState,n.toState,t||n.phaseName,e.totalTime??n.totalTime,!!e.disabled),o=n._data;return null!=o&&(i._data=o),i}function Rk(n,t,e,r,s="",i=0,o){return{element:n,triggerName:t,fromState:e,toState:r,phaseName:s,totalTime:i,disabled:!!o}}function gi(n,t,e){let r=n.get(t);return r||n.set(t,r=e),r}function Oj(n){const t=n.indexOf(":");return[n.substring(1,t),n.slice(t+1)]}let Mk=(n,t)=>!1,Pj=(n,t,e)=>[],$j=null;function Fk(n){const t=n.parentNode||n.host;return t===$j?null:t}(kk()||typeof Element<"u")&&(XOe()?($j=(()=>document.documentElement)(),Mk=(n,t)=>{for(;t;){if(t===n)return!0;t=Fk(t)}return!1}):Mk=(n,t)=>n.contains(t),Pj=(n,t,e)=>{if(e)return Array.from(n.querySelectorAll(t));const r=n.querySelector(t);return r?[r]:[]});let Uc=null,Lj=!1;const Bj=Mk,Vj=Pj;let zj=(()=>{class n{validateStyleProperty(e){return function ZOe(n){Uc||(Uc=function QOe(){return typeof document<"u"?document.body:null}()||{},Lj=!!Uc.style&&"WebkitAppearance"in Uc.style);let t=!0;return Uc.style&&!function YOe(n){return"ebkit"==n.substring(1,6)}(n)&&(t=n in Uc.style,!t&&Lj&&(t="Webkit"+n.charAt(0).toUpperCase()+n.slice(1)in Uc.style)),t}(e)}matchesElement(e,r){return!1}containsElement(e,r){return Bj(e,r)}getParentElement(e){return Fk(e)}query(e,r,s){return Vj(e,r,s)}computeStyle(e,r,s){return s||""}animate(e,r,s,i,o,a=[],l){return new Sm(s,i)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})(),Ok=(()=>{class n{}return n.NOOP=new zj,n})();const Pk="ng-enter",lx="ng-leave",cx="ng-trigger",ux=".ng-trigger",Hj="ng-animating",$k=".ng-animating";function Aa(n){if("number"==typeof n)return n;const t=n.match(/^(-?[\.\d]+)(m?s)/);return!t||t.length<2?0:Lk(parseFloat(t[1]),t[2])}function Lk(n,t){return"s"===t?1e3*n:n}function dx(n,t,e){return n.hasOwnProperty("duration")?n:function t2e(n,t,e){let s,i=0,o="";if("string"==typeof n){const a=n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===a)return t.push(Mj()),{duration:0,delay:0,easing:""};s=Lk(parseFloat(a[1]),a[2]);const l=a[3];null!=l&&(i=Lk(parseFloat(l),a[4]));const c=a[5];c&&(o=c)}else s=n;if(!e){let a=!1,l=t.length;s<0&&(t.push(function mOe(){return new te(3100,!1)}()),a=!0),i<0&&(t.push(function gOe(){return new te(3101,!1)}()),a=!0),a&&t.splice(l,0,Mj())}return{duration:s,delay:i,easing:o}}(n,t,e)}function Rm(n,t={}){return Object.keys(n).forEach(e=>{t[e]=n[e]}),t}function Wj(n){const t=new Map;return Object.keys(n).forEach(e=>{t.set(e,n[e])}),t}function Al(n,t=new Map,e){if(e)for(let[r,s]of e)t.set(r,s);for(let[r,s]of n)t.set(r,s);return t}function Gj(n,t,e){return e?t+":"+e+";":""}function qj(n){let t="";for(let e=0;e<n.style.length;e++){const r=n.style.item(e);t+=Gj(0,r,n.style.getPropertyValue(r))}for(const e in n.style)n.style.hasOwnProperty(e)&&!e.startsWith("_")&&(t+=Gj(0,i2e(e),n.style[e]));n.setAttribute("style",t)}function Ko(n,t,e){n.style&&(t.forEach((r,s)=>{const i=Vk(s);e&&!e.has(s)&&e.set(s,n.style[i]),n.style[i]=r}),kk()&&qj(n))}function Hc(n,t){n.style&&(t.forEach((e,r)=>{const s=Vk(r);n.style[s]=""}),kk()&&qj(n))}function Mm(n){return Array.isArray(n)?1==n.length?n[0]:LH(n):n}const Bk=new RegExp("{{\\s*(.+?)\\s*}}","g");function Kj(n){let t=[];if("string"==typeof n){let e;for(;e=Bk.exec(n);)t.push(e[1]);Bk.lastIndex=0}return t}function Fm(n,t,e){const r=n.toString(),s=r.replace(Bk,(i,o)=>{let a=t[o];return null==a&&(e.push(function bOe(n){return new te(3003,!1)}()),a=""),a.toString()});return s==r?n:s}function hx(n){const t=[];let e=n.next();for(;!e.done;)t.push(e.value),e=n.next();return t}const s2e=/-+([a-z0-9])/g;function Vk(n){return n.replace(s2e,(...t)=>t[1].toUpperCase())}function i2e(n){return n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}function yi(n,t,e){switch(t.type){case 7:return n.visitTrigger(t,e);case 0:return n.visitState(t,e);case 1:return n.visitTransition(t,e);case 2:return n.visitSequence(t,e);case 3:return n.visitGroup(t,e);case 4:return n.visitAnimate(t,e);case 5:return n.visitKeyframes(t,e);case 6:return n.visitStyle(t,e);case 8:return n.visitReference(t,e);case 9:return n.visitAnimateChild(t,e);case 10:return n.visitAnimateRef(t,e);case 11:return n.visitQuery(t,e);case 12:return n.visitStagger(t,e);default:throw function _Oe(n){return new te(3004,!1)}()}}function Xj(n,t){return window.getComputedStyle(n)[t]}function d2e(n,t){const e=[];return"string"==typeof n?n.split(/\s*,\s*/).forEach(r=>function h2e(n,t,e){if(":"==n[0]){const l=function f2e(n,t){switch(n){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(e,r)=>parseFloat(r)>parseFloat(e);case":decrement":return(e,r)=>parseFloat(r)<parseFloat(e);default:return t.push(function MOe(n){return new te(3016,!1)}()),"* => *"}}(n,e);if("function"==typeof l)return void t.push(l);n=l}const r=n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==r||r.length<4)return e.push(function ROe(n){return new te(3015,!1)}()),t;const s=r[1],i=r[2],o=r[3];t.push(Yj(s,o));"<"==i[0]&&!("*"==s&&"*"==o)&&t.push(Yj(o,s))}(r,e,t)):e.push(n),e}const gx=new Set(["true","1"]),yx=new Set(["false","0"]);function Yj(n,t){const e=gx.has(n)||yx.has(n),r=gx.has(t)||yx.has(t);return(s,i)=>{let o="*"==n||n==s,a="*"==t||t==i;return!o&&e&&"boolean"==typeof s&&(o=s?gx.has(n):yx.has(n)),!a&&r&&"boolean"==typeof i&&(a=i?gx.has(t):yx.has(t)),o&&a}}const p2e=new RegExp("s*:selfs*,?","g");function zk(n,t,e,r){return new m2e(n).build(t,e,r)}class m2e{constructor(t){this._driver=t}build(t,e,r){const s=new b2e(e);return this._resetContextStyleTimingState(s),yi(this,Mm(t),s)}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles=new Map,t.collectedStyles.set("",new Map),t.currentTime=0}visitTrigger(t,e){let r=e.queryCount=0,s=e.depCount=0;const i=[],o=[];return"@"==t.name.charAt(0)&&e.errors.push(function xOe(){return new te(3006,!1)}()),t.definitions.forEach(a=>{if(this._resetContextStyleTimingState(e),0==a.type){const l=a,c=l.name;c.toString().split(/\s*,\s*/).forEach(u=>{l.name=u,i.push(this.visitState(l,e))}),l.name=c}else if(1==a.type){const l=this.visitTransition(a,e);r+=l.queryCount,s+=l.depCount,o.push(l)}else e.errors.push(function wOe(){return new te(3007,!1)}())}),{type:7,name:t.name,states:i,transitions:o,queryCount:r,depCount:s,options:null}}visitState(t,e){const r=this.visitStyle(t.styles,e),s=t.options&&t.options.params||null;if(r.containsDynamicStyles){const i=new Set,o=s||{};r.styles.forEach(a=>{a instanceof Map&&a.forEach(l=>{Kj(l).forEach(c=>{o.hasOwnProperty(c)||i.add(c)})})}),i.size&&(hx(i.values()),e.errors.push(function COe(n,t){return new te(3008,!1)}()))}return{type:0,name:t.name,style:r,options:s?{params:s}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const r=yi(this,Mm(t.animation),e);return{type:1,matchers:d2e(t.expr,e.errors),animation:r,queryCount:e.queryCount,depCount:e.depCount,options:Wc(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(r=>yi(this,r,e)),options:Wc(t.options)}}visitGroup(t,e){const r=e.currentTime;let s=0;const i=t.steps.map(o=>{e.currentTime=r;const a=yi(this,o,e);return s=Math.max(s,e.currentTime),a});return e.currentTime=s,{type:3,steps:i,options:Wc(t.options)}}visitAnimate(t,e){const r=function v2e(n,t){if(n.hasOwnProperty("duration"))return n;if("number"==typeof n)return Uk(dx(n,t).duration,0,"");const e=n;if(e.split(/\s+/).some(i=>"{"==i.charAt(0)&&"{"==i.charAt(1))){const i=Uk(0,0,"");return i.dynamic=!0,i.strValue=e,i}const s=dx(e,t);return Uk(s.duration,s.delay,s.easing)}(t.timings,e.errors);e.currentAnimateTimings=r;let s,i=t.styles?t.styles:xs({});if(5==i.type)s=this.visitKeyframes(i,e);else{let o=t.styles,a=!1;if(!o){a=!0;const c={};r.easing&&(c.easing=r.easing),o=xs(c)}e.currentTime+=r.duration+r.delay;const l=this.visitStyle(o,e);l.isEmptyStep=a,s=l}return e.currentAnimateTimings=null,{type:4,timings:r,style:s,options:null}}visitStyle(t,e){const r=this._makeStyleAst(t,e);return this._validateStyleAst(r,e),r}_makeStyleAst(t,e){const r=[],s=Array.isArray(t.styles)?t.styles:[t.styles];for(let a of s)"string"==typeof a?a===Ta?r.push(a):e.errors.push(new te(3002,!1)):r.push(Wj(a));let i=!1,o=null;return r.forEach(a=>{if(a instanceof Map&&(a.has("easing")&&(o=a.get("easing"),a.delete("easing")),!i))for(let l of a.values())if(l.toString().indexOf("{{")>=0){i=!0;break}}),{type:6,styles:r,easing:o,offset:t.offset,containsDynamicStyles:i,options:null}}_validateStyleAst(t,e){const r=e.currentAnimateTimings;let s=e.currentTime,i=e.currentTime;r&&i>0&&(i-=r.duration+r.delay),t.styles.forEach(o=>{"string"!=typeof o&&o.forEach((a,l)=>{const c=e.collectedStyles.get(e.currentQuerySelector),u=c.get(l);let d=!0;u&&(i!=s&&i>=u.startTime&&s<=u.endTime&&(e.errors.push(function EOe(n,t,e,r,s){return new te(3010,!1)}()),d=!1),i=u.startTime),d&&c.set(l,{startTime:i,endTime:s}),e.options&&function r2e(n,t,e){const r=t.params||{},s=Kj(n);s.length&&s.forEach(i=>{r.hasOwnProperty(i)||e.push(function yOe(n){return new te(3001,!1)}())})}(a,e.options,e.errors)})})}visitKeyframes(t,e){const r={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push(function IOe(){return new te(3011,!1)}()),r;let i=0;const o=[];let a=!1,l=!1,c=0;const u=t.steps.map(y=>{const b=this._makeStyleAst(y,e);let _=null!=b.offset?b.offset:function _2e(n){if("string"==typeof n)return null;let t=null;if(Array.isArray(n))n.forEach(e=>{if(e instanceof Map&&e.has("offset")){const r=e;t=parseFloat(r.get("offset")),r.delete("offset")}});else if(n instanceof Map&&n.has("offset")){const e=n;t=parseFloat(e.get("offset")),e.delete("offset")}return t}(b.styles),v=0;return null!=_&&(i++,v=b.offset=_),l=l||v<0||v>1,a=a||v<c,c=v,o.push(v),b});l&&e.errors.push(function DOe(){return new te(3012,!1)}()),a&&e.errors.push(function TOe(){return new te(3200,!1)}());const d=t.steps.length;let h=0;i>0&&i<d?e.errors.push(function kOe(){return new te(3202,!1)}()):0==i&&(h=1/(d-1));const f=d-1,p=e.currentTime,m=e.currentAnimateTimings,g=m.duration;return u.forEach((y,b)=>{const _=h>0?b==f?1:h*b:o[b],v=_*g;e.currentTime=p+m.delay+v,m.duration=v,this._validateStyleAst(y,e),y.offset=_,r.styles.push(y)}),r}visitReference(t,e){return{type:8,animation:yi(this,Mm(t.animation),e),options:Wc(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:Wc(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:Wc(t.options)}}visitQuery(t,e){const r=e.currentQuerySelector,s=t.options||{};e.queryCount++,e.currentQuery=t;const[i,o]=function g2e(n){const t=!!n.split(/\s*,\s*/).find(e=>":self"==e);return t&&(n=n.replace(p2e,"")),n=n.replace(/@\*/g,ux).replace(/@\w+/g,e=>ux+"-"+e.slice(1)).replace(/:animating/g,$k),[n,t]}(t.selector);e.currentQuerySelector=r.length?r+" "+i:i,gi(e.collectedStyles,e.currentQuerySelector,new Map);const a=yi(this,Mm(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=r,{type:11,selector:i,limit:s.limit||0,optional:!!s.optional,includeSelf:o,animation:a,originalSelector:t.selector,options:Wc(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push(function NOe(){return new te(3013,!1)}());const r="full"===t.timings?{duration:0,delay:0,easing:"full"}:dx(t.timings,e.errors,!0);return{type:12,animation:yi(this,Mm(t.animation),e),timings:r,options:null}}}class b2e{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles=new Map,this.options=null,this.unsupportedCSSPropertiesFound=new Set}}function Wc(n){return n?(n=Rm(n)).params&&(n.params=function y2e(n){return n?Rm(n):null}(n.params)):n={},n}function Uk(n,t,e){return{duration:n,delay:t,easing:e}}function Hk(n,t,e,r,s,i,o=null,a=!1){return{type:1,element:n,keyframes:t,preStyleProps:e,postStyleProps:r,duration:s,delay:i,totalTime:s+i,easing:o,subTimeline:a}}class bx{constructor(){this._map=new Map}get(t){return this._map.get(t)||[]}append(t,e){let r=this._map.get(t);r||this._map.set(t,r=[]),r.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const C2e=new RegExp(":enter","g"),E2e=new RegExp(":leave","g");function Wk(n,t,e,r,s,i=new Map,o=new Map,a,l,c=[]){return(new I2e).buildKeyframes(n,t,e,r,s,i,o,a,l,c)}class I2e{buildKeyframes(t,e,r,s,i,o,a,l,c,u=[]){c=c||new bx;const d=new jk(t,e,c,s,i,u,[]);d.options=l;const h=l.delay?Aa(l.delay):0;d.currentTimeline.delayNextStep(h),d.currentTimeline.setStyles([o],null,d.errors,l),yi(this,r,d);const f=d.timelines.filter(p=>p.containsAnimation());if(f.length&&a.size){let p;for(let m=f.length-1;m>=0;m--){const g=f[m];if(g.element===e){p=g;break}}p&&!p.allowOnlyTimelineStyles()&&p.setStyles([a],null,d.errors,l)}return f.length?f.map(p=>p.buildKeyframes()):[Hk(e,[],[],[],0,h,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const r=e.subInstructions.get(e.element);if(r){const s=e.createSubContext(t.options),i=e.currentTimeline.currentTime,o=this._visitSubInstructions(r,s,s.options);i!=o&&e.transformIntoNewTimeline(o)}e.previousNode=t}visitAnimateRef(t,e){const r=e.createSubContext(t.options);r.transformIntoNewTimeline(),this._applyAnimationRefDelays([t.options,t.animation.options],e,r),this.visitReference(t.animation,r),e.transformIntoNewTimeline(r.currentTimeline.currentTime),e.previousNode=t}_applyAnimationRefDelays(t,e,r){for(const s of t){const i=s?.delay;if(i){const o="number"==typeof i?i:Aa(Fm(i,s?.params??{},e.errors));r.delayNextStep(o)}}}_visitSubInstructions(t,e,r){let i=e.currentTimeline.currentTime;const o=null!=r.duration?Aa(r.duration):null,a=null!=r.delay?Aa(r.delay):null;return 0!==o&&t.forEach(l=>{const c=e.appendInstructionToTimeline(l,o,a);i=Math.max(i,c.duration+c.delay)}),i}visitReference(t,e){e.updateOptions(t.options,!0),yi(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const r=e.subContextCount;let s=e;const i=t.options;if(i&&(i.params||i.delay)&&(s=e.createSubContext(i),s.transformIntoNewTimeline(),null!=i.delay)){6==s.previousNode.type&&(s.currentTimeline.snapshotCurrentStyles(),s.previousNode=_x);const o=Aa(i.delay);s.delayNextStep(o)}t.steps.length&&(t.steps.forEach(o=>yi(this,o,s)),s.currentTimeline.applyStylesToKeyframe(),s.subContextCount>r&&s.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const r=[];let s=e.currentTimeline.currentTime;const i=t.options&&t.options.delay?Aa(t.options.delay):0;t.steps.forEach(o=>{const a=e.createSubContext(t.options);i&&a.delayNextStep(i),yi(this,o,a),s=Math.max(s,a.currentTimeline.currentTime),r.push(a.currentTimeline)}),r.forEach(o=>e.currentTimeline.mergeTimelineCollectedStyles(o)),e.transformIntoNewTimeline(s),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const r=t.strValue;return dx(e.params?Fm(r,e.params,e.errors):r,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const r=e.currentAnimateTimings=this._visitTiming(t.timings,e),s=e.currentTimeline;r.delay&&(e.incrementTime(r.delay),s.snapshotCurrentStyles());const i=t.style;5==i.type?this.visitKeyframes(i,e):(e.incrementTime(r.duration),this.visitStyle(i,e),s.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const r=e.currentTimeline,s=e.currentAnimateTimings;!s&&r.hasCurrentStyleProperties()&&r.forwardFrame();const i=s&&s.easing||t.easing;t.isEmptyStep?r.applyEmptyStep(i):r.setStyles(t.styles,i,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const r=e.currentAnimateTimings,s=e.currentTimeline.duration,i=r.duration,a=e.createSubContext().currentTimeline;a.easing=r.easing,t.styles.forEach(l=>{a.forwardTime((l.offset||0)*i),a.setStyles(l.styles,l.easing,e.errors,e.options),a.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(a),e.transformIntoNewTimeline(s+i),e.previousNode=t}visitQuery(t,e){const r=e.currentTimeline.currentTime,s=t.options||{},i=s.delay?Aa(s.delay):0;i&&(6===e.previousNode.type||0==r&&e.currentTimeline.hasCurrentStyleProperties())&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=_x);let o=r;const a=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!s.optional,e.errors);e.currentQueryTotal=a.length;let l=null;a.forEach((c,u)=>{e.currentQueryIndex=u;const d=e.createSubContext(t.options,c);i&&d.delayNextStep(i),c===e.element&&(l=d.currentTimeline),yi(this,t.animation,d),d.currentTimeline.applyStylesToKeyframe(),o=Math.max(o,d.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(o),l&&(e.currentTimeline.mergeTimelineCollectedStyles(l),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const r=e.parentContext,s=e.currentTimeline,i=t.timings,o=Math.abs(i.duration),a=o*(e.currentQueryTotal-1);let l=o*e.currentQueryIndex;switch(i.duration<0?"reverse":i.easing){case"reverse":l=a-l;break;case"full":l=r.currentStaggerTime}const u=e.currentTimeline;l&&u.delayNextStep(l);const d=u.currentTime;yi(this,t.animation,e),e.previousNode=t,r.currentStaggerTime=s.currentTime-d+(s.startTime-r.currentTimeline.startTime)}}const _x={};class jk{constructor(t,e,r,s,i,o,a,l){this._driver=t,this.element=e,this.subInstructions=r,this._enterClassName=s,this._leaveClassName=i,this.errors=o,this.timelines=a,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=_x,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=l||new vx(this._driver,e,0),a.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const r=t;let s=this.options;null!=r.duration&&(s.duration=Aa(r.duration)),null!=r.delay&&(s.delay=Aa(r.delay));const i=r.params;if(i){let o=s.params;o||(o=this.options.params={}),Object.keys(i).forEach(a=>{(!e||!o.hasOwnProperty(a))&&(o[a]=Fm(i[a],o,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const r=t.params={};Object.keys(e).forEach(s=>{r[s]=e[s]})}}return t}createSubContext(t=null,e,r){const s=e||this.element,i=new jk(this._driver,s,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(s,r||0));return i.previousNode=this.previousNode,i.currentAnimateTimings=this.currentAnimateTimings,i.options=this._copyOptions(),i.updateOptions(t),i.currentQueryIndex=this.currentQueryIndex,i.currentQueryTotal=this.currentQueryTotal,i.parentContext=this,this.subContextCount++,i}transformIntoNewTimeline(t){return this.previousNode=_x,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,r){const s={duration:e??t.duration,delay:this.currentTimeline.currentTime+(r??0)+t.delay,easing:""},i=new D2e(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,s,t.stretchStartingKeyframe);return this.timelines.push(i),s}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,r,s,i,o){let a=[];if(s&&a.push(this.element),t.length>0){t=(t=t.replace(C2e,"."+this._enterClassName)).replace(E2e,"."+this._leaveClassName);let c=this._driver.query(this.element,t,1!=r);0!==r&&(c=r<0?c.slice(c.length+r,c.length):c.slice(0,r)),a.push(...c)}return!i&&0==a.length&&o.push(function AOe(n){return new te(3014,!1)}()),a}}class vx{constructor(t,e,r,s){this._driver=t,this.element=e,this.startTime=r,this._elementTimelineStylesLookup=s,this.duration=0,this._previousKeyframe=new Map,this._currentKeyframe=new Map,this._keyframes=new Map,this._styleSummary=new Map,this._localTimelineStyles=new Map,this._pendingStyles=new Map,this._backFill=new Map,this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.hasCurrentStyleProperties();default:return!0}}hasCurrentStyleProperties(){return this._currentKeyframe.size>0}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1===this._keyframes.size&&this._pendingStyles.size;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new vx(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=new Map,this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles.set(t,e),this._globalTimelineStyles.set(t,e),this._styleSummary.set(t,{time:this.currentTime,value:e})}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&this._previousKeyframe.set("easing",t);for(let[e,r]of this._globalTimelineStyles)this._backFill.set(e,r||Ta),this._currentKeyframe.set(e,Ta);this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,r,s){e&&this._previousKeyframe.set("easing",e);const i=s&&s.params||{},o=function T2e(n,t){const e=new Map;let r;return n.forEach(s=>{if("*"===s){r=r||t.keys();for(let i of r)e.set(i,Ta)}else Al(s,e)}),e}(t,this._globalTimelineStyles);for(let[a,l]of o){const c=Fm(l,i,r);this._pendingStyles.set(a,c),this._localTimelineStyles.has(a)||this._backFill.set(a,this._globalTimelineStyles.get(a)??Ta),this._updateStyle(a,c)}}applyStylesToKeyframe(){0!=this._pendingStyles.size&&(this._pendingStyles.forEach((t,e)=>{this._currentKeyframe.set(e,t)}),this._pendingStyles.clear(),this._localTimelineStyles.forEach((t,e)=>{this._currentKeyframe.has(e)||this._currentKeyframe.set(e,t)}))}snapshotCurrentStyles(){for(let[t,e]of this._localTimelineStyles)this._pendingStyles.set(t,e),this._updateStyle(t,e)}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){t._styleSummary.forEach((e,r)=>{const s=this._styleSummary.get(r);(!s||e.time>s.time)&&this._updateStyle(r,e.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,r=1===this._keyframes.size&&0===this.duration;let s=[];this._keyframes.forEach((a,l)=>{const c=Al(a,new Map,this._backFill);c.forEach((u,d)=>{"!"===u?t.add(d):u===Ta&&e.add(d)}),r||c.set("offset",l/this.duration),s.push(c)});const i=t.size?hx(t.values()):[],o=e.size?hx(e.values()):[];if(r){const a=s[0],l=new Map(a);a.set("offset",0),l.set("offset",1),s=[a,l]}return Hk(this.element,s,i,o,this.duration,this.startTime,this.easing,!1)}}class D2e extends vx{constructor(t,e,r,s,i,o,a=!1){super(t,e,o.delay),this.keyframes=r,this.preStyleProps=s,this.postStyleProps=i,this._stretchStartingKeyframe=a,this.timings={duration:o.duration,delay:o.delay,easing:o.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:r,easing:s}=this.timings;if(this._stretchStartingKeyframe&&e){const i=[],o=r+e,a=e/o,l=Al(t[0]);l.set("offset",0),i.push(l);const c=Al(t[0]);c.set("offset",Jj(a)),i.push(c);const u=t.length-1;for(let d=1;d<=u;d++){let h=Al(t[d]);const f=h.get("offset");h.set("offset",Jj((e+f*r)/o)),i.push(h)}r=o,e=0,s="",t=i}return Hk(this.element,t,this.preStyleProps,this.postStyleProps,r,e,s,!0)}}function Jj(n,t=3){const e=Math.pow(10,t-1);return Math.round(n*e)/e}class Gk{}const k2e=new Set(["width","height","minWidth","minHeight","maxWidth","maxHeight","left","top","bottom","right","fontSize","outlineWidth","outlineOffset","paddingTop","paddingLeft","paddingBottom","paddingRight","marginTop","marginLeft","marginBottom","marginRight","borderRadius","borderWidth","borderTopWidth","borderLeftWidth","borderRightWidth","borderBottomWidth","textIndent","perspective"]);class N2e extends Gk{normalizePropertyName(t,e){return Vk(t)}normalizeStyleValue(t,e,r,s){let i="";const o=r.toString().trim();if(k2e.has(e)&&0!==r&&"0"!==r)if("number"==typeof r)i="px";else{const a=r.match(/^[+-]?[\d\.]+([a-z]*)$/);a&&0==a[1].length&&s.push(function vOe(n,t){return new te(3005,!1)}())}return o+i}}function eG(n,t,e,r,s,i,o,a,l,c,u,d,h){return{type:0,element:n,triggerName:t,isRemovalTransition:s,fromState:e,fromStyles:i,toState:r,toStyles:o,timelines:a,queriedElements:l,preStyleProps:c,postStyleProps:u,totalTime:d,errors:h}}const qk={};class tG{constructor(t,e,r){this._triggerName=t,this.ast=e,this._stateStyles=r}match(t,e,r,s){return function A2e(n,t,e,r,s){return n.some(i=>i(t,e,r,s))}(this.ast.matchers,t,e,r,s)}buildStyles(t,e,r){let s=this._stateStyles.get("*");return void 0!==t&&(s=this._stateStyles.get(t?.toString())||s),s?s.buildStyles(e,r):new Map}build(t,e,r,s,i,o,a,l,c,u){const d=[],h=this.ast.options&&this.ast.options.params||qk,p=this.buildStyles(r,a&&a.params||qk,d),m=l&&l.params||qk,g=this.buildStyles(s,m,d),y=new Set,b=new Map,_=new Map,v="void"===s,w={params:R2e(m,h),delay:this.ast.options?.delay},C=u?[]:Wk(t,e,this.ast.animation,i,o,p,g,w,c,d);let I=0;if(C.forEach(T=>{I=Math.max(T.duration+T.delay,I)}),d.length)return eG(e,this._triggerName,r,s,v,p,g,[],[],b,_,I,d);C.forEach(T=>{const N=T.element,$=gi(b,N,new Set);T.preStyleProps.forEach(j=>$.add(j));const z=gi(_,N,new Set);T.postStyleProps.forEach(j=>z.add(j)),N!==e&&y.add(N)});const D=hx(y.values());return eG(e,this._triggerName,r,s,v,p,g,C,D,b,_,I)}}function R2e(n,t){const e=Rm(t);for(const r in n)n.hasOwnProperty(r)&&null!=n[r]&&(e[r]=n[r]);return e}class M2e{constructor(t,e,r){this.styles=t,this.defaultParams=e,this.normalizer=r}buildStyles(t,e){const r=new Map,s=Rm(this.defaultParams);return Object.keys(t).forEach(i=>{const o=t[i];null!==o&&(s[i]=o)}),this.styles.styles.forEach(i=>{"string"!=typeof i&&i.forEach((o,a)=>{o&&(o=Fm(o,s,e));const l=this.normalizer.normalizePropertyName(a,e);o=this.normalizer.normalizeStyleValue(a,l,o,e),r.set(l,o)})}),r}}class O2e{constructor(t,e,r){this.name=t,this.ast=e,this._normalizer=r,this.transitionFactories=[],this.states=new Map,e.states.forEach(s=>{this.states.set(s.name,new M2e(s.style,s.options&&s.options.params||{},r))}),nG(this.states,"true","1"),nG(this.states,"false","0"),e.transitions.forEach(s=>{this.transitionFactories.push(new tG(t,s,this.states))}),this.fallbackTransition=function P2e(n,t,e){return new tG(n,{type:1,animation:{type:2,steps:[],options:null},matchers:[(o,a)=>!0],options:null,queryCount:0,depCount:0},t)}(t,this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,r,s){return this.transitionFactories.find(o=>o.match(t,e,r,s))||null}matchStyles(t,e,r){return this.fallbackTransition.buildStyles(t,e,r)}}function nG(n,t,e){n.has(t)?n.has(e)||n.set(e,n.get(t)):n.has(e)&&n.set(t,n.get(e))}const $2e=new bx;class L2e{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._animations=new Map,this._playersById=new Map,this.players=[]}register(t,e){const r=[],i=zk(this._driver,e,r,[]);if(r.length)throw function LOe(n){return new te(3503,!1)}();this._animations.set(t,i)}_buildPlayer(t,e,r){const s=t.element,i=Fj(0,this._normalizer,0,t.keyframes,e,r);return this._driver.animate(s,i,t.duration,t.delay,t.easing,[],!0)}create(t,e,r={}){const s=[],i=this._animations.get(t);let o;const a=new Map;if(i?(o=Wk(this._driver,e,i,Pk,lx,new Map,new Map,r,$2e,s),o.forEach(u=>{const d=gi(a,u.element,new Map);u.postStyleProps.forEach(h=>d.set(h,null))})):(s.push(function BOe(){return new te(3300,!1)}()),o=[]),s.length)throw function VOe(n){return new te(3504,!1)}();a.forEach((u,d)=>{u.forEach((h,f)=>{u.set(f,this._driver.computeStyle(d,f,Ta))})});const c=Nl(o.map(u=>{const d=a.get(u.element);return this._buildPlayer(u,new Map,d)}));return this._playersById.set(t,c),c.onDestroy(()=>this.destroy(t)),this.players.push(c),c}destroy(t){const e=this._getPlayer(t);e.destroy(),this._playersById.delete(t);const r=this.players.indexOf(e);r>=0&&this.players.splice(r,1)}_getPlayer(t){const e=this._playersById.get(t);if(!e)throw function zOe(n){return new te(3301,!1)}();return e}listen(t,e,r,s){const i=Rk(e,"","","");return Nk(this._getPlayer(t),r,i,s),()=>{}}command(t,e,r,s){if("register"==r)return void this.register(t,s[0]);if("create"==r)return void this.create(t,e,s[0]||{});const i=this._getPlayer(t);switch(r){case"play":i.play();break;case"pause":i.pause();break;case"reset":i.reset();break;case"restart":i.restart();break;case"finish":i.finish();break;case"init":i.init();break;case"setPosition":i.setPosition(parseFloat(s[0]));break;case"destroy":this.destroy(t)}}}const rG="ng-animate-queued",Kk="ng-animate-disabled",H2e=[],sG={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},W2e={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0},Wi="__ng_removed";class Xk{constructor(t,e=""){this.namespaceId=e;const r=t&&t.hasOwnProperty("value");if(this.value=function K2e(n){return n??null}(r?t.value:t),r){const i=Rm(t);delete i.value,this.options=i}else this.options={};this.options.params||(this.options.params={})}get params(){return this.options.params}absorbOptions(t){const e=t.params;if(e){const r=this.options.params;Object.keys(e).forEach(s=>{null==r[s]&&(r[s]=e[s])})}}}const Om="void",Yk=new Xk(Om);class j2e{constructor(t,e,r){this.id=t,this.hostElement=e,this._engine=r,this.players=[],this._triggers=new Map,this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,ji(e,this._hostClassName)}listen(t,e,r,s){if(!this._triggers.has(e))throw function UOe(n,t){return new te(3302,!1)}();if(null==r||0==r.length)throw function HOe(n){return new te(3303,!1)}();if(!function X2e(n){return"start"==n||"done"==n}(r))throw function WOe(n,t){return new te(3400,!1)}();const i=gi(this._elementListeners,t,[]),o={name:e,phase:r,callback:s};i.push(o);const a=gi(this._engine.statesByElement,t,new Map);return a.has(e)||(ji(t,cx),ji(t,cx+"-"+e),a.set(e,Yk)),()=>{this._engine.afterFlush(()=>{const l=i.indexOf(o);l>=0&&i.splice(l,1),this._triggers.has(e)||a.delete(e)})}}register(t,e){return!this._triggers.has(t)&&(this._triggers.set(t,e),!0)}_getTrigger(t){const e=this._triggers.get(t);if(!e)throw function jOe(n){return new te(3401,!1)}();return e}trigger(t,e,r,s=!0){const i=this._getTrigger(e),o=new Zk(this.id,e,t);let a=this._engine.statesByElement.get(t);a||(ji(t,cx),ji(t,cx+"-"+e),this._engine.statesByElement.set(t,a=new Map));let l=a.get(e);const c=new Xk(r,this.id);if(!(r&&r.hasOwnProperty("value"))&&l&&c.absorbOptions(l.options),a.set(e,c),l||(l=Yk),c.value!==Om&&l.value===c.value){if(!function Q2e(n,t){const e=Object.keys(n),r=Object.keys(t);if(e.length!=r.length)return!1;for(let s=0;s<e.length;s++){const i=e[s];if(!t.hasOwnProperty(i)||n[i]!==t[i])return!1}return!0}(l.params,c.params)){const m=[],g=i.matchStyles(l.value,l.params,m),y=i.matchStyles(c.value,c.params,m);m.length?this._engine.reportError(m):this._engine.afterFlush(()=>{Hc(t,g),Ko(t,y)})}return}const h=gi(this._engine.playersByElement,t,[]);h.forEach(m=>{m.namespaceId==this.id&&m.triggerName==e&&m.queued&&m.destroy()});let f=i.matchTransition(l.value,c.value,t,c.params),p=!1;if(!f){if(!s)return;f=i.fallbackTransition,p=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:f,fromState:l,toState:c,player:o,isFallbackTransition:p}),p||(ji(t,rG),o.onStart(()=>{nh(t,rG)})),o.onDone(()=>{let m=this.players.indexOf(o);m>=0&&this.players.splice(m,1);const g=this._engine.playersByElement.get(t);if(g){let y=g.indexOf(o);y>=0&&g.splice(y,1)}}),this.players.push(o),h.push(o),o}deregister(t){this._triggers.delete(t),this._engine.statesByElement.forEach(e=>e.delete(t)),this._elementListeners.forEach((e,r)=>{this._elementListeners.set(r,e.filter(s=>s.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(r=>r.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const r=this._engine.driver.query(t,ux,!0);r.forEach(s=>{if(s[Wi])return;const i=this._engine.fetchNamespacesByElement(s);i.size?i.forEach(o=>o.triggerLeaveAnimation(s,e,!1,!0)):this.clearElementCache(s)}),this._engine.afterFlushAnimationsDone(()=>r.forEach(s=>this.clearElementCache(s)))}triggerLeaveAnimation(t,e,r,s){const i=this._engine.statesByElement.get(t),o=new Map;if(i){const a=[];if(i.forEach((l,c)=>{if(o.set(c,l.value),this._triggers.has(c)){const u=this.trigger(t,c,Om,s);u&&a.push(u)}}),a.length)return this._engine.markElementAsRemoved(this.id,t,!0,e,o),r&&Nl(a).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),r=this._engine.statesByElement.get(t);if(e&&r){const s=new Set;e.forEach(i=>{const o=i.name;if(s.has(o))return;s.add(o);const l=this._triggers.get(o).fallbackTransition,c=r.get(o)||Yk,u=new Xk(Om),d=new Zk(this.id,o,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:o,transition:l,fromState:c,toState:u,player:d,isFallbackTransition:!0})})}}removeNode(t,e){const r=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let s=!1;if(r.totalAnimations){const i=r.players.length?r.playersByQueriedElement.get(t):[];if(i&&i.length)s=!0;else{let o=t;for(;o=o.parentNode;)if(r.statesByElement.get(o)){s=!0;break}}}if(this.prepareLeaveAnimationListeners(t),s)r.markElementAsRemoved(this.id,t,!1,e);else{const i=t[Wi];(!i||i===sG)&&(r.afterFlush(()=>this.clearElementCache(t)),r.destroyInnerAnimations(t),r._onRemovalComplete(t,e))}}insertNode(t,e){ji(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(r=>{const s=r.player;if(s.destroyed)return;const i=r.element,o=this._elementListeners.get(i);o&&o.forEach(a=>{if(a.name==r.triggerName){const l=Rk(i,r.triggerName,r.fromState.value,r.toState.value);l._data=t,Nk(r.player,a.phase,l,a.callback)}}),s.markedForDestroy?this._engine.afterFlush(()=>{s.destroy()}):e.push(r)}),this._queue=[],e.sort((r,s)=>{const i=r.transition.ast.depCount,o=s.transition.ast.depCount;return 0==i||0==o?i-o:this._engine.driver.containsElement(r.element,s.element)?1:-1})}destroy(t){this.players.forEach(e=>e.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(r=>r.element===t)||e,e}}class G2e{constructor(t,e,r){this.bodyNode=t,this.driver=e,this._normalizer=r,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(s,i)=>{}}_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(r=>{r.queued&&t.push(r)})}),t}createNamespace(t,e){const r=new j2e(t,e,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,e)?this._balanceNamespaceList(r,e):(this.newHostElements.set(e,r),this.collectEnterElement(e)),this._namespaceLookup[t]=r}_balanceNamespaceList(t,e){const r=this._namespaceList,s=this.namespacesByHostElement;if(r.length-1>=0){let o=!1,a=this.driver.getParentElement(e);for(;a;){const l=s.get(a);if(l){const c=r.indexOf(l);r.splice(c+1,0,t),o=!0;break}a=this.driver.getParentElement(a)}o||r.unshift(t)}else r.push(t);return s.set(e,t),t}register(t,e){let r=this._namespaceLookup[t];return r||(r=this.createNamespace(t,e)),r}registerTrigger(t,e,r){let s=this._namespaceLookup[t];s&&s.register(e,r)&&this.totalAnimations++}destroy(t,e){if(!t)return;const r=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(r.hostElement),delete this._namespaceLookup[t];const s=this._namespaceList.indexOf(r);s>=0&&this._namespaceList.splice(s,1)}),this.afterFlushAnimationsDone(()=>r.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,r=this.statesByElement.get(t);if(r)for(let s of r.values())if(s.namespaceId){const i=this._fetchNamespace(s.namespaceId);i&&e.add(i)}return e}trigger(t,e,r,s){if(xx(e)){const i=this._fetchNamespace(t);if(i)return i.trigger(e,r,s),!0}return!1}insertNode(t,e,r,s){if(!xx(e))return;const i=e[Wi];if(i&&i.setForRemoval){i.setForRemoval=!1,i.setForMove=!0;const o=this.collectedLeaveElements.indexOf(e);o>=0&&this.collectedLeaveElements.splice(o,1)}if(t){const o=this._fetchNamespace(t);o&&o.insertNode(e,r)}s&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),ji(t,Kk)):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),nh(t,Kk))}removeNode(t,e,r,s){if(xx(e)){const i=t?this._fetchNamespace(t):null;if(i?i.removeNode(e,s):this.markElementAsRemoved(t,e,!1,s),r){const o=this.namespacesByHostElement.get(e);o&&o.id!==t&&o.removeNode(e,s)}}else this._onRemovalComplete(e,s)}markElementAsRemoved(t,e,r,s,i){this.collectedLeaveElements.push(e),e[Wi]={namespaceId:t,setForRemoval:s,hasAnimation:r,removedBeforeQueried:!1,previousTriggersValues:i}}listen(t,e,r,s,i){return xx(e)?this._fetchNamespace(t).listen(e,r,s,i):()=>{}}_buildInstruction(t,e,r,s,i){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,r,s,t.fromState.options,t.toState.options,e,i)}destroyInnerAnimations(t){let e=this.driver.query(t,ux,!0);e.forEach(r=>this.destroyActiveAnimationsForElement(r)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,$k,!0),e.forEach(r=>this.finishActiveQueriedAnimationOnElement(r)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(r=>{r.queued?r.markedForDestroy=!0:r.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(r=>r.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return Nl(this.players).onDone(()=>t());t()})}processLeaveNode(t){const e=t[Wi];if(e&&e.setForRemoval){if(t[Wi]=sG,e.namespaceId){this.destroyInnerAnimations(t);const r=this._fetchNamespace(e.namespaceId);r&&r.clearElementCache(t)}this._onRemovalComplete(t,e.setForRemoval)}t.classList?.contains(Kk)&&this.markElementAsDisabled(t,!1),this.driver.query(t,".ng-animate-disabled",!0).forEach(r=>{this.markElementAsDisabled(r,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((r,s)=>this._balanceNamespaceList(r,s)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let r=0;r<this.collectedEnterElements.length;r++)ji(this.collectedEnterElements[r],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const r=[];try{e=this._flushAnimations(r,t)}finally{for(let s=0;s<r.length;s++)r[s]()}}else for(let r=0;r<this.collectedLeaveElements.length;r++)this.processLeaveNode(this.collectedLeaveElements[r]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(r=>r()),this._flushFns=[],this._whenQuietFns.length){const r=this._whenQuietFns;this._whenQuietFns=[],e.length?Nl(e).onDone(()=>{r.forEach(s=>s())}):r.forEach(s=>s())}}reportError(t){throw function GOe(n){return new te(3402,!1)}()}_flushAnimations(t,e){const r=new bx,s=[],i=new Map,o=[],a=new Map,l=new Map,c=new Map,u=new Set;this.disabledNodes.forEach(P=>{u.add(P);const B=this.driver.query(P,".ng-animate-queued",!0);for(let L=0;L<B.length;L++)u.add(B[L])});const d=this.bodyNode,h=Array.from(this.statesByElement.keys()),f=aG(h,this.collectedEnterElements),p=new Map;let m=0;f.forEach((P,B)=>{const L=Pk+m++;p.set(B,L),P.forEach(W=>ji(W,L))});const g=[],y=new Set,b=new Set;for(let P=0;P<this.collectedLeaveElements.length;P++){const B=this.collectedLeaveElements[P],L=B[Wi];L&&L.setForRemoval&&(g.push(B),y.add(B),L.hasAnimation?this.driver.query(B,".ng-star-inserted",!0).forEach(W=>y.add(W)):b.add(B))}const _=new Map,v=aG(h,Array.from(y));v.forEach((P,B)=>{const L=lx+m++;_.set(B,L),P.forEach(W=>ji(W,L))}),t.push(()=>{f.forEach((P,B)=>{const L=p.get(B);P.forEach(W=>nh(W,L))}),v.forEach((P,B)=>{const L=_.get(B);P.forEach(W=>nh(W,L))}),g.forEach(P=>{this.processLeaveNode(P)})});const w=[],C=[];for(let P=this._namespaceList.length-1;P>=0;P--)this._namespaceList[P].drainQueuedTransitions(e).forEach(L=>{const W=L.player,ne=L.element;if(w.push(W),this.collectedEnterElements.length){const _e=ne[Wi];if(_e&&_e.setForMove){if(_e.previousTriggersValues&&_e.previousTriggersValues.has(L.triggerName)){const Me=_e.previousTriggersValues.get(L.triggerName),ke=this.statesByElement.get(L.element);if(ke&&ke.has(L.triggerName)){const Ze=ke.get(L.triggerName);Ze.value=Me,ke.set(L.triggerName,Ze)}}return void W.destroy()}}const ie=!d||!this.driver.containsElement(d,ne),de=_.get(ne),ue=p.get(ne),he=this._buildInstruction(L,r,ue,de,ie);if(he.errors&&he.errors.length)return void C.push(he);if(ie)return W.onStart(()=>Hc(ne,he.fromStyles)),W.onDestroy(()=>Ko(ne,he.toStyles)),void s.push(W);if(L.isFallbackTransition)return W.onStart(()=>Hc(ne,he.fromStyles)),W.onDestroy(()=>Ko(ne,he.toStyles)),void s.push(W);const ge=[];he.timelines.forEach(_e=>{_e.stretchStartingKeyframe=!0,this.disabledNodes.has(_e.element)||ge.push(_e)}),he.timelines=ge,r.append(ne,he.timelines),o.push({instruction:he,player:W,element:ne}),he.queriedElements.forEach(_e=>gi(a,_e,[]).push(W)),he.preStyleProps.forEach((_e,Me)=>{if(_e.size){let ke=l.get(Me);ke||l.set(Me,ke=new Set),_e.forEach((Ze,at)=>ke.add(at))}}),he.postStyleProps.forEach((_e,Me)=>{let ke=c.get(Me);ke||c.set(Me,ke=new Set),_e.forEach((Ze,at)=>ke.add(at))})});if(C.length){const P=[];C.forEach(B=>{P.push(function qOe(n,t){return new te(3505,!1)}())}),w.forEach(B=>B.destroy()),this.reportError(P)}const I=new Map,D=new Map;o.forEach(P=>{const B=P.element;r.has(B)&&(D.set(B,B),this._beforeAnimationBuild(P.player.namespaceId,P.instruction,I))}),s.forEach(P=>{const B=P.element;this._getPreviousPlayers(B,!1,P.namespaceId,P.triggerName,null).forEach(W=>{gi(I,B,[]).push(W),W.destroy()})});const T=g.filter(P=>cG(P,l,c)),N=new Map;oG(N,this.driver,b,c,Ta).forEach(P=>{cG(P,l,c)&&T.push(P)});const z=new Map;f.forEach((P,B)=>{oG(z,this.driver,new Set(P),l,"!")}),T.forEach(P=>{const B=N.get(P),L=z.get(P);N.set(P,new Map([...Array.from(B?.entries()??[]),...Array.from(L?.entries()??[])]))});const j=[],q=[],K={};o.forEach(P=>{const{element:B,player:L,instruction:W}=P;if(r.has(B)){if(u.has(B))return L.onDestroy(()=>Ko(B,W.toStyles)),L.disabled=!0,L.overrideTotalTime(W.totalTime),void s.push(L);let ne=K;if(D.size>1){let de=B;const ue=[];for(;de=de.parentNode;){const he=D.get(de);if(he){ne=he;break}ue.push(de)}ue.forEach(he=>D.set(he,ne))}const ie=this._buildAnimation(L.namespaceId,W,I,i,z,N);if(L.setRealPlayer(ie),ne===K)j.push(L);else{const de=this.playersByElement.get(ne);de&&de.length&&(L.parentPlayer=Nl(de)),s.push(L)}}else Hc(B,W.fromStyles),L.onDestroy(()=>Ko(B,W.toStyles)),q.push(L),u.has(B)&&s.push(L)}),q.forEach(P=>{const B=i.get(P.element);if(B&&B.length){const L=Nl(B);P.setRealPlayer(L)}}),s.forEach(P=>{P.parentPlayer?P.syncPlayerEvents(P.parentPlayer):P.destroy()});for(let P=0;P<g.length;P++){const B=g[P],L=B[Wi];if(nh(B,lx),L&&L.hasAnimation)continue;let W=[];if(a.size){let ie=a.get(B);ie&&ie.length&&W.push(...ie);let de=this.driver.query(B,$k,!0);for(let ue=0;ue<de.length;ue++){let he=a.get(de[ue]);he&&he.length&&W.push(...he)}}const ne=W.filter(ie=>!ie.destroyed);ne.length?Y2e(this,B,ne):this.processLeaveNode(B)}return g.length=0,j.forEach(P=>{this.players.push(P),P.onDone(()=>{P.destroy();const B=this.players.indexOf(P);this.players.splice(B,1)}),P.play()}),j}elementContainsData(t,e){let r=!1;const s=e[Wi];return s&&s.setForRemoval&&(r=!0),this.playersByElement.has(e)&&(r=!0),this.playersByQueriedElement.has(e)&&(r=!0),this.statesByElement.has(e)&&(r=!0),this._fetchNamespace(t).elementContainsData(e)||r}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,r,s,i){let o=[];if(e){const a=this.playersByQueriedElement.get(t);a&&(o=a)}else{const a=this.playersByElement.get(t);if(a){const l=!i||i==Om;a.forEach(c=>{c.queued||!l&&c.triggerName!=s||o.push(c)})}}return(r||s)&&(o=o.filter(a=>!(r&&r!=a.namespaceId||s&&s!=a.triggerName))),o}_beforeAnimationBuild(t,e,r){const i=e.element,o=e.isRemovalTransition?void 0:t,a=e.isRemovalTransition?void 0:e.triggerName;for(const l of e.timelines){const c=l.element,u=c!==i,d=gi(r,c,[]);this._getPreviousPlayers(c,u,o,a,e.toState).forEach(f=>{const p=f.getRealPlayer();p.beforeDestroy&&p.beforeDestroy(),f.destroy(),d.push(f)})}Hc(i,e.fromStyles)}_buildAnimation(t,e,r,s,i,o){const a=e.triggerName,l=e.element,c=[],u=new Set,d=new Set,h=e.timelines.map(p=>{const m=p.element;u.add(m);const g=m[Wi];if(g&&g.removedBeforeQueried)return new Sm(p.duration,p.delay);const y=m!==l,b=function Z2e(n){const t=[];return lG(n,t),t}((r.get(m)||H2e).map(I=>I.getRealPlayer())).filter(I=>!!I.element&&I.element===m),_=i.get(m),v=o.get(m),w=Fj(0,this._normalizer,0,p.keyframes,_,v),C=this._buildPlayer(p,w,b);if(p.subTimeline&&s&&d.add(m),y){const I=new Zk(t,a,m);I.setRealPlayer(C),c.push(I)}return C});c.forEach(p=>{gi(this.playersByQueriedElement,p.element,[]).push(p),p.onDone(()=>function q2e(n,t,e){let r=n.get(t);if(r){if(r.length){const s=r.indexOf(e);r.splice(s,1)}0==r.length&&n.delete(t)}return r}(this.playersByQueriedElement,p.element,p))}),u.forEach(p=>ji(p,Hj));const f=Nl(h);return f.onDestroy(()=>{u.forEach(p=>nh(p,Hj)),Ko(l,e.toStyles)}),d.forEach(p=>{gi(s,p,[]).push(f)}),f}_buildPlayer(t,e,r){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,r):new Sm(t.duration,t.delay)}}class Zk{constructor(t,e,r){this.namespaceId=t,this.triggerName=e,this.element=r,this._player=new Sm,this._containsRealPlayer=!1,this._queuedCallbacks=new Map,this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,this._queuedCallbacks.forEach((e,r)=>{e.forEach(s=>Nk(t,r,void 0,s))}),this._queuedCallbacks.clear(),this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){gi(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function xx(n){return n&&1===n.nodeType}function iG(n,t){const e=n.style.display;return n.style.display=t??"none",e}function oG(n,t,e,r,s){const i=[];e.forEach(l=>i.push(iG(l)));const o=[];r.forEach((l,c)=>{const u=new Map;l.forEach(d=>{const h=t.computeStyle(c,d,s);u.set(d,h),(!h||0==h.length)&&(c[Wi]=W2e,o.push(c))}),n.set(c,u)});let a=0;return e.forEach(l=>iG(l,i[a++])),o}function aG(n,t){const e=new Map;if(n.forEach(a=>e.set(a,[])),0==t.length)return e;const s=new Set(t),i=new Map;function o(a){if(!a)return 1;let l=i.get(a);if(l)return l;const c=a.parentNode;return l=e.has(c)?c:s.has(c)?1:o(c),i.set(a,l),l}return t.forEach(a=>{const l=o(a);1!==l&&e.get(l).push(a)}),e}function ji(n,t){n.classList?.add(t)}function nh(n,t){n.classList?.remove(t)}function Y2e(n,t,e){Nl(e).onDone(()=>n.processLeaveNode(t))}function lG(n,t){for(let e=0;e<n.length;e++){const r=n[e];r instanceof VH?lG(r.players,t):t.push(r)}}function cG(n,t,e){const r=e.get(n);if(!r)return!1;let s=t.get(n);return s?r.forEach(i=>s.add(i)):t.set(n,r),e.delete(n),!0}class wx{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._triggerCache={},this.onRemovalComplete=(s,i)=>{},this._transitionEngine=new G2e(t,e,r),this._timelineEngine=new L2e(t,e,r),this._transitionEngine.onRemovalComplete=(s,i)=>this.onRemovalComplete(s,i)}registerTrigger(t,e,r,s,i){const o=t+"-"+s;let a=this._triggerCache[o];if(!a){const l=[],u=zk(this._driver,i,l,[]);if(l.length)throw function POe(n,t){return new te(3404,!1)}();a=function F2e(n,t,e){return new O2e(n,t,e)}(s,u,this._normalizer),this._triggerCache[o]=a}this._transitionEngine.registerTrigger(e,s,a)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,r,s){this._transitionEngine.insertNode(t,e,r,s)}onRemove(t,e,r,s){this._transitionEngine.removeNode(t,e,s||!1,r)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,r,s){if("@"==r.charAt(0)){const[i,o]=Oj(r);this._timelineEngine.command(i,e,o,s)}else this._transitionEngine.trigger(t,e,r,s)}listen(t,e,r,s,i){if("@"==r.charAt(0)){const[o,a]=Oj(r);return this._timelineEngine.listen(o,e,a,i)}return this._transitionEngine.listen(t,e,r,s,i)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}let ePe=(()=>{class n{constructor(e,r,s){this._element=e,this._startStyles=r,this._endStyles=s,this._state=0;let i=n.initialStylesByElement.get(e);i||n.initialStylesByElement.set(e,i=new Map),this._initialStyles=i}start(){this._state<1&&(this._startStyles&&Ko(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(Ko(this._element,this._initialStyles),this._endStyles&&(Ko(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(n.initialStylesByElement.delete(this._element),this._startStyles&&(Hc(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(Hc(this._element,this._endStyles),this._endStyles=null),Ko(this._element,this._initialStyles),this._state=3)}}return n.initialStylesByElement=new WeakMap,n})();function Qk(n){let t=null;return n.forEach((e,r)=>{(function tPe(n){return"display"===n||"position"===n})(r)&&(t=t||new Map,t.set(r,e))}),t}class uG{constructor(t,e,r,s){this.element=t,this.keyframes=e,this.options=r,this._specialStyles=s,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this._originalOnDoneFns=[],this._originalOnStartFns=[],this.time=0,this.parentPlayer=null,this.currentSnapshot=new Map,this._duration=r.duration,this._delay=r.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:new Map,this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_convertKeyframesToObject(t){const e=[];return t.forEach(r=>{e.push(Object.fromEntries(r))}),e}_triggerWebAnimation(t,e,r){return t.animate(this._convertKeyframesToObject(e),r)}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t=new Map;this.hasStarted()&&this._finalKeyframe.forEach((r,s)=>{"offset"!==s&&t.set(s,this._finished?r:Xj(this.element,s))}),this.currentSnapshot=t}triggerCallback(t){const e="start"===t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class nPe{validateStyleProperty(t){return!0}validateAnimatableStyleProperty(t){return!0}matchesElement(t,e){return!1}containsElement(t,e){return Bj(t,e)}getParentElement(t){return Fk(t)}query(t,e,r){return Vj(t,e,r)}computeStyle(t,e,r){return window.getComputedStyle(t)[e]}animate(t,e,r,s,i,o=[]){const l={duration:r,delay:s,fill:0==s?"both":"forwards"};i&&(l.easing=i);const c=new Map,u=o.filter(f=>f instanceof uG);(function o2e(n,t){return 0===n||0===t})(r,s)&&u.forEach(f=>{f.currentSnapshot.forEach((p,m)=>c.set(m,p))});let d=function n2e(n){return n.length?n[0]instanceof Map?n:n.map(t=>Wj(t)):[]}(e).map(f=>Al(f));d=function a2e(n,t,e){if(e.size&&t.length){let r=t[0],s=[];if(e.forEach((i,o)=>{r.has(o)||s.push(o),r.set(o,i)}),s.length)for(let i=1;i<t.length;i++){let o=t[i];s.forEach(a=>o.set(a,Xj(n,a)))}}return t}(t,d,c);const h=function J2e(n,t){let e=null,r=null;return Array.isArray(t)&&t.length?(e=Qk(t[0]),t.length>1&&(r=Qk(t[t.length-1]))):t instanceof Map&&(e=Qk(t)),e||r?new ePe(n,e,r):null}(t,d);return new uG(t,d,l,h)}}let rPe=(()=>{class n extends $H{constructor(e,r){super(),this._nextAnimationId=0,this._renderer=e.createRenderer(r.body,{id:"0",encapsulation:qi.None,styles:[],data:{animation:[]}})}build(e){const r=this._nextAnimationId.toString();this._nextAnimationId++;const s=Array.isArray(e)?LH(e):e;return dG(this._renderer,null,r,"register",[s]),new sPe(r,this._renderer)}}return n.\u0275fac=function(e){return new(e||n)(Z(kh),Z(vt))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();class sPe extends MAe{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new iPe(this._id,t,e||{},this._renderer)}}class iPe{constructor(t,e,r,s){this.id=t,this.element=e,this._renderer=s,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",r)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return dG(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset"),this._started=!1}setPosition(t){this._command("setPosition",t)}getPosition(){return this._renderer.engine.players[+this.id]?.getPosition()??0}}function dG(n,t,e,r,s){return n.setProperty(t,`@@${e}:${r}`,s)}const hG="@.disabled";let oPe=(()=>{class n{constructor(e,r,s){this.delegate=e,this.engine=r,this._zone=s,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),r.onRemovalComplete=(i,o)=>{const a=o?.parentNode(i);a&&o.removeChild(a,i)}}createRenderer(e,r){const i=this.delegate.createRenderer(e,r);if(!(e&&r&&r.data&&r.data.animation)){let u=this._rendererCache.get(i);return u||(u=new fG("",i,this.engine,()=>this._rendererCache.delete(i)),this._rendererCache.set(i,u)),u}const o=r.id,a=r.id+"-"+this._currentId;this._currentId++,this.engine.register(a,e);const l=u=>{Array.isArray(u)?u.forEach(l):this.engine.registerTrigger(o,a,e,u.name,u)};return r.data.animation.forEach(l),new aPe(this,a,i,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(e,r,s){e>=0&&e<this._microtaskId?this._zone.run(()=>r(s)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(i=>{const[o,a]=i;o(a)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([r,s]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return n.\u0275fac=function(e){return new(e||n)(Z(kh),Z(wx),Z(yt))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();class fG{constructor(t,e,r,s){this.namespaceId=t,this.delegate=e,this.engine=r,this._onDestroy=s,this.destroyNode=this.delegate.destroyNode?i=>e.destroyNode(i):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy(),this._onDestroy?.()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,r,s=!0){this.delegate.insertBefore(t,e,r),this.engine.onInsert(this.namespaceId,e,t,s)}removeChild(t,e,r){this.engine.onRemove(this.namespaceId,e,this.delegate,r)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,r,s){this.delegate.setAttribute(t,e,r,s)}removeAttribute(t,e,r){this.delegate.removeAttribute(t,e,r)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,r,s){this.delegate.setStyle(t,e,r,s)}removeStyle(t,e,r){this.delegate.removeStyle(t,e,r)}setProperty(t,e,r){"@"==e.charAt(0)&&e==hG?this.disableAnimations(t,!!r):this.delegate.setProperty(t,e,r)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,r){return this.delegate.listen(t,e,r)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class aPe extends fG{constructor(t,e,r,s,i){super(e,r,s,i),this.factory=t,this.namespaceId=e}setProperty(t,e,r){"@"==e.charAt(0)?"."==e.charAt(1)&&e==hG?this.disableAnimations(t,r=void 0===r||!!r):this.engine.process(this.namespaceId,t,e.slice(1),r):this.delegate.setProperty(t,e,r)}listen(t,e,r){if("@"==e.charAt(0)){const s=function lPe(n){switch(n){case"body":return document.body;case"document":return document;case"window":return window;default:return n}}(t);let i=e.slice(1),o="";return"@"!=i.charAt(0)&&([i,o]=function cPe(n){const t=n.indexOf(".");return[n.substring(0,t),n.slice(t+1)]}(i)),this.engine.listen(this.namespaceId,s,i,o,a=>{this.factory.scheduleListenerCallback(a._data||-1,r,a)})}return this.delegate.listen(t,e,r)}}const pG=[{provide:$H,useClass:rPe},{provide:Gk,useFactory:function dPe(){return new N2e}},{provide:wx,useClass:(()=>{class n extends wx{constructor(e,r,s,i){super(e.body,r,s)}ngOnDestroy(){this.flush()}}return n.\u0275fac=function(e){return new(e||n)(Z(vt),Z(Ok),Z(Gk),Z(Pu))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})()},{provide:kh,useFactory:function hPe(n,t,e){return new oPe(n,t,e)},deps:[fy,wx,yt]}],Jk=[{provide:Ok,useFactory:()=>new nPe},{provide:ca,useValue:"BrowserAnimations"},...pG],mG=[{provide:Ok,useClass:zj},{provide:ca,useValue:"NoopAnimations"},...pG];let fPe=(()=>{class n{static withConfig(e){return{ngModule:n,providers:e.disableAnimations?mG:Jk}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Xt({type:n}),n.\u0275inj=Wt({providers:Jk,imports:[sP]}),n})();class Sx{static#e=this.\u0275fac=function(e){return new(e||Sx)};static#t=this.\u0275mod=Xt({type:Sx,bootstrap:[ax]});static#n=this.\u0275inj=Wt({imports:[sP,$y,HRe,fPe,wMe,PH,nOe,pOe,OFe,PFe,iW]})}VQ().bootstrapModule(Sx).catch(n=>console.error(n))},658:Ct=>{Ct.exports=Q;var _t=null;try{_t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Q(J,k,ae){this.low=0|J,this.high=0|k,this.unsigned=!!ae}function Ue(J){return!0===(J&&J.__isLong__)}Object.defineProperty(Q.prototype,"__isLong__",{value:!0}),Q.isLong=Ue;var Zn={},Ke={};function gn(J,k){var ae,je,Et;return k?(Et=0<=(J>>>=0)&&J<256)&&(je=Ke[J])?je:(ae=Ve(J,(0|J)<0?-1:0,!0),Et&&(Ke[J]=ae),ae):(Et=-128<=(J|=0)&&J<128)&&(je=Zn[J])?je:(ae=Ve(J,J<0?-1:0,!1),Et&&(Zn[J]=ae),ae)}function lt(J,k){if(isNaN(J))return k?Qn:zt;if(k){if(J<0)return Qn;if(J>=fe)return Mt}else{if(J<=-Ne)return Ft;if(J+1>=Ne)return St}return J<0?lt(-J,k).neg():Ve(J%re|0,J/re|0,k)}function Ve(J,k,ae){return new Q(J,k,ae)}Q.fromInt=gn,Q.fromNumber=lt,Q.fromBits=Ve;var st=Math.pow;function Ie(J,k,ae){if(0===J.length)throw Error("empty string");if("NaN"===J||"Infinity"===J||"+Infinity"===J||"-Infinity"===J)return zt;if("number"==typeof k?(ae=k,k=!1):k=!!k,(ae=ae||10)<2||36<ae)throw RangeError("radix");var je;if((je=J.indexOf("-"))>0)throw Error("interior hyphen");if(0===je)return Ie(J.substring(1),k,ae).neg();for(var Et=lt(st(ae,8)),ct=zt,He=0;He<J.length;He+=8){var Fn=Math.min(8,J.length-He),jn=parseInt(J.substring(He,He+Fn),ae);if(Fn<8){var ur=lt(st(ae,Fn));ct=ct.mul(ur).add(lt(jn))}else ct=(ct=ct.mul(Et)).add(lt(jn))}return ct.unsigned=k,ct}function U(J,k){return"number"==typeof J?lt(J,k):"string"==typeof J?Ie(J,k):Ve(J.low,J.high,"boolean"==typeof k?k:J.unsigned)}Q.fromString=Ie,Q.fromValue=U;var re=4294967296,fe=re*re,Ne=fe/2,Fe=gn(1<<24),zt=gn(0);Q.ZERO=zt;var Qn=gn(0,!0);Q.UZERO=Qn;var Wn=gn(1);Q.ONE=Wn;var _i=gn(1,!0);Q.UONE=_i;var Hs=gn(-1);Q.NEG_ONE=Hs;var St=Ve(-1,2147483647,!1);Q.MAX_VALUE=St;var Mt=Ve(-1,-1,!0);Q.MAX_UNSIGNED_VALUE=Mt;var Ft=Ve(0,-2147483648,!1);Q.MIN_VALUE=Ft;var ce=Q.prototype;ce.toInt=function(){return this.unsigned?this.low>>>0:this.low},ce.toNumber=function(){return this.unsigned?(this.high>>>0)*re+(this.low>>>0):this.high*re+(this.low>>>0)},ce.toString=function(k){if((k=k||10)<2||36<k)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Ft)){var ae=lt(k),je=this.div(ae),Et=je.mul(ae).sub(this);return je.toString(k)+Et.toInt().toString(k)}return"-"+this.neg().toString(k)}for(var ct=lt(st(k,6),this.unsigned),He=this,Fn="";;){var jn=He.div(ct),Zt=(He.sub(jn.mul(ct)).toInt()>>>0).toString(k);if((He=jn).isZero())return Zt+Fn;for(;Zt.length<6;)Zt="0"+Zt;Fn=""+Zt+Fn}},ce.getHighBits=function(){return this.high},ce.getHighBitsUnsigned=function(){return this.high>>>0},ce.getLowBits=function(){return this.low},ce.getLowBitsUnsigned=function(){return this.low>>>0},ce.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Ft)?64:this.neg().getNumBitsAbs();for(var k=0!=this.high?this.high:this.low,ae=31;ae>0&&0==(k&1<<ae);ae--);return 0!=this.high?ae+33:ae+1},ce.isZero=function(){return 0===this.high&&0===this.low},ce.eqz=ce.isZero,ce.isNegative=function(){return!this.unsigned&&this.high<0},ce.isPositive=function(){return this.unsigned||this.high>=0},ce.isOdd=function(){return 1==(1&this.low)},ce.isEven=function(){return 0==(1&this.low)},ce.equals=function(k){return Ue(k)||(k=U(k)),(this.unsigned===k.unsigned||this.high>>>31!=1||k.high>>>31!=1)&&this.high===k.high&&this.low===k.low},ce.eq=ce.equals,ce.notEquals=function(k){return!this.eq(k)},ce.neq=ce.notEquals,ce.ne=ce.notEquals,ce.lessThan=function(k){return this.comp(k)<0},ce.lt=ce.lessThan,ce.lessThanOrEqual=function(k){return this.comp(k)<=0},ce.lte=ce.lessThanOrEqual,ce.le=ce.lessThanOrEqual,ce.greaterThan=function(k){return this.comp(k)>0},ce.gt=ce.greaterThan,ce.greaterThanOrEqual=function(k){return this.comp(k)>=0},ce.gte=ce.greaterThanOrEqual,ce.ge=ce.greaterThanOrEqual,ce.compare=function(k){if(Ue(k)||(k=U(k)),this.eq(k))return 0;var ae=this.isNegative(),je=k.isNegative();return ae&&!je?-1:!ae&&je?1:this.unsigned?k.high>>>0>this.high>>>0||k.high===this.high&&k.low>>>0>this.low>>>0?-1:1:this.sub(k).isNegative()?-1:1},ce.comp=ce.compare,ce.negate=function(){return!this.unsigned&&this.eq(Ft)?Ft:this.not().add(Wn)},ce.neg=ce.negate,ce.add=function(k){Ue(k)||(k=U(k));var Zt=0,Fr=0,Gn=0,Or=0;return Gn+=(Or+=(65535&this.low)+(65535&k.low))>>>16,Fr+=(Gn+=(this.low>>>16)+(k.low>>>16))>>>16,Zt+=(Fr+=(65535&this.high)+(65535&k.high))>>>16,Zt+=(this.high>>>16)+(k.high>>>16),Ve((Gn&=65535)<<16|(Or&=65535),(Zt&=65535)<<16|(Fr&=65535),this.unsigned)},ce.subtract=function(k){return Ue(k)||(k=U(k)),this.add(k.neg())},ce.sub=ce.subtract,ce.multiply=function(k){if(this.isZero())return zt;if(Ue(k)||(k=U(k)),_t)return Ve(_t.mul(this.low,this.high,k.low,k.high),_t.get_high(),this.unsigned);if(k.isZero())return zt;if(this.eq(Ft))return k.isOdd()?Ft:zt;if(k.eq(Ft))return this.isOdd()?Ft:zt;if(this.isNegative())return k.isNegative()?this.neg().mul(k.neg()):this.neg().mul(k).neg();if(k.isNegative())return this.mul(k.neg()).neg();if(this.lt(Fe)&&k.lt(Fe))return lt(this.toNumber()*k.toNumber(),this.unsigned);var Et=65535&this.high,ct=this.low>>>16,He=65535&this.low,jn=65535&k.high,ur=k.low>>>16,Zt=65535&k.low,Fr=0,Gn=0,Or=0,Gc=0;return Or+=(Gc+=He*Zt)>>>16,Gn+=(Or+=ct*Zt)>>>16,Or&=65535,Gn+=(Or+=He*ur)>>>16,Fr+=(Gn+=Et*Zt)>>>16,Gn&=65535,Fr+=(Gn+=ct*ur)>>>16,Gn&=65535,Fr+=(Gn+=He*jn)>>>16,Fr+=(this.high>>>16)*Zt+Et*ur+ct*jn+He*(k.high>>>16),Ve((Or&=65535)<<16|(Gc&=65535),(Fr&=65535)<<16|(Gn&=65535),this.unsigned)},ce.mul=ce.multiply,ce.divide=function(k){if(Ue(k)||(k=U(k)),k.isZero())throw Error("division by zero");var je,Et,ct;if(_t)return this.unsigned||-2147483648!==this.high||-1!==k.low||-1!==k.high?Ve((this.unsigned?_t.div_u:_t.div_s)(this.low,this.high,k.low,k.high),_t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?Qn:zt;if(this.unsigned){if(k.unsigned||(k=k.toUnsigned()),k.gt(this))return Qn;if(k.gt(this.shru(1)))return _i;ct=Qn}else{if(this.eq(Ft))return k.eq(Wn)||k.eq(Hs)?Ft:k.eq(Ft)?Wn:(je=this.shr(1).div(k).shl(1)).eq(zt)?k.isNegative()?Wn:Hs:(Et=this.sub(k.mul(je)),ct=je.add(Et.div(k)));if(k.eq(Ft))return this.unsigned?Qn:zt;if(this.isNegative())return k.isNegative()?this.neg().div(k.neg()):this.neg().div(k).neg();if(k.isNegative())return this.div(k.neg()).neg();ct=zt}for(Et=this;Et.gte(k);){je=Math.max(1,Math.floor(Et.toNumber()/k.toNumber()));for(var Fn=Math.ceil(Math.log(je)/Math.LN2),jn=Fn<=48?1:st(2,Fn-48),ur=lt(je),Zt=ur.mul(k);Zt.isNegative()||Zt.gt(Et);)Zt=(ur=lt(je-=jn,this.unsigned)).mul(k);ur.isZero()&&(ur=Wn),ct=ct.add(ur),Et=Et.sub(Zt)}return ct},ce.div=ce.divide,ce.modulo=function(k){return Ue(k)||(k=U(k)),_t?Ve((this.unsigned?_t.rem_u:_t.rem_s)(this.low,this.high,k.low,k.high),_t.get_high(),this.unsigned):this.sub(this.div(k).mul(k))},ce.mod=ce.modulo,ce.rem=ce.modulo,ce.not=function(){return Ve(~this.low,~this.high,this.unsigned)},ce.and=function(k){return Ue(k)||(k=U(k)),Ve(this.low&k.low,this.high&k.high,this.unsigned)},ce.or=function(k){return Ue(k)||(k=U(k)),Ve(this.low|k.low,this.high|k.high,this.unsigned)},ce.xor=function(k){return Ue(k)||(k=U(k)),Ve(this.low^k.low,this.high^k.high,this.unsigned)},ce.shiftLeft=function(k){return Ue(k)&&(k=k.toInt()),0==(k&=63)?this:k<32?Ve(this.low<<k,this.high<<k|this.low>>>32-k,this.unsigned):Ve(0,this.low<<k-32,this.unsigned)},ce.shl=ce.shiftLeft,ce.shiftRight=function(k){return Ue(k)&&(k=k.toInt()),0==(k&=63)?this:k<32?Ve(this.low>>>k|this.high<<32-k,this.high>>k,this.unsigned):Ve(this.high>>k-32,this.high>=0?0:-1,this.unsigned)},ce.shr=ce.shiftRight,ce.shiftRightUnsigned=function(k){if(Ue(k)&&(k=k.toInt()),0==(k&=63))return this;var ae=this.high;return k<32?Ve(this.low>>>k|ae<<32-k,ae>>>k,this.unsigned):Ve(32===k?ae:ae>>>k-32,0,this.unsigned)},ce.shru=ce.shiftRightUnsigned,ce.shr_u=ce.shiftRightUnsigned,ce.toSigned=function(){return this.unsigned?Ve(this.low,this.high,!1):this},ce.toUnsigned=function(){return this.unsigned?this:Ve(this.low,this.high,!0)},ce.toBytes=function(k){return k?this.toBytesLE():this.toBytesBE()},ce.toBytesLE=function(){var k=this.high,ae=this.low;return[255&ae,ae>>>8&255,ae>>>16&255,ae>>>24,255&k,k>>>8&255,k>>>16&255,k>>>24]},ce.toBytesBE=function(){var k=this.high,ae=this.low;return[k>>>24,k>>>16&255,k>>>8&255,255&k,ae>>>24,ae>>>16&255,ae>>>8&255,255&ae]},Q.fromBytes=function(k,ae,je){return je?Q.fromBytesLE(k,ae):Q.fromBytesBE(k,ae)},Q.fromBytesLE=function(k,ae){return new Q(k[0]|k[1]<<8|k[2]<<16|k[3]<<24,k[4]|k[5]<<8|k[6]<<16|k[7]<<24,ae)},Q.fromBytesBE=function(k,ae){return new Q(k[4]<<24|k[5]<<16|k[6]<<8|k[7],k[0]<<24|k[1]<<16|k[2]<<8|k[3],ae)}},340:(Ct,_t,Q)=>{var Ue=Q(471),Zn=Q(992),Ke=Q(657),gn=Q(583),lt=Q(929),Ve=Q(83),st=Q(818);st.alea=Ue,st.xor128=Zn,st.xorwow=Ke,st.xorshift7=gn,st.xor4096=lt,st.tychei=Ve,Ct.exports=st},471:function(Ct,_t,Q){var Ue;!function(Zn,Ke,gn){function lt(U){var pe=this,be=function Ie(){var U=4022871197;return function(be){be=String(be);for(var re=0;re<be.length;re++){var fe=.02519603282416938*(U+=be.charCodeAt(re));fe-=U=fe>>>0,U=(fe*=U)>>>0,U+=4294967296*(fe-=U)}return 2.3283064365386963e-10*(U>>>0)}}();pe.next=function(){var re=2091639*pe.s0+2.3283064365386963e-10*pe.c;return pe.s0=pe.s1,pe.s1=pe.s2,pe.s2=re-(pe.c=0|re)},pe.c=1,pe.s0=be(" "),pe.s1=be(" "),pe.s2=be(" "),pe.s0-=be(U),pe.s0<0&&(pe.s0+=1),pe.s1-=be(U),pe.s1<0&&(pe.s1+=1),pe.s2-=be(U),pe.s2<0&&(pe.s2+=1),be=null}function Ve(U,pe){return pe.c=U.c,pe.s0=U.s0,pe.s1=U.s1,pe.s2=U.s2,pe}function st(U,pe){var be=new lt(U),re=pe&&pe.state,fe=be.next;return fe.int32=function(){return 4294967296*be.next()|0},fe.double=function(){return fe()+11102230246251565e-32*(2097152*fe()|0)},fe.quick=fe,re&&("object"==typeof re&&Ve(re,be),fe.state=function(){return Ve(be,{})}),fe}Ke&&Ke.exports?Ke.exports=st:Q.amdD&&Q.amdO?void 0!==(Ue=function(){return st}.call(_t,Q,_t,Ke))&&(Ke.exports=Ue):this.alea=st}(0,Ct=Q.nmd(Ct))},83:function(Ct,_t,Q){var Ue;!function(Zn,Ke,gn){function lt(Ie){var U=this,pe="";U.next=function(){var re=U.b,fe=U.c,Ne=U.d,Fe=U.a;return re=re<<25^re>>>7^fe,fe=fe-Ne|0,Ne=Ne<<24^Ne>>>8^Fe,Fe=Fe-re|0,U.b=re=re<<20^re>>>12^fe,U.c=fe=fe-Ne|0,U.d=Ne<<16^fe>>>16^Fe,U.a=Fe-re|0},U.a=0,U.b=0,U.c=-1640531527,U.d=1367130551,Ie===Math.floor(Ie)?(U.a=Ie/4294967296|0,U.b=0|Ie):pe+=Ie;for(var be=0;be<pe.length+20;be++)U.b^=0|pe.charCodeAt(be),U.next()}function Ve(Ie,U){return U.a=Ie.a,U.b=Ie.b,U.c=Ie.c,U.d=Ie.d,U}function st(Ie,U){var pe=new lt(Ie),be=U&&U.state,re=function(){return(pe.next()>>>0)/4294967296};return re.double=function(){do{var Fe=((pe.next()>>>11)+(pe.next()>>>0)/4294967296)/(1<<21)}while(0===Fe);return Fe},re.int32=pe.next,re.quick=re,be&&("object"==typeof be&&Ve(be,pe),re.state=function(){return Ve(pe,{})}),re}Ke&&Ke.exports?Ke.exports=st:Q.amdD&&Q.amdO?void 0!==(Ue=function(){return st}.call(_t,Q,_t,Ke))&&(Ke.exports=Ue):this.tychei=st}(0,Ct=Q.nmd(Ct))},992:function(Ct,_t,Q){var Ue;!function(Zn,Ke,gn){function lt(Ie){var U=this,pe="";U.x=0,U.y=0,U.z=0,U.w=0,U.next=function(){var re=U.x^U.x<<11;return U.x=U.y,U.y=U.z,U.z=U.w,U.w^=U.w>>>19^re^re>>>8},Ie===(0|Ie)?U.x=Ie:pe+=Ie;for(var be=0;be<pe.length+64;be++)U.x^=0|pe.charCodeAt(be),U.next()}function Ve(Ie,U){return U.x=Ie.x,U.y=Ie.y,U.z=Ie.z,U.w=Ie.w,U}function st(Ie,U){var pe=new lt(Ie),be=U&&U.state,re=function(){return(pe.next()>>>0)/4294967296};return re.double=function(){do{var Fe=((pe.next()>>>11)+(pe.next()>>>0)/4294967296)/(1<<21)}while(0===Fe);return Fe},re.int32=pe.next,re.quick=re,be&&("object"==typeof be&&Ve(be,pe),re.state=function(){return Ve(pe,{})}),re}Ke&&Ke.exports?Ke.exports=st:Q.amdD&&Q.amdO?void 0!==(Ue=function(){return st}.call(_t,Q,_t,Ke))&&(Ke.exports=Ue):this.xor128=st}(0,Ct=Q.nmd(Ct))},929:function(Ct,_t,Q){var Ue;!function(Zn,Ke,gn){function lt(Ie){var U=this;U.next=function(){var Ne,Fe,be=U.w,re=U.X,fe=U.i;return U.w=be=be+1640531527|0,Fe=re[fe+34&127],Ne=re[fe=fe+1&127],Fe^=Fe<<13,Ne^=Ne<<17,Fe=re[fe]=(Fe^=Fe>>>15)^(Ne^=Ne>>>12),U.i=fe,Fe+(be^be>>>16)|0},function pe(be,re){var fe,Ne,Fe,zt,Qn,Wn=[],_i=128;for(re===(0|re)?(Ne=re,re=null):(re+="\0",Ne=0,_i=Math.max(_i,re.length)),Fe=0,zt=-32;zt<_i;++zt)re&&(Ne^=re.charCodeAt((zt+32)%re.length)),0===zt&&(Qn=Ne),Ne^=Ne<<10,Ne^=Ne>>>15,Ne^=Ne<<4,Ne^=Ne>>>13,zt>=0&&(Fe=0==(fe=Wn[127&zt]^=Ne+(Qn=Qn+1640531527|0))?Fe+1:0);for(Fe>=128&&(Wn[127&(re&&re.length||0)]=-1),Fe=127,zt=512;zt>0;--zt)Ne=Wn[Fe+34&127],fe=Wn[Fe=Fe+1&127],Ne^=Ne<<13,fe^=fe<<17,Wn[Fe]=(Ne^=Ne>>>15)^(fe^=fe>>>12);be.w=Qn,be.X=Wn,be.i=Fe}(U,Ie)}function Ve(Ie,U){return U.i=Ie.i,U.w=Ie.w,U.X=Ie.X.slice(),U}function st(Ie,U){null==Ie&&(Ie=+new Date);var pe=new lt(Ie),be=U&&U.state,re=function(){return(pe.next()>>>0)/4294967296};return re.double=function(){do{var Fe=((pe.next()>>>11)+(pe.next()>>>0)/4294967296)/(1<<21)}while(0===Fe);return Fe},re.int32=pe.next,re.quick=re,be&&(be.X&&Ve(be,pe),re.state=function(){return Ve(pe,{})}),re}Ke&&Ke.exports?Ke.exports=st:Q.amdD&&Q.amdO?void 0!==(Ue=function(){return st}.call(_t,Q,_t,Ke))&&(Ke.exports=Ue):this.xor4096=st}(0,Ct=Q.nmd(Ct))},583:function(Ct,_t,Q){var Ue;!function(Zn,Ke,gn){function lt(Ie){var U=this;U.next=function(){var fe,Ne,be=U.x,re=U.i;return fe=be[re],Ne=(fe^=fe>>>7)^fe<<24,Ne^=(fe=be[re+1&7])^fe>>>10,Ne^=(fe=be[re+3&7])^fe>>>3,Ne^=(fe=be[re+4&7])^fe<<7,fe=be[re+7&7],be[re]=Ne^=(fe^=fe<<13)^fe<<9,U.i=re+1&7,Ne},function pe(be,re){var fe,Fe=[];if(re===(0|re))Fe[0]=re;else for(re=""+re,fe=0;fe<re.length;++fe)Fe[7&fe]=Fe[7&fe]<<15^re.charCodeAt(fe)+Fe[fe+1&7]<<13;for(;Fe.length<8;)Fe.push(0);for(fe=0;fe<8&&0===Fe[fe];++fe);for(8==fe&&(Fe[7]=-1),be.x=Fe,be.i=0,fe=256;fe>0;--fe)be.next()}(U,Ie)}function Ve(Ie,U){return U.x=Ie.x.slice(),U.i=Ie.i,U}function st(Ie,U){null==Ie&&(Ie=+new Date);var pe=new lt(Ie),be=U&&U.state,re=function(){return(pe.next()>>>0)/4294967296};return re.double=function(){do{var Fe=((pe.next()>>>11)+(pe.next()>>>0)/4294967296)/(1<<21)}while(0===Fe);return Fe},re.int32=pe.next,re.quick=re,be&&(be.x&&Ve(be,pe),re.state=function(){return Ve(pe,{})}),re}Ke&&Ke.exports?Ke.exports=st:Q.amdD&&Q.amdO?void 0!==(Ue=function(){return st}.call(_t,Q,_t,Ke))&&(Ke.exports=Ue):this.xorshift7=st}(0,Ct=Q.nmd(Ct))},657:function(Ct,_t,Q){var Ue;!function(Zn,Ke,gn){function lt(Ie){var U=this,pe="";U.next=function(){var re=U.x^U.x>>>2;return U.x=U.y,U.y=U.z,U.z=U.w,U.w=U.v,(U.d=U.d+362437|0)+(U.v=U.v^U.v<<4^re^re<<1)|0},U.x=0,U.y=0,U.z=0,U.w=0,U.v=0,Ie===(0|Ie)?U.x=Ie:pe+=Ie;for(var be=0;be<pe.length+64;be++)U.x^=0|pe.charCodeAt(be),be==pe.length&&(U.d=U.x<<10^U.x>>>4),U.next()}function Ve(Ie,U){return U.x=Ie.x,U.y=Ie.y,U.z=Ie.z,U.w=Ie.w,U.v=Ie.v,U.d=Ie.d,U}function st(Ie,U){var pe=new lt(Ie),be=U&&U.state,re=function(){return(pe.next()>>>0)/4294967296};return re.double=function(){do{var Fe=((pe.next()>>>11)+(pe.next()>>>0)/4294967296)/(1<<21)}while(0===Fe);return Fe},re.int32=pe.next,re.quick=re,be&&("object"==typeof be&&Ve(be,pe),re.state=function(){return Ve(pe,{})}),re}Ke&&Ke.exports?Ke.exports=st:Q.amdD&&Q.amdO?void 0!==(Ue=function(){return st}.call(_t,Q,_t,Ke))&&(Ke.exports=Ue):this.xorwow=st}(0,Ct=Q.nmd(Ct))},818:function(Ct,_t,Q){var Ue;!function(Zn,Ke,gn){var fe,lt=256,U=gn.pow(lt,6),pe=gn.pow(2,52),be=2*pe;function Ne(St,Mt,Ft){var ce=[],J=Wn(Qn((Mt=1==Mt?{entropy:!0}:Mt||{}).entropy?[St,Hs(Ke)]:St??function _i(){try{var St;return fe&&(St=fe.randomBytes)?St=St(lt):(St=new Uint8Array(lt),(Zn.crypto||Zn.msCrypto).getRandomValues(St)),Hs(St)}catch{var Mt=Zn.navigator,Ft=Mt&&Mt.plugins;return[+new Date,Zn,Ft,Zn.screen,Hs(Ke)]}}(),3),ce),k=new Fe(ce),ae=function(){for(var je=k.g(6),Et=U,ct=0;je<pe;)je=(je+ct)*lt,Et*=lt,ct=k.g(1);for(;je>=be;)je/=2,Et/=2,ct>>>=1;return(je+ct)/Et};return ae.int32=function(){return 0|k.g(4)},ae.quick=function(){return k.g(4)/4294967296},ae.double=ae,Wn(Hs(k.S),Ke),(Mt.pass||Ft||function(je,Et,ct,He){return He&&(He.S&&zt(He,k),je.state=function(){return zt(k,{})}),ct?(gn.random=je,Et):je})(ae,J,"global"in Mt?Mt.global:this==gn,Mt.state)}function Fe(St){var Mt,Ft=St.length,ce=this,J=0,k=ce.i=ce.j=0,ae=ce.S=[];for(Ft||(St=[Ft++]);J<lt;)ae[J]=J++;for(J=0;J<lt;J++)ae[J]=ae[k=255&k+St[J%Ft]+(Mt=ae[J])],ae[k]=Mt;(ce.g=function(je){for(var Et,ct=0,He=ce.i,Fn=ce.j,jn=ce.S;je--;)Et=jn[He=255&He+1],ct=ct*lt+jn[255&(jn[He]=jn[Fn=255&Fn+Et])+(jn[Fn]=Et)];return ce.i=He,ce.j=Fn,ct})(lt)}function zt(St,Mt){return Mt.i=St.i,Mt.j=St.j,Mt.S=St.S.slice(),Mt}function Qn(St,Mt){var J,Ft=[],ce=typeof St;if(Mt&&"object"==ce)for(J in St)try{Ft.push(Qn(St[J],Mt-1))}catch{}return Ft.length?Ft:"string"==ce?St:St+"\0"}function Wn(St,Mt){for(var ce,Ft=St+"",J=0;J<Ft.length;)Mt[255&J]=255&(ce^=19*Mt[255&J])+Ft.charCodeAt(J++);return Hs(Mt)}function Hs(St){return String.fromCharCode.apply(0,St)}if(Wn(gn.random(),Ke),Ct.exports){Ct.exports=Ne;try{fe=Q(42)}catch{}}else void 0!==(Ue=function(){return Ne}.call(_t,Q,_t,Ct))&&(Ct.exports=Ue)}(typeof self<"u"?self:this,[],Math)},410:()=>{},628:()=>{},601:()=>{},792:()=>{},977:()=>{},42:()=>{}},Ct=>{Ct(Ct.s=170)}]);