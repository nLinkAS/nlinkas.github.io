(self.webpackChunkml_iframe=self.webpackChunkml_iframe||[]).push([[179],{903:(kt,St,Q)=>{"use strict";var He={};Q.r(He),Q.d(He,{browserFiles:()=>dre,browserHTTPRequest:()=>gre,concatenateArrayBuffers:()=>r_,copyModel:()=>Qne,decodeWeights:()=>dL,encodeWeights:()=>aE,fromMemory:()=>bre,fromMemorySync:()=>ML,getLoadHandlers:()=>Bne,getModelArtifactsForJSON:()=>uE,getModelArtifactsForJSONSync:()=>mL,getModelArtifactsInfoForJSON:()=>Rp,getSaveHandlers:()=>yL,getWeightSpecs:()=>gL,http:()=>IE,isHTTPScheme:()=>SE,listModels:()=>Yne,loadWeights:()=>hre,moveModel:()=>Jne,registerLoadRouter:()=>Lne,registerSaveRouter:()=>Pne,removeModel:()=>Zne,weightsLoaderFactory:()=>kL,withSaveHandler:()=>_re,withSaveHandlerSync:()=>vre});var er={};Q.r(er),Q.d(er,{assertParamsValid:()=>NE,computeFlatOffset:()=>ME,computeOutShape:()=>AE,getNormalizedAxes:()=>Tre,isSliceContinous:()=>RE,maskToAxes:()=>Dre,parseSliceParams:()=>o_,sliceInfo:()=>FE,startForAxis:()=>UL,startIndicesWithElidedDims:()=>BL,stopForAxis:()=>HL,stopIndicesWithElidedDims:()=>VL,stridesForAxis:()=>zL,stridesWithElidedDims:()=>$L});var Ke={};Q.r(Ke),Q.d(Ke,{conv2d:()=>jB,depthwiseConv2d:()=>tle,matMul:()=>wD});var vn={};Q.r(vn),Q.d(vn,{collectGatherOpShapeInfo:()=>r1,computeOutShape:()=>EV,segOpComputeOptimalWindowSize:()=>IV});var ut={};Q.r(ut),Q.d(ut,{ERF_A1:()=>HD,ERF_A2:()=>WD,ERF_A3:()=>jD,ERF_A4:()=>GD,ERF_A5:()=>qD,ERF_P:()=>UD,PARALLELIZE_THRESHOLD:()=>PD,RowPartitionType:()=>Hi,SELU_SCALE:()=>$_,SELU_SCALEALPHA:()=>O_,applyActivation:()=>A_,assertAndGetBroadcastShape:()=>tt,assertAxesAreInnerMostDims:()=>Lr,assertParamsConsistent:()=>$D,assignToTypedArray:()=>cV,axesAreInnerMostDims:()=>GE,calculateShapes:()=>qp,checkEinsumDimSizes:()=>QD,checkPadOnDimRoundingMode:()=>ls,combineLocations:()=>bB,combineRaggedTensorToTensorShapes:()=>nV,complexWithEvenIndex:()=>aV,complexWithOddIndex:()=>lV,computeConv2DInfo:()=>Tr,computeConv3DInfo:()=>fl,computeDefaultPad:()=>PE,computeDilation2DInfo:()=>Mp,computeOptimalWindowSize:()=>F_,computeOutAndReduceShapes:()=>kr,computeOutShape:()=>Uo,computePool2DInfo:()=>Li,computePool3DInfo:()=>Sa,convertConv2DDataFormat:()=>Ia,decodeEinsumEquation:()=>YD,eitherStridesOrDilationsAreOne:()=>Pr,expandShapeToKeepDim:()=>Hn,exponent:()=>dV,exponents:()=>uV,fromStringArrayToUint8:()=>DV,fromUint8ToStringArray:()=>Nc,getAxesPermutation:()=>An,getBroadcastDims:()=>yd,getComplexWithIndex:()=>KD,getEinsumComputePath:()=>JD,getEinsumPermutation:()=>ZD,getFusedBiasGradient:()=>N_,getFusedDyActivation:()=>k_,getImageCenter:()=>LD,getInnerMostAxes:()=>Wn,getPermuted:()=>Xp,getRaggedRank:()=>sV,getReductionAxes:()=>lr,getReshaped:()=>Kp,getReshapedPermuted:()=>Yp,getRowPartitionTypesHelper:()=>rV,getSliceBeginCoords:()=>BD,getSliceSize:()=>VD,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>pV,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>mV,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>gV,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>_V,getSparseReshapeInputOutputMismatchErrorMessage:()=>xV,getSparseReshapeInputOutputMultipleErrorMessage:()=>vV,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>yV,getSparseReshapeNegativeOutputDimErrorMessage:()=>bV,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>SV,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>n1,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>wV,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>CV,getUndoAxesPermutation:()=>gl,isIdentityPermutation:()=>e1,log:()=>rne,mergeRealAndImagArrays:()=>ka,prepareAndValidate:()=>zD,prepareSplitSize:()=>t1,segment_util:()=>vn,shouldFuse:()=>R_,slice_util:()=>er,splitRealAndImagArrays:()=>oV,tupleValuesAreOne:()=>pl,upcastType:()=>zs,validateDefaultValueShape:()=>iV,validateInput:()=>UB,validateUpdateShape:()=>zB,warn:()=>ui});var ze={};Q.r(ze),Q.d(ze,{json:()=>Ffe});var ot={};Q.r(ot),Q.d(ot,{json:()=>Ofe});var Ee={};Q.r(Ee),Q.d(Ee,{json:()=>$fe});var H={};Q.r(H),Q.d(H,{json:()=>Pfe});var pe={};Q.r(pe),Q.d(pe,{json:()=>Lfe});var be={};Q.r(be),Q.d(be,{json:()=>Bfe});var re={};Q.r(re),Q.d(re,{json:()=>Vfe});var fe={};Q.r(fe),Q.d(fe,{json:()=>zfe});var Ne={};Q.r(Ne),Q.d(Ne,{json:()=>Ufe});var $e={};Q.r($e),Q.d($e,{json:()=>Hfe});var Ht={};Q.r(Ht),Q.d(Ht,{json:()=>Wfe});var tr={};Q.r(tr),Q.d(tr,{json:()=>jfe});var qn={};Q.r(qn),Q.d(qn,{json:()=>Gfe});var Ei={};Q.r(Ei),Q.d(Ei,{json:()=>qfe});var Zs={};Q.r(Zs),Q.d(Zs,{json:()=>Kfe});var Nt={};Q.r(Nt),Q.d(Nt,{json:()=>Xfe});var Pt={};Q.r(Pt),Q.d(Pt,{json:()=>Yfe});var Lt={};Q.r(Lt),Q.d(Lt,{json:()=>Zfe});var ce={};Q.r(ce),Q.d(ce,{json:()=>Qfe});var J={};Q.r(J),Q.d(J,{OP_SCOPE_SUFFIX:()=>uL,abs:()=>cr,acos:()=>GL,acosh:()=>qL,add:()=>le,addN:()=>Bre,all:()=>$E,any:()=>l_,argMax:()=>_d,argMin:()=>KL,asin:()=>XL,asinh:()=>YL,atan:()=>ZL,atan2:()=>QL,atanh:()=>JL,avgPool:()=>u_,avgPool3d:()=>eB,basicLSTMCell:()=>cse,batchNorm:()=>Fp,batchNorm2d:()=>tB,batchNorm3d:()=>nB,batchNorm4d:()=>rB,batchToSpaceND:()=>d_,bincount:()=>sB,booleanMaskAsync:()=>Oae,broadcastArgs:()=>bse,broadcastTo:()=>wd,buffer:()=>lt,cast:()=>ve,ceil:()=>iB,clipByValue:()=>Us,clone:()=>wa,complex:()=>cl,concat:()=>Qn,concat1d:()=>oB,concat2d:()=>aB,concat3d:()=>lB,concat4d:()=>cB,conv1d:()=>BE,conv2d:()=>ml,conv2dTranspose:()=>zE,conv3d:()=>uB,conv3dTranspose:()=>hB,cos:()=>h_,cosh:()=>UE,cosineWindow:()=>_D,cumprod:()=>f_,cumsum:()=>HE,denseBincount:()=>WE,depthToSpace:()=>fB,depthwiseConv2d:()=>Op,diag:()=>zse,dilation2d:()=>pB,div:()=>Pe,divNoNan:()=>mB,dot:()=>gB,dropout:()=>HB,einsum:()=>Zse,elu:()=>$p,enclosingPowerOfTwo:()=>WB,equal:()=>go,erf:()=>yB,euclideanNorm:()=>vB,exp:()=>hi,expandDims:()=>Is,expm1:()=>xB,eye:()=>qE,fft:()=>D_,fill:()=>Cd,floor:()=>Bp,floorDiv:()=>jE,fused:()=>Ke,gather:()=>Vp,gatherND:()=>jae,greater:()=>Hs,greaterEqual:()=>bl,ifft:()=>jp,imag:()=>p_,image:()=>Ta,inTopKAsync:()=>Xae,irfft:()=>hD,isFinite:()=>wB,isInf:()=>CB,isNaN:()=>SB,leakyRelu:()=>m_,less:()=>KE,lessEqual:()=>Dc,linalg:()=>eV,linspace:()=>Sie,localResponseNormalization:()=>IB,log:()=>fi,log1p:()=>g_,logSigmoid:()=>EB,logSoftmax:()=>XE,logSumExp:()=>YE,logicalAnd:()=>Vo,logicalNot:()=>y_,logicalOr:()=>ZE,logicalXor:()=>DB,losses:()=>kce,lowerBound:()=>Bie,matMul:()=>_t,max:()=>Bi,maxPool:()=>__,maxPool3d:()=>TB,maxPoolWithArgmax:()=>Hie,maximum:()=>Ea,mean:()=>Ln,meshgrid:()=>Gie,min:()=>Pp,minimum:()=>zp,mirrorPad:()=>kB,mod:()=>NB,moments:()=>v_,movingAverage:()=>Lae,mul:()=>M,multiRNNCell:()=>Qie,multinomial:()=>eoe,neg:()=>Cn,norm:()=>Lp,notEqual:()=>Id,oneHot:()=>JE,ones:()=>pi,onesLike:()=>mi,op:()=>A,outerProduct:()=>ioe,pad:()=>_l,pad1d:()=>loe,pad2d:()=>uoe,pad3d:()=>hoe,pad4d:()=>poe,pool:()=>AB,pow:()=>yl,prelu:()=>w_,print:()=>IL,prod:()=>RB,raggedGather:()=>woe,raggedRange:()=>Soe,raggedTensorToTensor:()=>Eoe,rand:()=>Toe,randomGamma:()=>Ooe,randomNormal:()=>nD,randomStandardNormal:()=>Loe,randomUniform:()=>Up,range:()=>Ed,real:()=>Hp,reciprocal:()=>MB,relu:()=>zo,relu6:()=>rD,reshape:()=>F,reverse:()=>zi,reverse1d:()=>Goe,reverse2d:()=>Koe,reverse3d:()=>Yoe,reverse4d:()=>Qoe,rfft:()=>T_,round:()=>sD,rsqrt:()=>iD,scalar:()=>Be,scatterND:()=>Vae,searchSorted:()=>QE,selu:()=>oD,separableConv2d:()=>aD,setdiff1dAsync:()=>sae,sigmoid:()=>Bo,sign:()=>FB,signal:()=>Tce,sin:()=>cD,sinh:()=>uD,slice:()=>Mt,slice1d:()=>S_,slice2d:()=>dD,slice3d:()=>I_,slice4d:()=>Wp,softmax:()=>E_,softplus:()=>Sd,spaceToBatchND:()=>x_,sparse:()=>Nce,sparseToDense:()=>Hae,spectral:()=>Dce,split:()=>Ws,sqrt:()=>Gr,square:()=>rn,squaredDifference:()=>fD,squeeze:()=>Tc,stack:()=>gi,step:()=>Dd,stridedSlice:()=>OB,string:()=>Ace,sub:()=>De,sum:()=>Re,tan:()=>$B,tanh:()=>xd,tensor:()=>mo,tensor1d:()=>Es,tensor2d:()=>Gp,tensor3d:()=>FL,tensor4d:()=>Sae,tensor5d:()=>Iae,tensor6d:()=>Eae,tile:()=>Vi,topk:()=>PB,transpose:()=>Tt,truncatedNormal:()=>pD,unique:()=>LB,unsortedSegmentSum:()=>mD,unstack:()=>Ui,upperBound:()=>Rae,variable:()=>BB,where:()=>Ss,whereAsync:()=>VB,zeros:()=>ur,zerosLike:()=>Ft});var k={};function ae(n){return"function"==typeof n}function je(n){const e=n(r=>{Error.call(r),r.stack=(new Error).stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}Q.r(k),Q.d(k,{addImpl:()=>L3,bincountImpl:()=>yT,bincountReduceImpl:()=>W3,castImpl:()=>P3,ceilImpl:()=>j3,concatImpl:()=>G3,equalImpl:()=>X3,expImpl:()=>Z3,expm1Impl:()=>J3,floorImpl:()=>nU,gatherNdImpl:()=>rU,gatherV2Impl:()=>sU,greaterEqualImpl:()=>oU,greaterImpl:()=>iU,lessEqualImpl:()=>lU,lessImpl:()=>aU,linSpaceImpl:()=>cU,logImpl:()=>uU,maxImpl:()=>dU,maximumImpl:()=>fU,minimumImpl:()=>pU,multiplyImpl:()=>bT,negImpl:()=>gU,notEqualImpl:()=>yU,prodImpl:()=>xU,raggedGatherImpl:()=>CU,raggedRangeImpl:()=>IU,raggedTensorToTensorImpl:()=>TU,rangeImpl:()=>kU,rsqrtImpl:()=>NU,scatterImpl:()=>Vd,sigmoidImpl:()=>xme,simpleAbsImpl:()=>V3,sliceImpl:()=>H3,sparseFillEmptyRowsImpl:()=>RU,sparseReshapeImpl:()=>MU,sparseSegmentReductionImpl:()=>ST,sqrtImpl:()=>Wve,squaredDifferenceImpl:()=>FU,stridedSliceImpl:()=>OU,stringNGramsImpl:()=>$U,stringSplitImpl:()=>PU,stringToHashBucketFastImpl:()=>LU,subImpl:()=>eU,tileImpl:()=>BU,topKImpl:()=>zU,transposeImpl:()=>mT,uniqueImpl:()=>HU});const At=je(n=>function(e){n(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((r,s)=>`${s+1}) ${r.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e});function dt(n,t){if(n){const e=n.indexOf(t);0<=e&&n.splice(e,1)}}class Ve{constructor(t){this.initialTeardown=t,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let t;if(!this.closed){this.closed=!0;const{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(const i of e)i.remove(this);else e.remove(this);const{initialTeardown:r}=this;if(ae(r))try{r()}catch(i){t=i instanceof At?i.errors:[i]}const{_finalizers:s}=this;if(s){this._finalizers=null;for(const i of s)try{gr(i)}catch(o){t=t??[],o instanceof At?t=[...t,...o.errors]:t.push(o)}}if(t)throw new At(t)}}add(t){var e;if(t&&t!==this)if(this.closed)gr(t);else{if(t instanceof Ve){if(t.closed||t._hasParent(this))return;t._addParent(this)}(this._finalizers=null!==(e=this._finalizers)&&void 0!==e?e:[]).push(t)}}_hasParent(t){const{_parentage:e}=this;return e===t||Array.isArray(e)&&e.includes(t)}_addParent(t){const{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(t),e):e?[e,t]:t}_removeParent(t){const{_parentage:e}=this;e===t?this._parentage=null:Array.isArray(e)&&dt(e,t)}remove(t){const{_finalizers:e}=this;e&&dt(e,t),t instanceof Ve&&t._removeParent(this)}}Ve.EMPTY=(()=>{const n=new Ve;return n.closed=!0,n})();const Vn=Ve.EMPTY;function Kn(n){return n instanceof Ve||n&&"closed"in n&&ae(n.remove)&&ae(n.add)&&ae(n.unsubscribe)}function gr(n){ae(n)?n():n.unsubscribe()}const nn={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},zr={setTimeout(n,t,...e){const{delegate:r}=zr;return r?.setTimeout?r.setTimeout(n,t,...e):setTimeout(n,t,...e)},clearTimeout(n){const{delegate:t}=zr;return(t?.clearTimeout||clearTimeout)(n)},delegate:void 0};function Xn(n){zr.setTimeout(()=>{const{onUnhandledError:t}=nn;if(!t)throw n;t(n)})}function Mr(){}const eu=Hx("C",void 0,void 0);function Hx(n,t,e){return{kind:n,value:t,error:e}}let Gl=null;function Wm(n){if(nn.useDeprecatedSynchronousErrorHandling){const t=!Gl;if(t&&(Gl={errorThrown:!1,error:null}),n(),t){const{errorThrown:e,error:r}=Gl;if(Gl=null,e)throw r}}else n()}class Wx extends Ve{constructor(t){super(),this.isStopped=!1,t?(this.destination=t,Kn(t)&&t.add(this)):this.destination=FG}static create(t,e,r){return new fh(t,e,r)}next(t){this.isStopped?Gx(function kG(n){return Hx("N",n,void 0)}(t),this):this._next(t)}error(t){this.isStopped?Gx(function TG(n){return Hx("E",void 0,n)}(t),this):(this.isStopped=!0,this._error(t))}complete(){this.isStopped?Gx(eu,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(t){this.destination.next(t)}_error(t){try{this.destination.error(t)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}const AG=Function.prototype.bind;function jx(n,t){return AG.call(n,t)}class RG{constructor(t){this.partialObserver=t}next(t){const{partialObserver:e}=this;if(e.next)try{e.next(t)}catch(r){jm(r)}}error(t){const{partialObserver:e}=this;if(e.error)try{e.error(t)}catch(r){jm(r)}else jm(t)}complete(){const{partialObserver:t}=this;if(t.complete)try{t.complete()}catch(e){jm(e)}}}class fh extends Wx{constructor(t,e,r){let s;if(super(),ae(t)||!t)s={next:t??void 0,error:e??void 0,complete:r??void 0};else{let i;this&&nn.useDeprecatedNextContext?(i=Object.create(t),i.unsubscribe=()=>this.unsubscribe(),s={next:t.next&&jx(t.next,i),error:t.error&&jx(t.error,i),complete:t.complete&&jx(t.complete,i)}):s=t}this.destination=new RG(s)}}function jm(n){nn.useDeprecatedSynchronousErrorHandling?function NG(n){nn.useDeprecatedSynchronousErrorHandling&&Gl&&(Gl.errorThrown=!0,Gl.error=n)}(n):Xn(n)}function Gx(n,t){const{onStoppedNotification:e}=nn;e&&zr.setTimeout(()=>e(n,t))}const FG={closed:!0,next:Mr,error:function MG(n){throw n},complete:Mr},qx="function"==typeof Symbol&&Symbol.observable||"@@observable";function za(n){return n}function gN(n){return 0===n.length?za:1===n.length?n[0]:function(e){return n.reduce((r,s)=>s(r),e)}}let Dn=(()=>{class n{constructor(e){e&&(this._subscribe=e)}lift(e){const r=new n;return r.source=this,r.operator=e,r}subscribe(e,r,s){const i=function PG(n){return n&&n instanceof Wx||function $G(n){return n&&ae(n.next)&&ae(n.error)&&ae(n.complete)}(n)&&Kn(n)}(e)?e:new fh(e,r,s);return Wm(()=>{const{operator:o,source:a}=this;i.add(o?o.call(i,a):a?this._subscribe(i):this._trySubscribe(i))}),i}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return new(r=yN(r))((s,i)=>{const o=new fh({next:a=>{try{e(a)}catch(l){i(l),o.unsubscribe()}},error:i,complete:s});this.subscribe(o)})}_subscribe(e){var r;return null===(r=this.source)||void 0===r?void 0:r.subscribe(e)}[qx](){return this}pipe(...e){return gN(e)(this)}toPromise(e){return new(e=yN(e))((r,s)=>{let i;this.subscribe(o=>i=o,o=>s(o),()=>r(i))})}}return n.create=t=>new n(t),n})();function yN(n){var t;return null!==(t=n??nn.Promise)&&void 0!==t?t:Promise}const LG=je(n=>function(){n(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});let It=(()=>{class n extends Dn{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){const r=new bN(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new LG}next(e){Wm(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(const r of this.currentObservers)r.next(e)}})}error(e){Wm(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;const{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){Wm(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;const{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){const{hasError:r,isStopped:s,observers:i}=this;return r||s?Vn:(this.currentObservers=null,i.push(e),new Ve(()=>{this.currentObservers=null,dt(i,e)}))}_checkFinalizedStatuses(e){const{hasError:r,thrownError:s,isStopped:i}=this;r?e.error(s):i&&e.complete()}asObservable(){const e=new Dn;return e.source=this,e}}return n.create=(t,e)=>new bN(t,e),n})();class bN extends It{constructor(t,e){super(),this.destination=t,this.source=e}next(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.next)||void 0===r||r.call(e,t)}error(t){var e,r;null===(r=null===(e=this.destination)||void 0===e?void 0:e.error)||void 0===r||r.call(e,t)}complete(){var t,e;null===(e=null===(t=this.destination)||void 0===t?void 0:t.complete)||void 0===e||e.call(t)}_subscribe(t){var e,r;return null!==(r=null===(e=this.source)||void 0===e?void 0:e.subscribe(t))&&void 0!==r?r:Vn}}function _N(n){return ae(n?.lift)}function Mn(n){return t=>{if(_N(t))return t.lift(function(e){try{return n(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function xn(n,t,e,r,s){return new BG(n,t,e,r,s)}class BG extends Wx{constructor(t,e,r,s,i,o){super(t),this.onFinalize=i,this.shouldUnsubscribe=o,this._next=e?function(a){try{e(a)}catch(l){t.error(l)}}:super._next,this._error=s?function(a){try{s(a)}catch(l){t.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){t.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var t;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){const{closed:e}=this;super.unsubscribe(),!e&&(null===(t=this.onFinalize)||void 0===t||t.call(this))}}}function Ue(n,t){return Mn((e,r)=>{let s=0;e.subscribe(xn(r,i=>{r.next(n.call(t,i,s++))}))})}function ql(n){return this instanceof ql?(this.v=n,this):new ql(n)}function UG(n,t,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s,r=e.apply(n,t||[]),i=[];return s={},o("next"),o("throw"),o("return"),s[Symbol.asyncIterator]=function(){return this},s;function o(h){r[h]&&(s[h]=function(f){return new Promise(function(p,m){i.push([h,f,p,m])>1||a(h,f)})})}function a(h,f){try{!function l(h){h.value instanceof ql?Promise.resolve(h.value.v).then(c,u):d(i[0][2],h)}(r[h](f))}catch(p){d(i[0][3],p)}}function c(h){a("next",h)}function u(h){a("throw",h)}function d(h,f){h(f),i.shift(),i.length&&a(i[0][0],i[0][1])}}function HG(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,t=n[Symbol.asyncIterator];return t?t.call(n):(n=function wN(n){var t="function"==typeof Symbol&&Symbol.iterator,e=t&&n[t],r=0;if(e)return e.call(n);if(n&&"number"==typeof n.length)return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}(n),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(i){e[i]=n[i]&&function(o){return new Promise(function(a,l){!function s(i,o,a,l){Promise.resolve(l).then(function(c){i({value:c,done:a})},o)}(a,l,(o=n[i](o)).done,o.value)})}}}const Xx=n=>n&&"number"==typeof n.length&&"function"!=typeof n;function CN(n){return ae(n?.then)}function SN(n){return ae(n[qx])}function IN(n){return Symbol.asyncIterator&&ae(n?.[Symbol.asyncIterator])}function EN(n){return new TypeError(`You provided ${null!==n&&"object"==typeof n?"an invalid object":`'${n}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}const DN=function jG(){return"function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator"}();function TN(n){return ae(n?.[DN])}function kN(n){return UG(this,arguments,function*(){const e=n.getReader();try{for(;;){const{value:r,done:s}=yield ql(e.read());if(s)return yield ql(void 0);yield yield ql(r)}}finally{e.releaseLock()}})}function NN(n){return ae(n?.getReader)}function Rs(n){if(n instanceof Dn)return n;if(null!=n){if(SN(n))return function GG(n){return new Dn(t=>{const e=n[qx]();if(ae(e.subscribe))return e.subscribe(t);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}(n);if(Xx(n))return function qG(n){return new Dn(t=>{for(let e=0;e<n.length&&!t.closed;e++)t.next(n[e]);t.complete()})}(n);if(CN(n))return function KG(n){return new Dn(t=>{n.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,Xn)})}(n);if(IN(n))return AN(n);if(TN(n))return function XG(n){return new Dn(t=>{for(const e of n)if(t.next(e),t.closed)return;t.complete()})}(n);if(NN(n))return function YG(n){return AN(kN(n))}(n)}throw EN(n)}function AN(n){return new Dn(t=>{(function ZG(n,t){var e,r,s,i;return function VG(n,t,e,r){return new(e||(e=Promise))(function(i,o){function a(u){try{c(r.next(u))}catch(d){o(d)}}function l(u){try{c(r.throw(u))}catch(d){o(d)}}function c(u){u.done?i(u.value):function s(i){return i instanceof e?i:new e(function(o){o(i)})}(u.value).then(a,l)}c((r=r.apply(n,t||[])).next())})}(this,void 0,void 0,function*(){try{for(e=HG(n);!(r=yield e.next()).done;)if(t.next(r.value),t.closed)return}catch(o){s={error:o}}finally{try{r&&!r.done&&(i=e.return)&&(yield i.call(e))}finally{if(s)throw s.error}}t.complete()})})(n,t).catch(e=>t.error(e))})}function ea(n,t,e,r=0,s=!1){const i=t.schedule(function(){e(),s?n.add(this.schedule(null,r)):this.unsubscribe()},r);if(n.add(i),!s)return i}function yr(n,t,e=1/0){return ae(t)?yr((r,s)=>Ue((i,o)=>t(r,i,s,o))(Rs(n(r,s))),e):("number"==typeof t&&(e=t),Mn((r,s)=>function QG(n,t,e,r,s,i,o,a){const l=[];let c=0,u=0,d=!1;const h=()=>{d&&!l.length&&!c&&t.complete()},f=m=>c<r?p(m):l.push(m),p=m=>{i&&t.next(m),c++;let g=!1;Rs(e(m,u++)).subscribe(xn(t,y=>{s?.(y),i?f(y):t.next(y)},()=>{g=!0},void 0,()=>{if(g)try{for(c--;l.length&&c<r;){const y=l.shift();o?ea(t,o,()=>p(y)):p(y)}h()}catch(y){t.error(y)}}))};return n.subscribe(xn(t,f,()=>{d=!0,h()})),()=>{a?.()}}(r,s,n,e)))}function tu(n=1/0){return yr(za,n)}const ta=new Dn(n=>n.complete());function RN(n){return n&&ae(n.schedule)}function Yx(n){return n[n.length-1]}function MN(n){return ae(Yx(n))?n.pop():void 0}function ph(n){return RN(Yx(n))?n.pop():void 0}function FN(n,t=0){return Mn((e,r)=>{e.subscribe(xn(r,s=>ea(r,n,()=>r.next(s),t),()=>ea(r,n,()=>r.complete(),t),s=>ea(r,n,()=>r.error(s),t)))})}function ON(n,t=0){return Mn((e,r)=>{r.add(n.schedule(()=>e.subscribe(r),t))})}function $N(n,t){if(!n)throw new Error("Iterable cannot be null");return new Dn(e=>{ea(e,t,()=>{const r=n[Symbol.asyncIterator]();ea(e,t,()=>{r.next().then(s=>{s.done?e.complete():e.next(s.value)})},0,!0)})})}function Tn(n,t){return t?function o5(n,t){if(null!=n){if(SN(n))return function t5(n,t){return Rs(n).pipe(ON(t),FN(t))}(n,t);if(Xx(n))return function r5(n,t){return new Dn(e=>{let r=0;return t.schedule(function(){r===n.length?e.complete():(e.next(n[r++]),e.closed||this.schedule())})})}(n,t);if(CN(n))return function n5(n,t){return Rs(n).pipe(ON(t),FN(t))}(n,t);if(IN(n))return $N(n,t);if(TN(n))return function s5(n,t){return new Dn(e=>{let r;return ea(e,t,()=>{r=n[DN](),ea(e,t,()=>{let s,i;try{({value:s,done:i}=r.next())}catch(o){return void e.error(o)}i?e.complete():e.next(s)},0,!0)}),()=>ae(r?.return)&&r.return()})}(n,t);if(NN(n))return function i5(n,t){return $N(kN(n),t)}(n,t)}throw EN(n)}(n,t):Rs(n)}function Ua(...n){const t=ph(n),e=function e5(n,t){return"number"==typeof Yx(n)?n.pop():t}(n,1/0),r=n;return r.length?1===r.length?Rs(r[0]):tu(e)(Tn(r,t)):ta}function PN(n={}){const{connector:t=(()=>new It),resetOnError:e=!0,resetOnComplete:r=!0,resetOnRefCountZero:s=!0}=n;return i=>{let o,a,l,c=0,u=!1,d=!1;const h=()=>{a?.unsubscribe(),a=void 0},f=()=>{h(),o=l=void 0,u=d=!1},p=()=>{const m=o;f(),m?.unsubscribe()};return Mn((m,g)=>{c++,!d&&!u&&h();const y=l=l??t();g.add(()=>{c--,0===c&&!d&&!u&&(a=Zx(p,s))}),y.subscribe(g),!o&&c>0&&(o=new fh({next:b=>y.next(b),error:b=>{d=!0,h(),a=Zx(f,e,b),y.error(b)},complete:()=>{u=!0,h(),a=Zx(f,r),y.complete()}}),Rs(m).subscribe(o))})(i)}}function Zx(n,t,...e){if(!0===t)return void n();if(!1===t)return;const r=new fh({next:()=>{r.unsubscribe(),n()}});return t(...e).subscribe(r)}function on(n){for(let t in n)if(n[t]===on)return t;throw Error("Could not find renamed property on target object.")}function Qx(n,t){for(const e in t)t.hasOwnProperty(e)&&!n.hasOwnProperty(e)&&(n[e]=t[e])}function an(n){if("string"==typeof n)return n;if(Array.isArray(n))return"["+n.map(an).join(", ")+"]";if(null==n)return""+n;if(n.overriddenName)return`${n.overriddenName}`;if(n.name)return`${n.name}`;const t=n.toString();if(null==t)return""+t;const e=t.indexOf("\n");return-1===e?t:t.substring(0,e)}function Jx(n,t){return null==n||""===n?null===t?"":t:null==t||""===t?n:n+" "+t}const a5=on({__forward_ref__:on});function fn(n){return n.__forward_ref__=fn,n.toString=function(){return an(this())},n}function Ge(n){return e0(n)?n():n}function e0(n){return"function"==typeof n&&n.hasOwnProperty(a5)&&n.__forward_ref__===fn}function t0(n){return n&&!!n.\u0275providers}const Gm="https://g.co/ng/security#xss";class te extends Error{constructor(t,e){super(function qm(n,t){return`NG0${Math.abs(n)}${t?": "+t.trim():""}`}(t,e)),this.code=t}}function rt(n){return"string"==typeof n?n:null==n?"":String(n)}function Km(n,t){throw new te(-201,!1)}function Js(n,t){null==n&&function jt(n,t,e,r){throw new Error(`ASSERTION ERROR: ${n}`+(null==r?"":` [Expected=> ${e} ${r} ${t} <=Actual]`))}(t,n,null,"!=")}function we(n){return{token:n.token,providedIn:n.providedIn||null,factory:n.factory,value:void 0}}function Gt(n){return{providers:n.providers||[],imports:n.imports||[]}}function Xm(n){return LN(n,Ym)||LN(n,VN)}function LN(n,t){return n.hasOwnProperty(t)?n[t]:null}function BN(n){return n&&(n.hasOwnProperty(n0)||n.hasOwnProperty(g5))?n[n0]:null}const Ym=on({\u0275prov:on}),n0=on({\u0275inj:on}),VN=on({ngInjectableDef:on}),g5=on({ngInjectorDef:on});var qe=(()=>((qe=qe||{})[qe.Default=0]="Default",qe[qe.Host=1]="Host",qe[qe.Self=2]="Self",qe[qe.SkipSelf=4]="SkipSelf",qe[qe.Optional=8]="Optional",qe))();let r0;function Di(n){const t=r0;return r0=n,t}function zN(n,t,e){const r=Xm(n);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:e&qe.Optional?null:void 0!==t?t:void Km(an(n))}const pn=(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)(),mh={},s0="__NG_DI_FLAG__",Zm="ngTempTokenPath",_5=/\n/gm,UN="__source";let gh;function nu(n){const t=gh;return gh=n,t}function x5(n,t=qe.Default){if(void 0===gh)throw new te(-203,!1);return null===gh?zN(n,void 0,t):gh.get(n,t&qe.Optional?null:void 0,t)}function Z(n,t=qe.Default){return(function y5(){return r0}()||x5)(Ge(n),t)}function Bt(n,t=qe.Default){return Z(n,Qm(t))}function Qm(n){return typeof n>"u"||"number"==typeof n?n:0|(n.optional&&8)|(n.host&&1)|(n.self&&2)|(n.skipSelf&&4)}function o0(n){const t=[];for(let e=0;e<n.length;e++){const r=Ge(n[e]);if(Array.isArray(r)){if(0===r.length)throw new te(900,!1);let s,i=qe.Default;for(let o=0;o<r.length;o++){const a=r[o],l=w5(a);"number"==typeof l?-1===l?s=a.token:i|=l:s=a}t.push(Z(s,i))}else t.push(Z(r))}return t}function yh(n,t){return n[s0]=t,n.prototype[s0]=t,n}function w5(n){return n[s0]}function Ha(n){return{toString:n}.toString()}var Qi=(()=>((Qi=Qi||{})[Qi.OnPush=0]="OnPush",Qi[Qi.Default=1]="Default",Qi))(),Ji=(()=>{return(n=Ji||(Ji={}))[n.Emulated=0]="Emulated",n[n.None=2]="None",n[n.ShadowDom=3]="ShadowDom",Ji;var n})();const ra={},zt=[],Jm=on({\u0275cmp:on}),a0=on({\u0275dir:on}),l0=on({\u0275pipe:on}),WN=on({\u0275mod:on}),sa=on({\u0275fac:on}),bh=on({__NG_ELEMENT_ID__:on});let I5=0;function Ur(n){return Ha(()=>{const e=!0===n.standalone,r={},s={type:n.type,providersResolver:null,decls:n.decls,vars:n.vars,factory:null,template:n.template||null,consts:n.consts||null,ngContentSelectors:n.ngContentSelectors,hostBindings:n.hostBindings||null,hostVars:n.hostVars||0,hostAttrs:n.hostAttrs||null,contentQueries:n.contentQueries||null,declaredInputs:r,inputs:null,outputs:null,exportAs:n.exportAs||null,onPush:n.changeDetection===Qi.OnPush,directiveDefs:null,pipeDefs:null,standalone:e,dependencies:e&&n.dependencies||null,getStandaloneInjector:null,selectors:n.selectors||zt,viewQuery:n.viewQuery||null,features:n.features||null,data:n.data||{},encapsulation:n.encapsulation||Ji.Emulated,id:"c"+I5++,styles:n.styles||zt,_:null,setInput:null,schemas:n.schemas||null,tView:null,findHostDirectiveDefs:null,hostDirectives:null},i=n.dependencies,o=n.features;return s.inputs=qN(n.inputs,r),s.outputs=qN(n.outputs),o&&o.forEach(a=>a(s)),s.directiveDefs=i?()=>("function"==typeof i?i():i).map(jN).filter(GN):null,s.pipeDefs=i?()=>("function"==typeof i?i():i).map(gs).filter(GN):null,s})}function jN(n){return qt(n)||Xr(n)}function GN(n){return null!==n}function Zt(n){return Ha(()=>({type:n.type,bootstrap:n.bootstrap||zt,declarations:n.declarations||zt,imports:n.imports||zt,exports:n.exports||zt,transitiveCompileScopes:null,schemas:n.schemas||null,id:n.id||null}))}function qN(n,t){if(null==n)return ra;const e={};for(const r in n)if(n.hasOwnProperty(r)){let s=n[r],i=s;Array.isArray(s)&&(i=s[1],s=s[0]),e[s]=r,t&&(t[s]=i)}return e}const Me=Ur;function Ms(n){return{type:n.type,name:n.name,factory:null,pure:!1!==n.pure,standalone:!0===n.standalone,onDestroy:n.type.prototype.ngOnDestroy||null}}function qt(n){return n[Jm]||null}function Xr(n){return n[a0]||null}function gs(n){return n[l0]||null}function ei(n,t){const e=n[WN]||null;if(!e&&!0===t)throw new Error(`Type ${an(n)} does not have '\u0275mod' property.`);return e}function Fs(n){return Array.isArray(n)&&"object"==typeof n[1]}function to(n){return Array.isArray(n)&&!0===n[1]}function d0(n){return 0!=(4&n.flags)}function rg(n){return n.componentOffset>-1}function sg(n){return 1==(1&n.flags)}function no(n){return null!==n.template}function A5(n){return 0!=(256&n[2])}function Ql(n,t){return n.hasOwnProperty(sa)?n[sa]:null}class F5{constructor(t,e,r){this.previousValue=t,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}}function Os(){return YN}function YN(n){return n.type.prototype.ngOnChanges&&(n.setInput=$5),O5}function O5(){const n=QN(this),t=n?.current;if(t){const e=n.previous;if(e===ra)n.previous=t;else for(let r in t)e[r]=t[r];n.current=null,this.ngOnChanges(t)}}function $5(n,t,e,r){const s=this.declaredInputs[e],i=QN(n)||function P5(n,t){return n[ZN]=t}(n,{previous:ra,current:null}),o=i.current||(i.current={}),a=i.previous,l=a[s];o[s]=new F5(l&&l.currentValue,t,a===ra),n[r]=t}Os.ngInherit=!0;const ZN="__ngSimpleChanges__";function QN(n){return n[ZN]||null}function br(n){for(;Array.isArray(n);)n=n[0];return n}function ig(n,t){return br(t[n])}function ni(n,t){return br(t[n.index])}function g0(n,t){return n.data[t]}function au(n,t){return n[t]}function ri(n,t){const e=t[n];return Fs(e)?e:e[0]}function og(n){return 64==(64&n[2])}function Wa(n,t){return null==t?null:n[t]}function JN(n){n[18]=0}function y0(n,t){n[5]+=t;let e=n,r=n[3];for(;null!==r&&(1===t&&1===e[5]||-1===t&&0===e[5]);)r[5]+=t,e=r,r=r[3]}const et={lFrame:cA(null),bindingsEnabled:!0};function tA(){return et.bindingsEnabled}function oe(){return et.lFrame.lView}function $t(){return et.lFrame.tView}function Qr(n){return et.lFrame.contextLView=n,n[8]}function Jr(n){return et.lFrame.contextLView=null,n}function Hr(){let n=nA();for(;null!==n&&64===n.type;)n=n.parent;return n}function nA(){return et.lFrame.currentTNode}function Io(n,t){const e=et.lFrame;e.currentTNode=n,e.isParent=t}function b0(){return et.lFrame.isParent}function _0(){et.lFrame.isParent=!1}function lu(){return et.lFrame.bindingIndex++}function oa(n){const t=et.lFrame,e=t.bindingIndex;return t.bindingIndex=t.bindingIndex+n,e}function Q5(n,t){const e=et.lFrame;e.bindingIndex=e.bindingRootIndex=n,v0(t)}function v0(n){et.lFrame.currentDirectiveIndex=n}function x0(n){const t=et.lFrame.currentDirectiveIndex;return-1===t?null:n[t]}function oA(){return et.lFrame.currentQueryIndex}function w0(n){et.lFrame.currentQueryIndex=n}function eq(n){const t=n[1];return 2===t.type?t.declTNode:1===t.type?n[6]:null}function aA(n,t,e){if(e&qe.SkipSelf){let s=t,i=n;for(;!(s=s.parent,null!==s||e&qe.Host||(s=eq(i),null===s||(i=i[15],10&s.type))););if(null===s)return!1;t=s,n=i}const r=et.lFrame=lA();return r.currentTNode=t,r.lView=n,!0}function C0(n){const t=lA(),e=n[1];et.lFrame=t,t.currentTNode=e.firstChild,t.lView=n,t.tView=e,t.contextLView=n,t.bindingIndex=e.bindingStartIndex,t.inI18n=!1}function lA(){const n=et.lFrame,t=null===n?null:n.child;return null===t?cA(n):t}function cA(n){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:n,child:null,inI18n:!1};return null!==n&&(n.child=t),t}function uA(){const n=et.lFrame;return et.lFrame=n.parent,n.currentTNode=null,n.lView=null,n}const dA=uA;function S0(){const n=uA();n.isParent=!0,n.tView=null,n.selectedIndex=-1,n.contextLView=null,n.elementDepthCount=0,n.currentDirectiveIndex=-1,n.currentNamespace=null,n.bindingRootIndex=-1,n.bindingIndex=-1,n.currentQueryIndex=0}function bs(){return et.lFrame.selectedIndex}function Jl(n){et.lFrame.selectedIndex=n}function Fn(){const n=et.lFrame;return g0(n.tView,n.selectedIndex)}function cu(){et.lFrame.currentNamespace="svg"}function I0(){!function sq(){et.lFrame.currentNamespace=null}()}function ag(n,t){for(let e=t.directiveStart,r=t.directiveEnd;e<r;e++){const i=n.data[e].type.prototype,{ngAfterContentInit:o,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:c,ngOnDestroy:u}=i;o&&(n.contentHooks||(n.contentHooks=[])).push(-e,o),a&&((n.contentHooks||(n.contentHooks=[])).push(e,a),(n.contentCheckHooks||(n.contentCheckHooks=[])).push(e,a)),l&&(n.viewHooks||(n.viewHooks=[])).push(-e,l),c&&((n.viewHooks||(n.viewHooks=[])).push(e,c),(n.viewCheckHooks||(n.viewCheckHooks=[])).push(e,c)),null!=u&&(n.destroyHooks||(n.destroyHooks=[])).push(e,u)}}function lg(n,t,e){hA(n,t,3,e)}function cg(n,t,e,r){(3&n[2])===e&&hA(n,t,e,r)}function E0(n,t){let e=n[2];(3&e)===t&&(e&=2047,e+=1,n[2]=e)}function hA(n,t,e,r){const i=r??-1,o=t.length-1;let a=0;for(let l=void 0!==r?65535&n[18]:0;l<o;l++)if("number"==typeof t[l+1]){if(a=t[l],null!=r&&a>=r)break}else t[l]<0&&(n[18]+=65536),(a<i||-1==i)&&(aq(n,e,t,l),n[18]=(4294901760&n[18])+l+2),l++}function aq(n,t,e,r){const s=e[r]<0,i=e[r+1],a=n[s?-e[r]:e[r]];if(s){if(n[2]>>11<n[18]>>16&&(3&n[2])===t){n[2]+=2048;try{i.call(a)}finally{}}}else try{i.call(a)}finally{}}class Sh{constructor(t,e,r){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=r}}function T0(n,t,e){let r=0;for(;r<e.length;){const s=e[r];if("number"==typeof s){if(0!==s)break;r++;const i=e[r++],o=e[r++],a=e[r++];n.setAttribute(t,o,a,i)}else{const i=s,o=e[++r];pA(i)?n.setProperty(t,i,o):n.setAttribute(t,i,o),r++}}return r}function fA(n){return 3===n||4===n||6===n}function pA(n){return 64===n.charCodeAt(0)}function Eh(n,t){if(null!==t&&0!==t.length)if(null===n||0===n.length)n=t.slice();else{let e=-1;for(let r=0;r<t.length;r++){const s=t[r];"number"==typeof s?e=s:0===e||mA(n,e,s,null,-1===e||2===e?t[++r]:null)}}return n}function mA(n,t,e,r,s){let i=0,o=n.length;if(-1===t)o=-1;else for(;i<n.length;){const a=n[i++];if("number"==typeof a){if(a===t){o=-1;break}if(a>t){o=i-1;break}}}for(;i<n.length;){const a=n[i];if("number"==typeof a)break;if(a===e){if(null===r)return void(null!==s&&(n[i+1]=s));if(r===n[i+1])return void(n[i+2]=s)}i++,null!==r&&i++,null!==s&&i++}-1!==o&&(n.splice(o,0,t),i=o+1),n.splice(i++,0,e),null!==r&&n.splice(i++,0,r),null!==s&&n.splice(i++,0,s)}function gA(n){return-1!==n}function uu(n){return 32767&n}function du(n,t){let e=function hq(n){return n>>16}(n),r=t;for(;e>0;)r=r[15],e--;return r}let k0=!0;function ug(n){const t=k0;return k0=n,t}let fq=0;const Eo={};function dg(n,t){const e=A0(n,t);if(-1!==e)return e;const r=t[1];r.firstCreatePass&&(n.injectorIndex=t.length,N0(r.data,n),N0(t,null),N0(r.blueprint,null));const s=hg(n,t),i=n.injectorIndex;if(gA(s)){const o=uu(s),a=du(s,t),l=a[1].data;for(let c=0;c<8;c++)t[i+c]=a[o+c]|l[o+c]}return t[i+8]=s,i}function N0(n,t){n.push(0,0,0,0,0,0,0,0,t)}function A0(n,t){return-1===n.injectorIndex||n.parent&&n.parent.injectorIndex===n.injectorIndex||null===t[n.injectorIndex+8]?-1:n.injectorIndex}function hg(n,t){if(n.parent&&-1!==n.parent.injectorIndex)return n.parent.injectorIndex;let e=0,r=null,s=t;for(;null!==s;){if(r=IA(s),null===r)return-1;if(e++,s=s[15],-1!==r.injectorIndex)return r.injectorIndex|e<<16}return-1}function R0(n,t,e){!function pq(n,t,e){let r;"string"==typeof e?r=e.charCodeAt(0)||0:e.hasOwnProperty(bh)&&(r=e[bh]),null==r&&(r=e[bh]=fq++);const s=255&r;t.data[n+(s>>5)]|=1<<s}(n,t,e)}function _A(n,t,e){if(e&qe.Optional||void 0!==n)return n;Km()}function vA(n,t,e,r){if(e&qe.Optional&&void 0===r&&(r=null),0==(e&(qe.Self|qe.Host))){const s=n[9],i=Di(void 0);try{return s?s.get(t,r,e&qe.Optional):zN(t,r,e&qe.Optional)}finally{Di(i)}}return _A(r,0,e)}function xA(n,t,e,r=qe.Default,s){if(null!==n){if(1024&t[2]){const o=function _q(n,t,e,r,s){let i=n,o=t;for(;null!==i&&null!==o&&1024&o[2]&&!(256&o[2]);){const a=wA(i,o,e,r|qe.Self,Eo);if(a!==Eo)return a;let l=i.parent;if(!l){const c=o[21];if(c){const u=c.get(e,Eo,r);if(u!==Eo)return u}l=IA(o),o=o[15]}i=l}return s}(n,t,e,r,Eo);if(o!==Eo)return o}const i=wA(n,t,e,r,Eo);if(i!==Eo)return i}return vA(t,e,r,s)}function wA(n,t,e,r,s){const i=function yq(n){if("string"==typeof n)return n.charCodeAt(0)||0;const t=n.hasOwnProperty(bh)?n[bh]:void 0;return"number"==typeof t?t>=0?255&t:bq:t}(e);if("function"==typeof i){if(!aA(t,n,r))return r&qe.Host?_A(s,0,r):vA(t,e,r,s);try{const o=i(r);if(null!=o||r&qe.Optional)return o;Km()}finally{dA()}}else if("number"==typeof i){let o=null,a=A0(n,t),l=-1,c=r&qe.Host?t[16][6]:null;for((-1===a||r&qe.SkipSelf)&&(l=-1===a?hg(n,t):t[a+8],-1!==l&&SA(r,!1)?(o=t[1],a=uu(l),t=du(l,t)):a=-1);-1!==a;){const u=t[1];if(CA(i,a,u.data)){const d=gq(a,t,e,o,r,c);if(d!==Eo)return d}l=t[a+8],-1!==l&&SA(r,t[1].data[a+8]===c)&&CA(i,a,t)?(o=u,a=uu(l),t=du(l,t)):a=-1}}return s}function gq(n,t,e,r,s,i){const o=t[1],a=o.data[n+8],u=fg(a,o,e,null==r?rg(a)&&k0:r!=o&&0!=(3&a.type),s&qe.Host&&i===a);return null!==u?hu(t,o,u,a):Eo}function fg(n,t,e,r,s){const i=n.providerIndexes,o=t.data,a=1048575&i,l=n.directiveStart,u=i>>20,h=s?a+u:n.directiveEnd;for(let f=r?a:a+u;f<h;f++){const p=o[f];if(f<l&&e===p||f>=l&&p.type===e)return f}if(s){const f=o[l];if(f&&no(f)&&f.type===e)return l}return null}function hu(n,t,e,r){let s=n[e];const i=t.data;if(function lq(n){return n instanceof Sh}(s)){const o=s;o.resolving&&function l5(n,t){const e=t?`. Dependency path: ${t.join(" > ")} > ${n}`:"";throw new te(-200,`Circular dependency in DI detected for ${n}${e}`)}(function Wt(n){return"function"==typeof n?n.name||n.toString():"object"==typeof n&&null!=n&&"function"==typeof n.type?n.type.name||n.type.toString():rt(n)}(i[e]));const a=ug(o.canSeeViewProviders);o.resolving=!0;const l=o.injectImpl?Di(o.injectImpl):null;aA(n,r,qe.Default);try{s=n[e]=o.factory(void 0,i,n,r),t.firstCreatePass&&e>=r.directiveStart&&function oq(n,t,e){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:i}=t.type.prototype;if(r){const o=YN(t);(e.preOrderHooks||(e.preOrderHooks=[])).push(n,o),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n,o)}s&&(e.preOrderHooks||(e.preOrderHooks=[])).push(0-n,s),i&&((e.preOrderHooks||(e.preOrderHooks=[])).push(n,i),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n,i))}(e,i[e],t)}finally{null!==l&&Di(l),ug(a),o.resolving=!1,dA()}}return s}function CA(n,t,e){return!!(e[t+(n>>5)]&1<<n)}function SA(n,t){return!(n&qe.Self||n&qe.Host&&t)}class fu{constructor(t,e){this._tNode=t,this._lView=e}get(t,e,r){return xA(this._tNode,this._lView,t,Qm(r),e)}}function bq(){return new fu(Hr(),oe())}function nr(n){return Ha(()=>{const t=n.prototype.constructor,e=t[sa]||M0(t),r=Object.prototype;let s=Object.getPrototypeOf(n.prototype).constructor;for(;s&&s!==r;){const i=s[sa]||M0(s);if(i&&i!==e)return i;s=Object.getPrototypeOf(s)}return i=>new i})}function M0(n){return e0(n)?()=>{const t=M0(Ge(n));return t&&t()}:Ql(n)}function IA(n){const t=n[1],e=t.type;return 2===e?t.declTNode:1===e?n[6]:null}function pu(n){return function mq(n,t){if("class"===t)return n.classes;if("style"===t)return n.styles;const e=n.attrs;if(e){const r=e.length;let s=0;for(;s<r;){const i=e[s];if(fA(i))break;if(0===i)s+=2;else if("number"==typeof i)for(s++;s<r&&"string"==typeof e[s];)s++;else{if(i===t)return e[s+1];s+=2}}}return null}(Hr(),n)}const gu="__parameters__";function bu(n,t,e){return Ha(()=>{const r=function F0(n){return function(...e){if(n){const r=n(...e);for(const s in r)this[s]=r[s]}}}(t);function s(...i){if(this instanceof s)return r.apply(this,i),this;const o=new s(...i);return a.annotation=o,a;function a(l,c,u){const d=l.hasOwnProperty(gu)?l[gu]:Object.defineProperty(l,gu,{value:[]})[gu];for(;d.length<=u;)d.push(null);return(d[u]=d[u]||[]).push(o),l}}return e&&(s.prototype=Object.create(e.prototype)),s.prototype.ngMetadataName=n,s.annotationCls=s,s})}class me{constructor(t,e){this._desc=t,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&&(this.\u0275prov=we({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}function si(n,t){void 0===t&&(t=n);for(let e=0;e<n.length;e++){let r=n[e];Array.isArray(r)?(t===n&&(t=n.slice(0,e)),si(r,t)):t!==n&&t.push(r)}return t}function ec(n,t){n.forEach(e=>Array.isArray(e)?ec(e,t):t(e))}function DA(n,t,e){t>=n.length?n.push(e):n.splice(t,0,e)}function pg(n,t){return t>=n.length-1?n.pop():n.splice(t,1)[0]}function kh(n,t){const e=[];for(let r=0;r<n;r++)e.push(t);return e}function ii(n,t,e){let r=_u(n,t);return r>=0?n[1|r]=e:(r=~r,function Cq(n,t,e,r){let s=n.length;if(s==t)n.push(e,r);else if(1===s)n.push(r,n[0]),n[0]=e;else{for(s--,n.push(n[s-1],n[s]);s>t;)n[s]=n[s-2],s--;n[t]=e,n[t+1]=r}}(n,r,t,e)),r}function $0(n,t){const e=_u(n,t);if(e>=0)return n[1|e]}function _u(n,t){return function NA(n,t,e){let r=0,s=n.length>>e;for(;s!==r;){const i=r+(s-r>>1),o=n[i<<e];if(t===o)return i<<e;o>t?s=i:r=i+1}return~(s<<e)}(n,t,1)}const Ga=yh(bu("Optional"),8),vu=yh(bu("SkipSelf"),4);var $s=(()=>(($s=$s||{})[$s.Important=1]="Important",$s[$s.DashCase=2]="DashCase",$s))();const U0=new Map;let jq=0;const W0="__ngContext__";function es(n,t){Fs(t)?(n[W0]=t[20],function qq(n){U0.set(n[20],n)}(t)):n[W0]=t}function G0(n,t){return undefined(n,t)}function Mh(n){const t=n[3];return to(t)?t[3]:t}function q0(n){return ZA(n[13])}function K0(n){return ZA(n[4])}function ZA(n){for(;null!==n&&!to(n);)n=n[4];return n}function wu(n,t,e,r,s){if(null!=r){let i,o=!1;to(r)?i=r:Fs(r)&&(o=!0,r=r[0]);const a=br(r);0===n&&null!==e?null==s?rR(t,e,a):tc(t,e,a,s||null,!0):1===n&&null!==e?tc(t,e,a,s||null,!0):2===n?function tw(n,t,e){const r=bg(n,t);r&&function p8(n,t,e,r){n.removeChild(t,e,r)}(n,r,t,e)}(t,a,o):3===n&&t.destroyNode(a),null!=i&&function y8(n,t,e,r,s){const i=e[7];i!==br(e)&&wu(t,n,r,i,s);for(let a=10;a<e.length;a++){const l=e[a];Fh(l[1],l,n,t,r,i)}}(t,n,i,e,s)}}function Y0(n,t,e){return n.createElement(t,e)}function JA(n,t){const e=n[9],r=e.indexOf(t),s=t[3];512&t[2]&&(t[2]&=-513,y0(s,-1)),e.splice(r,1)}function Z0(n,t){if(n.length<=10)return;const e=10+t,r=n[e];if(r){const s=r[17];null!==s&&s!==n&&JA(s,r),t>0&&(n[e-1][4]=r[4]);const i=pg(n,10+t);!function o8(n,t){Fh(n,t,t[11],2,null,null),t[0]=null,t[6]=null}(r[1],r);const o=i[19];null!==o&&o.detachView(i[1]),r[3]=null,r[4]=null,r[2]&=-65}return r}function eR(n,t){if(!(128&t[2])){const e=t[11];e.destroyNode&&Fh(n,t,e,3,null,null),function c8(n){let t=n[13];if(!t)return Q0(n[1],n);for(;t;){let e=null;if(Fs(t))e=t[13];else{const r=t[10];r&&(e=r)}if(!e){for(;t&&!t[4]&&t!==n;)Fs(t)&&Q0(t[1],t),t=t[3];null===t&&(t=n),Fs(t)&&Q0(t[1],t),e=t&&t[4]}t=e}}(t)}}function Q0(n,t){if(!(128&t[2])){t[2]&=-65,t[2]|=128,function f8(n,t){let e;if(null!=n&&null!=(e=n.destroyHooks))for(let r=0;r<e.length;r+=2){const s=t[e[r]];if(!(s instanceof Sh)){const i=e[r+1];if(Array.isArray(i))for(let o=0;o<i.length;o+=2){const a=s[i[o]],l=i[o+1];try{l.call(a)}finally{}}else try{i.call(s)}finally{}}}}(n,t),function h8(n,t){const e=n.cleanup,r=t[7];let s=-1;if(null!==e)for(let i=0;i<e.length-1;i+=2)if("string"==typeof e[i]){const o=e[i+3];o>=0?r[s=o]():r[s=-o].unsubscribe(),i+=2}else{const o=r[s=e[i+1]];e[i].call(o)}if(null!==r){for(let i=s+1;i<r.length;i++)(0,r[i])();t[7]=null}}(n,t),1===t[1].type&&t[11].destroy();const e=t[17];if(null!==e&&to(t[3])){e!==t[3]&&JA(e,t);const r=t[19];null!==r&&r.detachView(n)}!function Kq(n){U0.delete(n[20])}(t)}}function tR(n,t,e){return function nR(n,t,e){let r=t;for(;null!==r&&40&r.type;)r=(t=r).parent;if(null===r)return e[0];{const{componentOffset:s}=r;if(s>-1){const{encapsulation:i}=n.data[r.directiveStart+s];if(i===Ji.None||i===Ji.Emulated)return null}return ni(r,e)}}(n,t.parent,e)}function tc(n,t,e,r,s){n.insertBefore(t,e,r,s)}function rR(n,t,e){n.appendChild(t,e)}function sR(n,t,e,r,s){null!==r?tc(n,t,e,r,s):rR(n,t,e)}function bg(n,t){return n.parentNode(t)}function iR(n,t,e){return aR(n,t,e)}let xg,sw,aR=function oR(n,t,e){return 40&n.type?ni(n,e):null};function _g(n,t,e,r){const s=tR(n,r,t),i=t[11],a=iR(r.parent||t[6],r,t);if(null!=s)if(Array.isArray(e))for(let l=0;l<e.length;l++)sR(i,s,e[l],a,!1);else sR(i,s,e,a,!1)}function vg(n,t){if(null!==t){const e=t.type;if(3&e)return ni(t,n);if(4&e)return ew(-1,n[t.index]);if(8&e){const r=t.child;if(null!==r)return vg(n,r);{const s=n[t.index];return to(s)?ew(-1,s):br(s)}}if(32&e)return G0(t,n)()||br(n[t.index]);{const r=cR(n,t);return null!==r?Array.isArray(r)?r[0]:vg(Mh(n[16]),r):vg(n,t.next)}}return null}function cR(n,t){return null!==t?n[16][6].projection[t.projection]:null}function ew(n,t){const e=10+n+1;if(e<t.length){const r=t[e],s=r[1].firstChild;if(null!==s)return vg(r,s)}return t[7]}function nw(n,t,e,r,s,i,o){for(;null!=e;){const a=r[e.index],l=e.type;if(o&&0===t&&(a&&es(br(a),r),e.flags|=2),32!=(32&e.flags))if(8&l)nw(n,t,e.child,r,s,i,!1),wu(t,n,s,a,i);else if(32&l){const c=G0(e,r);let u;for(;u=c();)wu(t,n,s,u,i);wu(t,n,s,a,i)}else 16&l?uR(n,t,r,e,s,i):wu(t,n,s,a,i);e=o?e.projectionNext:e.next}}function Fh(n,t,e,r,s,i){nw(e,r,n.firstChild,t,s,i,!1)}function uR(n,t,e,r,s,i){const o=e[16],l=o[6].projection[r.projection];if(Array.isArray(l))for(let c=0;c<l.length;c++)wu(t,n,s,l[c],i);else nw(n,t,l,o[3],s,i,!0)}function dR(n,t,e){""===e?n.removeAttribute(t,"class"):n.setAttribute(t,"class",e)}function hR(n,t,e){const{mergedAttrs:r,classes:s,styles:i}=e;null!==r&&T0(n,t,r),null!==s&&dR(n,t,s),null!==i&&function _8(n,t,e){n.setAttribute(t,"style",e)}(n,t,i)}function nc(n){return function rw(){if(void 0===xg&&(xg=null,pn.trustedTypes))try{xg=pn.trustedTypes.createPolicy("angular",{createHTML:n=>n,createScript:n=>n,createScriptURL:n=>n})}catch{}return xg}()?.createHTML(n)||n}class rc{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${Gm})`}}class S8 extends rc{getTypeName(){return"HTML"}}class I8 extends rc{getTypeName(){return"Style"}}class E8 extends rc{getTypeName(){return"Script"}}class D8 extends rc{getTypeName(){return"URL"}}class T8 extends rc{getTypeName(){return"ResourceURL"}}function oi(n){return n instanceof rc?n.changingThisBreaksApplicationSecurity:n}function Do(n,t){const e=function k8(n){return n instanceof rc&&n.getTypeName()||null}(n);if(null!=e&&e!==t){if("ResourceURL"===e&&"URL"===t)return!0;throw new Error(`Required a safe ${t}, got a ${e} (see ${Gm})`)}return e===t}class O8{constructor(t){this.inertDocumentHelper=t}getInertBodyElement(t){t="<body><remove></remove>"+t;try{const e=(new window.DOMParser).parseFromString(nc(t),"text/html").body;return null===e?this.inertDocumentHelper.getInertBodyElement(t):(e.removeChild(e.firstChild),e)}catch{return null}}}class $8{constructor(t){if(this.defaultDoc=t,this.inertDocument=this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"),null==this.inertDocument.body){const e=this.inertDocument.createElement("html");this.inertDocument.appendChild(e);const r=this.inertDocument.createElement("body");e.appendChild(r)}}getInertBodyElement(t){const e=this.inertDocument.createElement("template");if("content"in e)return e.innerHTML=nc(t),e;const r=this.inertDocument.createElement("body");return r.innerHTML=nc(t),this.defaultDoc.documentMode&&this.stripCustomNsAttrs(r),r}stripCustomNsAttrs(t){const e=t.attributes;for(let s=e.length-1;0<s;s--){const o=e.item(s).name;("xmlns:ns1"===o||0===o.indexOf("ns1:"))&&t.removeAttribute(o)}let r=t.firstChild;for(;r;)r.nodeType===Node.ELEMENT_NODE&&this.stripCustomNsAttrs(r),r=r.nextSibling}}const L8=/^(?:(?:https?|mailto|data|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi;function Cg(n){return(n=String(n)).match(L8)?n:"unsafe:"+n}function aa(n){const t={};for(const e of n.split(","))t[e]=!0;return t}function Oh(...n){const t={};for(const e of n)for(const r in e)e.hasOwnProperty(r)&&(t[r]=!0);return t}const bR=aa("area,br,col,hr,img,wbr"),_R=aa("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),vR=aa("rp,rt"),ow=Oh(bR,Oh(_R,aa("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),Oh(vR,aa("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),Oh(vR,_R)),aw=aa("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),xR=Oh(aw,aa("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),aa("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")),B8=aa("script,style,template");class V8{constructor(){this.sanitizedSomething=!1,this.buf=[]}sanitizeChildren(t){let e=t.firstChild,r=!0;for(;e;)if(e.nodeType===Node.ELEMENT_NODE?r=this.startElement(e):e.nodeType===Node.TEXT_NODE?this.chars(e.nodeValue):this.sanitizedSomething=!0,r&&e.firstChild)e=e.firstChild;else for(;e;){e.nodeType===Node.ELEMENT_NODE&&this.endElement(e);let s=this.checkClobberedElement(e,e.nextSibling);if(s){e=s;break}e=this.checkClobberedElement(e,e.parentNode)}return this.buf.join("")}startElement(t){const e=t.nodeName.toLowerCase();if(!ow.hasOwnProperty(e))return this.sanitizedSomething=!0,!B8.hasOwnProperty(e);this.buf.push("<"),this.buf.push(e);const r=t.attributes;for(let s=0;s<r.length;s++){const i=r.item(s),o=i.name,a=o.toLowerCase();if(!xR.hasOwnProperty(a)){this.sanitizedSomething=!0;continue}let l=i.value;aw[a]&&(l=Cg(l)),this.buf.push(" ",o,'="',wR(l),'"')}return this.buf.push(">"),!0}endElement(t){const e=t.nodeName.toLowerCase();ow.hasOwnProperty(e)&&!bR.hasOwnProperty(e)&&(this.buf.push("</"),this.buf.push(e),this.buf.push(">"))}chars(t){this.buf.push(wR(t))}checkClobberedElement(t,e){if(e&&(t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_CONTAINED_BY)===Node.DOCUMENT_POSITION_CONTAINED_BY)throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`);return e}}const z8=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,U8=/([^\#-~ |!])/g;function wR(n){return n.replace(/&/g,"&amp;").replace(z8,function(t){return"&#"+(1024*(t.charCodeAt(0)-55296)+(t.charCodeAt(1)-56320)+65536)+";"}).replace(U8,function(t){return"&#"+t.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}let Sg;function CR(n,t){let e=null;try{Sg=Sg||function yR(n){const t=new $8(n);return function P8(){try{return!!(new window.DOMParser).parseFromString(nc(""),"text/html")}catch{return!1}}()?new O8(t):t}(n);let r=t?String(t):"";e=Sg.getInertBodyElement(r);let s=5,i=r;do{if(0===s)throw new Error("Failed to sanitize html because the input is unstable");s--,r=i,i=e.innerHTML,e=Sg.getInertBodyElement(r)}while(r!==i);return nc((new V8).sanitizeChildren(lw(e)||e))}finally{if(e){const r=lw(e)||e;for(;r.firstChild;)r.removeChild(r.firstChild)}}}function lw(n){return"content"in n&&function H8(n){return n.nodeType===Node.ELEMENT_NODE&&"TEMPLATE"===n.nodeName}(n)?n.content:null}var Ut=(()=>((Ut=Ut||{})[Ut.NONE=0]="NONE",Ut[Ut.HTML=1]="HTML",Ut[Ut.STYLE=2]="STYLE",Ut[Ut.SCRIPT=3]="SCRIPT",Ut[Ut.URL=4]="URL",Ut[Ut.RESOURCE_URL=5]="RESOURCE_URL",Ut))();const Ig=new me("ENVIRONMENT_INITIALIZER"),DR=new me("INJECTOR",-1),TR=new me("INJECTOR_DEF_TYPES");class kR{get(t,e=mh){if(e===mh){const r=new Error(`NullInjectorError: No provider for ${an(t)}!`);throw r.name="NullInjectorError",r}return e}}function Y8(...n){return{\u0275providers:NR(0,n),\u0275fromNgModule:!0}}function NR(n,...t){const e=[],r=new Set;let s;return ec(t,i=>{const o=i;cw(o,e,[],r)&&(s||(s=[]),s.push(o))}),void 0!==s&&AR(s,e),e}function AR(n,t){for(let e=0;e<n.length;e++){const{providers:s}=n[e];uw(s,i=>{t.push(i)})}}function cw(n,t,e,r){if(!(n=Ge(n)))return!1;let s=null,i=BN(n);const o=!i&&qt(n);if(i||o){if(o&&!o.standalone)return!1;s=n}else{const l=n.ngModule;if(i=BN(l),!i)return!1;s=l}const a=r.has(s);if(o){if(a)return!1;if(r.add(s),o.dependencies){const l="function"==typeof o.dependencies?o.dependencies():o.dependencies;for(const c of l)cw(c,t,e,r)}}else{if(!i)return!1;{if(null!=i.imports&&!a){let c;r.add(s);try{ec(i.imports,u=>{cw(u,t,e,r)&&(c||(c=[]),c.push(u))})}finally{}void 0!==c&&AR(c,t)}if(!a){const c=Ql(s)||(()=>new s);t.push({provide:s,useFactory:c,deps:zt},{provide:TR,useValue:s,multi:!0},{provide:Ig,useValue:()=>Z(s),multi:!0})}const l=i.providers;null==l||a||uw(l,u=>{t.push(u)})}}return s!==n&&void 0!==n.providers}function uw(n,t){for(let e of n)t0(e)&&(e=e.\u0275providers),Array.isArray(e)?uw(e,t):t(e)}const Z8=on({provide:String,useValue:on});function dw(n){return null!==n&&"object"==typeof n&&Z8 in n}function sc(n){return"function"==typeof n}const hw=new me("Set Injector scope."),Eg={},J8={};let fw;function Dg(){return void 0===fw&&(fw=new kR),fw}class qa{}class FR extends qa{constructor(t,e,r,s){super(),this.parent=e,this.source=r,this.scopes=s,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,mw(t,o=>this.processProvider(o)),this.records.set(DR,Cu(void 0,this)),s.has("environment")&&this.records.set(qa,Cu(void 0,this));const i=this.records.get(hw);null!=i&&"string"==typeof i.value&&this.scopes.add(i.value),this.injectorDefTypes=new Set(this.get(TR.multi,zt,qe.Self))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const t of this._ngOnDestroyHooks)t.ngOnDestroy();for(const t of this._onDestroyHooks)t()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),this._onDestroyHooks.length=0}}onDestroy(t){this._onDestroyHooks.push(t)}runInContext(t){this.assertNotDestroyed();const e=nu(this),r=Di(void 0);try{return t()}finally{nu(e),Di(r)}}get(t,e=mh,r=qe.Default){this.assertNotDestroyed(),r=Qm(r);const s=nu(this),i=Di(void 0);try{if(!(r&qe.SkipSelf)){let a=this.records.get(t);if(void 0===a){const l=function s6(n){return"function"==typeof n||"object"==typeof n&&n instanceof me}(t)&&Xm(t);a=l&&this.injectableDefInScope(l)?Cu(pw(t),Eg):null,this.records.set(t,a)}if(null!=a)return this.hydrate(t,a)}return(r&qe.Self?Dg():this.parent).get(t,e=r&qe.Optional&&e===mh?null:e)}catch(o){if("NullInjectorError"===o.name){if((o[Zm]=o[Zm]||[]).unshift(an(t)),s)throw o;return function C5(n,t,e,r){const s=n[Zm];throw t[UN]&&s.unshift(t[UN]),n.message=function S5(n,t,e,r=null){n=n&&"\n"===n.charAt(0)&&"\u0275"==n.charAt(1)?n.slice(2):n;let s=an(t);if(Array.isArray(t))s=t.map(an).join(" -> ");else if("object"==typeof t){let i=[];for(let o in t)if(t.hasOwnProperty(o)){let a=t[o];i.push(o+":"+("string"==typeof a?JSON.stringify(a):an(a)))}s=`{${i.join(", ")}}`}return`${e}${r?"("+r+")":""}[${s}]: ${n.replace(_5,"\n  ")}`}("\n"+n.message,s,e,r),n.ngTokenPath=s,n[Zm]=null,n}(o,t,"R3InjectorError",this.source)}throw o}finally{Di(i),nu(s)}}resolveInjectorInitializers(){const t=nu(this),e=Di(void 0);try{const r=this.get(Ig.multi,zt,qe.Self);for(const s of r)s()}finally{nu(t),Di(e)}}toString(){const t=[],e=this.records;for(const r of e.keys())t.push(an(r));return`R3Injector[${t.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new te(205,!1)}processProvider(t){let e=sc(t=Ge(t))?t:Ge(t&&t.provide);const r=function t6(n){return dw(n)?Cu(void 0,n.useValue):Cu(OR(n),Eg)}(t);if(sc(t)||!0!==t.multi)this.records.get(e);else{let s=this.records.get(e);s||(s=Cu(void 0,Eg,!0),s.factory=()=>o0(s.multi),this.records.set(e,s)),e=t,s.multi.push(t)}this.records.set(e,r)}hydrate(t,e){return e.value===Eg&&(e.value=J8,e.value=e.factory()),"object"==typeof e.value&&e.value&&function r6(n){return null!==n&&"object"==typeof n&&"function"==typeof n.ngOnDestroy}(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}injectableDefInScope(t){if(!t.providedIn)return!1;const e=Ge(t.providedIn);return"string"==typeof e?"any"===e||this.scopes.has(e):this.injectorDefTypes.has(e)}}function pw(n){const t=Xm(n),e=null!==t?t.factory:Ql(n);if(null!==e)return e;if(n instanceof me)throw new te(204,!1);if(n instanceof Function)return function e6(n){const t=n.length;if(t>0)throw kh(t,"?"),new te(204,!1);const e=function p5(n){const t=n&&(n[Ym]||n[VN]);if(t){const e=function m5(n){if(n.hasOwnProperty("name"))return n.name;const t=(""+n).match(/^function\s*([^\s(]+)/);return null===t?"":t[1]}(n);return console.warn(`DEPRECATED: DI is instantiating a token "${e}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${e}" class.`),t}return null}(n);return null!==e?()=>e.factory(n):()=>new n}(n);throw new te(204,!1)}function OR(n,t,e){let r;if(sc(n)){const s=Ge(n);return Ql(s)||pw(s)}if(dw(n))r=()=>Ge(n.useValue);else if(function MR(n){return!(!n||!n.useFactory)}(n))r=()=>n.useFactory(...o0(n.deps||[]));else if(function RR(n){return!(!n||!n.useExisting)}(n))r=()=>Z(Ge(n.useExisting));else{const s=Ge(n&&(n.useClass||n.provide));if(!function n6(n){return!!n.deps}(n))return Ql(s)||pw(s);r=()=>new s(...o0(n.deps))}return r}function Cu(n,t,e=!1){return{factory:n,value:t,multi:e?[]:void 0}}function mw(n,t){for(const e of n)Array.isArray(e)?mw(e,t):e&&t0(e)?mw(e.\u0275providers,t):t(e)}class i6{}class $R{}class a6{resolveComponentFactory(t){throw function o6(n){const t=Error(`No component factory found for ${an(n)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=n,t}(t)}}let ic=(()=>{class n{}return n.NULL=new a6,n})();function l6(){return Su(Hr(),oe())}function Su(n,t){return new Kt(ni(n,t))}let Kt=(()=>{class n{constructor(e){this.nativeElement=e}}return n.__NG_ELEMENT_ID__=l6,n})();function c6(n){return n instanceof Kt?n.nativeElement:n}class Ph{}let la=(()=>{class n{}return n.__NG_ELEMENT_ID__=()=>function u6(){const n=oe(),e=ri(Hr().index,n);return(Fs(e)?e:n)[11]}(),n})(),d6=(()=>{class n{}return n.\u0275prov=we({token:n,providedIn:"root",factory:()=>null}),n})();class oc{constructor(t){this.full=t,this.major=t.split(".")[0],this.minor=t.split(".")[1],this.patch=t.split(".").slice(2).join(".")}}const h6=new oc("15.0.1"),gw={};function bw(n){return n.ngOriginalError}class ca{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t);this._console.error("ERROR",t),e&&this._console.error("ORIGINAL ERROR",e)}_findOriginalError(t){let e=t&&bw(t);for(;e&&bw(e);)e=bw(e);return e||null}}function ua(n){return n instanceof Function?n():n}function BR(n,t,e){let r=n.length;for(;;){const s=n.indexOf(t,e);if(-1===s)return s;if(0===s||n.charCodeAt(s-1)<=32){const i=t.length;if(s+i===r||n.charCodeAt(s+i)<=32)return s}e=s+1}}const VR="ng-template";function C6(n,t,e){let r=0;for(;r<n.length;){let s=n[r++];if(e&&"class"===s){if(s=n[r],-1!==BR(s.toLowerCase(),t,0))return!0}else if(1===s){for(;r<n.length&&"string"==typeof(s=n[r++]);)if(s.toLowerCase()===t)return!0;return!1}}return!1}function zR(n){return 4===n.type&&n.value!==VR}function S6(n,t,e){return t===(4!==n.type||e?n.value:VR)}function I6(n,t,e){let r=4;const s=n.attrs||[],i=function T6(n){for(let t=0;t<n.length;t++)if(fA(n[t]))return t;return n.length}(s);let o=!1;for(let a=0;a<t.length;a++){const l=t[a];if("number"!=typeof l){if(!o)if(4&r){if(r=2|1&r,""!==l&&!S6(n,l,e)||""===l&&1===t.length){if(ro(r))return!1;o=!0}}else{const c=8&r?l:t[++a];if(8&r&&null!==n.attrs){if(!C6(n.attrs,c,e)){if(ro(r))return!1;o=!0}continue}const d=E6(8&r?"class":l,s,zR(n),e);if(-1===d){if(ro(r))return!1;o=!0;continue}if(""!==c){let h;h=d>i?"":s[d+1].toLowerCase();const f=8&r?h:null;if(f&&-1!==BR(f,c,0)||2&r&&c!==h){if(ro(r))return!1;o=!0}}}}else{if(!o&&!ro(r)&&!ro(l))return!1;if(o&&ro(l))continue;o=!1,r=l|1&r}}return ro(r)||o}function ro(n){return 0==(1&n)}function E6(n,t,e,r){if(null===t)return-1;let s=0;if(r||!e){let i=!1;for(;s<t.length;){const o=t[s];if(o===n)return s;if(3===o||6===o)i=!0;else{if(1===o||2===o){let a=t[++s];for(;"string"==typeof a;)a=t[++s];continue}if(4===o)break;if(0===o){s+=4;continue}}s+=i?1:2}return-1}return function k6(n,t){let e=n.indexOf(4);if(e>-1)for(e++;e<n.length;){const r=n[e];if("number"==typeof r)return-1;if(r===t)return e;e++}return-1}(t,n)}function UR(n,t,e=!1){for(let r=0;r<t.length;r++)if(I6(n,t[r],e))return!0;return!1}function N6(n,t){e:for(let e=0;e<t.length;e++){const r=t[e];if(n.length===r.length){for(let s=0;s<n.length;s++)if(n[s]!==r[s])continue e;return!0}}return!1}function HR(n,t){return n?":not("+t.trim()+")":t}function A6(n){let t=n[0],e=1,r=2,s="",i=!1;for(;e<n.length;){let o=n[e];if("string"==typeof o)if(2&r){const a=n[++e];s+="["+o+(a.length>0?'="'+a+'"':"")+"]"}else 8&r?s+="."+o:4&r&&(s+=" "+o);else""!==s&&!ro(o)&&(t+=HR(i,s),s=""),r=o,i=i||!ro(r);e++}return""!==s&&(t+=HR(i,s)),t}const st={};function gt(n){WR($t(),oe(),bs()+n,!1)}function WR(n,t,e,r){if(!r)if(3==(3&t[2])){const i=n.preOrderCheckHooks;null!==i&&lg(t,i,e)}else{const i=n.preOrderHooks;null!==i&&cg(t,i,0,e)}Jl(e)}function KR(n,t=null,e=null,r){const s=XR(n,t,e,r);return s.resolveInjectorInitializers(),s}function XR(n,t=null,e=null,r,s=new Set){const i=[e||zt,Y8(n)];return r=r||("object"==typeof n?void 0:an(n)),new FR(i,t||Dg(),r||null,s)}let vr=(()=>{class n{static create(e,r){if(Array.isArray(e))return KR({name:""},r,e,"");{const s=e.name??"";return KR({name:s},e.parent,e.providers,s)}}}return n.THROW_IF_NOT_FOUND=mh,n.NULL=new kR,n.\u0275prov=we({token:n,providedIn:"any",factory:()=>Z(DR)}),n.__NG_ELEMENT_ID__=-1,n})();function B(n,t=qe.Default){const e=oe();return null===e?Z(n,t):xA(Hr(),e,Ge(n),t)}function Lh(){throw new Error("invalid")}function kg(n,t){return n<<17|t<<2}function so(n){return n>>17&32767}function Cw(n){return 2|n}function da(n){return(131068&n)>>2}function Sw(n,t){return-131069&n|t<<2}function Iw(n){return 1|n}function hM(n,t){const e=n.contentQueries;if(null!==e)for(let r=0;r<e.length;r+=2){const s=e[r],i=e[r+1];if(-1!==i){const o=n.data[i];w0(s),o.contentQueries(2,t[i],i)}}}function Rg(n,t,e,r,s,i,o,a,l,c,u){const d=t.blueprint.slice();return d[0]=s,d[2]=76|r,(null!==u||n&&1024&n[2])&&(d[2]|=1024),JN(d),d[3]=d[15]=n,d[8]=e,d[10]=o||n&&n[10],d[11]=a||n&&n[11],d[12]=l||n&&n[12]||null,d[9]=c||n&&n[9]||null,d[6]=i,d[20]=function Gq(){return jq++}(),d[21]=u,d[16]=2==t.type?n[16]:d,d}function Du(n,t,e,r,s){let i=n.data[t];if(null===i)i=function Mw(n,t,e,r,s){const i=nA(),o=b0(),l=n.data[t]=function fK(n,t,e,r,s,i){return{type:e,index:r,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:0,providerIndexes:0,value:s,attrs:i,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,o?i:i&&i.parent,e,t,r,s);return null===n.firstChild&&(n.firstChild=l),null!==i&&(o?null==i.child&&null!==l.parent&&(i.child=l):null===i.next&&(i.next=l)),l}(n,t,e,r,s),function Z5(){return et.lFrame.inI18n}()&&(i.flags|=32);else if(64&i.type){i.type=e,i.value=r,i.attrs=s;const o=function Ch(){const n=et.lFrame,t=n.currentTNode;return n.isParent?t:t.parent}();i.injectorIndex=null===o?-1:o.injectorIndex}return Io(i,!0),i}function Bh(n,t,e,r){if(0===e)return-1;const s=t.length;for(let i=0;i<e;i++)t.push(r),n.blueprint.push(r),n.data.push(null);return s}function Fw(n,t,e){C0(t);try{const r=n.viewQuery;null!==r&&Ww(1,r,e);const s=n.template;null!==s&&fM(n,t,s,1,e),n.firstCreatePass&&(n.firstCreatePass=!1),n.staticContentQueries&&hM(n,t),n.staticViewQueries&&Ww(2,n.viewQuery,e);const i=n.components;null!==i&&function uK(n,t){for(let e=0;e<t.length;e++)RK(n,t[e])}(t,i)}catch(r){throw n.firstCreatePass&&(n.incompleteFirstPass=!0,n.firstCreatePass=!1),r}finally{t[2]&=-5,S0()}}function Mg(n,t,e,r){const s=t[2];if(128!=(128&s)){C0(t);try{JN(t),function sA(n){return et.lFrame.bindingIndex=n}(n.bindingStartIndex),null!==e&&fM(n,t,e,2,r);const o=3==(3&s);if(o){const c=n.preOrderCheckHooks;null!==c&&lg(t,c,null)}else{const c=n.preOrderHooks;null!==c&&cg(t,c,0,null),E0(t,0)}if(function NK(n){for(let t=q0(n);null!==t;t=K0(t)){if(!t[2])continue;const e=t[9];for(let r=0;r<e.length;r++){const s=e[r],i=s[3];0==(512&s[2])&&y0(i,1),s[2]|=512}}}(t),function kK(n){for(let t=q0(n);null!==t;t=K0(t))for(let e=10;e<t.length;e++){const r=t[e],s=r[1];og(r)&&Mg(s,r,s.template,r[8])}}(t),null!==n.contentQueries&&hM(n,t),o){const c=n.contentCheckHooks;null!==c&&lg(t,c)}else{const c=n.contentHooks;null!==c&&cg(t,c,1),E0(t,1)}!function lK(n,t){const e=n.hostBindingOpCodes;if(null!==e)try{for(let r=0;r<e.length;r++){const s=e[r];if(s<0)Jl(~s);else{const i=s,o=e[++r],a=e[++r];Q5(o,i),a(2,t[i])}}}finally{Jl(-1)}}(n,t);const a=n.components;null!==a&&function cK(n,t){for(let e=0;e<t.length;e++)AK(n,t[e])}(t,a);const l=n.viewQuery;if(null!==l&&Ww(2,l,r),o){const c=n.viewCheckHooks;null!==c&&lg(t,c)}else{const c=n.viewHooks;null!==c&&cg(t,c,2),E0(t,2)}!0===n.firstUpdatePass&&(n.firstUpdatePass=!1),t[2]&=-41,512&t[2]&&(t[2]&=-513,y0(t[3],-1))}finally{S0()}}}function fM(n,t,e,r,s){const i=bs(),o=2&r;try{Jl(-1),o&&t.length>22&&WR(n,t,22,!1),e(r,s)}finally{Jl(i)}}function Ow(n,t,e){if(d0(t)){const s=t.directiveEnd;for(let i=t.directiveStart;i<s;i++){const o=n.data[i];o.contentQueries&&o.contentQueries(1,e[i],i)}}}function $w(n,t,e){!tA()||(function _K(n,t,e,r){const s=e.directiveStart,i=e.directiveEnd;n.firstCreatePass||dg(e,t),es(r,t);const o=e.initialInputs;for(let a=s;a<i;a++){const l=n.data[a],c=no(l);c&&EK(t,e,l);const u=hu(t,n,a,e);es(u,t),null!==o&&DK(0,a-s,u,l,0,o),c&&(ri(e.index,t)[8]=u)}}(n,t,e,ni(e,t)),64==(64&e.flags)&&vM(n,t,e))}function Pw(n,t,e=ni){const r=t.localNames;if(null!==r){let s=t.index+1;for(let i=0;i<r.length;i+=2){const o=r[i+1],a=-1===o?e(t,n):n[o];n[s++]=a}}}function pM(n){const t=n.tView;return null===t||t.incompleteFirstPass?n.tView=Lw(1,null,n.template,n.decls,n.vars,n.directiveDefs,n.pipeDefs,n.viewQuery,n.schemas,n.consts):t}function Lw(n,t,e,r,s,i,o,a,l,c){const u=22+r,d=u+s,h=function dK(n,t){const e=[];for(let r=0;r<t;r++)e.push(r<n?null:st);return e}(u,d),f="function"==typeof c?c():c;return h[1]={type:n,blueprint:h,template:e,queries:null,viewQuery:a,declTNode:t,data:h.slice().fill(null,u),bindingStartIndex:u,expandoStartIndex:d,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof i?i():i,pipeRegistry:"function"==typeof o?o():o,firstChild:null,schemas:l,consts:f,incompleteFirstPass:!1}}function mM(n,t,e,r){const s=wM(t);null===e?s.push(r):(s.push(e),n.firstCreatePass&&CM(n).push(r,s.length-1))}function gM(n,t,e,r){for(let s in n)if(n.hasOwnProperty(s)){e=null===e?{}:e;const i=n[s];null===r?yM(e,t,s,i):r.hasOwnProperty(s)&&yM(e,t,r[s],i)}return e}function yM(n,t,e,r){n.hasOwnProperty(e)?n[e].push(t,r):n[e]=[t,r]}function ai(n,t,e,r,s,i,o,a){const l=ni(t,e);let u,c=t.inputs;!a&&null!=c&&(u=c[r])?(jw(n,e,u,r,s),rg(t)&&bM(e,t.index)):3&t.type&&(r=function mK(n){return"class"===n?"className":"for"===n?"htmlFor":"formaction"===n?"formAction":"innerHtml"===n?"innerHTML":"readonly"===n?"readOnly":"tabindex"===n?"tabIndex":n}(r),s=null!=o?o(s,t.value||"",r):s,i.setProperty(l,r,s))}function bM(n,t){const e=ri(t,n);16&e[2]||(e[2]|=32)}function Bw(n,t,e,r){let s=!1;if(tA()){const i=null===r?null:{"":-1},o=function xK(n,t){const e=n.directiveRegistry;let r=null,s=null;if(e)for(let i=0;i<e.length;i++){const o=e[i];if(UR(t,o.selectors,!1))if(r||(r=[]),no(o))if(null!==o.findHostDirectiveDefs){const a=[];s=s||new Map,o.findHostDirectiveDefs(o,a,s),r.unshift(...a,o),Vw(n,t,a.length)}else r.unshift(o),Vw(n,t,0);else s=s||new Map,o.findHostDirectiveDefs?.(o,r,s),r.push(o)}return null===r?null:[r,s]}(n,e);let a,l;null===o?a=l=null:[a,l]=o,null!==a&&(s=!0,_M(n,t,e,a,i,l)),i&&function wK(n,t,e){if(t){const r=n.localNames=[];for(let s=0;s<t.length;s+=2){const i=e[t[s+1]];if(null==i)throw new te(-301,!1);r.push(t[s],i)}}}(e,r,i)}return e.mergedAttrs=Eh(e.mergedAttrs,e.attrs),s}function _M(n,t,e,r,s,i){for(let c=0;c<r.length;c++)R0(dg(e,t),n,r[c].type);!function SK(n,t,e){n.flags|=1,n.directiveStart=t,n.directiveEnd=t+e,n.providerIndexes=t}(e,n.data.length,r.length);for(let c=0;c<r.length;c++){const u=r[c];u.providersResolver&&u.providersResolver(u)}let o=!1,a=!1,l=Bh(n,t,r.length,null);for(let c=0;c<r.length;c++){const u=r[c];e.mergedAttrs=Eh(e.mergedAttrs,u.hostAttrs),IK(n,e,t,l,u),CK(l,u,s),null!==u.contentQueries&&(e.flags|=4),(null!==u.hostBindings||null!==u.hostAttrs||0!==u.hostVars)&&(e.flags|=64);const d=u.type.prototype;!o&&(d.ngOnChanges||d.ngOnInit||d.ngDoCheck)&&((n.preOrderHooks||(n.preOrderHooks=[])).push(e.index),o=!0),!a&&(d.ngOnChanges||d.ngDoCheck)&&((n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e.index),a=!0),l++}!function pK(n,t,e){const s=t.directiveEnd,i=n.data,o=t.attrs,a=[];let l=null,c=null;for(let u=t.directiveStart;u<s;u++){const d=i[u],h=e?e.get(d):null,p=h?h.outputs:null;l=gM(d.inputs,u,l,h?h.inputs:null),c=gM(d.outputs,u,c,p);const m=null===l||null===o||zR(t)?null:TK(l,u,o);a.push(m)}null!==l&&(l.hasOwnProperty("class")&&(t.flags|=8),l.hasOwnProperty("style")&&(t.flags|=16)),t.initialInputs=a,t.inputs=l,t.outputs=c}(n,e,i)}function vM(n,t,e){const r=e.directiveStart,s=e.directiveEnd,i=e.index,o=function J5(){return et.lFrame.currentDirectiveIndex}();try{Jl(i);for(let a=r;a<s;a++){const l=n.data[a],c=t[a];v0(a),(null!==l.hostBindings||0!==l.hostVars||null!==l.hostAttrs)&&vK(l,c)}}finally{Jl(-1),v0(o)}}function vK(n,t){null!==n.hostBindings&&n.hostBindings(1,t)}function Vw(n,t,e){t.componentOffset=e,(n.components||(n.components=[])).push(t.index)}function CK(n,t,e){if(e){if(t.exportAs)for(let r=0;r<t.exportAs.length;r++)e[t.exportAs[r]]=n;no(t)&&(e[""]=n)}}function IK(n,t,e,r,s){n.data[r]=s;const i=s.factory||(s.factory=Ql(s.type)),o=new Sh(i,no(s),B);n.blueprint[r]=o,e[r]=o,function yK(n,t,e,r,s){const i=s.hostBindings;if(i){let o=n.hostBindingOpCodes;null===o&&(o=n.hostBindingOpCodes=[]);const a=~t.index;(function bK(n){let t=n.length;for(;t>0;){const e=n[--t];if("number"==typeof e&&e<0)return e}return 0})(o)!=a&&o.push(a),o.push(e,r,i)}}(n,t,r,Bh(n,e,s.hostVars,st),s)}function EK(n,t,e){const r=ni(t,n),s=pM(e),i=n[10],o=Fg(n,Rg(n,s,null,e.onPush?32:16,r,t,i,i.createRenderer(r,e),null,null,null));n[t.index]=o}function To(n,t,e,r,s,i){const o=ni(n,t);!function zw(n,t,e,r,s,i,o){if(null==i)n.removeAttribute(t,s,e);else{const a=null==o?rt(i):o(i,r||"",s);n.setAttribute(t,s,a,e)}}(t[11],o,i,n.value,e,r,s)}function DK(n,t,e,r,s,i){const o=i[t];if(null!==o){const a=r.setInput;for(let l=0;l<o.length;){const c=o[l++],u=o[l++],d=o[l++];null!==a?r.setInput(e,d,c,u):e[u]=d}}}function TK(n,t,e){let r=null,s=0;for(;s<e.length;){const i=e[s];if(0!==i)if(5!==i){if("number"==typeof i)break;if(n.hasOwnProperty(i)){null===r&&(r=[]);const o=n[i];for(let a=0;a<o.length;a+=2)if(o[a]===t){r.push(i,o[a+1],e[s+1]);break}}s+=2}else s+=2;else s+=4}return r}function xM(n,t,e,r){return new Array(n,!0,!1,t,null,0,r,e,null,null)}function AK(n,t){const e=ri(t,n);if(og(e)){const r=e[1];48&e[2]?Mg(r,e,r.template,e[8]):e[5]>0&&Uw(e)}}function Uw(n){for(let r=q0(n);null!==r;r=K0(r))for(let s=10;s<r.length;s++){const i=r[s];if(og(i))if(512&i[2]){const o=i[1];Mg(o,i,o.template,i[8])}else i[5]>0&&Uw(i)}const e=n[1].components;if(null!==e)for(let r=0;r<e.length;r++){const s=ri(e[r],n);og(s)&&s[5]>0&&Uw(s)}}function RK(n,t){const e=ri(t,n),r=e[1];(function MK(n,t){for(let e=t.length;e<n.blueprint.length;e++)t.push(n.blueprint[e])})(r,e),Fw(r,e,e[8])}function Fg(n,t){return n[13]?n[14][4]=t:n[13]=t,n[14]=t,t}function Hw(n){for(;n;){n[2]|=32;const t=Mh(n);if(A5(n)&&!t)return n;n=t}return null}function Og(n,t,e,r=!0){const s=t[10];s.begin&&s.begin();try{Mg(n,t,n.template,e)}catch(o){throw r&&IM(t,o),o}finally{s.end&&s.end()}}function Ww(n,t,e){w0(0),t(n,e)}function wM(n){return n[7]||(n[7]=[])}function CM(n){return n.cleanup||(n.cleanup=[])}function SM(n,t,e){return(null===n||no(n))&&(e=function z5(n){for(;Array.isArray(n);){if("object"==typeof n[1])return n;n=n[0]}return null}(e[t.index])),e[11]}function IM(n,t){const e=n[9],r=e?e.get(ca,null):null;r&&r.handleError(t)}function jw(n,t,e,r,s){for(let i=0;i<e.length;){const o=e[i++],a=e[i++],l=t[o],c=n.data[o];null!==c.setInput?c.setInput(l,s,r,a):l[a]=s}}function $g(n,t,e){let r=e?n.styles:null,s=e?n.classes:null,i=0;if(null!==t)for(let o=0;o<t.length;o++){const a=t[o];"number"==typeof a?i=a:1==i?s=Jx(s,a):2==i&&(r=Jx(r,a+": "+t[++o]+";"))}e?n.styles=r:n.stylesWithoutHost=r,e?n.classes=s:n.classesWithoutHost=s}function Pg(n,t,e,r,s=!1){for(;null!==e;){const i=t[e.index];if(null!==i&&r.push(br(i)),to(i))for(let a=10;a<i.length;a++){const l=i[a],c=l[1].firstChild;null!==c&&Pg(l[1],l,c,r)}const o=e.type;if(8&o)Pg(n,t,e.child,r);else if(32&o){const a=G0(e,t);let l;for(;l=a();)r.push(l)}else if(16&o){const a=cR(t,e);if(Array.isArray(a))r.push(...a);else{const l=Mh(t[16]);Pg(l[1],l,a,r,!0)}}e=s?e.projectionNext:e.next}return r}class Vh{constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const t=this._lView,e=t[1];return Pg(e,t,e.firstChild,[])}get context(){return this._lView[8]}set context(t){this._lView[8]=t}get destroyed(){return 128==(128&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[3];if(to(t)){const e=t[8],r=e?e.indexOf(this):-1;r>-1&&(Z0(t,r),pg(e,r))}this._attachedToViewContainer=!1}eR(this._lView[1],this._lView)}onDestroy(t){mM(this._lView[1],this._lView,null,t)}markForCheck(){Hw(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-65}reattach(){this._lView[2]|=64}detectChanges(){Og(this._lView[1],this._lView,this.context)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new te(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function l8(n,t){Fh(n,t,t[11],2,null,null)}(this._lView[1],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new te(902,!1);this._appRef=t}}class FK extends Vh{constructor(t){super(t),this._view=t}detectChanges(){const t=this._view;Og(t[1],t,t[8],!1)}checkNoChanges(){}get context(){return null}}class Gw extends ic{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=qt(t);return new zh(e,this.ngModule)}}function EM(n){const t=[];for(let e in n)n.hasOwnProperty(e)&&t.push({propName:n[e],templateName:e});return t}class $K{constructor(t,e){this.injector=t,this.parentInjector=e}get(t,e,r){r=Qm(r);const s=this.injector.get(t,gw,r);return s!==gw||e===gw?s:this.parentInjector.get(t,e,r)}}class zh extends $R{constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=function R6(n){return n.map(A6).join(",")}(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return EM(this.componentDef.inputs)}get outputs(){return EM(this.componentDef.outputs)}create(t,e,r,s){let i=(s=s||this.ngModule)instanceof qa?s:s?.injector;i&&null!==this.componentDef.getStandaloneInjector&&(i=this.componentDef.getStandaloneInjector(i)||i);const o=i?new $K(t,i):t,a=o.get(Ph,null);if(null===a)throw new te(407,!1);const l=o.get(d6,null),c=a.createRenderer(null,this.componentDef),u=this.componentDef.selectors[0][0]||"div",d=r?function hK(n,t,e){return n.selectRootElement(t,e===Ji.ShadowDom)}(c,r,this.componentDef.encapsulation):Y0(c,u,function OK(n){const t=n.toLowerCase();return"svg"===t?"svg":"math"===t?"math":null}(u)),h=this.componentDef.onPush?288:272,f=Lw(0,null,null,1,0,null,null,null,null,null),p=Rg(null,f,null,h,null,null,a,c,l,o,null);let m,g;C0(p);try{const y=this.componentDef;let b,_=null;y.findHostDirectiveDefs?(b=[],_=new Map,y.findHostDirectiveDefs(y,b,_),b.push(y)):b=[y];const v=function BK(n,t){const e=n[1];return n[22]=t,Du(e,22,2,"#host",null)}(p,d),w=function VK(n,t,e,r,s,i,o,a){const l=s[1];!function zK(n,t,e,r){for(const s of n)t.mergedAttrs=Eh(t.mergedAttrs,s.hostAttrs);null!==t.mergedAttrs&&($g(t,t.mergedAttrs,!0),null!==e&&hR(r,e,t))}(r,n,t,o);const c=i.createRenderer(t,e),u=Rg(s,pM(e),null,e.onPush?32:16,s[n.index],n,i,c,a||null,null,null);return l.firstCreatePass&&Vw(l,n,r.length-1),Fg(s,u),s[n.index]=u}(v,d,y,b,p,a,c);g=g0(f,22),d&&function HK(n,t,e,r){if(r)T0(n,e,["ng-version",h6.full]);else{const{attrs:s,classes:i}=function M6(n){const t=[],e=[];let r=1,s=2;for(;r<n.length;){let i=n[r];if("string"==typeof i)2===s?""!==i&&t.push(i,n[++r]):8===s&&e.push(i);else{if(!ro(s))break;s=i}r++}return{attrs:t,classes:e}}(t.selectors[0]);s&&T0(n,e,s),i&&i.length>0&&dR(n,e,i.join(" "))}}(c,y,d,r),void 0!==e&&function WK(n,t,e){const r=n.projection=[];for(let s=0;s<t.length;s++){const i=e[s];r.push(null!=i?Array.from(i):null)}}(g,this.ngContentSelectors,e),m=function UK(n,t,e,r,s,i){const o=Hr(),a=s[1],l=ni(o,s);_M(a,s,o,e,null,r);for(let u=0;u<e.length;u++)es(hu(s,a,o.directiveStart+u,o),s);vM(a,s,o),l&&es(l,s);const c=hu(s,a,o.directiveStart+o.componentOffset,o);if(n[8]=s[8]=c,null!==i)for(const u of i)u(c,t);return Ow(a,o,n),c}(w,y,b,_,p,[jK]),Fw(f,p,null)}finally{S0()}return new LK(this.componentType,m,Su(g,p),p,g)}}class LK extends i6{constructor(t,e,r,s,i){super(),this.location=r,this._rootLView=s,this._tNode=i,this.instance=e,this.hostView=this.changeDetectorRef=new FK(s),this.componentType=t}setInput(t,e){const r=this._tNode.inputs;let s;if(null!==r&&(s=r[t])){const i=this._rootLView;jw(i[1],i,s,t,e),bM(i,this._tNode.index)}}get injector(){return new fu(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}function jK(){const n=Hr();ag(oe()[1],n)}function it(n){let t=function DM(n){return Object.getPrototypeOf(n.prototype).constructor}(n.type),e=!0;const r=[n];for(;t;){let s;if(no(n))s=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new te(903,!1);s=t.\u0275dir}if(s){if(e){r.push(s);const o=n;o.inputs=qw(n.inputs),o.declaredInputs=qw(n.declaredInputs),o.outputs=qw(n.outputs);const a=s.hostBindings;a&&XK(n,a);const l=s.viewQuery,c=s.contentQueries;if(l&&qK(n,l),c&&KK(n,c),Qx(n.inputs,s.inputs),Qx(n.declaredInputs,s.declaredInputs),Qx(n.outputs,s.outputs),no(s)&&s.data.animation){const u=n.data;u.animation=(u.animation||[]).concat(s.data.animation)}}const i=s.features;if(i)for(let o=0;o<i.length;o++){const a=i[o];a&&a.ngInherit&&a(n),a===it&&(e=!1)}}t=Object.getPrototypeOf(t)}!function GK(n){let t=0,e=null;for(let r=n.length-1;r>=0;r--){const s=n[r];s.hostVars=t+=s.hostVars,s.hostAttrs=Eh(s.hostAttrs,e=Eh(e,s.hostAttrs))}}(r)}function qw(n){return n===ra?{}:n===zt?[]:n}function qK(n,t){const e=n.viewQuery;n.viewQuery=e?(r,s)=>{t(r,s),e(r,s)}:t}function KK(n,t){const e=n.contentQueries;n.contentQueries=e?(r,s,i)=>{t(r,s,i),e(r,s,i)}:t}function XK(n,t){const e=n.hostBindings;n.hostBindings=e?(r,s)=>{t(r,s),e(r,s)}:t}let Lg=null;function ac(){if(!Lg){const n=pn.Symbol;if(n&&n.iterator)Lg=n.iterator;else{const t=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e<t.length;++e){const r=t[e];"entries"!==r&&"size"!==r&&Map.prototype[r]===Map.prototype.entries&&(Lg=r)}}}return Lg}function Uh(n){return!!Kw(n)&&(Array.isArray(n)||!(n instanceof Map)&&ac()in n)}function Kw(n){return null!==n&&("function"==typeof n||"object"==typeof n)}function ts(n,t,e){return!Object.is(n[t],e)&&(n[t]=e,!0)}function Qt(n,t,e,r){const s=oe();return ts(s,lu(),t)&&($t(),To(Fn(),s,n,t,e,r)),Qt}function ku(n,t,e,r){return ts(n,lu(),e)?t+rt(e)+r:st}function wn(n,t,e,r,s,i,o,a){const l=oe(),c=$t(),u=n+22,d=c.firstCreatePass?function iX(n,t,e,r,s,i,o,a,l){const c=t.consts,u=Du(t,n,4,o||null,Wa(c,a));Bw(t,e,u,Wa(c,l)),ag(t,u);const d=u.tViews=Lw(2,u,r,s,i,t.directiveRegistry,t.pipeRegistry,null,t.schemas,c);return null!==t.queries&&(t.queries.template(t,u),d.queries=t.queries.embeddedTView(u)),u}(u,c,l,t,e,r,s,i,o):c.data[u];Io(d,!1);const h=l[11].createComment("");_g(c,l,h,d),es(h,l),Fg(l,l[u]=xM(h,l,h,d)),sg(d)&&$w(c,l,d),null!=o&&Pw(l,d,a)}function fa(n){return au(function Y5(){return et.lFrame.contextLView}(),22+n)}function yt(n,t,e){const r=oe();return ts(r,lu(),t)&&ai($t(),Fn(),r,n,t,r[11],e,!1),yt}function Xw(n,t,e,r,s){const o=s?"class":"style";jw(n,e,t.inputs[o],o,r)}function Qe(n,t,e,r){const s=oe(),i=$t(),o=22+n,a=s[11],l=s[o]=Y0(a,t,function iq(){return et.lFrame.currentNamespace}()),c=i.firstCreatePass?function aX(n,t,e,r,s,i,o){const a=t.consts,c=Du(t,n,2,s,Wa(a,i));return Bw(t,e,c,Wa(a,o)),null!==c.attrs&&$g(c,c.attrs,!1),null!==c.mergedAttrs&&$g(c,c.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,c),c}(o,i,s,0,t,e,r):i.data[o];return Io(c,!0),hR(a,l,c),32!=(32&c.flags)&&_g(i,s,l,c),0===function j5(){return et.lFrame.elementDepthCount}()&&es(l,s),function G5(){et.lFrame.elementDepthCount++}(),sg(c)&&($w(i,s,c),Ow(i,c,s)),null!==r&&Pw(s,c),Qe}function xt(){let n=Hr();b0()?_0():(n=n.parent,Io(n,!1));const t=n;!function q5(){et.lFrame.elementDepthCount--}();const e=$t();return e.firstCreatePass&&(ag(e,n),d0(n)&&e.queries.elementEnd(n)),null!=t.classesWithoutHost&&function uq(n){return 0!=(8&n.flags)}(t)&&Xw(e,t,oe(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function dq(n){return 0!=(16&n.flags)}(t)&&Xw(e,t,oe(),t.stylesWithoutHost,!1),xt}function rr(n,t,e,r){return Qe(n,t,e,r),xt(),rr}function Wh(n,t,e){const r=oe(),s=$t(),i=n+22,o=s.firstCreatePass?function lX(n,t,e,r,s){const i=t.consts,o=Wa(i,r),a=Du(t,n,8,"ng-container",o);return null!==o&&$g(a,o,!0),Bw(t,e,a,Wa(i,s)),null!==t.queries&&t.queries.elementStart(t,a),a}(i,s,r,t,e):s.data[i];Io(o,!0);const a=r[i]=r[11].createComment("");return _g(s,r,a,o),es(a,r),sg(o)&&($w(s,r,o),Ow(s,o,r)),null!=e&&Pw(r,o),Wh}function jh(){let n=Hr();const t=$t();return b0()?_0():(n=n.parent,Io(n,!1)),t.firstCreatePass&&(ag(t,n),d0(n)&&t.queries.elementEnd(n)),jh}function Gh(n,t,e){return Wh(n,t,e),jh(),Gh}function pa(){return oe()}function qh(n){return!!n&&"function"==typeof n.then}const Yw=function VM(n){return!!n&&"function"==typeof n.subscribe};function Jt(n,t,e,r){const s=oe(),i=$t(),o=Hr();return zM(i,s,s[11],o,n,t,r),Jt}function Zw(n,t){const e=Hr(),r=oe(),s=$t();return zM(s,r,SM(x0(s.data),e,r),e,n,t),Zw}function zM(n,t,e,r,s,i,o){const a=sg(r),c=n.firstCreatePass&&CM(n),u=t[8],d=wM(t);let h=!0;if(3&r.type||o){const m=ni(r,t),g=o?o(m):m,y=d.length,b=o?v=>o(br(v[r.index])):r.index;let _=null;if(!o&&a&&(_=function cX(n,t,e,r){const s=n.cleanup;if(null!=s)for(let i=0;i<s.length-1;i+=2){const o=s[i];if(o===e&&s[i+1]===r){const a=t[7],l=s[i+2];return a.length>l?a[l]:null}"string"==typeof o&&(i+=2)}return null}(n,t,s,r.index)),null!==_)(_.__ngLastListenerFn__||_).__ngNextListenerFn__=i,_.__ngLastListenerFn__=i,h=!1;else{i=HM(r,t,u,i,!1);const v=e.listen(g,s,i);d.push(i,v),c&&c.push(s,b,y,y+1)}}else i=HM(r,t,u,i,!1);const f=r.outputs;let p;if(h&&null!==f&&(p=f[s])){const m=p.length;if(m)for(let g=0;g<m;g+=2){const w=t[p[g]][p[g+1]].subscribe(i),C=d.length;d.push(i,w),c&&c.push(s,r.index,C,-(C+1))}}}function UM(n,t,e,r){try{return!1!==e(r)}catch(s){return IM(n,s),!1}}function HM(n,t,e,r,s){return function i(o){if(o===Function)return r;Hw(n.componentOffset>-1?ri(n.index,t):t);let l=UM(t,0,r,o),c=i.__ngNextListenerFn__;for(;c;)l=UM(t,0,c,o)&&l,c=c.__ngNextListenerFn__;return s&&!1===l&&(o.preventDefault(),o.returnValue=!1),l}}function en(n=1){return function tq(n){return(et.lFrame.contextLView=function nq(n,t){for(;n>0;)t=t[15],n--;return t}(n,et.lFrame.contextLView))[8]}(n)}function uX(n,t){let e=null;const r=function D6(n){const t=n.attrs;if(null!=t){const e=t.indexOf(5);if(0==(1&e))return t[e+1]}return null}(n);for(let s=0;s<t.length;s++){const i=t[s];if("*"!==i){if(null===r?UR(n,i,!0):N6(r,i))return s}else e=s}return e}function ma(n){const t=oe()[16][6];if(!t.projection){const r=t.projection=kh(n?n.length:1,null),s=r.slice();let i=t.child;for(;null!==i;){const o=n?uX(i,n):0;null!==o&&(s[o]?s[o].projectionNext=i:r[o]=i,s[o]=i),i=i.next}}}function vs(n,t=0,e){const r=oe(),s=$t(),i=Du(s,22+n,16,null,e||null);null===i.projection&&(i.projection=t),_0(),32!=(32&i.flags)&&function g8(n,t,e){uR(t[11],0,t,e,tR(n,e,t),iR(e.parent||t[6],e,t))}(s,r,i)}function JM(n,t,e,r,s){const i=n[e+1],o=null===t;let a=r?so(i):da(i),l=!1;for(;0!==a&&(!1===l||o);){const u=n[a+1];fX(n[a],t)&&(l=!0,n[a+1]=r?Iw(u):Cw(u)),a=r?so(u):da(u)}l&&(n[e+1]=r?Cw(i):Iw(i))}function fX(n,t){return null===n||null==t||(Array.isArray(n)?n[1]:n)===t||!(!Array.isArray(n)||"string"!=typeof t)&&_u(n,t)>=0}const xr={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function eF(n){return n.substring(xr.key,xr.keyEnd)}function tF(n,t){const e=xr.textEnd;return e===t?-1:(t=xr.keyEnd=function yX(n,t,e){for(;t<e&&n.charCodeAt(t)>32;)t++;return t}(n,xr.key=t,e),Pu(n,t,e))}function Pu(n,t,e){for(;t<e&&n.charCodeAt(t)<=32;)t++;return t}function Kh(n,t,e){return oo(n,t,e,!1),Kh}function ns(n,t){return oo(n,t,null,!0),ns}function Ao(n,t){for(let e=function mX(n){return function rF(n){xr.key=0,xr.keyEnd=0,xr.value=0,xr.valueEnd=0,xr.textEnd=n.length}(n),tF(n,Pu(n,0,xr.textEnd))}(t);e>=0;e=tF(t,e))ii(n,eF(t),!0)}function oo(n,t,e,r){const s=oe(),i=$t(),o=oa(2);i.firstUpdatePass&&aF(i,n,o,r),t!==st&&ts(s,o,t)&&cF(i,i.data[bs()],s,s[11],n,s[o+1]=function TX(n,t){return null==n||("string"==typeof t?n+=t:"object"==typeof n&&(n=an(oi(n)))),n}(t,e),r,o)}function oF(n,t){return t>=n.expandoStartIndex}function aF(n,t,e,r){const s=n.data;if(null===s[e+1]){const i=s[bs()],o=oF(n,e);dF(i,r)&&null===t&&!o&&(t=!1),t=function wX(n,t,e,r){const s=x0(n);let i=r?t.residualClasses:t.residualStyles;if(null===s)0===(r?t.classBindings:t.styleBindings)&&(e=Xh(e=Jw(null,n,t,e,r),t.attrs,r),i=null);else{const o=t.directiveStylingLast;if(-1===o||n[o]!==s)if(e=Jw(s,n,t,e,r),null===i){let l=function CX(n,t,e){const r=e?t.classBindings:t.styleBindings;if(0!==da(r))return n[so(r)]}(n,t,r);void 0!==l&&Array.isArray(l)&&(l=Jw(null,n,t,l[1],r),l=Xh(l,t.attrs,r),function SX(n,t,e,r){n[so(e?t.classBindings:t.styleBindings)]=r}(n,t,r,l))}else i=function IX(n,t,e){let r;const s=t.directiveEnd;for(let i=1+t.directiveStylingLast;i<s;i++)r=Xh(r,n[i].hostAttrs,e);return Xh(r,t.attrs,e)}(n,t,r)}return void 0!==i&&(r?t.residualClasses=i:t.residualStyles=i),e}(s,i,t,r),function dX(n,t,e,r,s,i){let o=i?t.classBindings:t.styleBindings,a=so(o),l=da(o);n[r]=e;let u,c=!1;if(Array.isArray(e)){const d=e;u=d[1],(null===u||_u(d,u)>0)&&(c=!0)}else u=e;if(s)if(0!==l){const h=so(n[a+1]);n[r+1]=kg(h,a),0!==h&&(n[h+1]=Sw(n[h+1],r)),n[a+1]=function Q6(n,t){return 131071&n|t<<17}(n[a+1],r)}else n[r+1]=kg(a,0),0!==a&&(n[a+1]=Sw(n[a+1],r)),a=r;else n[r+1]=kg(l,0),0===a?a=r:n[l+1]=Sw(n[l+1],r),l=r;c&&(n[r+1]=Cw(n[r+1])),JM(n,u,r,!0),JM(n,u,r,!1),function hX(n,t,e,r,s){const i=s?n.residualClasses:n.residualStyles;null!=i&&"string"==typeof t&&_u(i,t)>=0&&(e[r+1]=Iw(e[r+1]))}(t,u,n,r,i),o=kg(a,l),i?t.classBindings=o:t.styleBindings=o}(s,i,t,e,o,r)}}function Jw(n,t,e,r,s){let i=null;const o=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a<o&&(i=t[a],r=Xh(r,i.hostAttrs,s),i!==n);)a++;return null!==n&&(e.directiveStylingLast=a),r}function Xh(n,t,e){const r=e?1:2;let s=-1;if(null!==t)for(let i=0;i<t.length;i++){const o=t[i];"number"==typeof o?s=o:s===r&&(Array.isArray(n)||(n=void 0===n?[]:["",n]),ii(n,o,!!e||t[++i]))}return void 0===n?null:n}function cF(n,t,e,r,s,i,o,a){if(!(3&t.type))return;const l=n.data,c=l[a+1];Vg(function sM(n){return 1==(1&n)}(c)?uF(l,t,e,s,da(c),o):void 0)||(Vg(i)||function rM(n){return 2==(2&n)}(c)&&(i=uF(l,null,e,s,a,o)),function b8(n,t,e,r,s){if(t)s?n.addClass(e,r):n.removeClass(e,r);else{let i=-1===r.indexOf("-")?void 0:$s.DashCase;null==s?n.removeStyle(e,r,i):("string"==typeof s&&s.endsWith("!important")&&(s=s.slice(0,-10),i|=$s.Important),n.setStyle(e,r,s,i))}}(r,o,ig(bs(),e),s,i))}function uF(n,t,e,r,s,i){const o=null===t;let a;for(;s>0;){const l=n[s],c=Array.isArray(l),u=c?l[1]:l,d=null===u;let h=e[s+1];h===st&&(h=d?zt:void 0);let f=d?$0(h,r):u===r?h:void 0;if(c&&!Vg(f)&&(f=$0(l,r)),Vg(f)&&(a=f,o))return a;const p=n[s+1];s=o?so(p):da(p)}if(null!==t){let l=i?t.residualClasses:t.residualStyles;null!=l&&(a=$0(l,r))}return a}function Vg(n){return void 0!==n}function dF(n,t){return 0!=(n.flags&(t?8:16))}function rs(n,t=""){const e=oe(),r=$t(),s=n+22,i=r.firstCreatePass?Du(r,s,1,t,null):r.data[s],o=e[s]=function X0(n,t){return n.createText(t)}(e[11],t);_g(r,e,o,i),Io(i,!1)}function Yh(n){return Lu("",n,""),Yh}function Lu(n,t,e){const r=oe(),s=ku(r,n,t,e);return s!==st&&function ha(n,t,e){const r=ig(t,n);!function QA(n,t,e){n.setValue(t,e)}(n[11],r,e)}(r,bs(),s),Lu}function vF(n,t,e){!function ao(n,t,e,r){const s=$t(),i=oa(2);s.firstUpdatePass&&aF(s,null,i,r);const o=oe();if(e!==st&&ts(o,i,e)){const a=s.data[bs()];if(dF(a,r)&&!oF(s,i)){let l=r?a.classesWithoutHost:a.stylesWithoutHost;null!==l&&(e=Jx(l,e||"")),Xw(s,a,o,e,r)}else!function DX(n,t,e,r,s,i,o,a){s===st&&(s=zt);let l=0,c=0,u=0<s.length?s[0]:null,d=0<i.length?i[0]:null;for(;null!==u||null!==d;){const h=l<s.length?s[l+1]:void 0,f=c<i.length?i[c+1]:void 0;let m,p=null;u===d?(l+=2,c+=2,h!==f&&(p=d,m=f)):null===d||null!==u&&u<d?(l+=2,p=u):(c+=2,p=d,m=f),null!==p&&cF(n,t,e,r,p,m,o,a),u=l<s.length?s[l]:null,d=c<i.length?i[c]:null}}(s,a,o,o[11],o[i+1],o[i+1]=function EX(n,t,e){if(null==e||""===e)return zt;const r=[],s=oi(e);if(Array.isArray(s))for(let i=0;i<s.length;i++)n(r,s[i],!0);else if("object"==typeof s)for(const i in s)s.hasOwnProperty(i)&&n(r,i,s[i]);else"string"==typeof s&&t(r,s);return r}(n,t,e),r,i)}}(ii,Ao,ku(oe(),n,t,e),!0)}function eC(n,t,e){const r=oe();return ts(r,lu(),t)&&ai($t(),Fn(),r,n,t,r[11],e,!0),eC}function tC(n,t,e){const r=oe();if(ts(r,lu(),t)){const i=$t(),o=Fn();ai(i,o,r,n,t,SM(x0(i.data),o,r),e,!0)}return tC}const Vu="en-US";let RF=Vu;function sC(n,t,e,r,s){if(n=Ge(n),Array.isArray(n))for(let i=0;i<n.length;i++)sC(n[i],t,e,r,s);else{const i=$t(),o=oe();let a=sc(n)?n:Ge(n.provide),l=OR(n);const c=Hr(),u=1048575&c.providerIndexes,d=c.directiveStart,h=c.providerIndexes>>20;if(sc(n)||!n.multi){const f=new Sh(l,s,B),p=oC(a,t,s?u:u+h,d);-1===p?(R0(dg(c,o),i,a),iC(i,n,t.length),t.push(a),c.directiveStart++,c.directiveEnd++,s&&(c.providerIndexes+=1048576),e.push(f),o.push(f)):(e[p]=f,o[p]=f)}else{const f=oC(a,t,u+h,d),p=oC(a,t,u,u+h),m=f>=0&&e[f],g=p>=0&&e[p];if(s&&!g||!s&&!m){R0(dg(c,o),i,a);const y=function jY(n,t,e,r,s){const i=new Sh(n,e,B);return i.multi=[],i.index=t,i.componentProviders=0,rO(i,s,r&&!e),i}(s?WY:HY,e.length,s,r,l);!s&&g&&(e[p].providerFactory=y),iC(i,n,t.length,0),t.push(a),c.directiveStart++,c.directiveEnd++,s&&(c.providerIndexes+=1048576),e.push(y),o.push(y)}else iC(i,n,f>-1?f:p,rO(e[s?p:f],l,!s&&r));!s&&r&&g&&e[p].componentProviders++}}}function iC(n,t,e,r){const s=sc(t),i=function Q8(n){return!!n.useClass}(t);if(s||i){const l=(i?Ge(t.useClass):t).prototype.ngOnDestroy;if(l){const c=n.destroyHooks||(n.destroyHooks=[]);if(!s&&t.multi){const u=c.indexOf(e);-1===u?c.push(e,[r,l]):c[u+1].push(r,l)}else c.push(e,l)}}}function rO(n,t,e){return e&&n.componentProviders++,n.multi.push(t)-1}function oC(n,t,e,r){for(let s=e;s<r;s++)if(t[s]===n)return s;return-1}function HY(n,t,e,r){return aC(this.multi,[])}function WY(n,t,e,r){const s=this.multi;let i;if(this.providerFactory){const o=this.providerFactory.componentProviders,a=hu(e,e[1],this.providerFactory.index,r);i=a.slice(0,o),aC(s,i);for(let l=o;l<a.length;l++)i.push(a[l])}else i=[],aC(s,i);return i}function aC(n,t){for(let e=0;e<n.length;e++)t.push((0,n[e])());return t}function gn(n,t=[]){return e=>{e.providersResolver=(r,s)=>function UY(n,t,e){const r=$t();if(r.firstCreatePass){const s=no(n);sC(e,r.data,r.blueprint,s,!0),sC(t,r.data,r.blueprint,s,!1)}}(r,s?s(n):n,t)}}class uc{}class sO{}class iO extends uc{constructor(t,e){super(),this._parent=e,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new Gw(this);const r=ei(t);this._bootstrapComponents=ua(r.bootstrap),this._r3Injector=XR(t,e,[{provide:uc,useValue:this},{provide:ic,useValue:this.componentFactoryResolver}],an(t),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(t)}get injector(){return this._r3Injector}destroy(){const t=this._r3Injector;!t.destroyed&&t.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class lC extends sO{constructor(t){super(),this.moduleType=t}create(t){return new iO(this.moduleType,t)}}class qY extends uc{constructor(t,e,r){super(),this.componentFactoryResolver=new Gw(this),this.instance=null;const s=new FR([...t,{provide:uc,useValue:this},{provide:ic,useValue:this.componentFactoryResolver}],e||Dg(),r,new Set(["environment"]));this.injector=s,s.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(t){this.injector.onDestroy(t)}}function jg(n,t,e=null){return new qY(n,t,e).injector}let KY=(()=>{class n{constructor(e){this._injector=e,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e.id)){const r=NR(0,e.type),s=r.length>0?jg([r],this._injector,`Standalone[${e.type.name}]`):null;this.cachedInjectors.set(e.id,s)}return this.cachedInjectors.get(e.id)}ngOnDestroy(){try{for(const e of this.cachedInjectors.values())null!==e&&e.destroy()}finally{this.cachedInjectors.clear()}}}return n.\u0275prov=we({token:n,providedIn:"environment",factory:()=>new n(Z(qa))}),n})();function oO(n){n.getStandaloneInjector=t=>t.get(KY).getOrCreateStandaloneInjector(n)}function fO(n,t,e,r,s,i){const o=t+e;return ts(n,o,s)?function ko(n,t,e){return n[t]=e}(n,o+1,i?r.call(i,s):r(s)):function rf(n,t){const e=n[t];return e===st?void 0:e}(n,o+1)}function _O(n,t,e){const r=n+22,s=oe(),i=au(s,r);return function sf(n,t){return n[1].data[t].pure}(s,r)?fO(s,function ys(){const n=et.lFrame;let t=n.bindingRootIndex;return-1===t&&(t=n.bindingRootIndex=n.tView.bindingStartIndex),t}(),t,i.transform,e,i):i.transform(e)}function uC(n){return t=>{setTimeout(n,void 0,t)}}const Et=class b7 extends It{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,r){let s=t,i=e||(()=>null),o=r;if(t&&"object"==typeof t){const l=t;s=l.next?.bind(l),i=l.error?.bind(l),o=l.complete?.bind(l)}this.__isAsync&&(i=uC(i),s&&(s=uC(s)),o&&(o=uC(o)));const a=super.subscribe({next:s,error:i,complete:o});return t instanceof Ve&&t.add(a),a}};function _7(){return this._results[ac()]()}class zu{constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=ac(),r=zu.prototype;r[e]||(r[e]=_7)}get changes(){return this._changes||(this._changes=new Et)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){const r=this;r.dirty=!1;const s=si(t);(this._changesDetected=!function xq(n,t,e){if(n.length!==t.length)return!1;for(let r=0;r<n.length;r++){let s=n[r],i=t[r];if(e&&(s=e(s),i=e(i)),i!==s)return!1}return!0}(r._results,s,e))&&(r._results=s,r.length=s.length,r.last=s[this.length-1],r.first=s[0])}notifyOnChanges(){this._changes&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}let Ai=(()=>{class n{}return n.__NG_ELEMENT_ID__=w7,n})();const v7=Ai,x7=class extends v7{constructor(t,e,r){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=r}createEmbeddedView(t,e){const r=this._declarationTContainer.tViews,s=Rg(this._declarationLView,r,t,16,null,r.declTNode,null,null,null,null,e||null);s[17]=this._declarationLView[this._declarationTContainer.index];const o=this._declarationLView[19];return null!==o&&(s[19]=o.createEmbeddedView(r)),Fw(r,s,t),new Vh(s)}};function w7(){return Gg(Hr(),oe())}function Gg(n,t){return 4&n.type?new x7(t,n,Su(n,t)):null}let Ps=(()=>{class n{}return n.__NG_ELEMENT_ID__=C7,n})();function C7(){return wO(Hr(),oe())}const S7=Ps,vO=class extends S7{constructor(t,e,r){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=r}get element(){return Su(this._hostTNode,this._hostLView)}get injector(){return new fu(this._hostTNode,this._hostLView)}get parentInjector(){const t=hg(this._hostTNode,this._hostLView);if(gA(t)){const e=du(t,this._hostLView),r=uu(t);return new fu(e[1].data[r+8],e)}return new fu(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(t){const e=xO(this._lContainer);return null!==e&&e[t]||null}get length(){return this._lContainer.length-10}createEmbeddedView(t,e,r){let s,i;"number"==typeof r?s=r:null!=r&&(s=r.index,i=r.injector);const o=t.createEmbeddedView(e||{},i);return this.insert(o,s),o}createComponent(t,e,r,s,i){const o=t&&!function Th(n){return"function"==typeof n}(t);let a;if(o)a=e;else{const d=e||{};a=d.index,r=d.injector,s=d.projectableNodes,i=d.environmentInjector||d.ngModuleRef}const l=o?t:new zh(qt(t)),c=r||this.parentInjector;if(!i&&null==l.ngModule){const h=(o?c:this.parentInjector).get(qa,null);h&&(i=h)}const u=l.create(c,s,void 0,i);return this.insert(u.hostView,a),u}insert(t,e){const r=t._lView,s=r[1];if(function W5(n){return to(n[3])}(r)){const u=this.indexOf(t);if(-1!==u)this.detach(u);else{const d=r[3],h=new vO(d,d[6],d[3]);h.detach(h.indexOf(t))}}const i=this._adjustIndex(e),o=this._lContainer;!function u8(n,t,e,r){const s=10+r,i=e.length;r>0&&(e[s-1][4]=t),r<i-10?(t[4]=e[s],DA(e,10+r,t)):(e.push(t),t[4]=null),t[3]=e;const o=t[17];null!==o&&e!==o&&function d8(n,t){const e=n[9];t[16]!==t[3][3][16]&&(n[2]=!0),null===e?n[9]=[t]:e.push(t)}(o,t);const a=t[19];null!==a&&a.insertView(n),t[2]|=64}(s,r,o,i);const a=ew(i,o),l=r[11],c=bg(l,o[7]);return null!==c&&function a8(n,t,e,r,s,i){r[0]=s,r[6]=t,Fh(n,r,e,1,s,i)}(s,o[6],l,r,c,a),t.attachToViewContainerRef(),DA(dC(o),i,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=xO(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),r=Z0(this._lContainer,e);r&&(pg(dC(this._lContainer),e),eR(r[1],r))}detach(t){const e=this._adjustIndex(t,-1),r=Z0(this._lContainer,e);return r&&null!=pg(dC(this._lContainer),e)?new Vh(r):null}_adjustIndex(t,e=0){return t??this.length+e}};function xO(n){return n[8]}function dC(n){return n[8]||(n[8]=[])}function wO(n,t){let e;const r=t[n.index];if(to(r))e=r;else{let s;if(8&n.type)s=br(r);else{const i=t[11];s=i.createComment("");const o=ni(n,t);tc(i,bg(i,o),s,function m8(n,t){return n.nextSibling(t)}(i,o),!1)}t[n.index]=e=xM(r,t,s,n),Fg(t,e)}return new vO(e,n,t)}class hC{constructor(t){this.queryList=t,this.matches=null}clone(){return new hC(this.queryList)}setDirty(){this.queryList.setDirty()}}class fC{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const r=null!==t.contentQueries?t.contentQueries[0]:e.length,s=[];for(let i=0;i<r;i++){const o=e.getByIndex(i);s.push(this.queries[o.indexInDeclarationView].clone())}return new fC(s)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e<this.queries.length;e++)null!==DO(t,e).matches&&this.queries[e].setDirty()}}class CO{constructor(t,e,r=null){this.predicate=t,this.flags=e,this.read=r}}class pC{constructor(t=[]){this.queries=t}elementStart(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(t,e)}elementEnd(t){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let r=0;r<this.length;r++){const s=null!==e?e.length:0,i=this.getByIndex(r).embeddedTView(t,s);i&&(i.indexInDeclarationView=r,null!==e?e.push(i):e=[i])}return null!==e?new pC(e):null}template(t,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class mC{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&&this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&&(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new mC(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const e=this._declarationNodeIndex;let r=t.parent;for(;null!==r&&8&r.type&&r.index!==e;)r=r.parent;return e===(null!==r?r.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const r=this.metadata.predicate;if(Array.isArray(r))for(let s=0;s<r.length;s++){const i=r[s];this.matchTNodeWithReadOption(t,e,D7(e,i)),this.matchTNodeWithReadOption(t,e,fg(e,t,i,!1,!1))}else r===Ai?4&e.type&&this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,fg(e,t,r,!1,!1))}matchTNodeWithReadOption(t,e,r){if(null!==r){const s=this.metadata.read;if(null!==s)if(s===Kt||s===Ps||s===Ai&&4&e.type)this.addMatch(e.index,-2);else{const i=fg(e,t,s,!1,!1);null!==i&&this.addMatch(e.index,i)}else this.addMatch(e.index,r)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function D7(n,t){const e=n.localNames;if(null!==e)for(let r=0;r<e.length;r+=2)if(e[r]===t)return e[r+1];return null}function k7(n,t,e,r){return-1===e?function T7(n,t){return 11&n.type?Su(n,t):4&n.type?Gg(n,t):null}(t,n):-2===e?function N7(n,t,e){return e===Kt?Su(t,n):e===Ai?Gg(t,n):e===Ps?wO(t,n):void 0}(n,t,r):hu(n,n[1],e,t)}function SO(n,t,e,r){const s=t[19].queries[r];if(null===s.matches){const i=n.data,o=e.matches,a=[];for(let l=0;l<o.length;l+=2){const c=o[l];a.push(c<0?null:k7(t,i[c],o[l+1],e.metadata.read))}s.matches=a}return s.matches}function gC(n,t,e,r){const s=n.queries.getByIndex(e),i=s.matches;if(null!==i){const o=SO(n,t,s,e);for(let a=0;a<i.length;a+=2){const l=i[a];if(l>0)r.push(o[a/2]);else{const c=i[a+1],u=t[-l];for(let d=10;d<u.length;d++){const h=u[d];h[17]===h[3]&&gC(h[1],h,c,r)}if(null!==u[9]){const d=u[9];for(let h=0;h<d.length;h++){const f=d[h];gC(f[1],f,c,r)}}}}}return r}function Or(n){const t=oe(),e=$t(),r=oA();w0(r+1);const s=DO(e,r);if(n.dirty&&function H5(n){return 4==(4&n[2])}(t)===(2==(2&s.metadata.flags))){if(null===s.matches)n.reset([]);else{const i=s.crossesNgTemplate?gC(e,t,r,[]):SO(e,t,s,r);n.reset(i,c6),n.notifyOnChanges()}return!0}return!1}function lo(n,t,e){const r=$t();r.firstCreatePass&&(EO(r,new CO(n,t,e),-1),2==(2&t)&&(r.staticViewQueries=!0)),IO(r,oe(),t)}function Ya(n,t,e,r){const s=$t();if(s.firstCreatePass){const i=Hr();EO(s,new CO(t,e,r),i.index),function R7(n,t){const e=n.contentQueries||(n.contentQueries=[]);t!==(e.length?e[e.length-1]:-1)&&e.push(n.queries.length-1,t)}(s,n),2==(2&e)&&(s.staticContentQueries=!0)}IO(s,oe(),e)}function $r(){return function A7(n,t){return n[19].queries[t].queryList}(oe(),oA())}function IO(n,t,e){const r=new zu(4==(4&e));mM(n,t,r,r.destroy),null===t[19]&&(t[19]=new fC),t[19].queries.push(new hC(r))}function EO(n,t,e){null===n.queries&&(n.queries=new pC),n.queries.track(new mC(t,e))}function DO(n,t){return n.queries.getByIndex(t)}function qg(n,t){return Gg(n,t)}function Xg(...n){}const Yg=new me("Application Initializer");let Zg=(()=>{class n{constructor(e){this.appInits=e,this.resolve=Xg,this.reject=Xg,this.initialized=!1,this.done=!1,this.donePromise=new Promise((r,s)=>{this.resolve=r,this.reject=s})}runInitializers(){if(this.initialized)return;const e=[],r=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let s=0;s<this.appInits.length;s++){const i=this.appInits[s]();if(qh(i))e.push(i);else if(Yw(i)){const o=new Promise((a,l)=>{i.subscribe({complete:a,error:l})});e.push(o)}}Promise.all(e).then(()=>{r()}).catch(s=>{this.reject(s)}),0===e.length&&r(),this.initialized=!0}}return n.\u0275fac=function(e){return new(e||n)(Z(Yg,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const lf=new me("AppId",{providedIn:"root",factory:function GO(){return`${xC()}${xC()}${xC()}`}});function xC(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const qO=new me("Platform Initializer"),wC=new me("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),KO=new me("appBootstrapListener"),ga=new me("AnimationModuleType");let Q7=(()=>{class n{log(e){console.log(e)}warn(e){console.warn(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();const Ro=new me("LocaleId",{providedIn:"root",factory:()=>Bt(Ro,qe.Optional|qe.SkipSelf)||function J7(){return typeof $localize<"u"&&$localize.locale||Vu}()});class t9{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}let CC=(()=>{class n{compileModuleSync(e){return new lC(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){const r=this.compileModuleSync(e),i=ua(ei(e).declarations).reduce((o,a)=>{const l=qt(a);return l&&o.push(new zh(l)),o},[]);return new t9(r,i)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const s9=(()=>Promise.resolve(0))();function SC(n){typeof Zone>"u"?s9.then(()=>{n&&n.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",n)}class ft{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:r=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Et(!1),this.onMicrotaskEmpty=new Et(!1),this.onStable=new Et(!1),this.onError=new Et(!1),typeof Zone>"u")throw new te(908,!1);Zone.assertZonePatched();const s=this;s._nesting=0,s._outer=s._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(s._inner=s._inner.fork(new Zone.TaskTrackingZoneSpec)),t&&Zone.longStackTraceZoneSpec&&(s._inner=s._inner.fork(Zone.longStackTraceZoneSpec)),s.shouldCoalesceEventChangeDetection=!r&&e,s.shouldCoalesceRunChangeDetection=r,s.lastRequestAnimationFrameId=-1,s.nativeRequestAnimationFrame=function i9(){let n=pn.requestAnimationFrame,t=pn.cancelAnimationFrame;if(typeof Zone<"u"&&n&&t){const e=n[Zone.__symbol__("OriginalDelegate")];e&&(n=e);const r=t[Zone.__symbol__("OriginalDelegate")];r&&(t=r)}return{nativeRequestAnimationFrame:n,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function l9(n){const t=()=>{!function a9(n){n.isCheckStableRunning||-1!==n.lastRequestAnimationFrameId||(n.lastRequestAnimationFrameId=n.nativeRequestAnimationFrame.call(pn,()=>{n.fakeTopEventTask||(n.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{n.lastRequestAnimationFrameId=-1,EC(n),n.isCheckStableRunning=!0,IC(n),n.isCheckStableRunning=!1},void 0,()=>{},()=>{})),n.fakeTopEventTask.invoke()}),EC(n))}(n)};n._inner=n._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(e,r,s,i,o,a)=>{try{return ZO(n),e.invokeTask(s,i,o,a)}finally{(n.shouldCoalesceEventChangeDetection&&"eventTask"===i.type||n.shouldCoalesceRunChangeDetection)&&t(),QO(n)}},onInvoke:(e,r,s,i,o,a,l)=>{try{return ZO(n),e.invoke(s,i,o,a,l)}finally{n.shouldCoalesceRunChangeDetection&&t(),QO(n)}},onHasTask:(e,r,s,i)=>{e.hasTask(s,i),r===s&&("microTask"==i.change?(n._hasPendingMicrotasks=i.microTask,EC(n),IC(n)):"macroTask"==i.change&&(n.hasPendingMacrotasks=i.macroTask))},onHandleError:(e,r,s,i)=>(e.handleError(s,i),n.runOutsideAngular(()=>n.onError.emit(i)),!1)})}(s)}static isInAngularZone(){return typeof Zone<"u"&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!ft.isInAngularZone())throw new te(909,!1)}static assertNotInAngularZone(){if(ft.isInAngularZone())throw new te(909,!1)}run(t,e,r){return this._inner.run(t,e,r)}runTask(t,e,r,s){const i=this._inner,o=i.scheduleEventTask("NgZoneEvent: "+s,t,o9,Xg,Xg);try{return i.runTask(o,e,r)}finally{i.cancelTask(o)}}runGuarded(t,e,r){return this._inner.runGuarded(t,e,r)}runOutsideAngular(t){return this._outer.run(t)}}const o9={};function IC(n){if(0==n._nesting&&!n.hasPendingMicrotasks&&!n.isStable)try{n._nesting++,n.onMicrotaskEmpty.emit(null)}finally{if(n._nesting--,!n.hasPendingMicrotasks)try{n.runOutsideAngular(()=>n.onStable.emit(null))}finally{n.isStable=!0}}}function EC(n){n.hasPendingMicrotasks=!!(n._hasPendingMicrotasks||(n.shouldCoalesceEventChangeDetection||n.shouldCoalesceRunChangeDetection)&&-1!==n.lastRequestAnimationFrameId)}function ZO(n){n._nesting++,n.isStable&&(n.isStable=!1,n.onUnstable.emit(null))}function QO(n){n._nesting--,IC(n)}class c9{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Et,this.onMicrotaskEmpty=new Et,this.onStable=new Et,this.onError=new Et}run(t,e,r){return t.apply(e,r)}runGuarded(t,e,r){return t.apply(e,r)}runOutsideAngular(t){return t()}runTask(t,e,r,s){return t.apply(e,r)}}const JO=new me(""),Qg=new me("");let kC,DC=(()=>{class n{constructor(e,r,s){this._ngZone=e,this.registry=r,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,kC||(function u9(n){kC=n}(s),s.addToWindow(r)),this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone=typeof Zone>"u"?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{ft.assertNotInAngularZone(),SC(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())SC(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(r=>!r.updateCb||!r.updateCb(e)||(clearTimeout(r.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,r,s){let i=-1;r&&r>0&&(i=setTimeout(()=>{this._callbacks=this._callbacks.filter(o=>o.timeoutId!==i),e(this._didWork,this.getPendingTasks())},r)),this._callbacks.push({doneCb:e,timeoutId:i,updateCb:s})}whenStable(e,r,s){if(s&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,r,s),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(e){this.registry.registerApplication(e,this)}unregisterApplication(e){this.registry.unregisterApplication(e)}findProviders(e,r,s){return[]}}return n.\u0275fac=function(e){return new(e||n)(Z(ft),Z(TC),Z(Qg))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})(),TC=(()=>{class n{constructor(){this._applications=new Map}registerApplication(e,r){this._applications.set(e,r)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,r=!0){return kC?.findTestabilityInTree(this,e,r)??null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})(),Za=null;const e2=new me("AllowMultipleToken"),NC=new me("PlatformDestroyListeners");class t2{constructor(t,e){this.name=t,this.token=e}}function r2(n,t,e=[]){const r=`Platform: ${t}`,s=new me(r);return(i=[])=>{let o=AC();if(!o||o.injector.get(e2,!1)){const a=[...e,...i,{provide:s,useValue:!0}];n?n(a):function f9(n){if(Za&&!Za.get(e2,!1))throw new te(400,!1);Za=n;const t=n.get(o2);(function n2(n){const t=n.get(qO,null);t&&t.forEach(e=>e())})(n)}(function s2(n=[],t){return vr.create({name:t,providers:[{provide:hw,useValue:"platform"},{provide:NC,useValue:new Set([()=>Za=null])},...n]})}(a,r))}return function m9(n){const t=AC();if(!t)throw new te(401,!1);return t}()}}function AC(){return Za?.get(o2)??null}let o2=(()=>{class n{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,r){const s=function l2(n,t){let e;return e="noop"===n?new c9:("zone.js"===n?void 0:n)||new ft(t),e}(r?.ngZone,function a2(n){return{enableLongStackTrace:!1,shouldCoalesceEventChangeDetection:!(!n||!n.ngZoneEventCoalescing)||!1,shouldCoalesceRunChangeDetection:!(!n||!n.ngZoneRunCoalescing)||!1}}(r)),i=[{provide:ft,useValue:s}];return s.run(()=>{const o=vr.create({providers:i,parent:this.injector,name:e.moduleType.name}),a=e.create(o),l=a.injector.get(ca,null);if(!l)throw new te(402,!1);return s.runOutsideAngular(()=>{const c=s.onError.subscribe({next:u=>{l.handleError(u)}});a.onDestroy(()=>{Jg(this._modules,a),c.unsubscribe()})}),function c2(n,t,e){try{const r=e();return qh(r)?r.catch(s=>{throw t.runOutsideAngular(()=>n.handleError(s)),s}):r}catch(r){throw t.runOutsideAngular(()=>n.handleError(r)),r}}(l,s,()=>{const c=a.injector.get(Zg);return c.runInitializers(),c.donePromise.then(()=>(function MF(n){Js(n,"Expected localeId to be defined"),"string"==typeof n&&(RF=n.toLowerCase().replace(/_/g,"-"))}(a.injector.get(Ro,Vu)||Vu),this._moduleDoBootstrap(a),a))})})}bootstrapModule(e,r=[]){const s=u2({},r);return function d9(n,t,e){const r=new lC(e);return Promise.resolve(r)}(0,0,e).then(i=>this.bootstrapModuleFactory(i,s))}_moduleDoBootstrap(e){const r=e.injector.get(Wu);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(s=>r.bootstrap(s));else{if(!e.instance.ngDoBootstrap)throw new te(403,!1);e.instance.ngDoBootstrap(r)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new te(404,!1);this._modules.slice().forEach(r=>r.destroy()),this._destroyListeners.forEach(r=>r());const e=this._injector.get(NC,null);e&&(e.forEach(r=>r()),e.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}}return n.\u0275fac=function(e){return new(e||n)(Z(vr))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"platform"}),n})();function u2(n,t){return Array.isArray(t)?t.reduce(u2,n):{...n,...t}}let Wu=(()=>{class n{constructor(e,r,s){this._zone=e,this._injector=r,this._exceptionHandler=s,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this._destroyed=!1,this._destroyListeners=[],this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const i=new Dn(a=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{a.next(this._stable),a.complete()})}),o=new Dn(a=>{let l;this._zone.runOutsideAngular(()=>{l=this._zone.onStable.subscribe(()=>{ft.assertNotInAngularZone(),SC(()=>{!this._stable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks&&(this._stable=!0,a.next(!0))})})});const c=this._zone.onUnstable.subscribe(()=>{ft.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{a.next(!1)}))});return()=>{l.unsubscribe(),c.unsubscribe()}});this.isStable=Ua(i,o.pipe(PN()))}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(e,r){const s=e instanceof $R;if(!this._injector.get(Zg).done)throw!s&&function ru(n){const t=qt(n)||Xr(n)||gs(n);return null!==t&&t.standalone}(e),new te(405,false);let o;o=s?e:this._injector.get(ic).resolveComponentFactory(e),this.componentTypes.push(o.componentType);const a=function h9(n){return n.isBoundToModule}(o)?void 0:this._injector.get(uc),c=o.create(vr.NULL,[],r||o.selector,a),u=c.location.nativeElement,d=c.injector.get(JO,null);return d?.registerApplication(u),c.onDestroy(()=>{this.detachView(c.hostView),Jg(this.components,c),d?.unregisterApplication(u)}),this._loadComponent(c),c}tick(){if(this._runningTick)throw new te(101,!1);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){const r=e;Jg(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get(KO,[]).concat(this._bootstrapListeners).forEach(s=>s(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>Jg(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new te(406,!1);const e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){}}return n.\u0275fac=function(e){return new(e||n)(Z(ft),Z(qa),Z(ca))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function Jg(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}let uo=(()=>{class n{}return n.__NG_ELEMENT_ID__=y9,n})();function y9(n){return function b9(n,t,e){if(rg(n)&&!e){const r=ri(n.index,t);return new Vh(r,r)}return 47&n.type?new Vh(t[16],t):null}(Hr(),oe(),16==(16&n))}class m2{constructor(){}supports(t){return Uh(t)}create(t){return new S9(t)}}const C9=(n,t)=>t;class S9{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||C9}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,r=this._removalsHead,s=0,i=null;for(;e||r;){const o=!r||e&&e.currentIndex<y2(r,s,i)?e:r,a=y2(o,s,i),l=o.currentIndex;if(o===r)s--,r=r._nextRemoved;else if(e=e._next,null==o.previousIndex)s++;else{i||(i=[]);const c=a-s,u=l-s;if(c!=u){for(let h=0;h<c;h++){const f=h<i.length?i[h]:i[h]=0,p=f+h;u<=p&&p<c&&(i[h]=f+1)}i[o.previousIndex]=u-c}}a!==l&&t(o,a,l)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&&(t=[]),!Uh(t))throw new te(900,!1);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let s,i,o,e=this._itHead,r=!1;if(Array.isArray(t)){this.length=t.length;for(let a=0;a<this.length;a++)i=t[a],o=this._trackByFn(a,i),null!==e&&Object.is(e.trackById,o)?(r&&(e=this._verifyReinsertion(e,i,o,a)),Object.is(e.item,i)||this._addIdentityChange(e,i)):(e=this._mismatch(e,i,o,a),r=!0),e=e._next}else s=0,function nX(n,t){if(Array.isArray(n))for(let e=0;e<n.length;e++)t(n[e]);else{const e=n[ac()]();let r;for(;!(r=e.next()).done;)t(r.value)}}(t,a=>{o=this._trackByFn(s,a),null!==e&&Object.is(e.trackById,o)?(r&&(e=this._verifyReinsertion(e,a,o,s)),Object.is(e.item,a)||this._addIdentityChange(e,a)):(e=this._mismatch(e,a,o,s),r=!0),e=e._next,s++}),this.length=s;return this._truncate(e),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,r,s){let i;return null===t?i=this._itTail:(i=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,i,s)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(r,s))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,i,s)):t=this._addAfter(new I9(e,r),i,s),t}_verifyReinsertion(t,e,r,s){let i=null===this._unlinkedRecords?null:this._unlinkedRecords.get(r,null);return null!==i?t=this._reinsertAfter(i,t._prev,s):t.currentIndex!=s&&(t.currentIndex=s,this._addToMoves(t,s)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,r){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(t);const s=t._prevRemoved,i=t._nextRemoved;return null===s?this._removalsHead=i:s._nextRemoved=i,null===i?this._removalsTail=s:i._prevRemoved=s,this._insertAfter(t,e,r),this._addToMoves(t,r),t}_moveAfter(t,e,r){return this._unlink(t),this._insertAfter(t,e,r),this._addToMoves(t,r),t}_addAfter(t,e,r){return this._insertAfter(t,e,r),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,r){const s=null===e?this._itHead:e._next;return t._next=s,t._prev=e,null===s?this._itTail=t:s._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&&(this._linkedRecords=new g2),this._linkedRecords.put(t),t.currentIndex=r,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&&this._linkedRecords.remove(t);const e=t._prev,r=t._next;return null===e?this._itHead=r:e._next=r,null===r?this._itTail=e:r._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&&(this._unlinkedRecords=new g2),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class I9{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class E9{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let r;for(r=this._head;null!==r;r=r._nextDup)if((null===e||e<=r.currentIndex)&&Object.is(r.trackById,t))return r;return null}remove(t){const e=t._prevDup,r=t._nextDup;return null===e?this._head=r:e._nextDup=r,null===r?this._tail=e:r._prevDup=e,null===this._head}}class g2{constructor(){this.map=new Map}put(t){const e=t.trackById;let r=this.map.get(e);r||(r=new E9,this.map.set(e,r)),r.add(t)}get(t,e){const s=this.map.get(t);return s?s.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&&this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function y2(n,t,e){const r=n.previousIndex;if(null===r)return r;let s=0;return e&&r<e.length&&(s=e[r]),r+t+s}class b2{constructor(){}supports(t){return t instanceof Map||Kw(t)}create(){return new D9}}class D9{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let e;for(e=this._mapHead;null!==e;e=e._next)t(e)}forEachPreviousItem(t){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)t(e)}forEachChangedItem(t){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}diff(t){if(t){if(!(t instanceof Map||Kw(t)))throw new te(900,!1)}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(t,(r,s)=>{if(e&&e.key===s)this._maybeAddToChanges(e,r),this._appendAfter=e,e=e._next;else{const i=this._getOrCreateRecordForKey(s,r);e=this._insertBeforeOrAppend(e,i)}}),e){e._prev&&(e._prev._next=null),this._removalsHead=e;for(let r=e;null!==r;r=r._nextRemoved)r===this._mapHead&&(this._mapHead=null),this._records.delete(r.key),r._nextRemoved=r._next,r.previousValue=r.currentValue,r.currentValue=null,r._prev=null,r._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,e){if(t){const r=t._prev;return e._next=t,e._prev=r,t._prev=e,r&&(r._next=e),t===this._mapHead&&(this._mapHead=e),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(t,e){if(this._records.has(t)){const s=this._records.get(t);this._maybeAddToChanges(s,e);const i=s._prev,o=s._next;return i&&(i._next=o),o&&(o._prev=i),s._next=null,s._prev=null,s}const r=new T9(t);return this._records.set(t,r),r.currentValue=e,this._addToAdditions(r),r}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,e){Object.is(e,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=e,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,e){t instanceof Map?t.forEach(e):Object.keys(t).forEach(r=>e(t[r],r))}}class T9{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function _2(){return new ny([new m2])}let ny=(()=>{class n{constructor(e){this.factories=e}static create(e,r){if(null!=r){const s=r.factories.slice();e=e.concat(s)}return new n(e)}static extend(e){return{provide:n,useFactory:r=>n.create(e,r||_2()),deps:[[n,new vu,new Ga]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(null!=r)return r;throw new te(901,!1)}}return n.\u0275prov=we({token:n,providedIn:"root",factory:_2}),n})();function v2(){return new cf([new b2])}let cf=(()=>{class n{constructor(e){this.factories=e}static create(e,r){if(r){const s=r.factories.slice();e=e.concat(s)}return new n(e)}static extend(e){return{provide:n,useFactory:r=>n.create(e,r||v2()),deps:[[n,new vu,new Ga]]}}find(e){const r=this.factories.find(s=>s.supports(e));if(r)return r;throw new te(901,!1)}}return n.\u0275prov=we({token:n,providedIn:"root",factory:v2}),n})();const A9=r2(null,"core",[]);let R9=(()=>{class n{constructor(e){}}return n.\u0275fac=function(e){return new(e||n)(Z(Wu))},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({}),n})();let ry=null;function Mo(){return ry}class O9{}const wt=new me("DocumentToken");let $C=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:function(){return function $9(){return Z(x2)}()},providedIn:"platform"}),n})();const P9=new me("Location Initialized");let x2=(()=>{class n extends $C{constructor(e){super(),this._doc=e,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Mo().getBaseHref(this._doc)}onPopState(e){const r=Mo().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){const r=Mo().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(e){this.location.pathname=e}pushState(e,r,s){w2()?this._history.pushState(e,r,s):this.location.hash=s}replaceState(e,r,s){w2()?this._history.replaceState(e,r,s):this.location.hash=s}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return n.\u0275fac=function(e){return new(e||n)(Z(wt))},n.\u0275prov=we({token:n,factory:function(){return function L9(){return new x2(Z(wt))}()},providedIn:"platform"}),n})();function w2(){return!!window.history.pushState}function PC(n,t){if(0==n.length)return t;if(0==t.length)return n;let e=0;return n.endsWith("/")&&e++,t.startsWith("/")&&e++,2==e?n+t.substring(1):1==e?n+t:n+"/"+t}function C2(n){const t=n.match(/#|\?|$/),e=t&&t.index||n.length;return n.slice(0,e-("/"===n[e-1]?1:0))+n.slice(e)}function ba(n){return n&&"?"!==n[0]?"?"+n:n}let hc=(()=>{class n{historyGo(e){throw new Error("Not implemented")}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:function(){return Bt(I2)},providedIn:"root"}),n})();const S2=new me("appBaseHref");let I2=(()=>{class n extends hc{constructor(e,r){super(),this._platformLocation=e,this._removeListenerFns=[],this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??Bt(wt).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return PC(this._baseHref,e)}path(e=!1){const r=this._platformLocation.pathname+ba(this._platformLocation.search),s=this._platformLocation.hash;return s&&e?`${r}${s}`:r}pushState(e,r,s,i){const o=this.prepareExternalUrl(s+ba(i));this._platformLocation.pushState(e,r,o)}replaceState(e,r,s,i){const o=this.prepareExternalUrl(s+ba(i));this._platformLocation.replaceState(e,r,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return n.\u0275fac=function(e){return new(e||n)(Z($C),Z(S2,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),B9=(()=>{class n extends hc{constructor(e,r){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=r&&(this._baseHref=r)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let r=this._platformLocation.hash;return null==r&&(r="#"),r.length>0?r.substring(1):r}prepareExternalUrl(e){const r=PC(this._baseHref,e);return r.length>0?"#"+r:r}pushState(e,r,s,i){let o=this.prepareExternalUrl(s+ba(i));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.pushState(e,r,o)}replaceState(e,r,s,i){let o=this.prepareExternalUrl(s+ba(i));0==o.length&&(o=this._platformLocation.pathname),this._platformLocation.replaceState(e,r,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}}return n.\u0275fac=function(e){return new(e||n)(Z($C),Z(S2,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})(),sy=(()=>{class n{constructor(e){this._subject=new Et,this._urlChangeListeners=[],this._urlChangeSubscription=null,this._locationStrategy=e;const r=this._locationStrategy.getBaseHref();this._baseHref=C2(E2(r)),this._locationStrategy.onPopState(s=>{this._subject.emit({url:this.path(!0),pop:!0,state:s.state,type:s.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+ba(r))}normalize(e){return n.stripTrailingSlash(function z9(n,t){return n&&t.startsWith(n)?t.substring(n.length):t}(this._baseHref,E2(e)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,r="",s=null){this._locationStrategy.pushState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+ba(r)),s)}replaceState(e,r="",s=null){this._locationStrategy.replaceState(s,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+ba(r)),s)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)})),()=>{const r=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(r,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(s=>s(e,r))}subscribe(e,r,s){return this._subject.subscribe({next:e,error:r,complete:s})}}return n.normalizeQueryParams=ba,n.joinWithSlash=PC,n.stripTrailingSlash=C2,n.\u0275fac=function(e){return new(e||n)(Z(hc))},n.\u0275prov=we({token:n,factory:function(){return function V9(){return new sy(Z(hc))}()},providedIn:"root"}),n})();function E2(n){return n.replace(/\/index.html$/,"")}let qC=(()=>{class n{constructor(e,r,s,i){this._iterableDiffers=e,this._keyValueDiffers=r,this._ngEl=s,this._renderer=i,this._iterableDiffer=null,this._keyValueDiffer=null,this._initialClasses=[],this._rawClass=null}set klass(e){this._removeClasses(this._initialClasses),this._initialClasses="string"==typeof e?e.split(/\s+/):[],this._applyClasses(this._initialClasses),this._applyClasses(this._rawClass)}set ngClass(e){this._removeClasses(this._rawClass),this._applyClasses(this._initialClasses),this._iterableDiffer=null,this._keyValueDiffer=null,this._rawClass="string"==typeof e?e.split(/\s+/):e,this._rawClass&&(Uh(this._rawClass)?this._iterableDiffer=this._iterableDiffers.find(this._rawClass).create():this._keyValueDiffer=this._keyValueDiffers.find(this._rawClass).create())}ngDoCheck(){if(this._iterableDiffer){const e=this._iterableDiffer.diff(this._rawClass);e&&this._applyIterableChanges(e)}else if(this._keyValueDiffer){const e=this._keyValueDiffer.diff(this._rawClass);e&&this._applyKeyValueChanges(e)}}_applyKeyValueChanges(e){e.forEachAddedItem(r=>this._toggleClass(r.key,r.currentValue)),e.forEachChangedItem(r=>this._toggleClass(r.key,r.currentValue)),e.forEachRemovedItem(r=>{r.previousValue&&this._toggleClass(r.key,!1)})}_applyIterableChanges(e){e.forEachAddedItem(r=>{if("string"!=typeof r.item)throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${an(r.item)}`);this._toggleClass(r.item,!0)}),e.forEachRemovedItem(r=>this._toggleClass(r.item,!1))}_applyClasses(e){e&&(Array.isArray(e)||e instanceof Set?e.forEach(r=>this._toggleClass(r,!0)):Object.keys(e).forEach(r=>this._toggleClass(r,!!e[r])))}_removeClasses(e){e&&(Array.isArray(e)||e instanceof Set?e.forEach(r=>this._toggleClass(r,!1)):Object.keys(e).forEach(r=>this._toggleClass(r,!1)))}_toggleClass(e,r){(e=e.trim())&&e.split(/\s+/g).forEach(s=>{r?this._renderer.addClass(this._ngEl.nativeElement,s):this._renderer.removeClass(this._ngEl.nativeElement,s)})}}return n.\u0275fac=function(e){return new(e||n)(B(ny),B(cf),B(Kt),B(la))},n.\u0275dir=Me({type:n,selectors:[["","ngClass",""]],inputs:{klass:["class","klass"],ngClass:"ngClass"},standalone:!0}),n})();class EZ{constructor(t,e,r,s){this.$implicit=t,this.ngForOf=e,this.index=r,this.count=s}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let P2=(()=>{class n{constructor(e,r,s){this._viewContainer=e,this._template=r,this._differs=s,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(e){e&&(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const e=this._ngForOf;!this._differ&&e&&(this._differ=this._differs.find(e).create(this.ngForTrackBy))}if(this._differ){const e=this._differ.diff(this._ngForOf);e&&this._applyChanges(e)}}_applyChanges(e){const r=this._viewContainer;e.forEachOperation((s,i,o)=>{if(null==s.previousIndex)r.createEmbeddedView(this._template,new EZ(s.item,this._ngForOf,-1,-1),null===o?void 0:o);else if(null==o)r.remove(null===i?void 0:i);else if(null!==i){const a=r.get(i);r.move(a,o),L2(a,s)}});for(let s=0,i=r.length;s<i;s++){const a=r.get(s).context;a.index=s,a.count=i,a.ngForOf=this._ngForOf}e.forEachIdentityChange(s=>{L2(r.get(s.currentIndex),s)})}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(B(Ps),B(Ai),B(ny))},n.\u0275dir=Me({type:n,selectors:[["","ngFor","","ngForOf",""]],inputs:{ngForOf:"ngForOf",ngForTrackBy:"ngForTrackBy",ngForTemplate:"ngForTemplate"},standalone:!0}),n})();function L2(n,t){n.context.$implicit=t.item}let hf=(()=>{class n{constructor(e,r){this._viewContainer=e,this._context=new TZ,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=r}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){B2("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){B2("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,r){return!0}}return n.\u0275fac=function(e){return new(e||n)(B(Ps),B(Ai))},n.\u0275dir=Me({type:n,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"},standalone:!0}),n})();class TZ{constructor(){this.$implicit=null,this.ngIf=null}}function B2(n,t){if(t&&!t.createEmbeddedView)throw new Error(`${n} must be a TemplateRef, but received '${an(t)}'.`)}class KC{constructor(t,e){this._viewContainerRef=t,this._templateRef=e,this._created=!1}create(){this._created=!0,this._viewContainerRef.createEmbeddedView(this._templateRef)}destroy(){this._created=!1,this._viewContainerRef.clear()}enforceState(t){t&&!this._created?this.create():!t&&this._created&&this.destroy()}}let py=(()=>{class n{constructor(){this._defaultUsed=!1,this._caseCount=0,this._lastCaseCheckIndex=0,this._lastCasesMatched=!1}set ngSwitch(e){this._ngSwitch=e,0===this._caseCount&&this._updateDefaultCases(!0)}_addCase(){return this._caseCount++}_addDefault(e){this._defaultViews||(this._defaultViews=[]),this._defaultViews.push(e)}_matchCase(e){const r=e==this._ngSwitch;return this._lastCasesMatched=this._lastCasesMatched||r,this._lastCaseCheckIndex++,this._lastCaseCheckIndex===this._caseCount&&(this._updateDefaultCases(!this._lastCasesMatched),this._lastCaseCheckIndex=0,this._lastCasesMatched=!1),r}_updateDefaultCases(e){if(this._defaultViews&&e!==this._defaultUsed){this._defaultUsed=e;for(let r=0;r<this._defaultViews.length;r++)this._defaultViews[r].enforceState(e)}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=Me({type:n,selectors:[["","ngSwitch",""]],inputs:{ngSwitch:"ngSwitch"},standalone:!0}),n})(),V2=(()=>{class n{constructor(e,r,s){this.ngSwitch=s,s._addCase(),this._view=new KC(e,r)}ngDoCheck(){this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))}}return n.\u0275fac=function(e){return new(e||n)(B(Ps),B(Ai),B(py,9))},n.\u0275dir=Me({type:n,selectors:[["","ngSwitchCase",""]],inputs:{ngSwitchCase:"ngSwitchCase"},standalone:!0}),n})(),z2=(()=>{class n{constructor(e,r,s){s._addDefault(new KC(e,r))}}return n.\u0275fac=function(e){return new(e||n)(B(Ps),B(Ai),B(py,9))},n.\u0275dir=Me({type:n,selectors:[["","ngSwitchDefault",""]],standalone:!0}),n})(),H2=(()=>{class n{constructor(e){this._viewContainerRef=e,this._viewRef=null,this.ngTemplateOutletContext=null,this.ngTemplateOutlet=null,this.ngTemplateOutletInjector=null}ngOnChanges(e){if(e.ngTemplateOutlet||e.ngTemplateOutletInjector){const r=this._viewContainerRef;if(this._viewRef&&r.remove(r.indexOf(this._viewRef)),this.ngTemplateOutlet){const{ngTemplateOutlet:s,ngTemplateOutletContext:i,ngTemplateOutletInjector:o}=this;this._viewRef=r.createEmbeddedView(s,i,o?{injector:o}:void 0)}else this._viewRef=null}else this._viewRef&&e.ngTemplateOutletContext&&this.ngTemplateOutletContext&&(this._viewRef.context=this.ngTemplateOutletContext)}}return n.\u0275fac=function(e){return new(e||n)(B(Ps))},n.\u0275dir=Me({type:n,selectors:[["","ngTemplateOutlet",""]],inputs:{ngTemplateOutletContext:"ngTemplateOutletContext",ngTemplateOutlet:"ngTemplateOutlet",ngTemplateOutletInjector:"ngTemplateOutletInjector"},standalone:!0,features:[Os]}),n})(),W2=(()=>{class n{constructor(e){this.differs=e,this.keyValues=[],this.compareFn=j2}transform(e,r=j2){if(!e||!(e instanceof Map)&&"object"!=typeof e)return null;this.differ||(this.differ=this.differs.find(e).create());const s=this.differ.diff(e),i=r!==this.compareFn;return s&&(this.keyValues=[],s.forEachItem(o=>{this.keyValues.push(function KZ(n,t){return{key:n,value:t}}(o.key,o.currentValue))})),(s||i)&&(this.keyValues.sort(r),this.compareFn=r),this.keyValues}}return n.\u0275fac=function(e){return new(e||n)(B(cf,16))},n.\u0275pipe=Ms({name:"keyvalue",type:n,pure:!1,standalone:!0}),n})();function j2(n,t){const e=n.key,r=t.key;if(e===r)return 0;if(void 0===e)return 1;if(void 0===r)return-1;if(null===e)return 1;if(null===r)return-1;if("string"==typeof e&&"string"==typeof r)return e<r?-1:1;if("number"==typeof e&&"number"==typeof r)return e-r;if("boolean"==typeof e&&"boolean"==typeof r)return e<r?-1:1;const s=String(e),i=String(r);return s==i?0:s<i?-1:1}let fc=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({}),n})();const G2="browser";let rQ=(()=>{class n{}return n.\u0275prov=we({token:n,providedIn:"root",factory:()=>new sQ(Z(wt),window)}),n})();class sQ{constructor(t,e){this.document=t,this.window=e,this.offset=()=>[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=>t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(t){this.supportsScrolling()&&this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){if(!this.supportsScrolling())return;const e=function iQ(n,t){const e=n.getElementById(t)||n.getElementsByName(t)[0];if(e)return e;if("function"==typeof n.createTreeWalker&&n.body&&(n.body.createShadowRoot||n.body.attachShadow)){const r=n.createTreeWalker(n.body,NodeFilter.SHOW_ELEMENT);let s=r.currentNode;for(;s;){const i=s.shadowRoot;if(i){const o=i.getElementById(t)||i.querySelector(`[name="${t}"]`);if(o)return o}s=r.nextNode()}}return null}(this.document,t);e&&(this.scrollToElement(e),e.focus())}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&&e.scrollRestoration&&(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),r=e.left+this.window.pageXOffset,s=e.top+this.window.pageYOffset,i=this.offset();this.window.scrollTo(r-i[0],s-i[1])}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const t=q2(this.window.history)||q2(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&&!t.set)}catch{return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch{return!1}}}function q2(n){return Object.getOwnPropertyDescriptor(n,"scrollRestoration")}class MQ extends O9{constructor(){super(...arguments),this.supportsDOMEvents=!0}}class JC extends MQ{static makeCurrent(){!function F9(n){ry||(ry=n)}(new JC)}onAndCancel(t,e,r){return t.addEventListener(e,r,!1),()=>{t.removeEventListener(e,r,!1)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){t.parentNode&&t.parentNode.removeChild(t)}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return"window"===e?window:"document"===e?t:"body"===e?t.body:null}getBaseHref(t){const e=function FQ(){return pf=pf||document.querySelector("base"),pf?pf.getAttribute("href"):null}();return null==e?null:function OQ(n){gy=gy||document.createElement("a"),gy.setAttribute("href",n);const t=gy.pathname;return"/"===t.charAt(0)?t:`/${t}`}(e)}resetBaseElement(){pf=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return function SZ(n,t){t=encodeURIComponent(t);for(const e of n.split(";")){const r=e.indexOf("="),[s,i]=-1==r?[e,""]:[e.slice(0,r),e.slice(r+1)];if(s.trim()===t)return decodeURIComponent(i)}return null}(document.cookie,t)}}let gy,pf=null;const J2=new me("TRANSITION_ID"),PQ=[{provide:Yg,useFactory:function $Q(n,t,e){return()=>{e.get(Zg).donePromise.then(()=>{const r=Mo(),s=t.querySelectorAll(`style[ng-transition="${n}"]`);for(let i=0;i<s.length;i++)r.remove(s[i])})}},deps:[J2,wt,vr],multi:!0}];let BQ=(()=>{class n{build(){return new XMLHttpRequest}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();const yy=new me("EventManagerPlugins");let by=(()=>{class n{constructor(e,r){this._zone=r,this._eventNameToPlugin=new Map,e.forEach(s=>s.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,r,s){return this._findPluginFor(r).addEventListener(e,r,s)}addGlobalEventListener(e,r,s){return this._findPluginFor(r).addGlobalEventListener(e,r,s)}getZone(){return this._zone}_findPluginFor(e){const r=this._eventNameToPlugin.get(e);if(r)return r;const s=this._plugins;for(let i=0;i<s.length;i++){const o=s[i];if(o.supports(e))return this._eventNameToPlugin.set(e,o),o}throw new Error(`No event manager plugin found for event ${e}`)}}return n.\u0275fac=function(e){return new(e||n)(Z(yy),Z(ft))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();class e${constructor(t){this._doc=t}addGlobalEventListener(t,e,r){const s=Mo().getGlobalEventTarget(this._doc,t);if(!s)throw new Error(`Unsupported event target ${s} for event ${e}`);return this.addEventListener(s,e,r)}}let t$=(()=>{class n{constructor(){this._stylesSet=new Set}addStyles(e){const r=new Set;e.forEach(s=>{this._stylesSet.has(s)||(this._stylesSet.add(s),r.add(s))}),this.onStylesAdded(r)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})(),mf=(()=>{class n extends t${constructor(e){super(),this._doc=e,this._hostNodes=new Map,this._hostNodes.set(e.head,[])}_addStylesToHost(e,r,s){e.forEach(i=>{const o=this._doc.createElement("style");o.textContent=i,s.push(r.appendChild(o))})}addHost(e){const r=[];this._addStylesToHost(this._stylesSet,e,r),this._hostNodes.set(e,r)}removeHost(e){const r=this._hostNodes.get(e);r&&r.forEach(n$),this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach((r,s)=>{this._addStylesToHost(e,s,r)})}ngOnDestroy(){this._hostNodes.forEach(e=>e.forEach(n$))}}return n.\u0275fac=function(e){return new(e||n)(Z(wt))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();function n$(n){Mo().remove(n)}const eS={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/MathML/"},tS=/%COMP%/g;function _y(n,t,e){for(let r=0;r<t.length;r++){let s=t[r];Array.isArray(s)?_y(n,s,e):(s=s.replace(tS,n),e.push(s))}return e}function i$(n){return t=>{if("__ngUnwrap__"===t)return n;!1===n(t)&&(t.preventDefault(),t.returnValue=!1)}}let vy=(()=>{class n{constructor(e,r,s){this.eventManager=e,this.sharedStylesHost=r,this.appId=s,this.rendererByCompId=new Map,this.defaultRenderer=new nS(e)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;switch(r.encapsulation){case Ji.Emulated:{let s=this.rendererByCompId.get(r.id);return s||(s=new jQ(this.eventManager,this.sharedStylesHost,r,this.appId),this.rendererByCompId.set(r.id,s)),s.applyToHost(e),s}case 1:case Ji.ShadowDom:return new GQ(this.eventManager,this.sharedStylesHost,e,r);default:if(!this.rendererByCompId.has(r.id)){const s=_y(r.id,r.styles,[]);this.sharedStylesHost.addStyles(s),this.rendererByCompId.set(r.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return n.\u0275fac=function(e){return new(e||n)(Z(by),Z(mf),Z(lf))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();class nS{constructor(t){this.eventManager=t,this.data=Object.create(null),this.destroyNode=null}destroy(){}createElement(t,e){return e?document.createElementNS(eS[e]||e,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,e){(a$(t)?t.content:t).appendChild(e)}insertBefore(t,e,r){t&&(a$(t)?t.content:t).insertBefore(e,r)}removeChild(t,e){t&&t.removeChild(e)}selectRootElement(t,e){let r="string"==typeof t?document.querySelector(t):t;if(!r)throw new Error(`The selector "${t}" did not match any elements`);return e||(r.textContent=""),r}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,r,s){if(s){e=s+":"+e;const i=eS[s];i?t.setAttributeNS(i,e,r):t.setAttribute(e,r)}else t.setAttribute(e,r)}removeAttribute(t,e,r){if(r){const s=eS[r];s?t.removeAttributeNS(s,e):t.removeAttribute(`${r}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,r,s){s&($s.DashCase|$s.Important)?t.style.setProperty(e,r,s&$s.Important?"important":""):t.style[e]=r}removeStyle(t,e,r){r&$s.DashCase?t.style.removeProperty(e):t.style[e]=""}setProperty(t,e,r){t[e]=r}setValue(t,e){t.nodeValue=e}listen(t,e,r){return"string"==typeof t?this.eventManager.addGlobalEventListener(t,e,i$(r)):this.eventManager.addEventListener(t,e,i$(r))}}function a$(n){return"TEMPLATE"===n.tagName&&void 0!==n.content}class jQ extends nS{constructor(t,e,r,s){super(t),this.component=r;const i=_y(s+"-"+r.id,r.styles,[]);e.addStyles(i),this.contentAttr=function UQ(n){return"_ngcontent-%COMP%".replace(tS,n)}(s+"-"+r.id),this.hostAttr=function HQ(n){return"_nghost-%COMP%".replace(tS,n)}(s+"-"+r.id)}applyToHost(t){super.setAttribute(t,this.hostAttr,"")}createElement(t,e){const r=super.createElement(t,e);return super.setAttribute(r,this.contentAttr,""),r}}class GQ extends nS{constructor(t,e,r,s){super(t),this.sharedStylesHost=e,this.hostEl=r,this.shadowRoot=r.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const i=_y(s.id,s.styles,[]);for(let o=0;o<i.length;o++){const a=document.createElement("style");a.textContent=i[o],this.shadowRoot.appendChild(a)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,r){return super.insertBefore(this.nodeOrShadowRoot(t),e,r)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}}let qQ=(()=>{class n extends e${constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,s){return e.addEventListener(r,s,!1),()=>this.removeEventListener(e,r,s)}removeEventListener(e,r,s){return e.removeEventListener(r,s)}}return n.\u0275fac=function(e){return new(e||n)(Z(wt))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();const l$=["alt","control","meta","shift"],KQ={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},XQ={alt:n=>n.altKey,control:n=>n.ctrlKey,meta:n=>n.metaKey,shift:n=>n.shiftKey};let YQ=(()=>{class n extends e${constructor(e){super(e)}supports(e){return null!=n.parseEventName(e)}addEventListener(e,r,s){const i=n.parseEventName(r),o=n.eventCallback(i.fullKey,s,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Mo().onAndCancel(e,i.domEventName,o))}static parseEventName(e){const r=e.toLowerCase().split("."),s=r.shift();if(0===r.length||"keydown"!==s&&"keyup"!==s)return null;const i=n._normalizeKey(r.pop());let o="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),o="code."),l$.forEach(c=>{const u=r.indexOf(c);u>-1&&(r.splice(u,1),o+=c+".")}),o+=i,0!=r.length||0===i.length)return null;const l={};return l.domEventName=s,l.fullKey=o,l}static matchEventFullKeyCode(e,r){let s=KQ[e.key]||e.key,i="";return r.indexOf("code.")>-1&&(s=e.code,i="code."),!(null==s||!s)&&(s=s.toLowerCase()," "===s?s="space":"."===s&&(s="dot"),l$.forEach(o=>{o!==s&&(0,XQ[o])(e)&&(i+=o+".")}),i+=s,i===r)}static eventCallback(e,r,s){return i=>{n.matchEventFullKeyCode(i,e)&&s.runGuarded(()=>r(i))}}static _normalizeKey(e){return"esc"===e?"escape":e}}return n.\u0275fac=function(e){return new(e||n)(Z(wt))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();const eJ=r2(A9,"browser",[{provide:wC,useValue:G2},{provide:qO,useValue:function ZQ(){JC.makeCurrent()},multi:!0},{provide:wt,useFactory:function JQ(){return function C8(n){sw=n}(document),document},deps:[]}]),d$=new me(""),h$=[{provide:Qg,useClass:class LQ{addToWindow(t){pn.getAngularTestability=(r,s=!0)=>{const i=t.findTestabilityInTree(r,s);if(null==i)throw new Error("Could not find testability for element.");return i},pn.getAllAngularTestabilities=()=>t.getAllTestabilities(),pn.getAllAngularRootElements=()=>t.getAllRootElements(),pn.frameworkStabilizers||(pn.frameworkStabilizers=[]),pn.frameworkStabilizers.push(r=>{const s=pn.getAllAngularTestabilities();let i=s.length,o=!1;const a=function(l){o=o||l,i--,0==i&&r(o)};s.forEach(function(l){l.whenStable(a)})})}findTestabilityInTree(t,e,r){return null==e?null:t.getTestability(e)??(r?Mo().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null)}},deps:[]},{provide:JO,useClass:DC,deps:[ft,TC,Qg]},{provide:DC,useClass:DC,deps:[ft,TC,Qg]}],f$=[{provide:hw,useValue:"root"},{provide:ca,useFactory:function QQ(){return new ca},deps:[]},{provide:yy,useClass:qQ,multi:!0,deps:[wt,ft,wC]},{provide:yy,useClass:YQ,multi:!0,deps:[wt]},{provide:vy,useClass:vy,deps:[by,mf,lf]},{provide:Ph,useExisting:vy},{provide:t$,useExisting:mf},{provide:mf,useClass:mf,deps:[wt]},{provide:by,useClass:by,deps:[yy,ft]},{provide:class oQ{},useClass:BQ,deps:[]},[]];let p$=(()=>{class n{constructor(e){}static withServerTransition(e){return{ngModule:n,providers:[{provide:lf,useValue:e.appId},{provide:J2,useExisting:lf},PQ]}}}return n.\u0275fac=function(e){return new(e||n)(Z(d$,12))},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({providers:[...f$,...h$],imports:[fc,R9]}),n})(),m$=(()=>{class n{constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}}return n.\u0275fac=function(e){return new(e||n)(Z(wt))},n.\u0275prov=we({token:n,factory:function(e){let r=null;return r=e?new e:function nJ(){return new m$(Z(wt))}(),r},providedIn:"root"}),n})();typeof window<"u"&&window;let iS=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:function(e){let r=null;return r=e?new(e||n):Z(b$),r},providedIn:"root"}),n})(),b$=(()=>{class n extends iS{constructor(e){super(),this._doc=e}sanitize(e,r){if(null==r)return null;switch(e){case Ut.NONE:return r;case Ut.HTML:return Do(r,"HTML")?oi(r):CR(this._doc,String(r)).toString();case Ut.STYLE:return Do(r,"Style")?oi(r):r;case Ut.SCRIPT:if(Do(r,"Script"))return oi(r);throw new Error("unsafe value used in a script context");case Ut.URL:return Do(r,"URL")?oi(r):Cg(String(r));case Ut.RESOURCE_URL:if(Do(r,"ResourceURL"))return oi(r);throw new Error(`unsafe value used in a resource URL context (see ${Gm})`);default:throw new Error(`Unexpected SecurityContext ${e} (see ${Gm})`)}}bypassSecurityTrustHtml(e){return function N8(n){return new S8(n)}(e)}bypassSecurityTrustStyle(e){return function A8(n){return new I8(n)}(e)}bypassSecurityTrustScript(e){return function R8(n){return new E8(n)}(e)}bypassSecurityTrustUrl(e){return function M8(n){return new D8(n)}(e)}bypassSecurityTrustResourceUrl(e){return function F8(n){return new T8(n)}(e)}}return n.\u0275fac=function(e){return new(e||n)(Z(wt))},n.\u0275prov=we({token:n,factory:function(e){let r=null;return r=e?new e:function cJ(n){return new b$(n.get(wt))}(Z(vr)),r},providedIn:"root"}),n})();function Ae(...n){return Tn(n,ph(n))}class li extends It{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return!e.closed&&t.next(this._value),e}getValue(){const{hasError:t,thrownError:e,_value:r}=this;if(t)throw e;return this._throwIfClosed(),r}next(t){super.next(this._value=t)}}const xy=je(n=>function(){n(this),this.name="EmptyError",this.message="no elements in sequence"}),{isArray:uJ}=Array,{getPrototypeOf:dJ,prototype:hJ,keys:fJ}=Object;function _$(n){if(1===n.length){const t=n[0];if(uJ(t))return{args:t,keys:null};if(function pJ(n){return n&&"object"==typeof n&&dJ(n)===hJ}(t)){const e=fJ(t);return{args:e.map(r=>t[r]),keys:e}}}return{args:n,keys:null}}const{isArray:mJ}=Array;function oS(n){return Ue(t=>function gJ(n,t){return mJ(t)?n(...t):n(t)}(n,t))}function v$(n,t){return n.reduce((e,r,s)=>(e[r]=t[s],e),{})}function aS(...n){const t=ph(n),e=MN(n),{args:r,keys:s}=_$(n);if(0===r.length)return Tn([],t);const i=new Dn(function yJ(n,t,e=za){return r=>{x$(t,()=>{const{length:s}=n,i=new Array(s);let o=s,a=s;for(let l=0;l<s;l++)x$(t,()=>{const c=Tn(n[l],t);let u=!1;c.subscribe(xn(r,d=>{i[l]=d,u||(u=!0,a--),a||r.next(e(i.slice()))},()=>{--o||r.complete()}))},r)},r)}}(r,t,s?o=>v$(s,o):za));return e?i.pipe(oS(e)):i}function x$(n,t,e){n?ea(e,n,t):t()}function gf(...n){return function bJ(){return tu(1)}()(Tn(n,ph(n)))}function wy(n){return new Dn(t=>{Rs(n()).subscribe(t)})}function Gu(n,t){const e=ae(n)?n:()=>n,r=s=>s.error(e());return new Dn(t?s=>t.schedule(r,0,s):r)}function lS(){return Mn((n,t)=>{let e=null;n._refCount++;const r=xn(t,void 0,void 0,void 0,()=>{if(!n||n._refCount<=0||0<--n._refCount)return void(e=null);const s=n._connection,i=e;e=null,s&&(!i||s===i)&&s.unsubscribe(),t.unsubscribe()});n.subscribe(r),r.closed||(e=n.connect())})}class w$ extends Dn{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._subject=null,this._refCount=0,this._connection=null,_N(t)&&(this.lift=t.lift)}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return(!t||t.isStopped)&&(this._subject=this.subjectFactory()),this._subject}_teardown(){this._refCount=0;const{_connection:t}=this;this._subject=this._connection=null,t?.unsubscribe()}connect(){let t=this._connection;if(!t){t=this._connection=new Ve;const e=this.getSubject();t.add(this.source.subscribe(xn(e,void 0,()=>{this._teardown(),e.complete()},r=>{this._teardown(),e.error(r)},()=>this._teardown()))),t.closed&&(this._connection=null,t=Ve.EMPTY)}return t}refCount(){return lS()(this)}}function ss(n,t){return Mn((e,r)=>{let s=null,i=0,o=!1;const a=()=>o&&!s&&r.complete();e.subscribe(xn(r,l=>{s?.unsubscribe();let c=0;const u=i++;Rs(n(l,u)).subscribe(s=xn(r,d=>r.next(t?t(l,d,u,c++):d),()=>{s=null,a()}))},()=>{o=!0,a()}))})}function $n(n){return n<=0?()=>ta:Mn((t,e)=>{let r=0;t.subscribe(xn(e,s=>{++r<=n&&(e.next(s),n<=r&&e.complete())}))})}function pc(...n){const t=ph(n);return Mn((e,r)=>{(t?gf(n,e,t):gf(n,e)).subscribe(r)})}function or(n,t){return Mn((e,r)=>{let s=0;e.subscribe(xn(r,i=>n.call(t,i,s++)&&r.next(i)))})}function Cy(n){return Mn((t,e)=>{let r=!1;t.subscribe(xn(e,s=>{r=!0,e.next(s)},()=>{r||e.next(n),e.complete()}))})}function C$(n=_J){return Mn((t,e)=>{let r=!1;t.subscribe(xn(e,s=>{r=!0,e.next(s)},()=>r?e.complete():e.error(n())))})}function _J(){return new xy}function Ja(n,t){const e=arguments.length>=2;return r=>r.pipe(n?or((s,i)=>n(s,i,r)):za,$n(1),e?Cy(t):C$(()=>new xy))}function el(n,t){return ae(t)?yr(n,t,1):yr(n,1)}function ar(n,t,e){const r=ae(n)||t||e?{next:n,error:t,complete:e}:n;return r?Mn((s,i)=>{var o;null===(o=r.subscribe)||void 0===o||o.call(r);let a=!0;s.subscribe(xn(i,l=>{var c;null===(c=r.next)||void 0===c||c.call(r,l),i.next(l)},()=>{var l;a=!1,null===(l=r.complete)||void 0===l||l.call(r),i.complete()},l=>{var c;a=!1,null===(c=r.error)||void 0===c||c.call(r,l),i.error(l)},()=>{var l,c;a&&(null===(l=r.unsubscribe)||void 0===l||l.call(r)),null===(c=r.finalize)||void 0===c||c.call(r)}))}):za}function Fi(n){return Mn((t,e)=>{let i,r=null,s=!1;r=t.subscribe(xn(e,void 0,void 0,o=>{i=Rs(n(o,Fi(n)(t))),r?(r.unsubscribe(),r=null,i.subscribe(e)):s=!0})),s&&(r.unsubscribe(),r=null,i.subscribe(e))})}function vJ(n,t,e,r,s){return(i,o)=>{let a=e,l=t,c=0;i.subscribe(xn(o,u=>{const d=c++;l=a?n(l,u,d):(a=!0,u),r&&o.next(l)},s&&(()=>{a&&o.next(l),o.complete()})))}}function S$(n,t){return Mn(vJ(n,t,arguments.length>=2,!0))}function cS(n){return n<=0?()=>ta:Mn((t,e)=>{let r=[];t.subscribe(xn(e,s=>{r.push(s),n<r.length&&r.shift()},()=>{for(const s of r)e.next(s);e.complete()},void 0,()=>{r=null}))})}function I$(n,t){const e=arguments.length>=2;return r=>r.pipe(n?or((s,i)=>n(s,i,r)):za,cS(1),e?Cy(t):C$(()=>new xy))}function E$(n,t=!1){return Mn((e,r)=>{let s=0;e.subscribe(xn(r,i=>{const o=n(i,s++);(o||t)&&r.next(i),!o&&r.complete()}))})}function D$(n){return Ue(()=>n)}function Sy(n){return Mn((t,e)=>{try{t.subscribe(e)}finally{e.add(n)}})}const bt="primary",yf=Symbol("RouteTitle");class xJ{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function qu(n){return new xJ(n)}function wJ(n,t,e){const r=e.path.split("/");if(r.length>n.length||"full"===e.pathMatch&&(t.hasChildren()||r.length<n.length))return null;const s={};for(let i=0;i<r.length;i++){const o=r[i],a=n[i];if(o.startsWith(":"))s[o.substring(1)]=a;else if(o!==a.path)return null}return{consumed:n.slice(0,r.length),posParams:s}}function Fo(n,t){const e=n?Object.keys(n):void 0,r=t?Object.keys(t):void 0;if(!e||!r||e.length!=r.length)return!1;let s;for(let i=0;i<e.length;i++)if(s=e[i],!T$(n[s],t[s]))return!1;return!0}function T$(n,t){if(Array.isArray(n)&&Array.isArray(t)){if(n.length!==t.length)return!1;const e=[...n].sort(),r=[...t].sort();return e.every((s,i)=>r[i]===s)}return n===t}function k$(n){return Array.prototype.concat.apply([],n)}function N$(n){return n.length>0?n[n.length-1]:null}function Wr(n,t){for(const e in n)n.hasOwnProperty(e)&&t(n[e],e)}function tl(n){return Yw(n)?n:qh(n)?Tn(Promise.resolve(n)):Ae(n)}const Iy=!1,SJ={exact:function M$(n,t,e){if(!gc(n.segments,t.segments)||!Ey(n.segments,t.segments,e)||n.numberOfChildren!==t.numberOfChildren)return!1;for(const r in t.children)if(!n.children[r]||!M$(n.children[r],t.children[r],e))return!1;return!0},subset:F$},A$={exact:function IJ(n,t){return Fo(n,t)},subset:function EJ(n,t){return Object.keys(t).length<=Object.keys(n).length&&Object.keys(t).every(e=>T$(n[e],t[e]))},ignored:()=>!0};function R$(n,t,e){return SJ[e.paths](n.root,t.root,e.matrixParams)&&A$[e.queryParams](n.queryParams,t.queryParams)&&!("exact"===e.fragment&&n.fragment!==t.fragment)}function F$(n,t,e){return O$(n,t,t.segments,e)}function O$(n,t,e,r){if(n.segments.length>e.length){const s=n.segments.slice(0,e.length);return!(!gc(s,e)||t.hasChildren()||!Ey(s,e,r))}if(n.segments.length===e.length){if(!gc(n.segments,e)||!Ey(n.segments,e,r))return!1;for(const s in t.children)if(!n.children[s]||!F$(n.children[s],t.children[s],r))return!1;return!0}{const s=e.slice(0,n.segments.length),i=e.slice(n.segments.length);return!!(gc(n.segments,s)&&Ey(n.segments,s,r)&&n.children[bt])&&O$(n.children[bt],t,i,r)}}function Ey(n,t,e){return t.every((r,s)=>A$[e](n[s].parameters,r.parameters))}class mc{constructor(t=new Ct([],{}),e={},r=null){this.root=t,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=qu(this.queryParams)),this._queryParamMap}toString(){return kJ.serialize(this)}}class Ct{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Wr(e,(r,s)=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Dy(this)}}class bf{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=qu(this.parameters)),this._parameterMap}toString(){return B$(this)}}function gc(n,t){return n.length===t.length&&n.every((e,r)=>e.path===t[r].path)}let $$=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:function(){return new uS},providedIn:"root"}),n})();class uS{parse(t){const e=new LJ(t);return new mc(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){const e=`/${_f(t.root,!0)}`,r=function RJ(n){const t=Object.keys(n).map(e=>{const r=n[e];return Array.isArray(r)?r.map(s=>`${Ty(e)}=${Ty(s)}`).join("&"):`${Ty(e)}=${Ty(r)}`}).filter(e=>!!e);return t.length?`?${t.join("&")}`:""}(t.queryParams);return`${e}${r}${"string"==typeof t.fragment?`#${function NJ(n){return encodeURI(n)}(t.fragment)}`:""}`}}const kJ=new uS;function Dy(n){return n.segments.map(t=>B$(t)).join("/")}function _f(n,t){if(!n.hasChildren())return Dy(n);if(t){const e=n.children[bt]?_f(n.children[bt],!1):"",r=[];return Wr(n.children,(s,i)=>{i!==bt&&r.push(`${i}:${_f(s,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}{const e=function TJ(n,t){let e=[];return Wr(n.children,(r,s)=>{s===bt&&(e=e.concat(t(r,s)))}),Wr(n.children,(r,s)=>{s!==bt&&(e=e.concat(t(r,s)))}),e}(n,(r,s)=>s===bt?[_f(n.children[bt],!1)]:[`${s}:${_f(r,!1)}`]);return 1===Object.keys(n.children).length&&null!=n.children[bt]?`${Dy(n)}/${e[0]}`:`${Dy(n)}/(${e.join("//")})`}}function P$(n){return encodeURIComponent(n).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Ty(n){return P$(n).replace(/%3B/gi,";")}function dS(n){return P$(n).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function ky(n){return decodeURIComponent(n)}function L$(n){return ky(n.replace(/\+/g,"%20"))}function B$(n){return`${dS(n.path)}${function AJ(n){return Object.keys(n).map(t=>`;${dS(t)}=${dS(n[t])}`).join("")}(n.parameters)}`}const MJ=/^[^\/()?;=#]+/;function Ny(n){const t=n.match(MJ);return t?t[0]:""}const FJ=/^[^=?&#]+/,$J=/^[^&#]+/;class LJ{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new Ct([],{}):new Ct([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional("?"))do{this.parseQueryParam(t)}while(this.consumeOptional("&"));return t}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const t=[];for(this.peekStartsWith("(")||t.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),t.push(this.parseSegment());let e={};this.peekStartsWith("/(")&&(this.capture("/"),e=this.parseParens(!0));let r={};return this.peekStartsWith("(")&&(r=this.parseParens(!1)),(t.length>0||Object.keys(e).length>0)&&(r[bt]=new Ct(t,e)),r}parseSegment(){const t=Ny(this.remaining);if(""===t&&this.peekStartsWith(";"))throw new te(4009,Iy);return this.capture(t),new bf(ky(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(";");)this.parseParam(t);return t}parseParam(t){const e=Ny(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const s=Ny(this.remaining);s&&(r=s,this.capture(r))}t[ky(e)]=ky(r)}parseQueryParam(t){const e=function OJ(n){const t=n.match(FJ);return t?t[0]:""}(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){const o=function PJ(n){const t=n.match($J);return t?t[0]:""}(this.remaining);o&&(r=o,this.capture(r))}const s=L$(e),i=L$(r);if(t.hasOwnProperty(s)){let o=t[s];Array.isArray(o)||(o=[o],t[s]=o),o.push(i)}else t[s]=i}parseParens(t){const e={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const r=Ny(this.remaining),s=this.remaining[r.length];if("/"!==s&&")"!==s&&";"!==s)throw new te(4010,Iy);let i;r.indexOf(":")>-1?(i=r.slice(0,r.indexOf(":")),this.capture(i),this.capture(":")):t&&(i=bt);const o=this.parseChildren();e[i]=1===Object.keys(o).length?o[bt]:new Ct([],o),this.consumeOptional("//")}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&&(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new te(4011,Iy)}}function hS(n){return n.segments.length>0?new Ct([],{[bt]:n}):n}function Ay(n){const t={};for(const r of Object.keys(n.children)){const i=Ay(n.children[r]);(i.segments.length>0||i.hasChildren())&&(t[r]=i)}return function BJ(n){if(1===n.numberOfChildren&&n.children[bt]){const t=n.children[bt];return new Ct(n.segments.concat(t.segments),t.children)}return n}(new Ct(n.segments,t))}function yc(n){return n instanceof mc}function UJ(n,t,e,r,s){if(0===e.length)return Ku(t.root,t.root,t.root,r,s);const i=function U$(n){if("string"==typeof n[0]&&1===n.length&&"/"===n[0])return new z$(!0,0,n);let t=0,e=!1;const r=n.reduce((s,i,o)=>{if("object"==typeof i&&null!=i){if(i.outlets){const a={};return Wr(i.outlets,(l,c)=>{a[c]="string"==typeof l?l.split("/"):l}),[...s,{outlets:a}]}if(i.segmentPath)return[...s,i.segmentPath]}return"string"!=typeof i?[...s,i]:0===o?(i.split("/").forEach((a,l)=>{0==l&&"."===a||(0==l&&""===a?e=!0:".."===a?t++:""!=a&&s.push(a))}),s):[...s,i]},[]);return new z$(e,t,r)}(e);return i.toRoot()?Ku(t.root,t.root,new Ct([],{}),r,s):function o(l){const c=function WJ(n,t,e,r){if(n.isAbsolute)return new Xu(t.root,!0,0);if(-1===r)return new Xu(e,e===t.root,0);return function H$(n,t,e){let r=n,s=t,i=e;for(;i>s;){if(i-=s,r=r.parent,!r)throw new te(4005,!1);s=r.segments.length}return new Xu(r,!1,s-i)}(e,r+(vf(n.commands[0])?0:1),n.numberOfDoubleDots)}(i,t,n.snapshot?._urlSegment,l),u=c.processChildren?wf(c.segmentGroup,c.index,i.commands):pS(c.segmentGroup,c.index,i.commands);return Ku(t.root,c.segmentGroup,u,r,s)}(n.snapshot?._lastPathIndex)}function vf(n){return"object"==typeof n&&null!=n&&!n.outlets&&!n.segmentPath}function xf(n){return"object"==typeof n&&null!=n&&n.outlets}function Ku(n,t,e,r,s){let o,i={};r&&Wr(r,(l,c)=>{i[c]=Array.isArray(l)?l.map(u=>`${u}`):`${l}`}),o=n===t?e:V$(n,t,e);const a=hS(Ay(o));return new mc(a,i,s)}function V$(n,t,e){const r={};return Wr(n.children,(s,i)=>{r[i]=s===t?e:V$(s,t,e)}),new Ct(n.segments,r)}class z${constructor(t,e,r){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=r,t&&r.length>0&&vf(r[0]))throw new te(4003,!1);const s=r.find(xf);if(s&&s!==N$(r))throw new te(4004,!1)}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class Xu{constructor(t,e,r){this.segmentGroup=t,this.processChildren=e,this.index=r}}function pS(n,t,e){if(n||(n=new Ct([],{})),0===n.segments.length&&n.hasChildren())return wf(n,t,e);const r=function GJ(n,t,e){let r=0,s=t;const i={match:!1,pathIndex:0,commandIndex:0};for(;s<n.segments.length;){if(r>=e.length)return i;const o=n.segments[s],a=e[r];if(xf(a))break;const l=`${a}`,c=r<e.length-1?e[r+1]:null;if(s>0&&void 0===l)break;if(l&&c&&"object"==typeof c&&void 0===c.outlets){if(!j$(l,c,o))return i;r+=2}else{if(!j$(l,{},o))return i;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(n,t,e),s=e.slice(r.commandIndex);if(r.match&&r.pathIndex<n.segments.length){const i=new Ct(n.segments.slice(0,r.pathIndex),{});return i.children[bt]=new Ct(n.segments.slice(r.pathIndex),n.children),wf(i,0,s)}return r.match&&0===s.length?new Ct(n.segments,{}):r.match&&!n.hasChildren()?mS(n,t,e):r.match?wf(n,0,s):mS(n,t,e)}function wf(n,t,e){if(0===e.length)return new Ct(n.segments,{});{const r=function jJ(n){return xf(n[0])?n[0].outlets:{[bt]:n}}(e),s={};return Wr(r,(i,o)=>{"string"==typeof i&&(i=[i]),null!==i&&(s[o]=pS(n.children[o],t,i))}),Wr(n.children,(i,o)=>{void 0===r[o]&&(s[o]=i)}),new Ct(n.segments,s)}}function mS(n,t,e){const r=n.segments.slice(0,t);let s=0;for(;s<e.length;){const i=e[s];if(xf(i)){const l=qJ(i.outlets);return new Ct(r,l)}if(0===s&&vf(e[0])){r.push(new bf(n.segments[t].path,W$(e[0]))),s++;continue}const o=xf(i)?i.outlets[bt]:`${i}`,a=s<e.length-1?e[s+1]:null;o&&a&&vf(a)?(r.push(new bf(o,W$(a))),s+=2):(r.push(new bf(o,{})),s++)}return new Ct(r,{})}function qJ(n){const t={};return Wr(n,(e,r)=>{"string"==typeof e&&(e=[e]),null!==e&&(t[r]=mS(new Ct([],{}),0,e))}),t}function W$(n){const t={};return Wr(n,(e,r)=>t[r]=`${e}`),t}function j$(n,t,e){return n==e.path&&Fo(t,e.parameters)}class va{constructor(t,e){this.id=t,this.url=e}}class gS extends va{constructor(t,e,r="imperative",s=null){super(t,e),this.type=0,this.navigationTrigger=r,this.restoredState=s}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class bc extends va{constructor(t,e,r){super(t,e),this.urlAfterRedirects=r,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Ry extends va{constructor(t,e,r,s){super(t,e),this.reason=r,this.code=s,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class G$ extends va{constructor(t,e,r,s){super(t,e),this.error=r,this.target=s,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class KJ extends va{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class XJ extends va{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class YJ extends va{constructor(t,e,r,s,i){super(t,e),this.urlAfterRedirects=r,this.state=s,this.shouldActivate=i,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class ZJ extends va{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class QJ extends va{constructor(t,e,r,s){super(t,e),this.urlAfterRedirects=r,this.state=s,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class JJ{constructor(t){this.route=t,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class eee{constructor(t){this.route=t,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class tee{constructor(t){this.snapshot=t,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class nee{constructor(t){this.snapshot=t,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class ree{constructor(t){this.snapshot=t,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class see{constructor(t){this.snapshot=t,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class q${constructor(t,e,r){this.routerEvent=t,this.position=e,this.anchor=r,this.type=15}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}class K${constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length>1?e[e.length-2]:null}children(t){const e=yS(t,this._root);return e?e.children.map(r=>r.value):[]}firstChild(t){const e=yS(t,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(t){const e=bS(t,this._root);return e.length<2?[]:e[e.length-2].children.map(s=>s.value).filter(s=>s!==t)}pathFromRoot(t){return bS(t,this._root).map(e=>e.value)}}function yS(n,t){if(n===t.value)return t;for(const e of t.children){const r=yS(n,e);if(r)return r}return null}function bS(n,t){if(n===t.value)return[t];for(const e of t.children){const r=bS(n,e);if(r.length)return r.unshift(t),r}return[]}class xa{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function Yu(n){const t={};return n&&n.children.forEach(e=>t[e.value.outlet]=e),t}class X$ extends K${constructor(t,e){super(t),this.snapshot=e,_S(this,t)}toString(){return this.snapshot.toString()}}function Y$(n,t){const e=function oee(n,t){const o=new My([],{},{},"",{},bt,t,null,n.root,-1,{});return new Q$("",new xa(o,[]))}(n,t),r=new li([new bf("",{})]),s=new li({}),i=new li({}),o=new li({}),a=new li(""),l=new Zu(r,s,o,a,i,bt,t,e.root);return l.snapshot=e.root,new X$(new xa(l,[]),e)}class Zu{constructor(t,e,r,s,i,o,a,l){this.url=t,this.params=e,this.queryParams=r,this.fragment=s,this.data=i,this.outlet=o,this.component=a,this.title=this.data?.pipe(Ue(c=>c[yf]))??Ae(void 0),this._futureSnapshot=l}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(Ue(t=>qu(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(Ue(t=>qu(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function Z$(n,t="emptyOnly"){const e=n.pathFromRoot;let r=0;if("always"!==t)for(r=e.length-1;r>=1;){const s=e[r],i=e[r-1];if(s.routeConfig&&""===s.routeConfig.path)r--;else{if(i.component)break;r--}}return function aee(n){return n.reduce((t,e)=>({params:{...t.params,...e.params},data:{...t.data,...e.data},resolve:{...e.data,...t.resolve,...e.routeConfig?.data,...e._resolvedData}}),{params:{},data:{},resolve:{}})}(e.slice(r))}class My{constructor(t,e,r,s,i,o,a,l,c,u,d){this.url=t,this.params=e,this.queryParams=r,this.fragment=s,this.data=i,this.outlet=o,this.component=a,this.routeConfig=l,this._urlSegment=c,this._lastPathIndex=u,this._resolve=d}get title(){return this.data?.[yf]}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=qu(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=qu(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(r=>r.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class Q$ extends K${constructor(t,e){super(e),this.url=t,_S(this,e)}toString(){return J$(this._root)}}function _S(n,t){t.value._routerState=n,t.children.forEach(e=>_S(n,e))}function J$(n){const t=n.children.length>0?` { ${n.children.map(J$).join(", ")} } `:"";return`${n.value}${t}`}function vS(n){if(n.snapshot){const t=n.snapshot,e=n._futureSnapshot;n.snapshot=e,Fo(t.queryParams,e.queryParams)||n.queryParams.next(e.queryParams),t.fragment!==e.fragment&&n.fragment.next(e.fragment),Fo(t.params,e.params)||n.params.next(e.params),function CJ(n,t){if(n.length!==t.length)return!1;for(let e=0;e<n.length;++e)if(!Fo(n[e],t[e]))return!1;return!0}(t.url,e.url)||n.url.next(e.url),Fo(t.data,e.data)||n.data.next(e.data)}else n.snapshot=n._futureSnapshot,n.data.next(n._futureSnapshot.data)}function xS(n,t){const e=Fo(n.params,t.params)&&function DJ(n,t){return gc(n,t)&&n.every((e,r)=>Fo(e.parameters,t[r].parameters))}(n.url,t.url);return e&&!(!n.parent!=!t.parent)&&(!n.parent||xS(n.parent,t.parent))}function Cf(n,t,e){if(e&&n.shouldReuseRoute(t.value,e.value.snapshot)){const r=e.value;r._futureSnapshot=t.value;const s=function cee(n,t,e){return t.children.map(r=>{for(const s of e.children)if(n.shouldReuseRoute(r.value,s.value.snapshot))return Cf(n,r,s);return Cf(n,r)})}(n,t,e);return new xa(r,s)}{if(n.shouldAttach(t.value)){const i=n.retrieve(t.value);if(null!==i){const o=i.route;return o.value._futureSnapshot=t.value,o.children=t.children.map(a=>Cf(n,a)),o}}const r=function uee(n){return new Zu(new li(n.url),new li(n.params),new li(n.queryParams),new li(n.fragment),new li(n.data),n.outlet,n.component,n)}(t.value),s=t.children.map(i=>Cf(n,i));return new xa(r,s)}}const wS="ngNavigationCancelingError";function eP(n,t){const{redirectTo:e,navigationBehaviorOptions:r}=yc(t)?{redirectTo:t,navigationBehaviorOptions:void 0}:t,s=tP(!1,0,t);return s.url=e,s.navigationBehaviorOptions=r,s}function tP(n,t,e){const r=new Error("NavigationCancelingError: "+(n||""));return r[wS]=!0,r.cancellationCode=t,e&&(r.url=e),r}function nP(n){return rP(n)&&yc(n.url)}function rP(n){return n&&n[wS]}class dee{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.injector=null,this.children=new Sf,this.attachRef=null}}let Sf=(()=>{class n{constructor(){this.contexts=new Map}onChildOutletCreated(e,r){const s=this.getOrCreateContext(e);s.outlet=r,this.contexts.set(e,s)}onChildOutletDestroyed(e){const r=this.getContext(e);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let r=this.getContext(e);return r||(r=new dee,this.contexts.set(e,r)),r}getContext(e){return this.contexts.get(e)||null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const Fy=!1;let sP=(()=>{class n{constructor(){this.activated=null,this._activatedRoute=null,this.name=bt,this.activateEvents=new Et,this.deactivateEvents=new Et,this.attachEvents=new Et,this.detachEvents=new Et,this.parentContexts=Bt(Sf),this.location=Bt(Ps),this.changeDetector=Bt(uo),this.environmentInjector=Bt(qa)}ngOnChanges(e){if(e.name){const{firstChange:r,previousValue:s}=e.name;if(r)return;this.isTrackedInParentContexts(s)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(s)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new te(4012,Fy);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new te(4012,Fy);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new te(4012,Fy);this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new te(4013,Fy);this._activatedRoute=e;const s=this.location,o=e.snapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,l=new hee(e,a,s.injector);if(r&&function fee(n){return!!n.resolveComponentFactory}(r)){const c=r.resolveComponentFactory(o);this.activated=s.createComponent(c,s.length,l)}else this.activated=s.createComponent(o,{index:s.length,injector:l,environmentInjector:r??this.environmentInjector});this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=Me({type:n,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[Os]}),n})();class hee{constructor(t,e,r){this.route=t,this.childContexts=e,this.parent=r}get(t,e){return t===Zu?this.route:t===Sf?this.childContexts:this.parent.get(t,e)}}let CS=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=Ur({type:n,selectors:[["ng-component"]],standalone:!0,features:[oO],decls:1,vars:0,template:function(e,r){1&e&&rr(0,"router-outlet")},dependencies:[sP],encapsulation:2}),n})();function iP(n,t){return n.providers&&!n._injector&&(n._injector=jg(n.providers,t,`Route: ${n.path}`)),n._injector??t}function IS(n){const t=n.children&&n.children.map(IS),e=t?{...n,children:t}:{...n};return!e.component&&!e.loadComponent&&(t||e.loadChildren)&&e.outlet&&e.outlet!==bt&&(e.component=CS),e}function Oi(n){return n.outlet||bt}function oP(n,t){const e=n.filter(r=>Oi(r)===t);return e.push(...n.filter(r=>Oi(r)!==t)),e}function If(n){if(!n)return null;if(n.routeConfig?._injector)return n.routeConfig._injector;for(let t=n.parent;t;t=t.parent){const e=t.routeConfig;if(e?._loadedInjector)return e._loadedInjector;if(e?._injector)return e._injector}return null}class bee{constructor(t,e,r,s){this.routeReuseStrategy=t,this.futureState=e,this.currState=r,this.forwardEvent=s}activate(t){const e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,t),vS(this.futureState.root),this.activateChildRoutes(e,r,t)}deactivateChildRoutes(t,e,r){const s=Yu(e);t.children.forEach(i=>{const o=i.value.outlet;this.deactivateRoutes(i,s[o],r),delete s[o]}),Wr(s,(i,o)=>{this.deactivateRouteAndItsChildren(i,r)})}deactivateRoutes(t,e,r){const s=t.value,i=e?e.value:null;if(s===i)if(s.component){const o=r.getContext(s.outlet);o&&this.deactivateChildRoutes(t,e,o.children)}else this.deactivateChildRoutes(t,e,r);else i&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(t,e){t.value.component&&this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const r=e.getContext(t.value.outlet),s=r&&t.value.component?r.children:e,i=Yu(t);for(const o of Object.keys(i))this.deactivateRouteAndItsChildren(i[o],s);if(r&&r.outlet){const o=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:o,route:t,contexts:a})}}deactivateRouteAndOutlet(t,e){const r=e.getContext(t.value.outlet),s=r&&t.value.component?r.children:e,i=Yu(t);for(const o of Object.keys(i))this.deactivateRouteAndItsChildren(i[o],s);r&&r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated(),r.attachRef=null,r.resolver=null,r.route=null)}activateChildRoutes(t,e,r){const s=Yu(e);t.children.forEach(i=>{this.activateRoutes(i,s[i.value.outlet],r),this.forwardEvent(new see(i.value.snapshot))}),t.children.length&&this.forwardEvent(new nee(t.value.snapshot))}activateRoutes(t,e,r){const s=t.value,i=e?e.value:null;if(vS(s),s===i)if(s.component){const o=r.getOrCreateContext(s.outlet);this.activateChildRoutes(t,e,o.children)}else this.activateChildRoutes(t,e,r);else if(s.component){const o=r.getOrCreateContext(s.outlet);if(this.routeReuseStrategy.shouldAttach(s.snapshot)){const a=this.routeReuseStrategy.retrieve(s.snapshot);this.routeReuseStrategy.store(s.snapshot,null),o.children.onOutletReAttached(a.contexts),o.attachRef=a.componentRef,o.route=a.route.value,o.outlet&&o.outlet.attach(a.componentRef,a.route.value),vS(a.route.value),this.activateChildRoutes(t,null,o.children)}else{const a=If(s.snapshot),l=a?.get(ic)??null;o.attachRef=null,o.route=s,o.resolver=l,o.injector=a,o.outlet&&o.outlet.activateWith(s,o.injector),this.activateChildRoutes(t,null,o.children)}}else this.activateChildRoutes(t,null,r)}}class aP{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class Oy{constructor(t,e){this.component=t,this.route=e}}function _ee(n,t,e){const r=n._root;return Ef(r,t?t._root:null,e,[r.value])}function Qu(n,t){const e=Symbol(),r=t.get(n,e);return r===e?"function"!=typeof n||function f5(n){return null!==Xm(n)}(n)?t.get(n):n:r}function Ef(n,t,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const i=Yu(t);return n.children.forEach(o=>{(function xee(n,t,e,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const i=n.value,o=t?t.value:null,a=e?e.getContext(n.value.outlet):null;if(o&&i.routeConfig===o.routeConfig){const l=function wee(n,t,e){if("function"==typeof e)return e(n,t);switch(e){case"pathParamsChange":return!gc(n.url,t.url);case"pathParamsOrQueryParamsChange":return!gc(n.url,t.url)||!Fo(n.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!xS(n,t)||!Fo(n.queryParams,t.queryParams);default:return!xS(n,t)}}(o,i,i.routeConfig.runGuardsAndResolvers);l?s.canActivateChecks.push(new aP(r)):(i.data=o.data,i._resolvedData=o._resolvedData),Ef(n,t,i.component?a?a.children:null:e,r,s),l&&a&&a.outlet&&a.outlet.isActivated&&s.canDeactivateChecks.push(new Oy(a.outlet.component,o))}else o&&Df(t,a,s),s.canActivateChecks.push(new aP(r)),Ef(n,null,i.component?a?a.children:null:e,r,s)})(o,i[o.value.outlet],e,r.concat([o.value]),s),delete i[o.value.outlet]}),Wr(i,(o,a)=>Df(o,e.getContext(a),s)),s}function Df(n,t,e){const r=Yu(n),s=n.value;Wr(r,(i,o)=>{Df(i,s.component?t?t.children.getContext(o):null:t,e)}),e.canDeactivateChecks.push(new Oy(s.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,s))}function Tf(n){return"function"==typeof n}function ES(n){return n instanceof xy||"EmptyError"===n?.name}const $y=Symbol("INITIAL_VALUE");function Ju(){return ss(n=>aS(n.map(t=>t.pipe($n(1),pc($y)))).pipe(Ue(t=>{for(const e of t)if(!0!==e){if(e===$y)return $y;if(!1===e||e instanceof mc)return e}return!0}),or(t=>t!==$y),$n(1)))}function lP(n){return function OG(...n){return gN(n)}(ar(t=>{if(yc(t))throw eP(0,t)}),Ue(t=>!0===t))}const DS={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function cP(n,t,e,r,s){const i=TS(n,t,e);return i.matched?function Bee(n,t,e,r){const s=t.canMatch;return s&&0!==s.length?Ae(s.map(o=>{const a=Qu(o,n);return tl(function Tee(n){return n&&Tf(n.canMatch)}(a)?a.canMatch(t,e):n.runInContext(()=>a(t,e)))})).pipe(Ju(),lP()):Ae(!0)}(r=iP(t,r),t,e).pipe(Ue(o=>!0===o?i:{...DS})):Ae(i)}function TS(n,t,e){if(""===t.path)return"full"===t.pathMatch&&(n.hasChildren()||e.length>0)?{...DS}:{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};const s=(t.matcher||wJ)(e,n,t);if(!s)return{...DS};const i={};Wr(s.posParams,(a,l)=>{i[l]=a.path});const o=s.consumed.length>0?{...i,...s.consumed[s.consumed.length-1].parameters}:i;return{matched:!0,consumedSegments:s.consumed,remainingSegments:e.slice(s.consumed.length),parameters:o,positionalParamSegments:s.posParams??{}}}function Py(n,t,e,r){if(e.length>0&&function Uee(n,t,e){return e.some(r=>Ly(n,t,r)&&Oi(r)!==bt)}(n,e,r)){const i=new Ct(t,function zee(n,t,e,r){const s={};s[bt]=r,r._sourceSegment=n,r._segmentIndexShift=t.length;for(const i of e)if(""===i.path&&Oi(i)!==bt){const o=new Ct([],{});o._sourceSegment=n,o._segmentIndexShift=t.length,s[Oi(i)]=o}return s}(n,t,r,new Ct(e,n.children)));return i._sourceSegment=n,i._segmentIndexShift=t.length,{segmentGroup:i,slicedSegments:[]}}if(0===e.length&&function Hee(n,t,e){return e.some(r=>Ly(n,t,r))}(n,e,r)){const i=new Ct(n.segments,function Vee(n,t,e,r,s){const i={};for(const o of r)if(Ly(n,e,o)&&!s[Oi(o)]){const a=new Ct([],{});a._sourceSegment=n,a._segmentIndexShift=t.length,i[Oi(o)]=a}return{...s,...i}}(n,t,e,r,n.children));return i._sourceSegment=n,i._segmentIndexShift=t.length,{segmentGroup:i,slicedSegments:e}}const s=new Ct(n.segments,n.children);return s._sourceSegment=n,s._segmentIndexShift=t.length,{segmentGroup:s,slicedSegments:e}}function Ly(n,t,e){return(!(n.hasChildren()||t.length>0)||"full"!==e.pathMatch)&&""===e.path}function uP(n,t,e,r){return!!(Oi(n)===r||r!==bt&&Ly(t,e,n))&&("**"===n.path||TS(t,n,e).matched)}function dP(n,t,e){return 0===t.length&&!n.children[e]}const By=!1;class Vy{constructor(t){this.segmentGroup=t||null}}class hP{constructor(t){this.urlTree=t}}function kf(n){return Gu(new Vy(n))}function fP(n){return Gu(new hP(n))}class qee{constructor(t,e,r,s,i){this.injector=t,this.configLoader=e,this.urlSerializer=r,this.urlTree=s,this.config=i,this.allowRedirects=!0}apply(){const t=Py(this.urlTree.root,[],[],this.config).segmentGroup,e=new Ct(t.segments,t.children);return this.expandSegmentGroup(this.injector,this.config,e,bt).pipe(Ue(i=>this.createUrlTree(Ay(i),this.urlTree.queryParams,this.urlTree.fragment))).pipe(Fi(i=>{if(i instanceof hP)return this.allowRedirects=!1,this.match(i.urlTree);throw i instanceof Vy?this.noMatchError(i):i}))}match(t){return this.expandSegmentGroup(this.injector,this.config,t.root,bt).pipe(Ue(s=>this.createUrlTree(Ay(s),t.queryParams,t.fragment))).pipe(Fi(s=>{throw s instanceof Vy?this.noMatchError(s):s}))}noMatchError(t){return new te(4002,By)}createUrlTree(t,e,r){const s=hS(t);return new mc(s,e,r)}expandSegmentGroup(t,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.expandChildren(t,e,r).pipe(Ue(i=>new Ct([],i))):this.expandSegment(t,r,e,r.segments,s,!0)}expandChildren(t,e,r){const s=[];for(const i of Object.keys(r.children))"primary"===i?s.unshift(i):s.push(i);return Tn(s).pipe(el(i=>{const o=r.children[i],a=oP(e,i);return this.expandSegmentGroup(t,a,o,i).pipe(Ue(l=>({segment:l,outlet:i})))}),S$((i,o)=>(i[o.outlet]=o.segment,i),{}),I$())}expandSegment(t,e,r,s,i,o){return Tn(r).pipe(el(a=>this.expandSegmentAgainstRoute(t,e,r,a,s,i,o).pipe(Fi(c=>{if(c instanceof Vy)return Ae(null);throw c}))),Ja(a=>!!a),Fi((a,l)=>{if(ES(a))return dP(e,s,i)?Ae(new Ct([],{})):kf(e);throw a}))}expandSegmentAgainstRoute(t,e,r,s,i,o,a){return uP(s,e,i,o)?void 0===s.redirectTo?this.matchSegmentAgainstRoute(t,e,s,i,o):a&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o):kf(e):kf(e)}expandSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o){return"**"===s.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,r,s,o):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,r,s){const i=this.applyRedirectCommands([],r.redirectTo,{});return r.redirectTo.startsWith("/")?fP(i):this.lineralizeSegments(r,i).pipe(yr(o=>{const a=new Ct(o,{});return this.expandSegment(t,a,e,o,s,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,r,s,i,o){const{matched:a,consumedSegments:l,remainingSegments:c,positionalParamSegments:u}=TS(e,s,i);if(!a)return kf(e);const d=this.applyRedirectCommands(l,s.redirectTo,u);return s.redirectTo.startsWith("/")?fP(d):this.lineralizeSegments(s,d).pipe(yr(h=>this.expandSegment(t,e,r,h.concat(c),o,!1)))}matchSegmentAgainstRoute(t,e,r,s,i){return"**"===r.path?(t=iP(r,t),r.loadChildren?(r._loadedRoutes?Ae({routes:r._loadedRoutes,injector:r._loadedInjector}):this.configLoader.loadChildren(t,r)).pipe(Ue(a=>(r._loadedRoutes=a.routes,r._loadedInjector=a.injector,new Ct(s,{})))):Ae(new Ct(s,{}))):cP(e,r,s,t).pipe(ss(({matched:o,consumedSegments:a,remainingSegments:l})=>o?this.getChildConfig(t=r._injector??t,r,s).pipe(yr(u=>{const d=u.injector??t,h=u.routes,{segmentGroup:f,slicedSegments:p}=Py(e,a,l,h),m=new Ct(f.segments,f.children);if(0===p.length&&m.hasChildren())return this.expandChildren(d,h,m).pipe(Ue(_=>new Ct(a,_)));if(0===h.length&&0===p.length)return Ae(new Ct(a,{}));const g=Oi(r)===i;return this.expandSegment(d,m,h,p,g?bt:i,!0).pipe(Ue(b=>new Ct(a.concat(b.segments),b.children)))})):kf(e)))}getChildConfig(t,e,r){return e.children?Ae({routes:e.children,injector:t}):e.loadChildren?void 0!==e._loadedRoutes?Ae({routes:e._loadedRoutes,injector:e._loadedInjector}):function Lee(n,t,e,r){const s=t.canLoad;return void 0===s||0===s.length?Ae(!0):Ae(s.map(o=>{const a=Qu(o,n);return tl(function See(n){return n&&Tf(n.canLoad)}(a)?a.canLoad(t,e):n.runInContext(()=>a(t,e)))})).pipe(Ju(),lP())}(t,e,r).pipe(yr(s=>s?this.configLoader.loadChildren(t,e).pipe(ar(i=>{e._loadedRoutes=i.routes,e._loadedInjector=i.injector})):function jee(n){return Gu(tP(By,3))}())):Ae({routes:[],injector:t})}lineralizeSegments(t,e){let r=[],s=e.root;for(;;){if(r=r.concat(s.segments),0===s.numberOfChildren)return Ae(r);if(s.numberOfChildren>1||!s.children[bt])return Gu(new te(4e3,By));s=s.children[bt]}}applyRedirectCommands(t,e,r){return this.applyRedirectCreateUrlTree(e,this.urlSerializer.parse(e),t,r)}applyRedirectCreateUrlTree(t,e,r,s){const i=this.createSegmentGroup(t,e.root,r,s);return new mc(i,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const r={};return Wr(t,(s,i)=>{if("string"==typeof s&&s.startsWith(":")){const a=s.substring(1);r[i]=e[a]}else r[i]=s}),r}createSegmentGroup(t,e,r,s){const i=this.createSegments(t,e.segments,r,s);let o={};return Wr(e.children,(a,l)=>{o[l]=this.createSegmentGroup(t,a,r,s)}),new Ct(i,o)}createSegments(t,e,r,s){return e.map(i=>i.path.startsWith(":")?this.findPosParam(t,i,s):this.findOrReturn(i,r))}findPosParam(t,e,r){const s=r[e.path.substring(1)];if(!s)throw new te(4001,By);return s}findOrReturn(t,e){let r=0;for(const s of e){if(s.path===t.path)return e.splice(r),s;r++}return t}}class Xee{}class Qee{constructor(t,e,r,s,i,o,a){this.injector=t,this.rootComponentType=e,this.config=r,this.urlTree=s,this.url=i,this.paramsInheritanceStrategy=o,this.urlSerializer=a}recognize(){const t=Py(this.urlTree.root,[],[],this.config.filter(e=>void 0===e.redirectTo)).segmentGroup;return this.processSegmentGroup(this.injector,this.config,t,bt).pipe(Ue(e=>{if(null===e)return null;const r=new My([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},bt,this.rootComponentType,null,this.urlTree.root,-1,{}),s=new xa(r,e),i=new Q$(this.url,s);return this.inheritParamsAndData(i._root),i}))}inheritParamsAndData(t){const e=t.value,r=Z$(e,this.paramsInheritanceStrategy);e.params=Object.freeze(r.params),e.data=Object.freeze(r.data),t.children.forEach(s=>this.inheritParamsAndData(s))}processSegmentGroup(t,e,r,s){return 0===r.segments.length&&r.hasChildren()?this.processChildren(t,e,r):this.processSegment(t,e,r,r.segments,s)}processChildren(t,e,r){return Tn(Object.keys(r.children)).pipe(el(s=>{const i=r.children[s],o=oP(e,s);return this.processSegmentGroup(t,o,i,s)}),S$((s,i)=>s&&i?(s.push(...i),s):null),E$(s=>null!==s),Cy(null),I$(),Ue(s=>{if(null===s)return null;const i=mP(s);return function Jee(n){n.sort((t,e)=>t.value.outlet===bt?-1:e.value.outlet===bt?1:t.value.outlet.localeCompare(e.value.outlet))}(i),i}))}processSegment(t,e,r,s,i){return Tn(e).pipe(el(o=>this.processSegmentAgainstRoute(o._injector??t,o,r,s,i)),Ja(o=>!!o),Fi(o=>{if(ES(o))return dP(r,s,i)?Ae([]):Ae(null);throw o}))}processSegmentAgainstRoute(t,e,r,s,i){if(e.redirectTo||!uP(e,r,s,i))return Ae(null);let o;if("**"===e.path){const a=s.length>0?N$(s).parameters:{},l=yP(r)+s.length;o=Ae({snapshot:new My(s,a,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,bP(e),Oi(e),e.component??e._loadedComponent??null,e,gP(r),l,_P(e)),consumedSegments:[],remainingSegments:[]})}else o=cP(r,e,s,t).pipe(Ue(({matched:a,consumedSegments:l,remainingSegments:c,parameters:u})=>{if(!a)return null;const d=yP(r)+l.length;return{snapshot:new My(l,u,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,bP(e),Oi(e),e.component??e._loadedComponent??null,e,gP(r),d,_P(e)),consumedSegments:l,remainingSegments:c}}));return o.pipe(ss(a=>{if(null===a)return Ae(null);const{snapshot:l,consumedSegments:c,remainingSegments:u}=a;t=e._injector??t;const d=e._loadedInjector??t,h=function ete(n){return n.children?n.children:n.loadChildren?n._loadedRoutes:[]}(e),{segmentGroup:f,slicedSegments:p}=Py(r,c,u,h.filter(g=>void 0===g.redirectTo));if(0===p.length&&f.hasChildren())return this.processChildren(d,h,f).pipe(Ue(g=>null===g?null:[new xa(l,g)]));if(0===h.length&&0===p.length)return Ae([new xa(l,[])]);const m=Oi(e)===i;return this.processSegment(d,h,f,p,m?bt:i).pipe(Ue(g=>null===g?null:[new xa(l,g)]))}))}}function tte(n){const t=n.value.routeConfig;return t&&""===t.path&&void 0===t.redirectTo}function mP(n){const t=[],e=new Set;for(const r of n){if(!tte(r)){t.push(r);continue}const s=t.find(i=>r.value.routeConfig===i.value.routeConfig);void 0!==s?(s.children.push(...r.children),e.add(s)):t.push(r)}for(const r of e){const s=mP(r.children);t.push(new xa(r.value,s))}return t.filter(r=>!e.has(r))}function gP(n){let t=n;for(;t._sourceSegment;)t=t._sourceSegment;return t}function yP(n){let t=n,e=t._segmentIndexShift??0;for(;t._sourceSegment;)t=t._sourceSegment,e+=t._segmentIndexShift??0;return e-1}function bP(n){return n.data||{}}function _P(n){return n.resolve||{}}function vP(n){return"string"==typeof n.title||null===n.title}function kS(n){return ss(t=>{const e=n(t);return e?Tn(e).pipe(Ue(()=>t)):Ae(t)})}class cte{constructor(t){this.router=t,this.currentNavigation=null}setupNavigations(t){const e=this.router.events;return t.pipe(or(r=>0!==r.id),Ue(r=>({...r,extractedUrl:this.router.urlHandlingStrategy.extract(r.rawUrl)})),ss(r=>{let s=!1,i=!1;return Ae(r).pipe(ar(o=>{this.currentNavigation={id:o.id,initialUrl:o.rawUrl,extractedUrl:o.extractedUrl,trigger:o.source,extras:o.extras,previousNavigation:this.router.lastSuccessfulNavigation?{...this.router.lastSuccessfulNavigation,previousNavigation:null}:null}}),ss(o=>{const a=this.router.browserUrlTree.toString(),l=!this.router.navigated||o.extractedUrl.toString()!==a||a!==this.router.currentUrlTree.toString();if(("reload"===this.router.onSameUrlNavigation||l)&&this.router.urlHandlingStrategy.shouldProcessUrl(o.rawUrl))return wP(o.source)&&(this.router.browserUrlTree=o.extractedUrl),Ae(o).pipe(ss(u=>{const d=this.router.transitions.getValue();return e.next(new gS(u.id,this.router.serializeUrl(u.extractedUrl),u.source,u.restoredState)),d!==this.router.transitions.getValue()?ta:Promise.resolve(u)}),function Kee(n,t,e,r){return ss(s=>function Gee(n,t,e,r,s){return new qee(n,t,e,r,s).apply()}(n,t,e,s.extractedUrl,r).pipe(Ue(i=>({...s,urlAfterRedirects:i}))))}(this.router.ngModule.injector,this.router.configLoader,this.router.urlSerializer,this.router.config),ar(u=>{this.currentNavigation={...this.currentNavigation,finalUrl:u.urlAfterRedirects},r.urlAfterRedirects=u.urlAfterRedirects}),function rte(n,t,e,r,s){return yr(i=>function Zee(n,t,e,r,s,i,o="emptyOnly"){return new Qee(n,t,e,r,s,o,i).recognize().pipe(ss(a=>null===a?function Yee(n){return new Dn(t=>t.error(n))}(new Xee):Ae(a)))}(n,t,e,i.urlAfterRedirects,r.serialize(i.urlAfterRedirects),r,s).pipe(Ue(o=>({...i,targetSnapshot:o}))))}(this.router.ngModule.injector,this.router.rootComponentType,this.router.config,this.router.urlSerializer,this.router.paramsInheritanceStrategy),ar(u=>{if(r.targetSnapshot=u.targetSnapshot,"eager"===this.router.urlUpdateStrategy){if(!u.extras.skipLocationChange){const h=this.router.urlHandlingStrategy.merge(u.urlAfterRedirects,u.rawUrl);this.router.setBrowserUrl(h,u)}this.router.browserUrlTree=u.urlAfterRedirects}const d=new KJ(u.id,this.router.serializeUrl(u.extractedUrl),this.router.serializeUrl(u.urlAfterRedirects),u.targetSnapshot);e.next(d)}));if(l&&this.router.rawUrlTree&&this.router.urlHandlingStrategy.shouldProcessUrl(this.router.rawUrlTree)){const{id:d,extractedUrl:h,source:f,restoredState:p,extras:m}=o,g=new gS(d,this.router.serializeUrl(h),f,p);e.next(g);const y=Y$(h,this.router.rootComponentType).snapshot;return Ae(r={...o,targetSnapshot:y,urlAfterRedirects:h,extras:{...m,skipLocationChange:!1,replaceUrl:!1}})}return this.router.rawUrlTree=o.rawUrl,o.resolve(null),ta}),ar(o=>{const a=new XJ(o.id,this.router.serializeUrl(o.extractedUrl),this.router.serializeUrl(o.urlAfterRedirects),o.targetSnapshot);this.router.triggerEvent(a)}),Ue(o=>r={...o,guards:_ee(o.targetSnapshot,o.currentSnapshot,this.router.rootContexts)}),function Nee(n,t){return yr(e=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:i,canDeactivateChecks:o}}=e;return 0===o.length&&0===i.length?Ae({...e,guardsResult:!0}):function Aee(n,t,e,r){return Tn(n).pipe(yr(s=>function Pee(n,t,e,r,s){const i=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return i&&0!==i.length?Ae(i.map(a=>{const l=If(t)??s,c=Qu(a,l);return tl(function Dee(n){return n&&Tf(n.canDeactivate)}(c)?c.canDeactivate(n,t,e,r):l.runInContext(()=>c(n,t,e,r))).pipe(Ja())})).pipe(Ju()):Ae(!0)}(s.component,s.route,e,t,r)),Ja(s=>!0!==s,!0))}(o,r,s,n).pipe(yr(a=>a&&function Cee(n){return"boolean"==typeof n}(a)?function Ree(n,t,e,r){return Tn(t).pipe(el(s=>gf(function Fee(n,t){return null!==n&&t&&t(new tee(n)),Ae(!0)}(s.route.parent,r),function Mee(n,t){return null!==n&&t&&t(new ree(n)),Ae(!0)}(s.route,r),function $ee(n,t,e){const r=t[t.length-1],i=t.slice(0,t.length-1).reverse().map(o=>function vee(n){const t=n.routeConfig?n.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:n,guards:t}:null}(o)).filter(o=>null!==o).map(o=>wy(()=>Ae(o.guards.map(l=>{const c=If(o.node)??e,u=Qu(l,c);return tl(function Eee(n){return n&&Tf(n.canActivateChild)}(u)?u.canActivateChild(r,n):c.runInContext(()=>u(r,n))).pipe(Ja())})).pipe(Ju())));return Ae(i).pipe(Ju())}(n,s.path,e),function Oee(n,t,e){const r=t.routeConfig?t.routeConfig.canActivate:null;if(!r||0===r.length)return Ae(!0);const s=r.map(i=>wy(()=>{const o=If(t)??e,a=Qu(i,o);return tl(function Iee(n){return n&&Tf(n.canActivate)}(a)?a.canActivate(t,n):o.runInContext(()=>a(t,n))).pipe(Ja())}));return Ae(s).pipe(Ju())}(n,s.route,e))),Ja(s=>!0!==s,!0))}(r,i,n,t):Ae(a)),Ue(a=>({...e,guardsResult:a})))})}(this.router.ngModule.injector,o=>this.router.triggerEvent(o)),ar(o=>{if(r.guardsResult=o.guardsResult,yc(o.guardsResult))throw eP(0,o.guardsResult);const a=new YJ(o.id,this.router.serializeUrl(o.extractedUrl),this.router.serializeUrl(o.urlAfterRedirects),o.targetSnapshot,!!o.guardsResult);this.router.triggerEvent(a)}),or(o=>!!o.guardsResult||(this.router.restoreHistory(o),this.router.cancelNavigationTransition(o,"",3),!1)),kS(o=>{if(o.guards.canActivateChecks.length)return Ae(o).pipe(ar(a=>{const l=new ZJ(a.id,this.router.serializeUrl(a.extractedUrl),this.router.serializeUrl(a.urlAfterRedirects),a.targetSnapshot);this.router.triggerEvent(l)}),ss(a=>{let l=!1;return Ae(a).pipe(function ste(n,t){return yr(e=>{const{targetSnapshot:r,guards:{canActivateChecks:s}}=e;if(!s.length)return Ae(e);let i=0;return Tn(s).pipe(el(o=>function ite(n,t,e,r){const s=n.routeConfig,i=n._resolve;return void 0!==s?.title&&!vP(s)&&(i[yf]=s.title),function ote(n,t,e,r){const s=function ate(n){return[...Object.keys(n),...Object.getOwnPropertySymbols(n)]}(n);if(0===s.length)return Ae({});const i={};return Tn(s).pipe(yr(o=>function lte(n,t,e,r){const s=If(t)??r,i=Qu(n,s);return tl(i.resolve?i.resolve(t,e):s.runInContext(()=>i(t,e)))}(n[o],t,e,r).pipe(Ja(),ar(a=>{i[o]=a}))),cS(1),D$(i),Fi(o=>ES(o)?ta:Gu(o)))}(i,n,t,r).pipe(Ue(o=>(n._resolvedData=o,n.data=Z$(n,e).resolve,s&&vP(s)&&(n.data[yf]=s.title),null)))}(o.route,r,n,t)),ar(()=>i++),cS(1),yr(o=>i===s.length?Ae(e):ta))})}(this.router.paramsInheritanceStrategy,this.router.ngModule.injector),ar({next:()=>l=!0,complete:()=>{l||(this.router.restoreHistory(a),this.router.cancelNavigationTransition(a,"",2))}}))}),ar(a=>{const l=new QJ(a.id,this.router.serializeUrl(a.extractedUrl),this.router.serializeUrl(a.urlAfterRedirects),a.targetSnapshot);this.router.triggerEvent(l)}))}),kS(o=>{const a=l=>{const c=[];l.routeConfig?.loadComponent&&!l.routeConfig._loadedComponent&&c.push(this.router.configLoader.loadComponent(l.routeConfig).pipe(ar(u=>{l.component=u}),Ue(()=>{})));for(const u of l.children)c.push(...a(u));return c};return aS(a(o.targetSnapshot.root)).pipe(Cy(),$n(1))}),kS(()=>this.router.afterPreactivation()),Ue(o=>{const a=function lee(n,t,e){const r=Cf(n,t._root,e?e._root:void 0);return new X$(r,t)}(this.router.routeReuseStrategy,o.targetSnapshot,o.currentRouterState);return r={...o,targetRouterState:a}}),ar(o=>{this.router.currentUrlTree=o.urlAfterRedirects,this.router.rawUrlTree=this.router.urlHandlingStrategy.merge(o.urlAfterRedirects,o.rawUrl),this.router.routerState=o.targetRouterState,"deferred"===this.router.urlUpdateStrategy&&(o.extras.skipLocationChange||this.router.setBrowserUrl(this.router.rawUrlTree,o),this.router.browserUrlTree=o.urlAfterRedirects)}),((n,t,e)=>Ue(r=>(new bee(t,r.targetRouterState,r.currentRouterState,e).activate(n),r)))(this.router.rootContexts,this.router.routeReuseStrategy,o=>this.router.triggerEvent(o)),ar({next(){s=!0},complete(){s=!0}}),Sy(()=>{s||i||this.router.cancelNavigationTransition(r,"",1),this.currentNavigation?.id===r.id&&(this.currentNavigation=null)}),Fi(o=>{if(i=!0,rP(o)){nP(o)||(this.router.navigated=!0,this.router.restoreHistory(r,!0));const a=new Ry(r.id,this.router.serializeUrl(r.extractedUrl),o.message,o.cancellationCode);if(e.next(a),nP(o)){const l=this.router.urlHandlingStrategy.merge(o.url,this.router.rawUrlTree),c={skipLocationChange:r.extras.skipLocationChange,replaceUrl:"eager"===this.router.urlUpdateStrategy||wP(r.source)};this.router.scheduleNavigation(l,"imperative",null,c,{resolve:r.resolve,reject:r.reject,promise:r.promise})}else r.resolve(!1)}else{this.router.restoreHistory(r,!0);const a=new G$(r.id,this.router.serializeUrl(r.extractedUrl),o,r.targetSnapshot??void 0);e.next(a);try{r.resolve(this.router.errorHandler(o))}catch(l){r.reject(l)}}return ta}))}))}}function wP(n){return"imperative"!==n}let CP=(()=>{class n{buildTitle(e){let r,s=e.root;for(;void 0!==s;)r=this.getResolvedTitleForRoute(s)??r,s=s.children.find(i=>i.outlet===bt);return r}getResolvedTitleForRoute(e){return e.data[yf]}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:function(){return Bt(ute)},providedIn:"root"}),n})(),ute=(()=>{class n extends CP{constructor(e){super(),this.title=e}updateTitle(e){const r=this.buildTitle(e);void 0!==r&&this.title.setTitle(r)}}return n.\u0275fac=function(e){return new(e||n)(Z(m$))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),dte=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:function(){return Bt(fte)},providedIn:"root"}),n})();class hte{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}let fte=(()=>{class n extends hte{}return n.\u0275fac=function(){let t;return function(r){return(t||(t=nr(n)))(r||n)}}(),n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const zy=new me("",{providedIn:"root",factory:()=>({})}),ed=new me("ROUTES");let NS=(()=>{class n{constructor(e,r){this.injector=e,this.compiler=r,this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap}loadComponent(e){if(this.componentLoaders.get(e))return this.componentLoaders.get(e);if(e._loadedComponent)return Ae(e._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(e);const r=tl(e.loadComponent()).pipe(Ue(IP),ar(i=>{this.onLoadEndListener&&this.onLoadEndListener(e),e._loadedComponent=i}),Sy(()=>{this.componentLoaders.delete(e)})),s=new w$(r,()=>new It).pipe(lS());return this.componentLoaders.set(e,s),s}loadChildren(e,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return Ae({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);const i=this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(Ue(a=>{this.onLoadEndListener&&this.onLoadEndListener(r);let l,c,u=!1;Array.isArray(a)?c=a:(l=a.create(e).injector,c=k$(l.get(ed,[],qe.Self|qe.Optional)));return{routes:c.map(IS),injector:l}}),Sy(()=>{this.childrenLoaders.delete(r)})),o=new w$(i,()=>new It).pipe(lS());return this.childrenLoaders.set(r,o),o}loadModuleFactoryOrRoutes(e){return tl(e()).pipe(Ue(IP),yr(s=>s instanceof sO||Array.isArray(s)?Ae(s):Tn(this.compiler.compileModuleAsync(s))))}}return n.\u0275fac=function(e){return new(e||n)(Z(vr),Z(CC))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function IP(n){return function gte(n){return n&&"object"==typeof n&&"default"in n}(n)?n.default:n}let yte=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:function(){return Bt(bte)},providedIn:"root"}),n})(),bte=(()=>{class n{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,r){return e}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function _te(n){throw n}function vte(n,t,e){return t.parse("/")}const xte={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},wte={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};function DP(){const n=Bt($$),t=Bt(Sf),e=Bt(sy),r=Bt(vr),s=Bt(CC),i=Bt(ed,{optional:!0})??[],o=Bt(zy,{optional:!0})??{},a=new is(null,n,t,e,r,s,k$(i));return function Cte(n,t){n.errorHandler&&(t.errorHandler=n.errorHandler),n.malformedUriErrorHandler&&(t.malformedUriErrorHandler=n.malformedUriErrorHandler),n.onSameUrlNavigation&&(t.onSameUrlNavigation=n.onSameUrlNavigation),n.paramsInheritanceStrategy&&(t.paramsInheritanceStrategy=n.paramsInheritanceStrategy),n.urlUpdateStrategy&&(t.urlUpdateStrategy=n.urlUpdateStrategy),n.canceledNavigationResolution&&(t.canceledNavigationResolution=n.canceledNavigationResolution)}(o,a),a}let is=(()=>{class n{constructor(e,r,s,i,o,a,l){this.rootComponentType=e,this.urlSerializer=r,this.rootContexts=s,this.location=i,this.config=l,this.lastSuccessfulNavigation=null,this.disposed=!1,this.navigationId=0,this.currentPageId=0,this.isNgZoneEnabled=!1,this.events=new It,this.errorHandler=_te,this.malformedUriErrorHandler=vte,this.navigated=!1,this.lastSuccessfulId=-1,this.afterPreactivation=()=>Ae(void 0),this.urlHandlingStrategy=Bt(yte),this.routeReuseStrategy=Bt(dte),this.titleStrategy=Bt(CP),this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.canceledNavigationResolution="replace",this.navigationTransitions=new cte(this),this.configLoader=o.get(NS),this.configLoader.onLoadEndListener=h=>this.triggerEvent(new eee(h)),this.configLoader.onLoadStartListener=h=>this.triggerEvent(new JJ(h)),this.ngModule=o.get(uc),this.console=o.get(Q7);const d=o.get(ft);this.isNgZoneEnabled=d instanceof ft&&ft.isInAngularZone(),this.resetConfig(l),this.currentUrlTree=new mc,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=Y$(this.currentUrlTree,this.rootComponentType),this.transitions=new li({id:0,targetPageId:0,currentUrlTree:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.navigationTransitions.setupNavigations(this.transitions),this.processNavigations()}get browserPageId(){return this.location.getState()?.\u0275routerPageId}resetRootComponentType(e){this.rootComponentType=e,this.routerState.root.component=this.rootComponentType}setTransition(e){this.transitions.next({...this.transitions.value,...e})}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const r="popstate"===e.type?"popstate":"hashchange";"popstate"===r&&setTimeout(()=>{const s={replaceUrl:!0},i=e.state?.navigationId?e.state:null;if(e.state){const a={...e.state};delete a.navigationId,delete a.\u0275routerPageId,0!==Object.keys(a).length&&(s.state=a)}const o=this.parseUrl(e.url);this.scheduleNavigation(o,r,i,s)},0)}))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}triggerEvent(e){this.events.next(e)}resetConfig(e){this.config=e.map(IS),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,r={}){const{relativeTo:s,queryParams:i,fragment:o,queryParamsHandling:a,preserveFragment:l}=r,c=s||this.routerState.root,u=l?this.currentUrlTree.fragment:o;let d=null;switch(a){case"merge":d={...this.currentUrlTree.queryParams,...i};break;case"preserve":d=this.currentUrlTree.queryParams;break;default:d=i||null}return null!==d&&(d=this.removeEmptyProps(d)),UJ(c,this.currentUrlTree,e,d,u??null)}navigateByUrl(e,r={skipLocationChange:!1}){const s=yc(e)?e:this.parseUrl(e),i=this.urlHandlingStrategy.merge(s,this.rawUrlTree);return this.scheduleNavigation(i,"imperative",null,r)}navigate(e,r={skipLocationChange:!1}){return function Ste(n){for(let t=0;t<n.length;t++){if(null==n[t])throw new te(4008,!1)}}(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let r;try{r=this.urlSerializer.parse(e)}catch(s){r=this.malformedUriErrorHandler(s,this.urlSerializer,e)}return r}isActive(e,r){let s;if(s=!0===r?{...xte}:!1===r?{...wte}:r,yc(e))return R$(this.currentUrlTree,e,s);const i=this.parseUrl(e);return R$(this.currentUrlTree,i,s)}removeEmptyProps(e){return Object.keys(e).reduce((r,s)=>{const i=e[s];return null!=i&&(r[s]=i),r},{})}processNavigations(){this.navigations.subscribe(e=>{this.navigated=!0,this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId,this.events.next(new bc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.getCurrentNavigation(),this.titleStrategy?.updateTitle(this.routerState.snapshot),e.resolve(!0)},e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)})}scheduleNavigation(e,r,s,i,o){if(this.disposed)return Promise.resolve(!1);let a,l,c;o?(a=o.resolve,l=o.reject,c=o.promise):c=new Promise((h,f)=>{a=h,l=f});const u=++this.navigationId;let d;return"computed"===this.canceledNavigationResolution?(0===this.currentPageId&&(s=this.location.getState()),d=s&&s.\u0275routerPageId?s.\u0275routerPageId:i.replaceUrl||i.skipLocationChange?this.browserPageId??0:(this.browserPageId??0)+1):d=0,this.setTransition({id:u,targetPageId:d,source:r,restoredState:s,currentUrlTree:this.currentUrlTree,rawUrl:e,extras:i,resolve:a,reject:l,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(h=>Promise.reject(h))}setBrowserUrl(e,r){const s=this.urlSerializer.serialize(e),i={...r.extras.state,...this.generateNgRouterState(r.id,r.targetPageId)};this.location.isCurrentPathEqualTo(s)||r.extras.replaceUrl?this.location.replaceState(s,"",i):this.location.go(s,"",i)}restoreHistory(e,r=!1){if("computed"===this.canceledNavigationResolution){const s=this.currentPageId-e.targetPageId;"popstate"!==e.source&&"eager"!==this.urlUpdateStrategy&&this.currentUrlTree!==this.getCurrentNavigation()?.finalUrl||0===s?this.currentUrlTree===this.getCurrentNavigation()?.finalUrl&&0===s&&(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree()):this.location.historyGo(s)}else"replace"===this.canceledNavigationResolution&&(r&&this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}cancelNavigationTransition(e,r,s){const i=new Ry(e.id,this.serializeUrl(e.extractedUrl),r,s);this.triggerEvent(i),e.resolve(!1)}generateNgRouterState(e,r){return"computed"===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}}return n.\u0275fac=function(e){Lh()},n.\u0275prov=we({token:n,factory:function(){return DP()},providedIn:"root"}),n})();class TP{}let Dte=(()=>{class n{constructor(e,r,s,i,o){this.router=e,this.injector=s,this.preloadingStrategy=i,this.loader=o}setUpPreloading(){this.subscription=this.router.events.pipe(or(e=>e instanceof bc),el(()=>this.preload())).subscribe(()=>{})}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,r){const s=[];for(const i of r){i.providers&&!i._injector&&(i._injector=jg(i.providers,e,`Route: ${i.path}`));const o=i._injector??e,a=i._loadedInjector??o;i.loadChildren&&!i._loadedRoutes&&void 0===i.canLoad||i.loadComponent&&!i._loadedComponent?s.push(this.preloadConfig(o,i)):(i.children||i._loadedRoutes)&&s.push(this.processRoutes(a,i.children??i._loadedRoutes))}return Tn(s).pipe(tu())}preloadConfig(e,r){return this.preloadingStrategy.preload(r,()=>{let s;s=r.loadChildren&&void 0===r.canLoad?this.loader.loadChildren(e,r):Ae(null);const i=s.pipe(yr(o=>null===o?Ae(void 0):(r._loadedRoutes=o.routes,r._loadedInjector=o.injector,this.processRoutes(o.injector??e,o.routes))));return r.loadComponent&&!r._loadedComponent?Tn([i,this.loader.loadComponent(r)]).pipe(tu()):i})}}return n.\u0275fac=function(e){return new(e||n)(Z(is),Z(CC),Z(qa),Z(TP),Z(NS))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const RS=new me("");let kP=(()=>{class n{constructor(e,r,s,i={}){this.router=e,this.viewportScroller=r,this.zone=s,this.options=i,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},i.scrollPositionRestoration=i.scrollPositionRestoration||"disabled",i.anchorScrolling=i.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(e=>{e instanceof gS?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof bc&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.router.parseUrl(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(e=>{e instanceof q$&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,r){this.zone.runOutsideAngular(()=>{setTimeout(()=>{this.zone.run(()=>{this.router.triggerEvent(new q$(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,r))})},0)})}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return n.\u0275fac=function(e){Lh()},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();function nd(n,t){return{\u0275kind:n,\u0275providers:t}}function AP(){const n=Bt(vr);return t=>{const e=n.get(Wu);if(t!==e.components[0])return;const r=n.get(is),s=n.get(RP);1===n.get(FS)&&r.initialNavigation(),n.get(MP,null,qe.Optional)?.setUpPreloading(),n.get(RS,null,qe.Optional)?.init(),r.resetRootComponentType(e.componentTypes[0]),s.closed||(s.next(),s.unsubscribe())}}const RP=new me("",{factory:()=>new It}),FS=new me("",{providedIn:"root",factory:()=>1});const MP=new me("");function Rte(n){return nd(0,[{provide:MP,useExisting:Dte},{provide:TP,useExisting:n}])}const FP=new me("ROUTER_FORROOT_GUARD"),Mte=[sy,{provide:$$,useClass:uS},{provide:is,useFactory:DP},Sf,{provide:Zu,useFactory:function NP(n){return n.routerState.root},deps:[is]},NS,[]];function Fte(){return new t2("Router",is)}let OP=(()=>{class n{constructor(e){}static forRoot(e,r){return{ngModule:n,providers:[Mte,[],{provide:ed,multi:!0,useValue:e},{provide:FP,useFactory:Lte,deps:[[is,new Ga,new vu]]},{provide:zy,useValue:r||{}},r?.useHash?{provide:hc,useClass:B9}:{provide:hc,useClass:I2},{provide:RS,useFactory:()=>{const n=Bt(is),t=Bt(rQ),e=Bt(ft),r=Bt(zy);return r.scrollOffset&&t.setOffset(r.scrollOffset),new kP(n,t,e,r)}},r?.preloadingStrategy?Rte(r.preloadingStrategy).\u0275providers:[],{provide:t2,multi:!0,useFactory:Fte},r?.initialNavigation?Bte(r):[],[{provide:$P,useFactory:AP},{provide:KO,multi:!0,useExisting:$P}]]}}static forChild(e){return{ngModule:n,providers:[{provide:ed,multi:!0,useValue:e}]}}}return n.\u0275fac=function(e){return new(e||n)(Z(FP,8))},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({imports:[CS]}),n})();function Lte(n){return"guarded"}function Bte(n){return["disabled"===n.initialNavigation?nd(3,[{provide:Yg,multi:!0,useFactory:()=>{const t=Bt(is);return()=>{t.setUpLocationChangeListener()}}},{provide:FS,useValue:2}]).\u0275providers:[],"enabledBlocking"===n.initialNavigation?nd(2,[{provide:FS,useValue:0},{provide:Yg,multi:!0,deps:[vr],useFactory:t=>{const e=t.get(P9,Promise.resolve());return()=>e.then(()=>new Promise(s=>{const i=t.get(is),o=t.get(RP);(function r(s){t.get(is).events.pipe(or(o=>o instanceof bc||o instanceof Ry||o instanceof G$),Ue(o=>o instanceof bc||o instanceof Ry&&(0===o.code||1===o.code)&&null),or(o=>null!==o),$n(1)).subscribe(()=>{s()})})(()=>{s(!0)}),i.afterPreactivation=()=>(s(!0),o.closed?Ae(void 0):o),i.initialNavigation()}))}}]).\u0275providers:[]]}const $P=new me(""),zte=[];class Uy{static#e=this.\u0275fac=function(e){return new(e||Uy)};static#t=this.\u0275mod=Zt({type:Uy});static#n=this.\u0275inj=Gt({imports:[OP.forRoot(zte),OP]})}function PP(n,t,e,r,s,i,o){try{var a=n[i](o),l=a.value}catch(c){return void e(c)}a.done?t(l):Promise.resolve(l).then(r,s)}function ee(n){return function(){var t=this,e=arguments;return new Promise(function(r,s){var i=n.apply(t,e);function o(l){PP(i,r,s,o,a,"next",l)}function a(l){PP(i,r,s,o,a,"throw",l)}o(void 0)})}}class LP{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class OS{refCount(t){return Bs("refCount")}incRef(t){return Bs("incRef")}timerAvailable(){return!0}time(t){return Bs("time")}read(t){return Bs("read")}readSync(t){return Bs("readSync")}readToGPU(t,e){return Bs("readToGPU")}numDataIds(){return Bs("numDataIds")}disposeData(t,e){return Bs("disposeData")}write(t,e,r){return Bs("write")}move(t,e,r,s,i){return Bs("move")}createTensorFromTexture(t,e,r){return Bs("createTensorFromTexture")}memory(){return Bs("memory")}floatPrecision(){return Bs("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Bs("dispose")}}function Bs(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function BP(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,nl(n,t,e)}function _c(n,t,e){return Math.max(n,Math.min(t,e))}function $S(n){return n%2==0?n:n+1}function nl(n,t,e){const r=n[t];n[t]=n[e],n[e]=r}function S(n,t){if(!n)throw new Error("string"==typeof t?t:t())}function Vs(n,t,e=""){S(Rt(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function rd(n){S(null!=n,()=>"The input to the tensor constructor must be a non-null value.")}function sd(n,t=[],e=!1){if(null==t&&(t=[]),Array.isArray(n)||Oo(n)&&!e)for(let r=0;r<n.length;++r)sd(n[r],t,e);else t.push(n);return t}function X(n){if(0===n.length)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function Rt(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function id(n){return n%1==0}function PS(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function od(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function VP(n,t=(s=>0),e,r){return new Promise((s,i)=>{let o=0;const a=()=>{if(n())return void s();o++;const l=t(o);null!=e&&o>=e?i():null!=r?r(a,l):setTimeout(a,l)};a()})}function zP(n,t){let e=1,r=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)e*=n[i];else if(-1===n[i]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(-1===r){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(0===e)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const s=n.slice();return s[r]=t/e,s}function mt(n,t){const e=t.length;return S((n=null==n?t.map((r,s)=>s):[].concat(n)).every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),S(n.every(r=>id(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?e+r:r)}function rl(n,t){const e=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||s?null:mt(t,n).sort();let o=0;for(let a=0;a<n.length;++a){if(null!=i){if(i[o]===a&&1!==n[a])throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(null==i[o]||i[o]>a)&&1===n[a]&&(e.push(n[a]),r.push(a)),i[o]<=a&&o++}1!==n[a]&&(e.push(n[a]),r.push(a))}return{newShape:e,keptDims:r}}function Sr(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);e=new Uint8Array(t)}return e}function Zn(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else if("bool"===n)e=new Uint8Array(t);else{if("string"!==n)throw new Error(`Unknown data type ${n}`);e=new Array(t)}return e}function UP(n,t){return!("complex64"===t||"float32"===t&&"complex64"!==n||"int32"===t&&"float32"!==n&&"complex64"!==n||"bool"===t&&"bool"===n)}function Oo(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function LS(n){if("float32"===n||"int32"===n)return 4;if("complex64"===n)return 8;if("bool"===n)return 1;throw new Error(`Unknown dtype ${n}`)}function Af(n){return"string"==typeof n||n instanceof String}function BS(n){return"number"==typeof n}function Rf(n){return Array.isArray(n)?Rf(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":BS(n)?"float32":Af(n)?"string":function Kte(n){return"boolean"==typeof n}(n)?"bool":"float32"}function VS(n){return!!(n&&n.constructor&&n.call&&n.apply)}function zS(n,t){for(let e=t;e<n;++e)if(n%e==0)return e;return n}function Le(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let r=t-3;r>=0;--r)e[r]=e[r+1]*n[r+1];return e}function HP(n,t,e,r=!1){const s=new Array;if(1===t.length){const i=t[0]*(r?2:1);for(let o=0;o<i;o++)s[o]=e[n+o]}else{const i=t[0],o=t.slice(1),a=o.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<i;l++)s[l]=HP(n+l*a,o,e,r)}return s}function $i(n,t,e=!1){if(0===n.length)return t[0];const r=n.reduce((s,i)=>s*i)*(e?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return HP(0,n,t,e)}function US(n,t){const e=jr(n,t);for(let r=0;r<e.length;r++)e[r]=1;return e}function jr(n,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t)return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function WP(n,t){const e=n.reduce((r,s)=>r*s,1);if(null==t||"float32"===t)return $i(n,new Float32Array(e));if("int32"===t)return $i(n,new Int32Array(e));if("bool"===t)return $i(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function ci(n){n.forEach(t=>{S(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function $o(n,t,e){if(0===t)return 0;if(1===t)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=e[s]*n[s];return r}function ad(n,t,e){if(0===t)return[];if(1===t)return[n];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/e[s]),n-=r[s]*e[s];return r[r.length-1]=n,r}function ld(n){return n&&n.then&&"function"==typeof n.then}const jP="tfjsflags";class Xte{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Yte,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},null!=this.urlFlags[t]){const s=this.urlFlags[t];G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}getAsync(t){var e=this;return ee(function*(){return t in e.flags||(e.flags[t]=yield e.evaluateFlag(t)),e.flags[t]})()}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(ld(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);jP in t&&t[jP].split(",").forEach(r=>{const[s,i]=r.split(":");this.urlFlags[s]=function Qte(n,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${n}.`)}(s,i)})}}function Yte(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(function Zte(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}(t,r[0],r[1]),r.join("="))),t}function G(){return GP}let HS,GP=null;function qP(){if(null==HS){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");n=self}HS=n}return HS}function WS(n,t){const e=function ene(){const n=qP();return null==n._tfGlobals&&(n._tfGlobals=new Map),n._tfGlobals}();if(e.has(n))return e.get(n);{const r=t();return e.set(n,r),e.get(n)}}const Hy="Abs",Mf="Acos",Ff="Acosh",cd="Add",Wy="AddN",jy="ArgMax",Gy="ArgMin",Of="Asin",$f="Asinh",Pf="Atan",Lf="Atanh",Bf="Atan2",qy="AvgPool",qS="AvgPoolGrad",Ky="AvgPool3D",KS="AvgPool3DGrad",Xy="BatchMatMul",Yy="BatchToSpaceND",XS="Bincount",YS="BroadcastArgs",Vf="Cast",zf="Ceil",Uf="ClipByValue",ZS="Complex",Zy="ComplexAbs",Qy="Concat",Jy="Conv2D",QS="Conv2DBackpropFilter",eb="Conv2DBackpropInput",tb="Conv3D",JS="Conv3DBackpropFilterV2",eI="Conv3DBackpropInputV2",Hf="Cos",Wf="Cosh",tI="Cumprod",nb="Cumsum",nI="CropAndResize",rI="DenseBincount",sI="DepthToSpace",rb="DepthwiseConv2dNative",iI="DepthwiseConv2dNativeBackpropFilter",oI="DepthwiseConv2dNativeBackpropInput",aI="Diag",sb="Dilation2D",lI="Dilation2DBackpropInput",cI="Dilation2DBackpropFilter",jf="RealDiv",uI="Einsum",Gf="Elu",dI="EluGrad",qf="Erf",ib="Equal",Kf="Exp",ob="ExpandDims",Xf="Expm1",fI="Fill",pI="FlipLeftRight",Yf="Floor",Zf="FloorDiv",ab="FusedBatchNorm",lb="GatherV2",mI="GatherNd",cb="Greater",Qf="GreaterEqual",Jf="Identity",gI="IFFT",yI="Imag",ep="IsFinite",tp="IsInf",np="IsNan",ub="LeakyRelu",db="Less",hb="LessEqual",bI="LinSpace",rp="Log",sp="Log1p",fb="LogicalAnd",pb="LogicalNot",mb="LogicalOr",gb="LRN",_I="LRNGrad",yb="Max",ip="Maximum",bb="MaxPool",vI="MaxPoolGrad",_b="MaxPool3D",xI="MaxPool3DGrad",wI="MaxPoolWithArgmax",vb="Mean",xb="Min",op="Minimum",wb="MirrorPad",ap="Mod",CI="Multinomial",lp="Multiply",Cb="Neg",Sb="NotEqual",SI="NonMaxSuppressionV3",II="NonMaxSuppressionV4",EI="NonMaxSuppressionV5",Ib="OnesLike",Eb="OneHot",Db="Pack",Tb="PadV2",cp="Pow",kb="Prelu",Nb="Prod",DI="RaggedGather",TI="RaggedRange",kI="RaggedTensorToTensor",NI="Range",AI="Real",up="Reciprocal",dp="Relu",Ab="Reshape",Rb="ResizeNearestNeighbor",RI="ResizeNearestNeighborGrad",Mb="ResizeBilinear",MI="ResizeBilinearGrad",hp="Relu6",Fb="Reverse",fp="Round",pp="Rsqrt",FI="ScatterNd",OI="SearchSorted",Ob="Select",mp="Selu",$b="Slice",gp="Sin",yp="Sinh",bp="Sign",_p="Sigmoid",vp="Softplus",xp="Sqrt",Pb="Sum",Lb="SpaceToBatchND",Bb="SplitV",Vb="Softmax",$I="SparseFillEmptyRows",PI="SparseReshape",LI="SparseSegmentMean",BI="SparseSegmentSum",VI="SparseToDense",wp="SquaredDifference",zI="Square",UI="StridedSlice",HI="StringNGrams",WI="StringSplit",jI="StringToHashBucketFast",Cp="Sub",Sp="Tan",Ip="Tanh",Ep="Tile",GI="TopK",qI="Transform",ud="Transpose",KI="Unique",zb="Unpack",Ub="UnsortedSegmentSum",Hb="ZerosLike",Dp="Step",XI="FromPixels",YI="RotateWithOffset",Wb="_FusedMatMul",jb="FusedConv2D",Gb="FusedDepthwiseConv2D";function ui(...n){G().getBool("IS_TEST")||G().getBool("PROD")||console.warn(...n)}function rne(...n){G().getBool("IS_TEST")||G().getBool("PROD")||console.log(...n)}const dd=WS("kernelRegistry",()=>new Map),Tp=WS("gradRegistry",()=>new Map);function ZI(n,t){const e=eE(n,t);return dd.get(e)}function KP(n){return Tp.get(n)}function QI(n){const t=dd.entries(),e=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[i,o]=s,[a]=i.split("_");a===n&&e.push(o)}return e}function JI(n){const{kernelName:t,backendName:e}=n,r=eE(t,e);dd.has(r)&&ui(`The kernel '${t}' for backend '${e}' is already registered`),dd.set(r,n)}function sne(n){const{kernelName:t}=n;Tp.has(t)&&G().getBool("DEBUG")&&ui(`Overriding the gradient for '${t}'`),Tp.set(t,n)}function eE(n,t){return`${t}_${n}`}var XP=Q(658);const vc=Q.n(XP)()||XP;function qb(n){return vc.fromString(n,!0,16)}const YP=qb("c3a5c85c97cb3127"),xc=qb("b492b66fbe98f273"),os=qb("9ae16a3b2f90404f");function tE(n){return n.xor(n.shru(47))}function ZP(n,t,e){const r=n.slice(t,t+e);return vc.fromBytes(Array.from(r),!0,!0)}function ln(n,t){return ZP(n,t,8)}function QP(n,t){return ZP(n,t,4)}function Ir(n,t){return 0===t?n:n.shru(t).or(n.shl(64-t))}function sl(n,t,e=qb("9ddfea08eb382d69")){let r=n.xor(t).mul(e);r=r.xor(r.shru(47));let s=t.xor(r).mul(e);return s=s.xor(s.shru(47)),s=s.mul(e),s}function Kb(n,t,e,r){return function one(n,t,e,r,s,i){s=s.add(n),i=Ir(i.add(s).add(r),21);const o=s;return s=(s=s.add(t)).add(e),i=i.add(Ir(s,44)),[s.add(r),i.add(o)]}(ln(n,t),ln(n,t+8),ln(n,t+16),ln(n,t+24),e,r)}function une(n,t=n.length){const e=vc.fromNumber(81,!0);if(t<=32)return t<=16?function ane(n,t=n.length){if(t>=8){const e=os.add(2*t),r=ln(n,0).add(os),s=ln(n,t-8);return sl(Ir(s,37).mul(e).add(r),Ir(r,25).add(s).mul(e),e)}if(t>=4){const e=os.add(2*t);return sl(QP(n,0).shl(3).add(t),QP(n,t-4),e)}if(t>0){const o=t+(n[t-1]<<2);return tE(os.mul(n[0]+(n[t>>1]<<8)).xor(YP.mul(o))).mul(os)}return os}(n,t):function lne(n,t=n.length){const e=os.add(2*t),r=ln(n,0).mul(xc),s=ln(n,8),i=ln(n,t-8).mul(e),o=ln(n,t-16).mul(os);return sl(Ir(r.add(s),43).add(Ir(i,30)).add(o),r.add(Ir(s.add(os),18)).add(i),e)}(n,t);if(t<=64)return function cne(n,t=n.length){const e=os.add(2*t),r=ln(n,0).mul(os),s=ln(n,8),i=ln(n,t-8).mul(e),o=ln(n,t-16).mul(os),a=Ir(r.add(s),43).add(Ir(i,30)).add(o),l=sl(a,r.add(Ir(s.add(os),18)).add(i),e),c=ln(n,16).mul(e),u=ln(n,24),d=a.add(ln(n,t-32)).mul(e),h=l.add(ln(n,t-24)).mul(e);return sl(Ir(c.add(u),43).add(Ir(d,30)).add(h),c.add(Ir(u.add(r),18)).add(d),e)}(n,t);let r=e,s=e.mul(xc).add(113),i=tE(s.mul(os).add(113)).mul(os),o=[vc.UZERO,vc.UZERO],a=[vc.UZERO,vc.UZERO];r=r.mul(os).add(ln(n,0));let l=0;const c=64*(t-1>>6),u=c+(t-1&63)-63;do{r=Ir(r.add(s).add(o[0]).add(ln(n,l+8)),37).mul(xc),s=Ir(s.add(o[1]).add(ln(n,l+48)),42).mul(xc),r=r.xor(a[1]),s=s.add(o[0]).add(ln(n,l+40)),i=Ir(i.add(a[0]),33).mul(xc),o=Kb(n,l,o[1].mul(xc),r.add(a[0])),a=Kb(n,l+32,i.add(a[1]),s.add(ln(n,l+16))),[i,r]=[r,i],l+=64}while(l!==c);const d=xc.add(i.and(255).shl(1));return l=u,a[0]=a[0].add(t-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),r=Ir(r.add(s).add(o[0]).add(ln(n,l+8)),37).mul(d),s=Ir(s.add(o[1]).add(ln(n,l+48)),42).mul(d),r=r.xor(a[1].mul(9)),s=s.add(o[0].mul(9).add(ln(n,l+40))),i=Ir(i.add(a[0]),33).mul(d),o=Kb(n,l,o[1].mul(d),r.add(a[0])),a=Kb(n,l+32,i.add(a[1]),s.add(ln(n,l+16))),[i,r]=[r,i],sl(sl(o[0],a[0],d).add(tE(s).mul(YP)).add(i),sl(o[1],a[1],d).add(r),d)}function il(n,t){return"string"===t?ol(n):wc([n],t)}function wc(n,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=sd(n)),G().getBool("DEBUG")&&function jte(n,t){for(let e=0;e<n.length;e++){const r=n[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(n,t),function dne(n,t){return n instanceof Float32Array&&"float32"===t||n instanceof Int32Array&&"int32"===t||n instanceof Uint8Array&&"bool"===t}(n,t))return n;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t){const e=new Uint8Array(n.length);for(let r=0;r<e.length;++r)0!==Math.round(n[r])&&(e[r]=1);return e}throw new Error(`Unknown data type ${t}`)}function Cs(){return G().platform.now()}function ol(n,t="utf-8"){return t=t||"utf-8",G().platform.encode(n,t)}function al(n,t="utf-8"){return t=t||"utf-8",G().platform.decode(n,t)}class hne{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new pne)}profileKernel(t,e,r){let s;const i=()=>{s=r()};let o;const a=Cs();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of s)c.dataSync();o=Promise.resolve({kernelMs:Cs()-a})}if(G().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<s.length;c++){const u=s[c];u.data().then(d=>{fne(d,u.dtype,t)})}return{kernelName:t,outputs:s,inputs:e,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>null!=c.getExtraProfileInfo?c.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:r,timeMs:s,inputs:i,extraInfo:o}=t;r.forEach(a=>{Promise.all([a.data(),s,o]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],i,l[2])})})}}function fne(n,t,e){if("float32"!==t)return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${e}'`),!0}return!1}class pne{logKernelProfile(t,e,r,s,i,o){const a="number"==typeof s?od(`${s}ms`,9):s.error,l=od(t,25),c=e.rank,u=e.size,d=od(e.shape.toString(),14);let h="";for(const f in i){const p=i[f];if(null!=p){const m=p.shape||e.shape,g=m.length;h+=`${f}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}\t%c${a}\t%c${c}D ${d}\t%c${u}\t%c${h}\t%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function yne(n,t,e,r){const s=Le(t),i=function bne(n,t,e,r){const s=X(t),i=r[r.length-1],o=new Array(i).fill(0),a=t.length,l="complex64"===e?Ap(n):n;if(a>1)for(let c=0;c<s/i;c++){const u=c*i;for(let d=0;d<i;d++)o[d]=Math.max(o[d],Np(l[u+d],0,e).length)}return o}(n,t,e,s),o=t.length,a=Xb(n,t,e,s,i),l=["Tensor"];return r&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join("\n")),l.join("\n")}function Np(n,t,e){let r;return r=Array.isArray(n)?`${parseFloat(n[0].toFixed(7))} + ${parseFloat(n[1].toFixed(7))}j`:Af(n)?`'${n}'`:"bool"===e?eL(n):parseFloat(n.toFixed(7)).toString(),od(r,t)}function eL(n){return 0===n?"false":"true"}function Xb(n,t,e,r,s,i=!0){const o="complex64"===e?2:1,a=t[0],l=t.length;if(0===l)return"complex64"===e?[Np(Ap(n)[0],0,e)]:"bool"===e?[eL(n[0])]:[n[0].toString()];if(1===l){if(a>20){let y=Array.from(n.slice(0,3*o)),b=Array.from(n.slice((a-3)*o,a*o));return"complex64"===e&&(y=Ap(y),b=Ap(b)),["["+y.map((_,v)=>Np(_,s[v],e)).join(", ")+", ..., "+b.map((_,v)=>Np(_,s[a-3+v],e)).join(", ")+"]"]}return["["+("complex64"===e?Ap(n):Array.from(n)).map((g,y)=>Np(g,s[y],e)).join(", ")+"]"]}const c=t.slice(1),u=r.slice(1),d=r[0]*o,h=[];if(a>20){for(let m=0;m<3;m++){const g=m*d;h.push(...Xb(n.slice(g,g+d),c,e,u,s,!1))}h.push("...");for(let m=a-3;m<a;m++){const g=m*d;h.push(...Xb(n.slice(g,g+d),c,e,u,s,m===a-1))}}else for(let m=0;m<a;m++){const g=m*d;h.push(...Xb(n.slice(g,g+d),c,e,u,s,m===a-1))}const f=2===l?",":"";h[0]="["+h[0]+f;for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+f;let p=",\n";for(let m=2;m<l;m++)p+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(i?"":p),h}function Ap(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class Er{constructor(t,e,r){if(this.dtype=e,this.shape=t.slice(),this.size=X(t),null!=r){const s=r.length;S(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Zn(e,this.size),this.strides=Le(t)}set(t,...e){0===e.length&&(e=[0]),S(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const r=this.locToIndex(e);this.values[r]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const s of t){if(s<0||s>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return po().makeTensor(this.values,this.shape,this.dtype)}}let po=null,hd=null,tL=null;class bn{constructor(t,e,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=X(t),this.strides=Le(t),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var t=this;return ee(function*(){const e=yield t.data();return hd.buffer(t.shape,t.dtype,e)})()}bufferSync(){return hd.buffer(this.shape,this.dtype,this.dataSync())}array(){var t=this;return ee(function*(){const e=yield t.data();return $i(t.shape,e,"complex64"===t.dtype)})()}arraySync(){return $i(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var t=this;return ee(function*(){t.throwIfDisposed();const e=po().read(t.dataId);if("string"===t.dtype){const r=yield e;try{return r.map(s=>al(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataToGPU(t){return this.throwIfDisposed(),po().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=po().readSync(this.dataId);if("string"===this.dtype)try{return t.map(e=>al(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){var t=this;return ee(function*(){t.throwIfDisposed();const e=yield po().read(t.dataId);return"string"===t.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(po().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return hd.print(this,t)}clone(){return this.throwIfDisposed(),hd.clone(this)}toString(t=!1){return yne(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),hd.cast(this,t)}variable(t=!0,e,r){return this.throwIfDisposed(),po().makeVariable(this,t,e,r)}}function Y(){return WS("Tensor",()=>bn)}Object.defineProperty(bn,Symbol.hasInstance,{value:n=>!!n&&null!=n.data&&null!=n.dataSync&&null!=n.throwIfDisposed}),Y();class Yb extends bn{constructor(t,e,r,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=e,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Rt(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);po().disposeTensor(this),this.dataId=t.dataId,po().incRef(this,null)}dispose(){po().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Yb,Symbol.hasInstance,{value:n=>n instanceof bn&&null!=n.assign&&n.assign instanceof Function});var Zb=(()=>{return(n=Zb||(Zb={})).float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64",Zb;var n})(),Qb=(()=>{return(n=Qb||(Qb={})).float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64",Qb;var n})(),Jb=(()=>{return(n=Jb||(Jb={})).float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64",Jb;var n})(),e_=(()=>{return(n=e_||(e_={})).float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64",e_;var n})();const wne={float32:Jb,int32:Zb,bool:Qb,complex64:e_};function zs(n,t){if("string"===n||"string"===t){if("string"===n&&"string"===t)return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return wne[n][t]}function rE(n){return zs(n,"int32")}function Pn(n,t){if(n.dtype===t.dtype)return[n,t];const e=zs(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function nL(n){const t=[];return rL(n,t,new Set),t}function rL(n,t,e){if(null==n)return;if(n instanceof bn)return void t.push(n);if(!function Sne(n){return Array.isArray(n)||"object"==typeof n}(n))return;const r=n;for(const s in r){const i=r[s];e.has(i)||(e.add(i),rL(i,t,e))}}function sE(n){return null!=n.kernelName}class sL{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}let Ine=(()=>{class n{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new sL}ready(){var e=this;return ee(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const r=e.getSortedBackends();for(let s=0;s<r.length;s++){const i=r[s];if(yield e.initializeBackend(i).success)return void(yield e.setBackend(i))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:r}=this.initializeBackend(e);if(r)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,s=1){return e in this.registryFactory?(ui(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:s},!0)}setBackend(e){var r=this;return ee(function*(){if(null==r.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(r.backendName=e,null==r.registry[e]){r.backendInstance=null;const{success:s,asyncInit:i}=r.initializeBackend(e);if(!(i?yield s:s))return!1}return r.backendInstance=r.registry[e],r.setupRegisteredKernels(),r.profiler=new hne(r.backendInstance),!0})()}setupRegisteredKernels(){QI(this.backendName).forEach(r=>{null!=r.setupFunc&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){QI(e).forEach(s=>{null!=s.disposeFunc&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const r=this.registryFactory[e];if(null==r)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=r.factory();if(!s||s instanceof OS||"function"!=typeof s.then)return this.registry[e]=s,{success:!0,asyncInit:!1};{const i=++this.pendingBackendInitId,o=s.then(a=>!(i<this.pendingBackendInitId||(this.registry[e]=a,this.pendingBackendInit=null,0))).catch(a=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,ui(`Initialization of backend ${e} failed`),ui(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}}catch(s){return ui(`Initialization of backend ${e} failed`),ui(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let r=0;r<e.length;r++){const s=e[r],{success:i,asyncInit:o}=this.initializeBackend(s);if(o||i)return{name:s,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){const s=this.state.tensorInfo.get(r),i=s.backend,o=this.readSync(r),a=i.refCount(r);i.disposeData(r,!0),s.backend=e,e.move(r,o,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let i,s=null;if(null==r){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");r=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof r)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun(()=>this.startScope(s),()=>this.endScope(i),()=>(i=r(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,r,s){e();try{const i=s();return r(),i}catch(i){throw r(),i}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(e){const r=R.runKernel(Jf,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[r],a=>({x:()=>R.runKernel(Vf,{x:a},{dtype:"float32"})}),[],{}),r}runKernel(e,r,s){if(null==ZI(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,s){const i=this.backend.numDataIds();let o=0;s.forEach(c=>{o+="complex64"===c.dtype?3:1});const l=i-r-o-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let r,s=[];const i=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;let l,c;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const u=sE(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(sE(e)){const{kernelName:m,inputs:g,attrs:y}=e,b=ZI(m,this.backendName);S(null!=b,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),l=()=>{const _=this.backend.numDataIds();c=b.kernelFunc({inputs:g,attrs:y,backend:this.backend});const v=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,_,v);const w=v.map(C=>null!=C.rank?C:this.makeTensorFromTensorInfo(C));if(i){const C=this.getTensorsForGradient(m,g,w);s=this.saveTensorsForBackwardMode(C)}return w}}else{const{forwardFunc:m}=e,g=y=>{!i||(s=y.map(b=>this.keep(this.clone(b))))};l=()=>{const y=this.backend.numDataIds();c=this.tidy(()=>m(this.backend,g));const b=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,y,b),b}}const{inputs:d,attrs:h}=e,f=sE(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(p=this.profiler.profileKernel(u,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),r=p.outputs):r=l()}),i&&this.addTapeNode(u,d,r,f,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(m=>null!=d[m]?d[m].shape:null),outputShapes:r.map(m=>m.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(c)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,r,s){const i=KP(e);if(null!=i){const o=i.inputsToSave||[],a=i.outputsToSave||[];let l;i.saveAllInputs?(S(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(r).map(u=>r[u])):l=o.map(u=>r[u]);const c=s.filter((u,d)=>a[d]);return l.concat(c)}return[]}makeTensor(e,r,s,i){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");i=i||this.backend;let o=e;"string"===(s=s||"float32")&&Af(e[0])&&(o=e.map(c=>ol(c)));const a=i.write(o,r,s),l=new bn(r,s,a,this.nextTensorId());if(this.trackTensor(l,i),"string"===s){const c=this.state.tensorInfo.get(a),u=function qte(n){if(null==n)return 0;let t=0;return n.forEach(e=>t+=e.length),t}(o);this.state.numBytes+=u-c.bytes,c.bytes=u}return l}makeTensorFromDataId(e,r,s,i){return this.makeTensorFromTensorInfo({dataId:e,shape:r,dtype:s=s||"float32"},i)}makeTensorFromTensorInfo(e,r){const{dataId:s,shape:i,dtype:o}=e,a=new bn(i,o,s,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(e,r=!0,s,i){s=s||this.nextVariableId().toString(),null!=i&&i!==e.dtype&&(e=e.cast(i));const o=new Yb(e,r,s,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,r){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let s=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(s=e.size*LS(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof Yb||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const s=e.size*LS(e.dtype);this.state.numBytes-=s}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var r=this;return ee(function*(){r.state.profiling=!0;const s=r.state.numBytes,i=r.state.numTensors;r.state.activeProfile.kernels=[],r.state.activeProfile.result=yield e(),r.state.profiling=!1,r.state.activeProfile.peakBytes=Math.max(...r.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),r.state.activeProfile.newBytes=r.state.numBytes-s,r.state.activeProfile.newTensors=r.state.numTensors-i;for(const o of r.state.activeProfile.kernels)o.kernelTimeMs=yield o.kernelTimeMs,o.extraInfo=yield o.extraInfo;return r.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,r,s,i,o,a){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:s,saved:o},c=KP(e);null!=c&&(i=c.gradFunc),null!=i&&(l.gradient=u=>(u=u.map((d,h)=>{if(null==d){const f=s[h],p=jr(f.size,f.dtype);return this.makeTensor(p,f.shape,f.dtype)}return d}),i(u.length>1?u:u[0],o,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){const r=nL(e),s=new Set(r.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const a=this.state.activeScope.track[o];!a.kept&&!s.has(a.id)&&a.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(o=>{!o.kept&&o.scopeId===i.id&&this.track(o)})}gradients(e,r,s,i=!1){if(S(r.length>0,()=>"gradients() received an empty list of xs."),null!=s&&"float32"!==s.dtype)throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));S(o instanceof bn,()=>"The result y returned by f() must be a tensor.");const a=function mne(n,t,e){const r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const d in u){const h=u[d];let f=!1;for(let p=0;p<t.length;p++)if(r[h.id]){c.outputs.forEach(m=>r[m.id]=!0),f=!0,s[c.id]=!0;break}if(f)break}}const i={};i[e.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let d=0;d<c.outputs.length;d++)if(i[c.outputs[d].id]){for(const h in u)i[u[h].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(s[c.id]&&o[c.id]){const u={};for(const h in c.inputs){const f=c.inputs[h];r[f.id]&&(u[h]=f)}const d=Object.assign({},c);d.inputs=u,d.outputs=c.outputs,a.push(d)}}return a}(this.state.activeTape,r,o);if(!i&&0===a.length&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[o.id]=s??function Ene(n){const t=US(X(n),"float32");return R.makeTensor(t,n,"float32")}(o.shape),function gne(n,t,e,r){for(let s=t.length-1;s>=0;s--){const i=t[s],o=[];if(i.outputs.forEach(l=>{const c=n[l.id];o.push(null!=c?c:null)}),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=e(()=>a[l]());if("float32"!==c.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=i.inputs[l];if(!Rt(c.shape,u.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(null==n[u.id])n[u.id]=c;else{const d=n[u.id];n[u.id]=r(d,c),d.dispose()}}}}(l,a,u=>this.tidy(u),Dne);const c=r.map(u=>l[u.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(u=>{for(const d of u.saved)d.dispose()}),this.state.activeTape=null),{value:o,grads:c}})}customGrad(e){return S(VS(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{let s;S(r.every(l=>l instanceof bn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const i={};return r.forEach((l,c)=>{i[c]=l}),this.runKernelFunc({forwardFunc:(l,c)=>(s=e(...r,c),S(s.value instanceof bn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),S(VS(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),backwardsFunc:(l,c)=>{const u=s.gradFunc(l,c),d=Array.isArray(u)?u:[u];S(d.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),S(d.every(f=>f instanceof bn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return d.forEach((f,p)=>{h[p]=()=>f}),h},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,r){return this.state.tensorInfo.get(e).backend.readToGPU(e,r)}time(e){var r=this;return ee(function*(){const s=Cs(),i=yield r.backend.time(e);return i.wallMs=Cs()-s,i})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new sL;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();function iL(){const n=qP();if(null==n._tfengine){const t=new Xte(n);n._tfengine=new Ine(t)}return function Jte(n){GP=n}(n._tfengine.ENV),function _ne(n){po=n}(()=>n._tfengine),n._tfengine}const R=iL();function Dne(n,t){return R.runKernel(cd,{a:n,b:t})}function oL(n){if(n||function Tne(){return typeof navigator<"u"&&null!=navigator}()){if(n||(n=navigator),"ReactNative"===n.product)return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function aL(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}const di=G();function ll(n,t){let e=n;if(Oo(n))return"string"===t?[]:[n.length];if("object"==typeof n&&"texture"in n)return[n.height,n.width*(n.channels||"RGBA").length];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(e)||Oo(e)&&"string"!==t;)r.push(e.length),e=e[0];return Array.isArray(n)&&G().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&lL(n,r,[]),r}function lL(n,t,e){if(e=e||[],!Array.isArray(n)&&!Oo(n))return void S(0===t.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);S(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),S(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const r=t.slice(1);for(let s=0;s<n.length;++s)lL(n[s],r,e.concat(s))}function cL(n,t,e,r){if("string_or_numeric"!==n){if(null==n)throw new Error("Expected dtype cannot be null.");if("numeric"!==n&&n!==t||"numeric"===n&&"string"===t)throw new Error(`Argument '${e}' passed to '${r}' must be ${n} tensor, but got ${t} tensor`)}}function I(n,t,e,r="numeric"){if(n instanceof bn)return cL(r,n.dtype,t,e),n;let s=Rf(n);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),cL(r,s,t,e),null==n||!Oo(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==n?"null":n.constructor.name}'`);const i=ll(n,s);!Oo(n)&&!Array.isArray(n)&&(n=[n]);const a="string"!==s?wc(n,s):sd(n,[],!0);return R.makeTensor(a,i,s)}function t_(n,t,e,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>I(i,`${t}[${o}]`,e,r))}di.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),di.registerFlag("IS_BROWSER",()=>aL()),di.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),di.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),di.registerFlag("PROD",()=>!1),di.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>di.getBool("DEBUG")),di.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),di.registerFlag("IS_TEST",()=>!1),di.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),di.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),di.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),di.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const uL="__op";function A(n){const t=Object.keys(n);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const r=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+=uL;const s=(...i)=>{R.startScope(e);try{const o=r(...i);return ld(o)&&console.error("Cannot return a Promise inside of tidy."),R.endScope(o),o}catch(o){throw R.endScope(null),o}};return Object.defineProperty(s,"name",{value:e,configurable:!0}),s}const cl=A({complex_:function kne(n,t){const e=I(n,"real","complex"),r=I(t,"imag","complex");return Vs(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`),R.runKernel(ZS,{real:e,imag:r})}});function ul(n,t,e,r){if(null==r&&(r=Rf(n)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if("object"==typeof n&&"texture"in n){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from texture only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return n.channels=n.channels||"RGBA",R.backend.createTensorFromTexture(n,t||e,r)}if(!Oo(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){ci(t);const s=X(t),i=X(e);S(s===i,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${i}`);for(let o=0;o<e.length;++o){const a=e[o],l=o!==e.length-1||a!==X(t.slice(o));S(e[o]===t[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!Oo(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n="string"!==r?wc(n,r):sd(n,[],!0),R.makeTensor(n,t,r)}function mo(n,t,e){return ul(n,t,ll(n,e),e)}const oE={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};function aE(n,t){return lE.apply(this,arguments)}function lE(){return lE=ee(function*(n,t){const e=[],r=[],s=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<s.length;++o){const a=s[o],l=Array.isArray(n)?n[o].tensor:n[a];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const u=new Promise(function(){var d=ee(function*(h){const f=yield l.bytes(),p=f.reduce((y,b)=>y+b.length,0)+4*f.length,m=new Uint8Array(p);let g=0;for(let y=0;y<f.length;y++){const b=f[y],_=new Uint8Array(new Uint32Array([b.length]).buffer);m.set(_,g),g+=4,m.set(b,g),g+=b.length}h(m)});return function(h){return d.apply(this,arguments)}}());r.push(u)}else r.push(l.data());null!=t&&(c.group=t),e.push(c)}return{data:Nne(yield Promise.all(r)),specs:e}}),lE.apply(this,arguments)}function dL(n,t){const e={};let r,s=0;for(const i of t){const o=i.name,a=i.dtype,l=i.shape,c=X(l);let u;if("quantization"in i){const d=i.quantization;if("uint8"===d.dtype||"uint16"===d.dtype){if(!("min"in d)||!("scale"in d))throw new Error(`Weight ${i.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==d.dtype)throw new Error(`Weight ${i.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==a)throw new Error(`Weight ${i.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${a}.`)}const h=oE[d.dtype],f=n.slice(s,s+c*h),p="uint8"===d.dtype?new Uint8Array(f):new Uint16Array(f);if("float32"===a)if("uint8"===d.dtype||"uint16"===d.dtype){u=new Float32Array(p.length);for(let m=0;m<p.length;m++)u[m]=p[m]*d.scale+d.min}else{if("float16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);void 0===r&&(r=$ne()),u=r(p)}else{if("int32"!==a)throw new Error(`Unsupported dtype in weight '${o}': ${a}`);if("uint8"!==d.dtype&&"uint16"!==d.dtype)throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);u=new Int32Array(p.length);for(let m=0;m<p.length;m++)u[m]=Math.round(p[m]*d.scale+d.min)}s+=c*h}else if("string"===a){const d=X(i.shape);u=[];for(let h=0;h<d;h++){const f=new Uint32Array(n.slice(s,s+4))[0];s+=4;const p=new Uint8Array(n.slice(s,s+f));u.push(p),s+=f}}else{const d=oE[a],h=n.slice(s,s+c*d);if("float32"===a)u=new Float32Array(h);else if("int32"===a)u=new Int32Array(h);else if("bool"===a)u=new Uint8Array(h);else{if("complex64"!==a)throw new Error(`Unsupported dtype in weight '${o}': ${a}`);{u=new Float32Array(h);const f=new Float32Array(u.length/2),p=new Float32Array(u.length/2);for(let y=0;y<f.length;y++)f[y]=u[2*y],p[y]=u[2*y+1];const m=mo(f,l,"float32"),g=mo(p,l,"float32");e[o]=cl(m,g),m.dispose(),g.dispose()}}s+=c*d}"complex64"!==a&&(e[o]=mo(u,l,a))}return e}function Nne(n){if(null===n)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(i=>{if(t+=i.byteLength,e.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const r=new Uint8Array(t);let s=0;return e.forEach(i=>{r.set(new Uint8Array(i.buffer),s),s+=i.byteLength}),r.buffer}const cE=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function hL(n){return cE?Buffer.byteLength(n):new Blob([n]).size}function r_(n){if(1===n.length)return n[0];let t=0;n.forEach(s=>{t+=s.byteLength});const e=new Uint8Array(t);let r=0;return n.forEach(s=>{e.set(new Uint8Array(s),r),r+=s.byteLength}),e.buffer}function fL(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const e=n.split("/");return e[e.length-1]}function pL(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return null!=n.signature&&(e.signature=n.signature),null!=n.userDefinedMetadata&&(e.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(e.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(e.initializerSignature=n.initializerSignature),null!=n.trainingConfig&&(e.trainingConfig=n.trainingConfig),e}function mL(n,t,e){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(null!=n.trainingConfig&&(r.trainingConfig=n.trainingConfig),null!=n.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=e}return null!=n.signature&&(r.signature=n.signature),null!=n.userDefinedMetadata&&(r.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(r.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(r.initializerSignature=n.initializerSignature),r}function uE(n,t){return dE.apply(this,arguments)}function dE(){return(dE=ee(function*(n,t){let e,r;return null!=n.weightsManifest&&([e,r]=yield t(n.weightsManifest)),mL(n,e,r)})).apply(this,arguments)}function Rp(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==n.modelTopology?0:hL(JSON.stringify(n.modelTopology)),weightSpecsBytes:null==n.weightSpecs?0:hL(JSON.stringify(n.weightSpecs)),weightDataBytes:null==n.weightData?0:n.weightData.byteLength}}function gL(n){const t=[];for(const e of n)t.push(...e.weights);return t}function $ne(){const n=function Mne(){const n=e=>{let r=e<<13,s=0;for(;0==(8388608&r);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function Fne(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}(),e=function One(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}();return r=>{const s=new ArrayBuffer(4*r.length),i=new Uint32Array(s);for(let o=0;o<r.length;o++){const a=r[o];i[o]=n[e[a>>10]+(1023&a)]+t[a>>10]}return new Float32Array(s)}}class Nn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Nn.instance&&(Nn.instance=new Nn),Nn.instance}static registerSaveRouter(t){Nn.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Nn.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Nn.getHandlers(t,"save")}static getLoadHandlers(t,e){return Nn.getHandlers(t,"load",e)}static getHandlers(t,e,r){const s=[];return("load"===e?Nn.getInstance().loadRouters:Nn.getInstance().saveRouters).forEach(o=>{const a=o(t,r);null!==a&&s.push(a)}),s}}const Pne=n=>Nn.registerSaveRouter(n),Lne=n=>Nn.registerLoadRouter(n),yL=n=>Nn.getSaveHandlers(n),Bne=(n,t)=>Nn.getLoadHandlers(n,t),s_="tensorflowjs",Cc="models_store",dl="model_info_store";function pE(){if(!G().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function mE(n){const t=n.result;t.createObjectStore(Cc,{keyPath:"modelPath"}),t.createObjectStore(dl,{keyPath:"modelPath"})}let fd=(()=>{class n{constructor(e){if(this.indexedDB=pE(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var r=this;return ee(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return r.databaseAction(r.modelPath,e)})()}load(){var e=this;return ee(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,r){return new Promise((s,i)=>{const o=this.indexedDB.open(s_,1);o.onupgradeneeded=()=>mE(o),o.onsuccess=()=>{const a=o.result;if(null==r){const l=a.transaction(Cc,"readonly"),u=l.objectStore(Cc).get(this.modelPath);u.onsuccess=()=>{if(null==u.result)return a.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(u.result.modelArtifacts)},u.onerror=d=>(a.close(),i(u.error)),l.oncomplete=()=>a.close()}else{const l=Rp(r),c=a.transaction(dl,"readwrite");let u=c.objectStore(dl);const d=u.put({modelPath:this.modelPath,modelArtifactsInfo:l});let h;d.onsuccess=()=>{h=a.transaction(Cc,"readwrite");const p=h.objectStore(Cc).put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l});p.onsuccess=()=>s({modelArtifactsInfo:l}),p.onerror=m=>{u=c.objectStore(dl);const g=u.delete(this.modelPath);g.onsuccess=()=>(a.close(),i(p.error)),g.onerror=y=>(a.close(),i(p.error))}},d.onerror=f=>(a.close(),i(d.error)),c.oncomplete=()=>{null==h?a.close():h.oncomplete=()=>a.close()}}},o.onerror=a=>i(o.error)})}}return n.URL_SCHEME="indexeddb://",n})();const bL=n=>G().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(fd.URL_SCHEME)?function Vne(n){return new fd(n)}(n.slice(fd.URL_SCHEME.length)):null;Nn.registerSaveRouter(bL),Nn.registerLoadRouter(bL);class Une{constructor(){this.indexedDB=pE()}listModels(){var t=this;return ee(function*(){return new Promise((e,r)=>{const s=t.indexedDB.open(s_,1);s.onupgradeneeded=()=>mE(s),s.onsuccess=()=>{const i=s.result,o=i.transaction(dl,"readonly"),l=o.objectStore(dl).getAll();l.onsuccess=()=>{const c={};for(const u of l.result)c[u.modelPath]=u.modelArtifactsInfo;e(c)},l.onerror=c=>(i.close(),r(l.error)),o.oncomplete=()=>i.close()},s.onerror=i=>r(s.error)})})()}removeModel(t){var e=this;return ee(function*(){return t=function zne(n){return n.startsWith(fd.URL_SCHEME)?n.slice(fd.URL_SCHEME.length):n}(t),new Promise((r,s)=>{const i=e.indexedDB.open(s_,1);i.onupgradeneeded=()=>mE(i),i.onsuccess=()=>{const o=i.result,a=o.transaction(dl,"readwrite"),l=a.objectStore(dl),c=l.get(t);let u;c.onsuccess=()=>{if(null==c.result)return o.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const d=l.delete(t),h=()=>{u=o.transaction(Cc,"readwrite");const p=u.objectStore(Cc).delete(t);p.onsuccess=()=>r(c.result.modelArtifactsInfo),p.onerror=m=>s(c.error)};d.onsuccess=h,d.onerror=f=>(h(),o.close(),s(c.error))}},c.onerror=d=>(o.close(),s(c.error)),a.oncomplete=()=>{null==u?o.close():u.oncomplete=()=>o.close()}},i.onerror=o=>s(i.error)})})()}}const Po="/",Sc="tensorflowjs_models",_L="info",Hne="model_topology",Wne="weight_specs",jne="weight_data",Gne="model_metadata";function vL(n){return{info:[Sc,n,_L].join(Po),topology:[Sc,n,Hne].join(Po),weightSpecs:[Sc,n,Wne].join(Po),weightData:[Sc,n,jne].join(Po),modelMetadata:[Sc,n,Gne].join(Po)}}function xL(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function wL(n){const t=n.split(Po);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(Po)}let pd=(()=>{class n{constructor(e){if(!G().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=vL(this.modelPath)}save(e){var r=this;return ee(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const s=JSON.stringify(e.modelTopology),i=JSON.stringify(e.weightSpecs),o=Rp(e);try{return r.LS.setItem(r.keys.info,JSON.stringify(o)),r.LS.setItem(r.keys.topology,s),r.LS.setItem(r.keys.weightSpecs,i),r.LS.setItem(r.keys.weightData,function Ane(n){if(cE)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let r=0,s=t.length;r<s;r++)e+=String.fromCharCode(t[r]);return btoa(e)}(e.weightData)),r.LS.setItem(r.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0})),{modelArtifactsInfo:o}}catch{throw xL(r.keys),new Error(`Failed to save model '${r.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}})()}load(){var e=this;return ee(function*(){const r=JSON.parse(e.LS.getItem(e.keys.info));if(null==r)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==r.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const s={},i=JSON.parse(e.LS.getItem(e.keys.topology));if(null==i)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);s.modelTopology=i;const o=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==o)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);s.weightSpecs=o;const a=e.LS.getItem(e.keys.modelMetadata);if(null!=a){const c=JSON.parse(a);s.format=c.format,s.generatedBy=c.generatedBy,s.convertedBy=c.convertedBy,null!=c.signature&&(s.signature=c.signature),null!=c.userDefinedMetadata&&(s.userDefinedMetadata=c.userDefinedMetadata),null!=c.modelInitializer&&(s.modelInitializer=c.modelInitializer),null!=c.initializerSignature&&(s.initializerSignature=c.initializerSignature),null!=c.trainingConfig&&(s.trainingConfig=c.trainingConfig)}const l=e.LS.getItem(e.keys.weightData);if(null==l)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return s.weightData=function Rne(n){if(cE){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let r=0;r<t.length;++r)e.set([t.charCodeAt(r)],r);return e.buffer}(l),s})()}}return n.URL_SCHEME="localstorage://",n})();const CL=n=>G().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(pd.URL_SCHEME)?function Kne(n){return new pd(n)}(n.slice(pd.URL_SCHEME.length)):null;Nn.registerSaveRouter(CL),Nn.registerLoadRouter(CL);class Xne{constructor(){S(G().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),S(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var t=this;return ee(function*(){const e={},r=Sc+Po,s=Po+_L;for(let i=0;i<t.LS.length;++i){const o=t.LS.key(i);o.startsWith(r)&&o.endsWith(s)&&(e[wL(o)]=JSON.parse(t.LS.getItem(o)))}return e})()}removeModel(t){var e=this;return ee(function*(){const r=vL(t=function qne(n){return n.startsWith(pd.URL_SCHEME)?n.slice(pd.URL_SCHEME.length):n}(t));if(null==e.LS.getItem(r.info))throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(e.LS.getItem(r.info));return xL(r),s})()}}const md="://";class as{constructor(){this.managers={}}static getInstance(){return null==as.instance&&(as.instance=new as),as.instance}static registerManager(t,e){S(null!=t,()=>"scheme must not be undefined or null."),t.endsWith(md)&&(t=t.slice(0,t.indexOf(md))),S(t.length>0,()=>"scheme must not be an empty string.");const r=as.getInstance();S(null==r.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=e}static getManager(t){const e=as.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(as.getInstance().managers)}}function i_(n){if(-1===n.indexOf(md))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${as.getSchemes().join(",")}`);return{scheme:n.split(md)[0],path:n.split(md)[1]}}function SL(n,t){return gE.apply(this,arguments)}function gE(){return(gE=ee(function*(n,t,e=!1){S(n!==t,()=>`Old path and new path are the same: '${n}'`);const r=Nn.getLoadHandlers(n);S(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),S(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const s=r[0],i=Nn.getSaveHandlers(t);S(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),S(i.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);const o=i[0],a=i_(n).scheme,l=i_(n).path,c=a===i_(n).scheme,u=yield s.load();e&&c&&(yield as.getManager(a).removeModel(l));const d=yield o.save(u);return e&&!c&&(yield as.getManager(a).removeModel(l)),d.modelArtifactsInfo})).apply(this,arguments)}function Yne(){return yE.apply(this,arguments)}function yE(){return(yE=ee(function*(){const n=as.getSchemes(),t={};for(const e of n){const r=yield as.getManager(e).listModels();for(const s in r)t[e+md+s]=r[s]}return t})).apply(this,arguments)}function Zne(n){return bE.apply(this,arguments)}function bE(){return(bE=ee(function*(n){const t=i_(n);return as.getManager(t.scheme).removeModel(t.path)})).apply(this,arguments)}function Qne(n,t){return _E.apply(this,arguments)}function _E(){return(_E=ee(function*(n,t){return SL(n,t,!1)})).apply(this,arguments)}function Jne(n,t){return vE.apply(this,arguments)}function vE(){return(vE=ee(function*(n,t){return SL(n,t,!0)})).apply(this,arguments)}class ere{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){typeof window>"u"||!G().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(t,e):(this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{r.source===window&&r.data.name===this.messageName&&(r.stopPropagation(),(0,this.functionRefs[r.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}}if(G().get("IS_BROWSER")){G().setPlatform("browser",new ere);try{as.registerManager(pd.URL_SCHEME,new Xne)}catch{}try{as.registerManager(fd.URL_SCHEME,new Une)}catch{}}let gd;function lt(n,t="float32",e){return t=t||"float32",ci(n),new Er(n,t,e)}G().get("IS_NODE")&&!G().get("IS_BROWSER")&&G().setPlatform("node",new class nre{constructor(){this.util=Q(628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=G().global.fetch?G().global.fetch(t,e):(null==gd&&(gd=Q(410)),gd(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}});const ve=A({cast_:function rre(n,t){const e=I(n,"x","cast");if(!function Gte(n){return"bool"===n||"complex64"===n||"float32"===n||"int32"===n||"string"===n}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==e.dtype||"string"!==t&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return R.runKernel(Vf,{x:e},{dtype:t})}}),wa=A({clone_:function sre(n){const e={x:I(n,"x","clone","string_or_numeric")};return R.runKernel(Jf,e)}});function IL(n,t=!1){console.log(n.toString(t))}function EL(n){return new Promise(t=>setTimeout(t)).then(n)}iL(),function vne(n){hd=n}({buffer:lt,cast:ve,clone:wa,print:IL});let xE=(()=>{class n{constructor(e){if(!G().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(n.URL_SCHEME)&&(e=e.slice(n.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var r=this;return ee(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const s=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const o=pL(e,[{paths:["./"+r.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),l=r.modelJsonAnchor??document.createElement("a");if(l.download=r.modelJsonFileName,l.href=a,yield EL(()=>l.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const c=r.weightDataAnchor??document.createElement("a");c.download=r.weightDataFileName,c.href=s,yield EL(()=>c.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Rp(e)}}})()}}return n.URL_SCHEME="downloads://",n})();class lre{constructor(t){if(null==t||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}load(){var t=this;return ee(function*(){return new Promise((e,r)=>{const s=new FileReader;s.onload=i=>{const o=JSON.parse(i.target.result),a=o.modelTopology;if(null==a)return void r(new Error(`modelTopology field is missing from file ${t.jsonFile.name}`));if(null==o.weightsManifest)return void r(new Error(`weightManifest field is missing from file ${t.jsonFile.name}`));if(0===t.weightsFiles.length)return void e({modelTopology:a});const c=uE(o,u=>t.loadWeights(u));e(c)},s.onerror=i=>r(`Failed to read model topology and weights manifest JSON from file '${t.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(t.jsonFile)})})()}loadWeights(t){const e=[],r=[];for(const o of t)e.push(...o.weights),r.push(...o.paths);const s=this.checkManifestAndWeightFiles(t),i=r.map(o=>this.loadWeightsFile(o,s[o]));return Promise.all(i).then(o=>[e,r_(o)])}loadWeightsFile(t,e){return new Promise((r,s)=>{const i=new FileReader;i.onload=o=>{r(o.target.result)},i.onerror=o=>s(`Failed to weights data from file of path '${t}'.`),i.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],r=this.weightsFiles.map(i=>fL(i.name)),s={};for(const i of t)i.paths.forEach(o=>{const a=fL(o);if(-1!==e.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),-1===r.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);s[o]=this.weightsFiles[r.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}function dre(n){return new lre(n)}function DL(n,t,e,r){(function o(l){S(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(n),function a(l,c){S(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),S(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),S(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}(e=e??0,r=r??1);let s=0;return Promise.all(n.map(l=>(l.then(c=>{const u=e+ ++s/n.length*(r-e);return t(u),c}),l)))}function TL(n,t){return wE.apply(this,arguments)}function wE(){return(wE=ee(function*(n,t){null==t&&(t={});const e=t.fetchFunc??G().platform.fetch,r=n.map(d=>e(d,t.requestInit,{isBinary:!0})),a=(null==t.onProgress?yield Promise.all(r):yield DL(r,t.onProgress,0,.5)).map(d=>d.arrayBuffer());return null==t.onProgress?yield Promise.all(a):yield DL(a,t.onProgress,.5,1)})).apply(this,arguments)}function hre(n){return CE.apply(this,arguments)}function CE(){return(CE=ee(function*(n,t="",e,r){return kL(o=>TL(o,{requestInit:r}))(n,t,e)})).apply(this,arguments)}function kL(n){return function(){var t=ee(function*(e,r="",s){const i=e.map(()=>!1),o={},a=null!=s?s.map(()=>!1):[],l=[];if(e.forEach((p,m)=>{let g=0;p.weights.forEach(y=>{const _=oE["quantization"in y?y.quantization.dtype:y.dtype]*X(y.shape),v=()=>{i[m]=!0,null==o[m]&&(o[m]=[]),o[m].push({manifestEntry:y,groupOffset:g,sizeBytes:_})};null!=s?s.forEach((w,C)=>{w===y.name&&(v(),a[C]=!0)}):v(),l.push(y.name),g+=_})}),!a.every(p=>p)){const p=s.filter((m,g)=>!a[g]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. \nManifest JSON has weights with names: ${l.join(", ")}.`)}const c=i.reduce((p,m,g)=>(m&&p.push(g),p),[]),u=[];c.forEach(p=>{e[p].paths.forEach(m=>{const g=r+(r.endsWith("/")?"":"/")+m;u.push(g)})});const d=yield n(u),h={};let f=0;return c.forEach(p=>{const m=e[p].paths.length;let g=0;for(let w=0;w<m;w++)g+=d[f+w].byteLength;const y=new ArrayBuffer(g),b=new Uint8Array(y);let _=0;for(let w=0;w<m;w++){const C=new Uint8Array(d[f+w]);b.set(C,_),_+=C.byteLength}o[p].forEach(w=>{const E=dL(y.slice(w.groupOffset,w.groupOffset+w.sizeBytes),[w.manifestEntry]);for(const D in E)h[D]=E[D]}),f+=m}),h});return function(e){return t.apply(this,arguments)}}()}Nn.registerSaveRouter(n=>G().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(xE.URL_SCHEME)?function ure(n="model"){return new xE(n)}(n.slice(xE.URL_SCHEME.length)):null);let NL=(()=>{class n{constructor(e,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.onProgress=r.onProgress,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?(S("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=G().platform.fetch,S(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&S(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{}}save(e){var r=this;return ee(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const s=Object.assign({method:r.DEFAULT_METHOD},r.requestInit);s.body=new FormData;const o=pL(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);s.body.append("model.json",new Blob([JSON.stringify(o)],{type:"application/json"}),"model.json"),null!=e.weightData&&s.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=yield r.fetch(r.path,s);if(a.ok)return{modelArtifactsInfo:Rp(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)})()}load(){var e=this;return ee(function*(){const r=yield e.fetch(e.path,e.requestInit);if(!r.ok)throw new Error(`Request to ${e.path} failed with status code ${r.status}. Please verify this URL points to the model JSON of the model to load.`);let s;try{s=yield r.json()}catch{let l=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?l+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":l+=" Please make sure the server is serving valid JSON for this request.",new Error(l)}if(null==s.modelTopology&&null==s.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return uE(s,a=>e.loadWeights(a))})()}loadWeights(e){var r=this;return ee(function*(){const s=Array.isArray(r.path)?r.path[1]:r.path,[i,o]=function mre(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?");return[n.substring(0,t)+"/",e>t?n.substring(e):""]}(s),a=r.weightPathPrefix||i,l=gL(e),c=[],u=[];for(const h of e)for(const f of h.paths)null!=r.weightUrlConverter?u.push(r.weightUrlConverter(f)):c.push(a+f+o);return r.weightUrlConverter&&c.push(...yield Promise.all(u)),[l,r_(yield TL(c,{requestInit:r.requestInit,fetchFunc:r.fetch,onProgress:r.onProgress}))]})()}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();function SE(n){return null!=n.match(NL.URL_SCHEME_REGEX)}const AL=(n,t)=>{if(typeof fetch>"u"&&(null==t||null==t.fetchFunc))return null;{let e=!0;if(e=Array.isArray(n)?n.every(r=>SE(r)):SE(n),e)return IE(n,t)}return null};function IE(n,t){return new NL(n,t)}function gre(n,t){return IE(n,t)}Nn.registerSaveRouter(AL),Nn.registerLoadRouter(AL);class EE{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class RL{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class yre{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function bre(n,t,e,r){const s=arguments;return new yre(ML(...s))}function ML(n,t,e,r){return 1===arguments.length?null!=n.modelTopology||null!=n.weightSpecs?new EE(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new EE({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new EE({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:r}))}function _re(n){return new RL(n)}function vre(n){return new RL(n)}function yd(n,t){const e=n.length,r=[];for(let s=0;s<e;s++){const i=e-1-s,o=n[i]||1;(t[t.length-1-s]||1)>1&&1===o&&r.unshift(i)}return r}function lr(n,t){const e=[];for(let r=0;r<t.length;r++){const s=n[n.length-r-1],i=t.length-r-1,o=t[i];(null==s||1===s&&o>1)&&e.unshift(i)}return e}function tt(n,t){const e=[],r=Math.max(n.length,t.length);for(let s=0;s<r;s++){let i=n[n.length-s-1];null==i&&(i=1);let o=t[t.length-s-1];if(null==o&&(o=1),1===i)e.unshift(o);else if(1===o)e.unshift(i);else{if(i!==o)throw Error(`Operands could not be broadcast together with shapes ${n} and ${t}.`);e.unshift(i)}}return e}function FL(n,t,e){if(rd(n),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=ll(n,e);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ul(n,t,r,e)}let Ic;const Ire=A({fromPixels_:function OL(n,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==n)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,r=!1,s=!1,i=!1,o=!1,a=!1;if(n.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)i=!0;else if(null!=n.getContext)o=!0;else{if(!(typeof ImageBitmap<"u"&&n instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);a=!0}if(null!=ZI(XI,R.backendName))return R.runKernel(XI,{pixels:n},{numChannels:t});const[c,u]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let d,h;if(o)d=n.getContext("2d").getImageData(0,0,c,u).data;else if(r||e)d=n.data;else if(i||s||a){if(null==Ic)if(typeof document>"u"){if(!(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u"))throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Ic=new OffscreenCanvas(1,1).getContext("2d")}else Ic=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Ic.canvas.width=c,Ic.canvas.height=u,Ic.drawImage(n,0,0,c,u),d=Ic.getImageData(0,0,c,u).data}if(4===t)h=new Int32Array(d);else{const p=c*u;h=new Int32Array(p*t);for(let m=0;m<p;m++)for(let g=0;g<t;++g)h[m*t+g]=d[4*m+g]}return FL(h,[u,c,t],"int32")}});function NE(n,t,e){const r=n.shape.length;S(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),S(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)S(t[s]+e[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+e[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function Dre(n){const t=[];let e=0;for(;n>0;)1&n&&t.push(e),n/=2,e++;return t}function AE(n,t,e){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((t[s]-n[s])/e[s]);return r}function $L(n,t,e,r){const s=[...n];for(let i=s.length;i<r.length;i++)s.push(1);for(let i=0;i<e;i++)0===i?s[t]=1:(s.splice(t,0,1),s.pop());return s}function PL(n,t,e){return e<=n?e:e-(t-1)}function LL(n,t){const e=[];for(let r=0;r<n;r++)e.push(t+r);return e}function Tre(n,t,e,r,s,i,o,a,l){const c=n.length;let u=new Array(c),d=new Array(c),h=new Array(c);if(t.length&&e>0){const f=t[0],p=e+1;u=BL(o,f,p,r,n),d=VL(a,f,p,s,n),h=$L(i,f,p,n)}else for(let f=0;f<c;f++)u[f]=UL(o,r,i,n,f,l),d[f]=HL(a,s,i,n,f,l),h[f]=zL(i,f,l);return{begin:u,end:d,strides:h}}function BL(n,t,e,r,s){const i=[...s],o=LL(e,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=PL(t,e,a);let c=r[l];n&1<<l&&(c=0),i[a]=c}return i}function VL(n,t,e,r,s){const i=[...s],o=LL(e,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=PL(t,e,a);let c=r[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),i[a]=c}for(let a=0;a<i.length;a++){const l=s[a];i[a]<0&&(i[a]+=l),i[a]=_c(0,i[a],s[a])}return i}function zL(n,t,e){let r=n[t];return(e&1<<t||null==r)&&(r=1),r}function UL(n,t,e,r,s,i){let o=t[s];(n&1<<s||i&1<<s||null==o)&&(o=(e[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=_c(0,o,l-1),o}function HL(n,t,e,r,s,i){let o=t[s];const a=e[s]||1;(n&1<<s||i&1<<s||null==o)&&(o=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=a>0?_c(0,o,l):_c(-1,o,l-1),o}function RE(n,t,e){let r=e.length;for(let s=0;s<e.length;s++)if(e[s]>1){r=s;break}for(let s=r+1;s<e.length;s++)if(t[s]>0||e[s]!==n[s])return!1;return!0}function ME(n,t){let e=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)e+=n[r]*t[r];return e}function o_(n,t,e){let r;const s=n.shape.length;let i;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach(o=>{S(-1!==o,()=>"slice() does not support negative begin indexing.")}),i=null==e?new Array(s).fill(-1):"number"==typeof e?[e,...new Array(s-1).fill(-1)]:e.length<s?e.concat(new Array(s-e.length).fill(-1)):e,i=i.map((o,a)=>o>=0?o:(S(-1===o,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,i]}function FE(n,t,e,r,s,i,o,a,l){let c;if(null==r?(c=new Array(t.length),c.fill(1)):c=r,null!=o&&0!=(o&o-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const d={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:c.slice(),beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let _=0;_<d.dims;_++)u&&0!=(1<<_&a)&&d.numAddAxisAfterEllipsis++,1<<_&o&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function kre(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=null!=n.begin,t.endValid=null!=n.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(t.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<s;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&n.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=n.begin&&(t.begin[e]=n.begin[r]),null!=n.end&&(t.end[e]=n.end[r]),t.strides[e]=n.strides[r],n.beginMask&1<<r&&(t.beginMask|=1<<e),n.endMask&1<<r&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[e]=r,e++}}(d,h);let f=!0,p=!0,m=!0;const g=[],y=[];for(let _=0;_<n.length;++_){if(0===h.strides[_])throw Error(`strides[${_}] must be non-zero`);const v=!!(h.shrinkAxisMask&1<<_),w=n[_];if(-1===w){g.push(v?1:-1);continue}const C=[h.beginMask&1<<_,h.endMask&1<<_],E=[h.strides[_]>0?0:-1,h.strides[_]>0?w:w-1];if(v&&h.strides[_]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[_];const D=!!(h.beginMask&1<<_&&h.endMask&1<<_);if(h.beginValid&&h.endValid){if(v){const U=h.begin[_]<0?w+h.begin[_]:h.begin[_];if(h.begin[_]=U,h.end[_]=h.begin[_]+1,U<0||U>=w)throw Error(`slice index ${h.begin[_]} of dimension ${_} out of bounds.`)}else h.begin[_]=WL(h.begin[_],0,h.strides[_],w,C,E),h.end[_]=WL(h.end[_],1,h.strides[_],w,C,E);const P=1===h.strides[_]&&0===h.begin[_]&&h.end[_]===w;f=f&&P,p=p&&(0===_&&1===h.strides[_]||P)}else f=f&&1===h.strides[_]&&D,p=p&&(0===_&&1===h.strides[_]||D);let T,N=!1;if(h.beginValid&&h.endValid?(T=h.end[_]-h.begin[_],N=!0):v?(T=1,N=!0):D&&w>=0&&(T=h.strides[_]<0?-w:w,N=!0),N){let P;P=0===T||T<0!=h.strides[_]<0?0:Math.trunc(T/h.strides[_])+(T%h.strides[_]!=0?1:0),g.push(P)}else g.push(-1)}for(let _=0;_<h.finalShapeGatherIndices.length;++_){const v=h.finalShapeGatherIndices[_];v>=0?y.push(g[v]):-2===v&&y.push(1)}return{finalShapeSparse:y.filter((_,v)=>-2!==h.finalShapeGatherIndices[v]),finalShape:y,isIdentity:f,sliceDim0:p,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function WL(n,t,e,r,s,i){if(s[t])return e>0?i[t]:i[t+1&1];{const o=n<0?r+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}class bd{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class Pi{constructor(){this.classNameMap={}}static getMap(){return null==Pi.instance&&(Pi.instance=new Pi),Pi.instance}static register(t){Pi.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function se(n){S(null!=n.className,()=>"Class being registered does not have the static className property defined."),S("string"==typeof n.className,()=>"className is required to be a string, but got type "+typeof n.className),S(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Pi.register(n)}function Lo(){return R}function OE(){return R.memory()}function z(n,t){return R.tidy(n,t)}function Je(n){nL(n).forEach(e=>e.dispose())}function Dr(n){return R.keep(n)}function jL(n,t,e=1){return R.registerBackend(n,t,e)}function Ca(n){return R.customGrad(n)}function Be(n,t){if((Oo(n)&&"string"!==t||Array.isArray(n))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Oo(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ul(n,[],[],t)}!function xne(n){tL=n}(function Are(n){G().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});class hl extends bd{minimize(t,e=!1,r){const{value:s,grads:i}=this.computeGradients(t,r);if(null!=r){const o=r.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return Je(i),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function Mre(n,t){S(VS(n),()=>"The f passed in variableGrads(f) must be a function"),S(null==t||Array.isArray(t)&&t.every(c=>c instanceof Yb),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=t;if(!e){t=[];for(const c in R.registeredVariables)t.push(R.registeredVariables[c])}const r=e?t.filter(c=>!c.trainable):null,s=t.length;S((t=t.filter(c=>c.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:o,grads:a}=R.gradients(n,t,null,!0);S(a.some(c=>null!=c),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),S(0===o.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return t.forEach((c,u)=>{null!=a[u]&&(l[c.name]=a[u])}),r?.forEach(c=>l[c.name]=null),{value:o,grads:l}}(t,e)}dispose(){null!=this.iterations_&&Je(this.iterations_)}saveIterations(){var t=this;return ee(function*(){return null==t.iterations_&&(t.iterations_=0),{name:"iter",tensor:Be(t.iterations_,"int32")}})()}getWeights(){return ee(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(t){var e=this;return ee(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(t){var e=this;return ee(function*(){return e.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})()}}Object.defineProperty(hl,Symbol.hasInstance,{value:n=>null!=n.minimize&&null!=n.computeGradients&&null!=n.applyGradients});const cr=A({abs_:function Fre(n){const t=I(n,"x","abs");return R.runKernel("complex64"===t.dtype?Zy:Hy,{x:t})}}),GL=A({acos_:function Ore(n){const e={x:I(n,"x","acos")};return R.runKernel(Mf,e)}}),qL=A({acosh_:function $re(n){const e={x:I(n,"x","acosh")};return R.runKernel(Ff,e)}}),le=A({add_:function Pre(n,t){let e=I(n,"a","add"),r=I(t,"b","add");return[e,r]=Pn(e,r),R.runKernel(cd,{a:e,b:r})}}),Bre=A({addN_:function Lre(n){S(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),S(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const t=n.map((s,i)=>I(s,`tensors${i}`,"addN")),e=t[0];return t.forEach(s=>{if(s.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(s=>{if(!Rt(s.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),R.runKernel(Wy,t)}}),$E=A({all_:function Vre(n,t=null,e=!1){const s={x:I(n,"x","all","bool")};return R.runKernel("All",s,{axis:t,keepDims:e})}}),l_=A({any_:function zre(n,t=null,e=!1){const s={x:I(n,"x","any","bool")};return R.runKernel("Any",s,{axis:t,keepDims:e})}}),_d=A({argMax_:function Ure(n,t=0){const r={x:I(n,"x","argMax")};return R.runKernel(jy,r,{axis:t})}}),KL=A({argMin_:function Hre(n,t=0){const r={x:I(n,"x","argMin")};return R.runKernel(Gy,r,{axis:t})}}),XL=A({asin_:function Wre(n){const e={x:I(n,"x","asin")};return R.runKernel(Of,e)}}),YL=A({asinh_:function jre(n){const e={x:I(n,"x","asinh")};return R.runKernel($f,e)}}),ZL=A({atan_:function Gre(n){const e={x:I(n,"x","atan")};return R.runKernel(Pf,e)}}),QL=A({atan2_:function qre(n,t){let e=I(n,"a","atan2"),r=I(t,"b","atan2");return[e,r]=Pn(e,r),R.runKernel(Bf,{a:e,b:r})}}),JL=A({atanh_:function Kre(n){const e={x:I(n,"x","atanh")};return R.runKernel(Lf,e)}});function Mp(n,t,e,r,s="NHWC",i){return Tr(n,[...t,n[3]],e,i,r,null,null,Ia(s))}function Li(n,t,e,r,s,i,o="channelsLast"){const[a,l]=c_(t);let c;if("channelsLast"===o)c=[a,l,n[3],n[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);c=[a,l,n[1],n[1]]}return Tr(n,c,e,r,s,i,!1,o)}function Sa(n,t,e,r,s,i,o="NDHWC"){const[a,l,c]=LE(t);let u,d;if("NDHWC"===o)d="channelsLast",u=[a,l,c,n[4],n[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);d="channelsFirst",u=[a,l,c,n[1],n[1]]}return fl(n,u,e,r,s,!1,d,i)}function Tr(n,t,e,r,s,i,o=!1,a="channelsLast"){let[l,c,u,d]=[-1,-1,-1,-1];if("channelsLast"===a)[l,c,u,d]=n;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,c,u]=n}const[h,f,,p]=t,[m,g]=c_(e),[y,b]=c_(r),_=vd(h,y),v=vd(f,b),{padInfo:w,outHeight:C,outWidth:E}=function Zre(n,t,e,r,s,i,o,a,l){let c,u,d;if("number"==typeof n){c={top:n,bottom:n,left:n,right:n,type:0===n?"VALID":"NUMBER"};const f=function Xre(n,t,e,r,s){null==r&&(r=PE(n,t,e));const o=n[1];return[Ec((n[0]-t+2*r)/e+1,s),Ec((o-t+2*r)/e+1,s)]}([t,e],i,r,n,a);u=f[0],d=f[1]}else if("same"===n){u=Math.ceil(t/r),d=Math.ceil(e/s);const h=Math.max(0,(u-1)*r+i-t),f=Math.max(0,(d-1)*s+o-e),p=Math.floor(h/2),m=h-p,g=Math.floor(f/2);c={top:p,bottom:m,left:g,right:f-g,type:"SAME"}}else if("valid"===n)c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-i+1)/r),d=Math.ceil((e-o+1)/s);else{if("object"!=typeof n)throw Error(`Unknown padding parameter: ${n}`);{const h="channelsLast"===l?n[1][0]:n[2][0],f="channelsLast"===l?n[1][1]:n[2][1],p="channelsLast"===l?n[2][0]:n[3][0],m="channelsLast"===l?n[2][1]:n[3][1];c={top:h,bottom:f,left:p,right:m,type:0===h&&0===f&&0===p&&0===m?"VALID":"EXPLICIT"},u=Ec((t-i+h+f)/r+1,a),d=Ec((e-o+p+m)/s+1,a)}}return{padInfo:c,outHeight:u,outWidth:d}}(s,c,u,m,g,_,v,i,a),D=o?p*d:p;let T;return"channelsFirst"===a?T=[l,D,C,E]:"channelsLast"===a&&(T=[l,C,E,D]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:d,outHeight:C,outWidth:E,outChannels:D,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:f,effectiveFilterHeight:_,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:n,outShape:T,filterShape:t}}function fl(n,t,e,r,s,i=!1,o="channelsLast",a){let[l,c,u,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,c,u,d,h]=n;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,c,u,d]=n}const[f,p,m,,g]=t,[y,b,_]=LE(e),[v,w,C]=LE(r),E=vd(f,v),D=vd(p,w),T=vd(m,C),{padInfo:N,outDepth:P,outHeight:U,outWidth:j}=function Qre(n,t,e,r,s,i,o,a,l,c,u){let d,h,f,p;if("number"==typeof n){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:0===n?"VALID":"NUMBER"};const g=function Yre(n,t,e,r,s,i){null==s&&(s=PE(n,t,r));const a=n[1],l=n[2];return[Ec((n[0]-t+2*s)/r+1,i),Ec((a-t+2*s)/r+1,i),Ec((l-t+2*s)/r+1,i),e]}([t,e,r,1],a,1,s,n,u);h=g[0],f=g[1],p=g[2]}else if("same"===n){h=Math.ceil(t/s),f=Math.ceil(e/i),p=Math.ceil(r/o);const m=(h-1)*s+a-t,g=(f-1)*i+l-e,y=(p-1)*o+c-r,b=Math.floor(m/2),_=m-b,v=Math.floor(g/2),w=g-v,C=Math.floor(y/2);d={top:v,bottom:w,left:C,right:y-C,front:b,back:_,type:"SAME"}}else{if("valid"!==n)throw Error(`Unknown padding parameter: ${n}`);d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},h=Math.ceil((t-a+1)/s),f=Math.ceil((e-l+1)/i),p=Math.ceil((r-c+1)/o)}return{padInfo:d,outDepth:h,outHeight:f,outWidth:p}}(s,c,u,d,y,b,_,E,D,T,a),q=i?g*h:g;let K;return"channelsFirst"===o?K=[l,q,P,U,j]:"channelsLast"===o&&(K=[l,P,U,j,q]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:d,inChannels:h,outDepth:P,outHeight:U,outWidth:j,outChannels:q,padInfo:N,strideDepth:y,strideHeight:b,strideWidth:_,filterDepth:f,filterHeight:p,filterWidth:m,effectiveFilterDepth:E,effectiveFilterHeight:D,effectiveFilterWidth:T,dilationDepth:v,dilationHeight:w,dilationWidth:C,inShape:n,outShape:K,filterShape:t}}function PE(n,t,e,r=1){const s=vd(t,r);return Math.floor((n[0]*(e-1)-e+s)/2)}function c_(n){return"number"==typeof n?[n,n,n]:2===n.length?[n[0],n[1],1]:n}function LE(n){return"number"==typeof n?[n,n,n]:n}function vd(n,t){return t<=1?n:n+(n-1)*(t-1)}function Ec(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function pl(n){const[t,e,r]=c_(n);return 1===t&&1===e&&1===r}function Pr(n,t){return pl(n)||pl(t)}function Ia(n){if("NHWC"===n)return"channelsLast";if("NCHW"===n)return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function ls(n,t,e){if(null!=e){if("string"==typeof t)throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if("number"==typeof t)S(id(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);t.forEach(r=>{r.forEach(s=>{S(id(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${s}.`)})})}}}const F=A({reshape_:function Jre(n,t){const r={x:I(n,"x","reshape","string_or_numeric")};return R.runKernel(Ab,r,{shape:t})}}),u_=A({avgPool_:function ese(n,t,e,r,s){const i=I(n,"x","avgPool","float32");S(Pr(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let a=i,l=!1;3===i.rank&&(l=!0,a=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(4===a.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),ls("avgPool",r,s);let d=R.runKernel(qy,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return d=ve(d,i.dtype),l?F(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),eB=A({avgPool3d_:function tse(n,t,e,r,s,i="NDHWC"){const o=I(n,"x","avgPool3d","float32");let a=o,l=!1;4===o.rank&&(l=!0,a=F(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===i,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),ls("avgPool3d",r,s);let d=R.runKernel(Ky,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:i});return d=ve(d,a.dtype),l?F(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Qn=A({concat_:function nse(n,t=0){S(n.length>=1,()=>"Pass at least one tensor to concat");const e=t_(n,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(i=>{if("complex64"!==i.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${i.dtype}. `)}),1===e.length?wa(e[0]):R.runKernel(Qy,e,{axis:t})}}),_t=A({matMul_:function rse(n,t,e=!1,r=!1){let s=I(n,"a","matMul"),i=I(t,"b","matMul");return[s,i]=Pn(s,i),R.runKernel(Xy,{a:s,b:i},{transposeA:e,transposeB:r})}}),M=A({mul_:function sse(n,t){let e=I(n,"a","mul"),r=I(t,"b","mul");return[e,r]=Pn(e,r),R.runKernel(lp,{a:e,b:r})}}),Bo=A({sigmoid_:function ise(n){const e={x:I(n,"x","sigmoid","float32")};return R.runKernel(_p,e)}}),Mt=A({slice_:function ose(n,t,e){const r=I(n,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return R.runKernel($b,{x:r},{begin:t,size:e})}}),xd=A({tanh_:function ase(n){const e={x:I(n,"x","tanh","float32")};return R.runKernel(Ip,e)}}),cse=A({basicLSTMCell_:function lse(n,t,e,r,s,i){const o=I(n,"forgetBias","basicLSTMCell"),a=I(t,"lstmKernel","basicLSTMCell"),l=I(e,"lstmBias","basicLSTMCell"),c=I(r,"data","basicLSTMCell"),u=I(s,"c","basicLSTMCell"),d=I(i,"h","basicLSTMCell"),h=Qn([c,d],1),f=_t(h,a),p=le(f,l),g=p.shape[1]/4,y=[p.shape[0],g],b=Mt(p,[0,0],y),_=Mt(p,[0,g],y),v=Mt(p,[0,2*g],y),w=Mt(p,[0,3*g],y),C=le(M(Bo(b),xd(_)),M(u,Bo(le(o,v))));return[C,M(xd(C),Bo(w))]}}),d_=A({batchToSpaceND_:function use(n,t,e){const r=I(n,"x","batchToSpaceND"),s=t.reduce((a,l)=>a*l);return S(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),S(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),S(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`),R.runKernel(Yy,{x:r},{blockShape:t,crops:e})}});function dse(n){let t;return t=0===n.rank||1===n.rank?F(n,[1,1,1,n.size]):2===n.rank?F(n,[1,1,n.shape[0],n.shape[1]]):3===n.rank?F(n,[1,n.shape[0],n.shape[1],n.shape[2]]):n,t}const Fp=A({batchNorm_:function hse(n,t,e,r,s,i){null==i&&(i=.001);const o=I(n,"x","batchNorm"),a=I(t,"mean","batchNorm"),l=I(e,"variance","batchNorm");let c,u;null!=s&&(c=I(s,"scale","batchNorm")),null!=r&&(u=I(r,"offset","batchNorm")),S(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==u||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:dse(o),scale:c,offset:u,mean:a,variance:l},p=R.runKernel(ab,h,{varianceEpsilon:i});return F(p,o.shape)}}),tB=A({batchNorm2d_:function fse(n,t,e,r,s,i){const o=I(n,"x","batchNorm"),a=I(t,"mean","batchNorm"),l=I(e,"variance","batchNorm");let c,u;return null!=s&&(c=I(s,"scale","batchNorm")),null!=r&&(u=I(r,"offset","batchNorm")),S(2===o.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),S(2===a.rank||1===a.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),S(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=c&&S(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),null!=u&&S(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),Fp(o,a,l,u,c,i)}}),nB=A({batchNorm3d_:function pse(n,t,e,r,s,i){const o=I(n,"x","batchNorm"),a=I(t,"mean","batchNorm"),l=I(e,"variance","batchNorm");let c,u;return null!=s&&(c=I(s,"scale","batchNorm")),null!=r&&(u=I(r,"offset","batchNorm")),S(3===o.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),S(3===a.rank||1===a.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),S(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=c&&S(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),null!=u&&S(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),Fp(o,a,l,u,c,i)}}),rB=A({batchNorm4d_:function mse(n,t,e,r,s,i){const o=I(n,"x","batchNorm"),a=I(t,"mean","batchNorm"),l=I(e,"variance","batchNorm");let c,u;return null!=s&&(c=I(s,"scale","batchNorm")),null!=r&&(u=I(r,"offset","batchNorm")),S(4===o.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),S(4===a.rank||1===a.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),S(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=c&&S(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),null!=u&&S(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),Fp(o,a,l,u,c,i)}}),sB=A({bincount_:function gse(n,t,e){const r=I(n,"x","bincount"),s=I(t,"weights","bincount");return S("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),S(e>=0,()=>`size must be non-negative, but got ${e}.`),S(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),R.runKernel(XS,{x:r,weights:s},{size:e})}}),bse=A({broadcastArgs_:function yse(n,t){const e=I(n,"s0","broadcastArgs","int32"),r=I(t,"s1","broadcastArgs","int32");if(1!==e.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);return R.runKernel(YS,{s0:e,s1:r})}}),wd=A({broadcastTo_:function _se(n,t){let e=I(n,"broadcastTo","x");const r=e.shape;if(ci(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const c=e.shape.slice();for(;c.length<t.length;)c.unshift(1);e=F(e,c)}const s=e.shape,i=Array.from(t);for(let c=t.length-1;c>=0;c--)if(s[c]===t[c])i[c]=1;else if(1!==e.shape[c])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);return 0===i.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length?wa(e):R.runKernel(Ep,{x:e},{reps:i})}}),iB=A({ceil_:function vse(n){const e={x:I(n,"x","ceil","float32")};return R.runKernel(zf,e)}});function Cd(n,t,e){return ci(n),R.runKernel(fI,{},{shape:n,value:t,dtype:e})}const Us=A({clipByValue_:function xse(n,t,e){const r=I(n,"x","clipByValue");return S(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e?Cd(r.shape,t,r.dtype):R.runKernel(Uf,{x:r},{clipValueMin:t,clipValueMax:e})}}),oB=A({concat1d_:function wse(n){return Qn(n,0)}}),aB=A({concat2d_:function Cse(n,t){return Qn(n,t)}}),lB=A({concat3d_:function Sse(n,t){return Qn(n,t)}}),cB=A({concat4d_:function Ise(n,t){return Qn(n,t)}}),ml=A({conv2d_:function Ese(n,t,e,r,s="NHWC",i=[1,1],o){const a=I(n,"x","conv2d","float32"),l=I(t,"filter","conv2d","float32");let c=a,u=!1;3===a.rank&&(u=!0,c=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===c.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),S(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),ls("conv2d",r,o);const d="NHWC"===s?c.shape[3]:c.shape[1];S(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),S(Pr(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const p=R.runKernel(Jy,{x:c,filter:l},{strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o});return u?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),BE=A({conv1d_:function Dse(n,t,e,r,s="NWC",i=1,o){const a=I(n,"x","conv1d"),l=I(t,"filter","conv1d");let c=a,u=!1;2===a.rank&&(u=!0,c=F(a,[1,a.shape[0],a.shape[1]])),S(3===c.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),S(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),ls("conv1d",r,o),S(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),S(Pr(e,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${i}'`),S("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=F(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=F(c,[c.shape[0],1,c.shape[1],c.shape[2]]),g=ml(h,d,[1,e],r,"NHWC",[1,i],o);return F(g,u?[g.shape[2],g.shape[3]]:[g.shape[0],g.shape[2],g.shape[3]])}}),VE=A({conv2DBackpropInput_:function Tse(n,t,e,r,s,i="NHWC",o){S(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let a=n,l=t,c=!1;3===t.rank&&(c=!0,l=F(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,n[0],n[1],n[2]]),S(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),S(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),S(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const u="NHWC"===i?a[3]:a[1],d="NHWC"===i?l.shape[3]:l.shape[1];S(u===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[2]}.`),S(d===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`),ls("conv2dDerInput",s,o);const p=R.runKernel(eb,{dy:l,filter:e},{strides:r,pad:s,dataFormat:i,dimRoundingMode:o,inputShape:a});return c?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),zE=A({conv2dTranspose_:function kse(n,t,e,r,s,i){const o=I(n,"x","conv2dTranspose"),a=I(t,"filter","conv2dTranspose");return VE(e,o,a,r,s,"NHWC",i)}}),uB=A({conv3d_:function Nse(n,t,e,r,s="NDHWC",i=[1,1,1]){const o=I(n,"x","conv3d"),a=I(t,"filter","conv3d");let l=o,c=!1;4===o.rank&&(c=!0,l=F(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),S(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),S(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),S(Pr(e,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),S("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const h=R.runKernel(tb,{x:l,filter:a},{strides:e,pad:r,dataFormat:s,dilations:i});return c?F(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),dB=A({conv3DBackpropInput_:function Ase(n,t,e,r,s){S(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let i=n,o=t,a=!1;4===t.rank&&(a=!0,o=F(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const l=i[4],c=o.shape[4];S(5===i.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),S(5===o.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),S(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),S(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),S(c===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${e.shape[4]}.`);const h=R.runKernel(eI,{dy:o,filter:e},{pad:s,strides:r,inputShape:i});return a?F(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),hB=A({conv3dTranspose_:function Rse(n,t,e,r,s){const i=I(n,"x","conv3dTranspose"),o=I(t,"filter","conv3dTranspose");return dB(e,i,o,r,s)}}),h_=A({cos_:function Mse(n){const e={x:I(n,"x","cos","float32")};return R.runKernel(Hf,e)}}),UE=A({cosh_:function Fse(n){const e={x:I(n,"x","cosh","float32")};return R.runKernel(Wf,e)}}),f_=A({cumprod_:function Ose(n,t=0,e=!1,r=!1){const i={x:I(n,"x","cumprod")};return R.runKernel(tI,i,{axis:t,exclusive:e,reverse:r})}}),HE=A({cumsum_:function $se(n,t=0,e=!1,r=!1){const i={x:I(n,"x","cumsum")};return R.runKernel(nb,i,{axis:t,exclusive:e,reverse:r})}}),WE=A({denseBincount_:function Pse(n,t,e,r=!1){const s=I(n,"x","denseBincount"),i=I(t,"weights","denseBincount");return S("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),S(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),S(e>=0,()=>`size must be non-negative, but got ${e}.`),S(i.size===s.size||0===i.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${i.shape}.`),R.runKernel(rI,{x:s,weights:i},{size:e,binaryOutput:r})}}),fB=A({depthToSpace_:function Lse(n,t,e="NHWC"){const r=I(n,"x","depthToSpace","float32"),s="NHWC"===e?r.shape[1]:r.shape[2],i="NHWC"===e?r.shape[2]:r.shape[3],o="NHWC"===e?r.shape[3]:r.shape[1];return S(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),S(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),S(i*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${t} for depthToSpace with input shape\n        ${r.shape}`),S(o%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${r.shape}`),R.runKernel(sI,{x:r},{blockSize:t,dataFormat:e})}}),Op=A({depthwiseConv2d_:function Bse(n,t,e,r,s="NHWC",i=[1,1],o){const a=I(n,"x","depthwiseConv2d","float32"),l=I(t,"filter","depthwiseConv2d","float32");let c=a,u=!1;3===a.rank&&(u=!0,c=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(4===c.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),S(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d="NHWC"===s?c.shape[3]:c.shape[1];S(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),ls("depthwiseConv2d",r,o);const p=R.runKernel(rb,{x:c,filter:l},{strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o});return u?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}}),zse=A({diag_:function Vse(n){const e={x:I(n,"x","diag")};return R.runKernel(aI,e)}}),pB=A({dilation2d_:function Use(n,t,e,r,s=[1,1],i="NHWC"){const o=I(n,"x","dilation2d"),a=I(t,"filter","dilation2d");S(3===o.rank||4===o.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),S(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),S("NHWC"===i,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,c=!1;3===o.rank&&(l=F(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0);const h=R.runKernel(sb,{x:l,filter:a},{strides:e,pad:r,dilations:s});return c?F(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),jE=A({floorDiv_:function Hse(n,t){let e=I(n,"a","floorDiv"),r=I(t,"b","floorDiv");return[e,r]=Pn(e,r),R.runKernel(Zf,{a:e,b:r})}}),Pe=A({div_:function Wse(n,t){let e=I(n,"a","div"),r=I(t,"b","div");return[e,r]=Pn(e,r),"int32"===e.dtype&&"int32"===r.dtype?jE(e,r):R.runKernel(jf,{a:e,b:r},{})}}),go=A({equal_:function jse(n,t){let e=I(n,"a","equal","string_or_numeric"),r=I(t,"b","equal","string_or_numeric");return[e,r]=Pn(e,r),tt(e.shape,r.shape),R.runKernel(ib,{a:e,b:r})}}),Ss=A({where_:function Gse(n,t,e){const r=I(t,"a","where"),s=I(e,"b","where"),i=I(n,"condition","where","bool"),o=tt(tt(i.shape,r.shape),s.shape),a=wd(i,o),l=wd(r,o),c=wd(s,o);return R.runKernel(Ob,{condition:a,t:l,e:c})}}),Ft=A({zerosLike_:function qse(n){const e={x:I(n,"x","zerosLike")};return R.runKernel(Hb,e)}}),mB=A({divNoNan_:function Kse(n,t){let e=I(n,"a","div"),r=I(t,"b","div");[e,r]=Pn(e,r);const s=Pe(e,r),i=Ft(s),o=go(r,i);return Ss(o,i,s)}}),gB=A({dot_:function Xse(n,t){const e=I(n,"t1","dot"),r=I(t,"t2","dot");S(!(1!==e.rank&&2!==e.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);const s=1===e.rank?e.size:e.shape[1],i=1===r.rank?r.size:r.shape[0];if(S(s===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${i}.`),1===e.rank&&1===r.rank){const o=F(e,[1,-1]),a=F(r,[-1,1]),l=_t(o,a);return F(l,[])}if(1===e.rank&&2===r.rank){const o=F(e,[1,-1]),a=F(r,[r.shape[0],r.shape[1]]),l=_t(o,a);return F(l,[l.size])}if(2===e.rank&&1===r.rank){const o=F(r,[-1,1]),a=_t(e,o);return F(a,[a.size])}{const o=F(r,[r.shape[0],r.shape[1]]);return _t(e,o)}}}),Zse=A({einsum_:function Yse(n,...t){const e=t.map((s,i)=>I(s,`tensors${i}`,"einsum"));return R.runKernel(uI,e,{equation:n})}}),$p=A({elu_:function Qse(n){const e={x:I(n,"x","elu","float32")};return R.runKernel(Gf,e)}}),yB=A({erf_:function Jse(n){let t=I(n,"x","erf");return S("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=ve(t,"float32")),R.runKernel(qf,{x:t})}});function GE(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function bB(n,t,e){const r=n.length+t.length,s=[];let i=0,o=0;for(let a=0;a<r;a++)-1===e.indexOf(a)?s.push(n[i++]):s.push(t[o++]);return s}function kr(n,t){const e=[],r=n.length;for(let i=0;i<r;i++)-1===t.indexOf(i)&&e.push(n[i]);return[e,t.map(i=>n[i])]}function Hn(n,t){return bB(n,t.map(r=>1),t)}function Lr(n,t,e){S(GE(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function An(n,t){if(GE(n,t))return null;const e=[];for(let r=0;r<t;++r)-1===n.indexOf(r)&&e.push(r);return n.forEach(r=>e.push(r)),e}function gl(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function Wn(n,t){const e=[];for(let r=t-n;r<t;++r)e.push(r);return e}const Bi=A({max_:function eie(n,t=null,e=!1){const s={x:I(n,"x","max")};return R.runKernel(yb,s,{reductionIndices:t,keepDims:e})}}),Pp=A({min_:function tie(n,t=null,e=!1){const s={x:I(n,"x","min")};return R.runKernel(xb,s,{axis:t,keepDims:e})}}),yl=A({pow_:function nie(n,t){let e=I(n,"base","pow"),r=I(t,"exp","pow");return[e,r]=Pn(e,r),R.runKernel(cp,{a:e,b:r})}}),Gr=A({sqrt_:function rie(n){const e={x:I(n,"x","sqrt","float32")};return R.runKernel(xp,e)}}),rn=A({square_:function sie(n){const t=I(n,"x","square");return R.runKernel("Square",{x:t},{})}}),Re=A({sum_:function iie(n,t=null,e=!1){let r=I(n,"x","sum");return"bool"===r.dtype&&(r=ve(r,"int32")),R.runKernel(Pb,{x:r},{axis:t,keepDims:e})}});function _B(n,t,e=null){if(0===n.rank)return cr(n);if(1!==n.rank&&null===e)return _B(F(n,[-1]),t,e);if(1===n.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===t)return Re(cr(n),e);if(t===1/0)return Bi(cr(n),e);if(t===-1/0)return Pp(cr(n),e);if("euclidean"===t||2===t)return Gr(Re(yl(cr(n),Be(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&2===e.length){if(1===t)return Bi(Re(cr(n),e[0]),e[1]-1);if(t===1/0)return Bi(Re(cr(n),e[1]),e[0]);if(t===-1/0)return Pp(Re(cr(n),e[1]),e[0]);if("fro"===t||"euclidean"===t)return Gr(Re(rn(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const Lp=A({norm_:function oie(n,t="euclidean",e=null,r=!1){const s=_B(n=I(n,"x","norm"),t,e);let i=s.shape;if(r){const o=mt(e,n.shape);i=Hn(s.shape,o)}return F(s,i)}}),vB=A({euclideanNorm_:function aie(n,t=null,e=!1){return Lp(n,"euclidean",t,e)}}),hi=A({exp_:function lie(n){const e={x:I(n,"x","exp")};return R.runKernel(Kf,e)}}),Is=A({expandDims_:function cie(n,t=0){const e=I(n,"x","expandDims","string_or_numeric");return S(t<=e.rank,()=>"Axis must be <= rank of the tensor"),R.runKernel(ob,{input:e},{dim:t})}}),xB=A({expm1_:function uie(n){const e={x:I(n,"x","expm1")};return R.runKernel(Xf,e)}}),Vi=A({tile_:function die(n,t){const e=I(n,"x","tile","string_or_numeric");return S(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`),R.runKernel(Ep,{x:e},{reps:t})}}),qE=A({eye_:function hie(n,t,e,r="float32"){null==t&&(t=n);const s=lt([n,t],r),i=n<=t?n:t;for(let a=0;a<i;++a)s.set(1,a,a);const o=F(s.toTensor(),[n,t]);if(null==e)return o;if(1===e.length)return Vi(Is(o,0),[e[0],1,1]);if(2===e.length)return Vi(Is(Is(o,0),0),[e[0],e[1],1,1]);if(3===e.length)return Vi(Is(Is(Is(o,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}}),Bp=A({floor_:function fie(n){const e={x:I(n,"x","floor","float32")};return R.runKernel(Yf,e)}}),Vp=A({gather_:function pie(n,t,e=0,r=0){const s=I(n,"x","gather"),i=I(t,"indices","gather","int32");return R.runKernel(lb,{x:s,indices:i},{axis:e,batchDims:r})}}),Hs=A({greater_:function mie(n,t){let e=I(n,"a","greater","string_or_numeric"),r=I(t,"b","greater","string_or_numeric");return[e,r]=Pn(e,r),tt(e.shape,r.shape),R.runKernel(cb,{a:e,b:r})}}),bl=A({greaterEqual_:function gie(n,t){let e=I(n,"a","greaterEqual","string_or_numeric"),r=I(t,"b","greaterEqual","string_or_numeric");return[e,r]=Pn(e,r),tt(e.shape,r.shape),R.runKernel(Qf,{a:e,b:r})}}),p_=A({imag_:function yie(n){const e={input:I(n,"input","imag")};return R.runKernel(yI,e)}}),wB=A({isFinite_:function bie(n){const e={x:I(n,"x","isFinite")};return R.runKernel(ep,e)}}),CB=A({isInf_:function _ie(n){const e={x:I(n,"x","isInf")};return R.runKernel(tp,e)}}),SB=A({isNaN_:function vie(n){const e={x:I(n,"x","isNaN")};return R.runKernel(np,e)}}),m_=A({leakyRelu_:function xie(n,t=.2){const r={x:I(n,"x","leakyRelu")};return R.runKernel(ub,r,{alpha:t})}}),KE=A({less_:function wie(n,t){let e=I(n,"a","less","string_or_numeric"),r=I(t,"b","less","string_or_numeric");return[e,r]=Pn(e,r),tt(e.shape,r.shape),R.runKernel(db,{a:e,b:r})}}),Dc=A({lessEqual_:function Cie(n,t){let e=I(n,"a","lessEqual","string_or_numeric"),r=I(t,"b","lessEqual","string_or_numeric");return[e,r]=Pn(e,r),tt(e.shape,r.shape),R.runKernel(hb,{a:e,b:r})}});function Sie(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");return R.runKernel(bI,{},{start:n,stop:t,num:e})}const IB=A({localResponseNormalization_:function Iie(n,t=5,e=1,r=1,s=.5){const i=I(n,"x","localResponseNormalization");S(4===i.rank||3===i.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`),S(id(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=i,a=!1;3===i.rank&&(a=!0,o=F(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const u=R.runKernel(gb,{x:o},{depthRadius:t,bias:e,alpha:r,beta:s});return a?F(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),fi=A({log_:function Eie(n){const e={x:I(n,"x","log","float32")};return R.runKernel(rp,e)}}),g_=A({log1p_:function Die(n){const e={x:I(n,"x","log1p")};return R.runKernel(sp,e)}}),Cn=A({neg_:function Tie(n){const e={x:I(n,"x","neg")};return R.runKernel(Cb,e)}}),Sd=A({softplus_:function kie(n){const e={x:I(n,"x","softplus")};return R.runKernel(vp,e)}}),EB=A({logSigmoid_:function Nie(n){const t=I(n,"x","logSigmoid");return Ca(r=>({value:Cn(Sd(Cn(r))),gradFunc:o=>M(o,Bo(Cn(r)))}))(t)}}),De=A({sub_:function Aie(n,t){let e=I(n,"a","sub"),r=I(t,"b","sub");return[e,r]=Pn(e,r),R.runKernel(Cp,{a:e,b:r})}}),XE=A({logSoftmax_:function Rie(n,t=-1){const e=I(n,"logits","logSoftmax");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return Ca((s,i)=>{const a=Bi(s,t,!0),l=De(s,a),c=De(ve(l,"float32"),fi(Re(hi(l),t,!0)));return i([c]),{value:c,gradFunc:(d,h)=>{const[f]=h,m=hi(f);return De(d,M(Re(d,t,!0),m))}}})(e)}}),YE=A({logSumExp_:function Mie(n,t=null,e=!1){const r=I(n,"x","logSumExp"),s=mt(t,r.shape),i=Bi(r,s,!0),o=De(r,i),a=hi(o),l=Re(a,s),c=fi(l),u=le(F(i,c.shape),c);if(e){const d=Hn(u.shape,s);return F(u,d)}return u}}),Vo=A({logicalAnd_:function Fie(n,t){const e=I(n,"a","logicalAnd","bool"),r=I(t,"b","logicalAnd","bool");return tt(e.shape,r.shape),R.runKernel(fb,{a:e,b:r})}}),y_=A({logicalNot_:function Oie(n){const e={x:I(n,"x","logicalNot","bool")};return R.runKernel(pb,e)}}),ZE=A({logicalOr_:function $ie(n,t){const e=I(n,"a","logicalOr","bool"),r=I(t,"b","logicalOr","bool");return tt(e.shape,r.shape),R.runKernel(mb,{a:e,b:r})}}),DB=A({logicalXor_:function Pie(n,t){const e=I(n,"a","logicalXor","bool"),r=I(t,"b","logicalXor","bool");return tt(e.shape,r.shape),Vo(ZE(n,t),y_(Vo(n,t)))}}),b_=2147483648,QE=A({searchSorted_:function Lie(n,t,e="left"){const r=I(n,"sortedSequence","searchSorted"),s=I(t,"values","searchSorted"),o=s.shape[s.shape.length-1],a=F(r,[-1,r.shape[r.shape.length-1]]),l=F(s,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(X(l.shape)>=b_)throw new Error(`values tensor size must less than ${b_}`);if(a.shape[1]>=b_)throw new Error(`trailing dim_size must less than ${b_} for int32 output type, was ${a.shape[1]}`);return R.runKernel(OI,{sortedSequence:a,values:l},{side:e})}});function Bie(n,t){return QE(n,t,"left")}const __=A({maxPool_:function Vie(n,t,e,r,s){const i=I(n,"x","maxPool");let a=i,l=!1;3===i.rank&&(l=!0,a=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(4===a.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),S(Pr(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),ls("maxPool",r,s);const d=R.runKernel(bb,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s});return l?F(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),TB=A({maxPool3d_:function zie(n,t=[1,1,1],e,r,s,i="NDHWC"){const o=I(n,"x","maxPool3d");let a=o,l=!1;4===o.rank&&(l=!0,a=F(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),S(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),S("NDHWC"===i,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),ls("maxPool3d",r,s);const d=R.runKernel(_b,{x:a},{filterSize:t,strides:e,pad:r,dimRoundingMode:s,dataFormat:i});return l?F(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Hie=A({maxPoolWithArgmax_:function Uie(n,t,e,r,s=!1){const o={x:I(n,"x","maxPoolWithArgmax")},l=R.runKernel(wI,o,{filterSize:t,strides:e,pad:r,includeBatchInIndex:s});return{result:l[0],indexes:l[1]}}}),Ea=A({maximum_:function Wie(n,t){let e=I(n,"a","maximum"),r=I(t,"b","maximum");return[e,r]=Pn(e,r),"bool"===e.dtype&&(e=ve(e,"int32"),r=ve(r,"int32")),tt(e.shape,r.shape),R.runKernel(ip,{a:e,b:r})}}),Ln=A({mean_:function jie(n,t=null,e=!1){const s={x:I(n,"x","mean")};return R.runKernel(vb,s,{axis:t,keepDims:e})}});function ur(n,t="float32"){if(ci(n),"complex64"===t){const r=ur(n,"float32"),s=ur(n,"float32");return cl(r,s)}const e=jr(X(n),t);return R.makeTensor(e,n,t)}function pi(n,t="float32"){if(ci(n),"complex64"===t){const r=pi(n,"float32"),s=ur(n,"float32");return cl(r,s)}const e=US(X(n),t);return R.makeTensor(e,n,t)}function Gie(n,t,{indexing:e="xy"}={}){if("xy"!==e&&"ij"!==e)throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(void 0===n)return[];let r=I(n,"x","meshgrid",n instanceof bn?n.dtype:"float32");if(void 0===t)return[r];let s=I(t,"y","meshgrid",t instanceof bn?t.dtype:"float32");const i=X(r.shape),o=X(s.shape);return"xy"===e?(r=F(r,[1,-1]),s=F(s,[-1,1]),[_t(pi([o,1],r.dtype),r),_t(s,pi([1,i],s.dtype))]):(r=F(r,[-1,1]),s=F(s,[1,-1]),[_t(r,pi([1,o],r.dtype)),_t(pi([i,1],s.dtype),s)])}const zp=A({minimum_:function qie(n,t){let e=I(n,"a","minimum"),r=I(t,"b","minimum");return[e,r]=Pn(e,r),"bool"===e.dtype&&(e=ve(e,"int32"),r=ve(r,"int32")),tt(e.shape,r.shape),R.runKernel(op,{a:e,b:r})}}),kB=A({mirrorPad_:function Kie(n,t,e){S("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const r=I(n,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");S(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s="reflect"===e?1:0;for(let a=0;a<r.rank;a++)S(2===t[a].length,()=>"Invalid number of paddings. Must be length of 2 each."),S(t[a][0]>=0&&t[a][0]<=r.shape[a]-s&&t[a][1]>=0&&t[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);return R.runKernel(wb,{x:r},{paddings:t,mode:e})}}),NB=A({mod_:function Xie(n,t){let e=I(n,"a","mod"),r=I(t,"b","mod");return[e,r]=Pn(e,r),R.runKernel(ap,{a:e,b:r})}}),v_=A({moments_:function Yie(n,t=null,e=!1){const r=mt(t,(n=I(n,"x","moments")).shape),s=Ln(n,r,e);let i=s.shape;e||(i=Hn(s.shape,r));const o=rn(De(ve(n,"float32"),F(s,i)));return{mean:s,variance:Ln(o,r,e)}}}),Qie=A({multiRNNCell_:function Zie(n,t,e,r){const s=I(t,"data","multiRNNCell"),i=t_(e,"c","multiRNNCell"),o=t_(r,"h","multiRNNCell");let a=s;const l=[];for(let d=0;d<n.length;d++){const h=n[d](a,i[d],o[d]);l.push(h[0]),l.push(h[1]),a=h[1]}const c=[],u=[];for(let d=0;d<l.length;d+=2)c.push(l[d]),u.push(l[d+1]);return[c,u]}}),eoe=A({multinomial_:function Jie(n,t,e,r=!1){const s=I(n,"logits","multinomial"),i=s.size,o=s.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);e=e||Math.random();const l={logits:1===o?F(s,[1,-1]):s},u=R.runKernel(CI,l,{numSamples:t,seed:e,normalized:r});return 1===o?F(u,[u.size]):u}}),Id=A({notEqual_:function toe(n,t){let e=I(n,"a","notEqual","string_or_numeric"),r=I(t,"b","notEqual","string_or_numeric");return[e,r]=Pn(e,r),tt(e.shape,r.shape),R.runKernel(Sb,{a:e,b:r})}}),JE=A({oneHot_:function noe(n,t,e=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:I(n,"indices","oneHot","int32")};return R.runKernel(Eb,o,{dtype:s,depth:t,onValue:e,offValue:r})}}),mi=A({onesLike_:function roe(n){const e={x:I(n,"x","onesLike")};return R.runKernel(Ib,e)}}),ioe=A({outerProduct_:function soe(n,t){const e=I(n,"v1","outerProduct"),r=I(t,"v2","outerProduct");S(1===e.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${r.rank}.`);const s=F(e,[-1,1]),i=F(r,[1,-1]);return _t(s,i)}}),_l=A({pad_:function ooe(n,t,e=0){const r=I(n,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return R.runKernel(Tb,{x:r},{paddings:t,constantValue:e})}}),loe=A({pad1d_:function aoe(n,t,e=0){return S(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),_l(n,[t],e)}}),uoe=A({pad2d_:function coe(n,t,e=0){return S(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),_l(n,t,e)}}),hoe=A({pad3d_:function doe(n,t,e=0){return S(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),_l(n,t,e)}}),poe=A({pad4d_:function foe(n,t,e=0){return S(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),_l(n,t,e)}}),x_=A({spaceToBatchND_:function moe(n,t,e){const r=I(n,"x","spaceToBatchND");return S(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),S(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),S(r.shape.reduce((o,a,l)=>l>0&&l<=t.length?o&&(a+e[l-1][0]+e[l-1][1])%t[l-1]==0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`),R.runKernel(Lb,{x:r},{blockShape:t,paddings:e})}}),AB=A({pool_:function goe(n,t,e,r,s,i,o){null==s&&(s=[1,1]),null==i&&(i=1),0===r&&(r="valid");const a=I(n,"x","maxPool");let l=a,c=!1;3===a.rank&&(c=!0,l=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),S(Pr(i,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${s}'`);const u=Li(l.shape,t,i,s,r),d=[u.dilationHeight,u.dilationWidth];let h;h="same"===r?function boe(n,t){const r=n.map((o,a)=>o+(o-1)*(t[a]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),i=r.map((o,a)=>o-s[a]);return r.map((o,a)=>[s[a],i[a]])}([u.filterHeight,u.filterWidth],d):[[0,0],[0,0]];const f=1===d[0]&&1===d[1],[p,m]=function yoe(n,t,e){const r=e.map(u=>u[0]),s=e.map(u=>u[1]),i=n.concat(r,s),o=t.map((u,d)=>(u-i[d]%u)%u),a=s.map((u,d)=>u+o[d]),l=t.map((u,d)=>[r[d],a[d]]),c=t.map((u,d)=>[0,o[d]]);return[l,c]}([u.inHeight,u.inWidth],d,h),g=f?r:"valid",y=f?l:x_(l,d,p),_=("avg"===e?()=>u_(y,t,i,g,o):()=>__(y,t,i,g,o))(),v=f?_:d_(_,d,m);return c?F(v,[v.shape[1],v.shape[2],v.shape[3]]):v}}),w_=A({prelu_:function _oe(n,t){const e=I(n,"x","prelu"),r=I(t,"alpha","prelu");return R.runKernel(kb,{x:e,alpha:r})}}),RB=A({prod_:function voe(n,t=null,e=!1){let r=I(n,"x","prod");return"bool"===r.dtype&&(r=ve(r,"int32")),R.runKernel(Nb,{x:r},{axis:t,keepDims:e})}}),woe=A({raggedGather_:function xoe(n,t,e,r){const s=n.map((u,d)=>I(u,`tensors${d}`,"raggedGather","int32")),i=I(t,"paramsDenseValues","raggedGather"),o=I(e,"indices","raggedGather","int32"),c=R.runKernel(DI,{paramsNestedSplits:s,paramsDenseValues:i,indices:o},{outputRaggedRank:r});return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}}),Soe=A({raggedRange_:function Coe(n,t,e){const r=I(n,"starts","raggedRange"),s=I(t,"limits","raggedRange",r.dtype),i=I(e,"deltas","raggedRange",r.dtype),a=R.runKernel(TI,{starts:r,limits:s,deltas:i});return{rtNestedSplits:a[0],rtDenseValues:a[1]}}}),Eoe=A({raggedTensorToTensor_:function Ioe(n,t,e,r,s){const i=I(n,"shape","raggedTensorToTensor","int32"),o=I(t,"values","raggedTensorToTensor"),a=I(e,"defaultValue","raggedTensorToTensor",o.dtype),l=r.map((d,h)=>I(d,`tensors${h}`,"raggedTensorToTensor","int32"));return R.runKernel(kI,{shape:i,values:o,defaultValue:a,rowPartitionTensors:l},{rowPartitionTypes:s})}}),Toe=A({rand_:function Doe(n,t,e){ci(n);const r=X(n);let s=null;if(null==e||"float32"===e)s=new Float32Array(r);else if("int32"===e)s=new Int32Array(r);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);s=new Uint8Array(r)}for(let i=0;i<r;i++)s[i]=t();return R.makeTensor(s,n,e)}});var C_=Q(340);class eD{constructor(t,e,r,s,i){this.mean=t,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=i||Math.random();this.random=C_.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let t,e,r=!1;for(;!r;){let s,i,o;do{s=2*this.random()-1,i=2*this.random()-1,o=s*s+i*i}while(o>=1||0===o);const a=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*s*a,e=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class koe{constructor(t,e,r,s){this.alpha=t,this.beta=1/e,this.dtype=r;const i=s||Math.random();this.randu=C_.alea(i.toString()),this.randn=new eD(0,1,r,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,r,s,i,o;for(;;){do{s=this.randn.nextValue(),o=1+this.c*s}while(o<=0);if(o*=o*o,t=s*s,e=1-.331*t*t,r=.5*t+this.d*(1-o+Math.log(o)),i=this.randu(),i<e||Math.log(i)<r)break}return o*=1/this.beta*this.d,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}class Noe{constructor(t=0,e=1,r,s){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=r,null==s&&(s=Math.random()),"number"==typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=C_.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Ooe=A({randomGamma_:function Foe(n,t,e=1,r="float32",s){if(ci(n),null==e&&(e=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const i=new koe(t,e,r,s),o=lt(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),nD=A({randomNormal_:function $oe(n,t=0,e=1,r,s){if(ci(n),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const i=new eD(t,e,r,!1,s),o=lt(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),Loe=A({randomStandardNormal_:function Poe(n,t,e){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return nD(n,0,1,t,e)}}),Up=A({randomUniform_:function Boe(n,t=0,e=1,r="float32",s){ci(n);const i=lt(n,r),o=new Noe(t,e,null,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}});function Ed(n,t,e=1,r="float32"){if(0===e)throw new Error("Cannot have a step of zero");return R.runKernel(NI,{},{start:n,stop:t,step:e,dtype:r})}const Hp=A({real_:function Voe(n){const e={input:I(n,"input","real")};return R.runKernel(AI,e)}}),MB=A({reciprocal_:function zoe(n){const e={x:I(n,"x","reciprocal")};return R.runKernel(up,e)}}),zo=A({relu_:function Uoe(n){const e={x:I(n,"x","relu")};return R.runKernel(dp,e)}}),rD=A({relu6_:function Hoe(n){const e={x:I(n,"x","relu6")};return R.runKernel(hp,e)}}),zi=A({reverse_:function Woe(n,t){const r={x:I(n,"x","reverse")};return R.runKernel(Fb,r,{dims:t})}}),Goe=A({reverse1d_:function joe(n){const t=I(n,"x","reverse");return S(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),zi(t,0)}}),Koe=A({reverse2d_:function qoe(n,t){const e=I(n,"x","reverse");return S(2===e.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),zi(e,t)}}),Yoe=A({reverse3d_:function Xoe(n,t){const e=I(n,"x","reverse");return S(3===e.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),zi(e,t)}}),Qoe=A({reverse4d_:function Zoe(n,t){const e=I(n,"x","reverse");return S(4===e.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),zi(e,t)}}),sD=A({round_:function Joe(n){const e={x:I(n,"x","round")};return R.runKernel(fp,e)}}),iD=A({rsqrt_:function eae(n){const e={x:I(n,"x","rsqrt","float32")};return R.runKernel(pp,e)}}),oD=A({selu_:function tae(n){const e={x:I(n,"x","selu")};return R.runKernel(mp,e)}}),aD=A({separableConv2d_:function nae(n,t,e,r,s,i=[1,1],o="NHWC"){const a=I(n,"x","separableConv2d"),l=I(t,"depthwiseFilter","separableConv2d"),c=I(e,"pointwiseFilter","separableConv2d");let u=a,d=!1;if(3===a.rank&&(d=!0,u=F(a,[1,a.shape[0],a.shape[1],a.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");S(4===u.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),S(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),S(4===c.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),S(1===c.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),S(1===c.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const h=l.shape[2],f=l.shape[3];S(c.shape[2]===h*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*f}, but got ${c.shape[2]}.`);const p=Op(u,l,r,s,o,i),g=ml(p,c,1,"valid",o);return d?F(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});function lD(){return(lD=ee(function*(n,t){const e=I(n,"x","setdiff1d"),r=I(t,"y","setdiff1d");S(e.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${r.dtype}).`),S(1===e.rank,()=>`x should be 1D tensor, but got x (${e.shape}).`),S(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=yield e.data(),i=yield r.data(),o=new Set(i);let a=0;for(let u=0;u<s.length;u++)o.has(s[u])||a++;const l=new Er([a],e.dtype),c=new Er([a],"int32");for(let u=0,d=0;u<s.length;u++)o.has(s[u])||(l.values[d]=s[u],c.values[d]=u,d++);return[l.toTensor(),c.toTensor()]})).apply(this,arguments)}const sae=function rae(n,t){return lD.apply(this,arguments)},FB=A({sign_:function iae(n){const e={x:I(n,"x","sign")};return R.runKernel(bp,e)}}),cD=A({sin_:function oae(n){const e={x:I(n,"x","sin","float32")};return R.runKernel(gp,e)}}),uD=A({sinh_:function aae(n){const e={x:I(n,"x","sinh")};return R.runKernel(yp,e)}}),S_=A({slice1d_:function lae(n,t,e){const r=I(n,"x","slice1d");return S(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Mt(r,[t],[e])}}),dD=A({slice2d_:function cae(n,t,e){const r=I(n,"x","slice2d");return S(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Mt(r,t,e)}}),I_=A({slice3d_:function uae(n,t,e){const r=I(n,"x","slice3d");return S(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Mt(r,t,e)}}),Wp=A({slice4d_:function dae(n,t,e){const r=I(n,"x","slice4d");return S(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Mt(r,t,e)}}),E_=A({softmax_:function hae(n,t=-1){const e=I(n,"logits","softmax","float32");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);return R.runKernel(Vb,{logits:e},{dim:t})}}),D_=A({fft_:function fae(n){return S("complex64"===n.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`),R.runKernel("FFT",{input:n})}}),jp=A({ifft_:function pae(n){return S("complex64"===n.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`),R.runKernel(gI,{input:n})}}),hD=A({irfft_:function mae(n){const t=n.shape[n.shape.length-1],e=n.size/t;let r;if(t<=2){const s=F(n,[e,t]);r=jp(s)}else{const s=[e,2*(t-1)],i=F(Hp(n),[e,t]),o=F(p_(n),[e,t]),a=zi(Mt(i,[0,1],[e,t-2]),1),l=M(zi(Mt(o,[0,1],[e,t-2]),1),Be(-1)),c=Qn([i,a],1),u=Qn([o,l],1),d=F(cl(c,u),[s[0],s[1]]);r=jp(d)}if(r=Hp(r),3===n.rank&&0!==n.shape[0]){const s=r,i=n.shape[0];r=F(r,[i,r.shape[0]/i,r.shape[1]]),s.dispose()}return r}}),Ws=A({split_:function gae(n,t,e=0){const s={x:I(n,"x","split")};return R.runKernel(Bb,s,{numOrSizeSplits:t,axis:e})}}),T_=A({rfft_:function yae(n,t){S("float32"===n.dtype,()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const r=n.size/e;let s;if(null!=t&&t<e){const p=n.shape.map(g=>0),m=n.shape.map(g=>g);m[n.shape.length-1]=t,s=Mt(n,p,m),e=t}else if(null!=t&&t>e){const p=n.shape.map(m=>m);p[n.shape.length-1]=t-e,s=Qn([n,ur(p)],n.shape.length-1),e=t}else s=n;const i=Ft(s),o=F(cl(s,i),[r,e]),a=D_(o),l=Math.floor(e/2)+1,c=Hp(a),u=p_(a),d=Ws(c,[l,e-l],c.shape.length-1),h=Ws(u,[l,e-l],u.shape.length-1),f=s.shape.slice();return f[s.shape.length-1]=l,F(cl(d[0],h[0]),f)}}),fD=A({squaredDifference_:function bae(n,t){let e=I(n,"a","squaredDifference"),r=I(t,"b","squaredDifference");return[e,r]=Pn(e,r),tt(e.shape,r.shape),R.runKernel(wp,{a:e,b:r},{})}}),Tc=A({squeeze_:function _ae(n,t){const e=I(n,"x","squeeze","string_or_numeric");return F(e,rl(e.shape,t).newShape)}}),gi=A({stack_:function vae(n,t=0){const e=t_(n,"tensors","stack","string_or_numeric");return S(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&S(t<=e[0].rank,()=>"Axis must be <= rank of the tensor"),R.runKernel(Db,e,{axis:t})}}),Dd=A({step_:function xae(n,t=0){const r={x:I(n,"x","step")};return R.runKernel(Dp,r,{alpha:t})}}),OB=A({stridedSlice_:function wae(n,t,e,r,s=0,i=0,o=0,a=0,l=0){const u={x:I(n,"x","stridedSlice","string_or_numeric")};return R.runKernel(UI,u,{begin:t,end:e,strides:r,beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l})}}),$B=A({tan_:function Cae(n){const e={x:I(n,"x","tan","float32")};return R.runKernel(Sp,e)}});function Es(n,t){rd(n);const e=ll(n,t);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ul(n,null,e,t)}function Gp(n,t,e){if(rd(n),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=ll(n,e);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ul(n,t,r,e)}function Sae(n,t,e){if(rd(n),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=ll(n,e);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return ul(n,t,r,e)}function Iae(n,t,e){if(rd(n),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=ll(n,e);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return ul(n,t,r,e)}function Eae(n,t,e){if(rd(n),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=ll(n,e);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return ul(n,t=t||r,r,e)}const PB=A({topk_:function Dae(n,t=1,e=!0){const r=I(n,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const i={x:r},o={k:t,sorted:e},[a,l]=R.runKernel(GI,i,o);return{values:a,indices:l}}}),pD=A({truncatedNormal_:function Tae(n,t=0,e=1,r,s){if(ci(n),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const i=new eD(t,e,r,!0,s),o=lt(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),LB=A({unique_:function kae(n,t=0){const e=I(n,"x","unique","string_or_numeric");S(e.rank>0,()=>"The input tensor must be at least 1D");const r={x:e},s={axis:t},[i,o]=R.runKernel(KI,r,s);return{values:i,indices:o}}}),mD=A({unsortedSegmentSum_:function Nae(n,t,e){const r=I(n,"x","unsortedSegmentSum"),s=I(t,"segmentIds","unsortedSegmentSum","int32");return S(id(e),()=>"numSegments must be of dtype int"),R.runKernel(Ub,{x:r,segmentIds:s},{numSegments:e})}}),Ui=A({unstack_:function Aae(n,t=0){const e=I(n,"x","unstack","string_or_numeric");return S(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`),R.runKernel(zb,{value:e},{axis:t})}});function Rae(n,t){return QE(n,t,"right")}function BB(n,t=!0,e,r){return R.makeVariable(n,t,e,r)}function gD(n,t){const e=[];for(let i=0;i<t.length;i++)t[i]&&e.push(i);const r=lt(n,"int32"),s=lt([e.length,n.length],"int32");for(let i=0;i<e.length;i++){const o=r.indexToLoc(e[i]);s.values.set(o,i*n.length)}return s.toTensor()}function yD(){return(yD=ee(function*(n){const t=I(n,"condition","whereAsync","bool"),e=yield t.data(),r=gD(t.shape,e);return n!==t&&t.dispose(),r})).apply(this,arguments)}const VB=function Mae(n){return yD.apply(this,arguments)};function bD(){return(bD=ee(function*(n,t,e){const r=I(n,"tensor","boolMask"),s=I(t,"mask","boolMask","bool"),i=e??0,o=s.rank,a=r.shape;S(o>0,()=>"mask cannot be scalar"),Vs(a.slice(i,i+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=i;m<i+o;m++)l*=a[m];const c=a.slice(0,i).concat([l],a.slice(i+o)),u=F(r,c),d=F(s,[-1]),h=yield VB(d),f=Tc(h,[1]),p=Vp(u,f,i);return n!==r&&r.dispose(),t!==s&&s.dispose(),f.dispose(),u.dispose(),d.dispose(),h.dispose(),p})).apply(this,arguments)}const Oae=function Fae(n,t,e){return bD.apply(this,arguments)},Tt=A({transpose_:function $ae(n,t,e){const r=I(n,"x","transpose");if(null==t&&(t=r.shape.map((o,a)=>a).reverse()),S(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(o=>{S(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();const s={x:r},i={perm:t};return"complex64"===r.dtype?z(()=>{let o=Hp(r),a=p_(r);return o=R.runKernel(ud,{x:o},i),a=R.runKernel(ud,{x:a},i),e&&(a=Cn(a)),cl(o,a)}):R.runKernel(ud,s,i)}}),Lae=A({movingAverage_:function Pae(n,t,e,r,s=!0){const i=I(n,"v","movingAverage"),o=I(t,"x","movingAverage"),a=I(e,"decay","movingAverage");(function Cne(n,t){S(n.dtype===t.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`)})(i,o),S(Rt(i.shape,o.shape),()=>"Shape mismatch in v and x");const l=Be(1),c=De(l,a);let u=M(De(o,i),c);if(s){S(null!=r,()=>"When using zeroDebias: true, step is required.");const d=I(r,"step","movingAverage");u=Pe(u,De(l,yl(a,d)))}return le(i,u)}});function zB(n,t,e){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(e.rank<s)throw new Error(i+` update.rank < ${s}. `);if(n.length<r+(e.rank-s))throw new Error(i+` Output shape length < ${r+(e.rank-s)}`);if(e.rank!==s+n.length-r)throw new Error(i+" update.rank != "+(s+n.length-r));for(let o=0;o<s;++o)if(e.shape[o]!==t.shape[o])throw new Error(i+` updates.shape[${o}] (${e.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<e.rank-s;++o)if(e.shape[o+s]!==n[o+r])throw new Error(i+` updates.shape[${o+s}] (${e.shape[o+s]}) != shape[${o+s}] (${n[o+s]})`)}function UB(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===n.size)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}zB(e,t,n)}function qp(n,t,e){const r=t.shape.length,s=r>1?t.shape[r-1]:1,i=e.length;let o=1;for(let d=s;d<i;++d)o*=e[d];const a=s<1?1:s;return{sliceRank:s,numUpdates:X(t.shape)/a,sliceSize:o,strides:[...Le(e.slice(0,s)),1],outputSize:X(e)}}const Vae=A({scatterND_:function Bae(n,t,e){ci(e);const r=I(n,"indices","scatterND","int32"),s=I(t,"updates","scatterND");return UB(s,r,e),R.runKernel(FI,{indices:r,updates:s},{shape:e})}}),Hae=A({sparseToDense_:function Uae(n,t,e,r=0){ci(e);const s=I(n,"sparseIndices","sparseToDense","int32"),i=I(t,"sparseValues","sparseToDense","string_or_numeric"),o=I(r,"defaultValue","sparseToDense",i.dtype);return function zae(n,t,e,r){if("int32"!==n.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(e.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${i}.`);if(0!==t.rank&&(1!==t.rank||t.size!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,i,e,o),R.runKernel(VI,{sparseIndices:s,sparseValues:i,defaultValue:o},{outputShape:e})}}),jae=A({gatherND_:function Wae(n,t){const e=I(t,"indices","gatherND","int32"),s={params:I(n,"x","gatherND","string_or_numeric"),indices:e};return R.runKernel(mI,s)}}),HB=A({dropout_:function qae(n,t,e,r){const s=I(n,"x","dropout");if(S("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),S(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return n instanceof bn?s.clone():s;const i=function Gae(n,t){if(null==t)return n.shape.slice();if(Rt(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let r=0;r<n.shape.length;r++)e.push(null==t[r]&&null!=n.shape[r]?n.shape[r]:t[r]);return e}return t}(s,e),o=1-t,a=Pe(Bp(le(Up(i,0,1,"float32",r),o)),o);return M(s,a)}});function WB(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function _D(n,t,e){const r=1-n%2,s=new Float32Array(n);for(let i=0;i<n;++i){const o=2*Math.PI*i/(n+r-1);s[i]=t-e*Math.cos(o)}return Es(s,"float32")}function vD(){return(vD=ee(function*(n,t,e=1){const r=I(n,"predictions","inTopK"),s=I(t,"targets","inTopK");S(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),S(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Vs(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=r.shape[r.shape.length-1];S(e>0&&e<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${e}`);const o=yield r.data(),a=yield s.data(),[l,c]=[o.length/i,i],u=Sr("bool",l);for(let d=0;d<l;d++){const h=d*c,f=o.subarray(h,h+c),p=[];for(let m=0;m<f.length;m++)p.push({value:f[m],index:m});p.sort((m,g)=>g.value-m.value),u[d]=0;for(let m=0;m<e;m++)if(p[m].index===a[d]){u[d]=1;break}}return n!==r&&r.dispose(),t!==s&&s.dispose(),mo(u,s.shape,"bool")})).apply(this,arguments)}const Xae=function Kae(n,t){return vD.apply(this,arguments)},xD=A({conv2DBackpropFilter_:function Yae(n,t,e,r,s,i="NHWC",o){let a=n;3===n.rank&&(a=F(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;3===l.rank&&(l=F(t,[1,t.shape[0],t.shape[1],t.shape[2]])),S(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),S(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),S(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const c="NHWC"===i?a.shape[3]:a.shape[1],u="NHWC"===i?l.shape[3]:l.shape[1];return S(c===e[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${e[2]}.`),S(u===e[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${e[3]}).`),ls("conv2dDerFilter",s,o),R.runKernel(QS,{x:a,dy:l},{strides:r,pad:s,dataFormat:i,dimRoundingMode:o,filterShape:e})}});function k_(n,t,e){if(null==e||"linear"===e)return n;if("relu"===e)return M(n,Dd(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function N_(n,t){let e=t;const r=lr(n.shape,t.shape);return r.length>0&&(e=Re(e,r)),F(e,n.shape)}function A_(n,t,e,r){if("linear"===t)return n;if("relu"===t)return zo(n);if("elu"===t)return $p(n);if("relu6"===t)return rD(n);if("prelu"===t)return w_(n,e);if("leakyrelu"===t)return m_(n,r);if("sigmoid"===t)return Bo(n);throw new Error(`Unknown fused activation ${t}.`)}const R_=(n,t)=>!(n>0)||"linear"===t,jB=A({fusedConv2d_:function Zae({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(!1===R_(R.state.gradientDepth,l=l||"linear")){S("NHWC"===s,()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let C=ml(n,t,e,r,s,i,o);return null!=a&&(C=le(C,a)),A_(C,l,c,u)}const d=I(n,"x","conv2d","float32"),h=I(t,"filter","conv2d","float32");let f=d,p=!1;3===d.rank&&(p=!0,f=F(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(4===f.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),S(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),ls("fused conv2d",r,o);const m="NHWC"===s?f.shape[3]:f.shape[1];S(h.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`),S(Pr(e,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);const g=Tr(f.shape,h.shape,e,i,r,o);let y,b;if(null!=a&&(y=I(a,"bias","fused conv2d"),[y]=Pn(y,d),"NHWC"===s?tt(g.outShape,y.shape):(S(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),S(0===y.shape.length||y.shape[0]===g.outChannels||1===y.shape[0],()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`))),null!=c){const C=c.shape;if(S(C.length<=1||3===C.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${C.length}.`),1===C.length)S(1===C[0]||C[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the number of output channels (${g.outChannels}).`);else if(3===C.length)try{tt(C,g.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${C}) is not compatible with the output shape of the conv2d (${g.outShape}).`)}b=I(c,"prelu weights","fused conv2d")}const _=(C,E)=>{S("NHWC"===s,()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[D,T,N,P]=E,U=k_(C,N,l);S(pl(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const K=[VE(T.shape,U,D,e,r),xD(T,U,D.shape,e,r)];if(null!=P){const $=N_(P,U);K.push($)}return K},v={x:f,filter:h,bias:y,preluActivationWeights:b},w={strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return null==a?Ca((E,D,T)=>{let N=R.runKernel(jb,v,w);return T([D,E,N]),p&&(N=F(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:_}})(f,h):Ca((E,D,T,N)=>{let P=R.runKernel(jb,v,w);return N([D,E,P,T]),p&&(P=F(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:_}})(f,h,y)}}),GB=A({depthwiseConv2dNativeBackpropFilter_:function Qae(n,t,e,r,s,i=[1,1],o){let a=n;3===n.rank&&(a=F(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;return 3===l.rank&&(l=F(t,[1,t.shape[0],t.shape[1],t.shape[2]])),R.runKernel(iI,{x:a,dy:l},{strides:r,pad:s,dimRoundingMode:o,dilations:i,filterShape:e})}}),qB=A({depthwiseConv2dNativeBackpropInput_:function Jae(n,t,e,r,s,i=[1,1],o){let a=t,l=!1;3===t.rank&&(l=!0,a=F(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const d=R.runKernel(oI,{dy:a,filter:e},{strides:r,pad:s,dimRoundingMode:o,dilations:i,inputShape:n});return l?F(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),tle=A({fusedDepthwiseConv2d_:function ele({x:n,filter:t,strides:e,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(!1===R_(R.state.gradientDepth,l)){let w=Op(n,t,e,r,s,i,o);return null!=a&&(w=le(w,a)),A_(w,l,c,u)}const d=I(n,"x","depthwiseConv2d","float32"),h=I(t,"filter","depthwiseConv2d","float32");let f=d,p=!1;3===d.rank&&(p=!0,f=F(d,[1,d.shape[0],d.shape[1],d.shape[2]])),S(4===f.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),S(4===h.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),S(f.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),null==i&&(i=[1,1]),S(Pr(e,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),ls("fused depthwiseConv2d",r,o);const m=Tr(f.shape,h.shape,e,i,r,o,!0);let g,y;null!=a&&(g=I(a,"bias","fused conv2d"),[g]=Pn(g,d),tt(m.outShape,g.shape)),null!=c&&(y=I(c,"prelu weights","fused depthwiseConv2d"));const b=(w,C)=>{S(pl(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[E,D,T,N]=C,P=k_(w,T,l),U=qB(D.shape,P,E,e,r,i,o),j=GB(D,P,E.shape,e,r,i,o);return null!=N?[U,j,N_(g,P)]:[U,j]},_={x:f,filter:h,bias:g,preluActivationWeights:y},v={strides:e,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return null==a?Ca((C,E,D)=>{let T=R.runKernel(Gb,_,v);return D([E,C,T]),p&&(T=F(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:b}})(f,h):Ca((C,E,D,T)=>{let N=R.runKernel(Gb,_,v);return T([E,C,N,D]),p&&(N=F(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:b}})(f,h,g)}}),wD=A({fusedMatMul_:function nle({a:n,b:t,transposeA:e=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(!1===R_(R.state.gradientDepth,i)){let P=_t(n,t,e,r);return null!=s&&(P=le(P,s)),A_(P,i,o,a)}let l=I(n,"a","fused matMul"),c=I(t,"b","fused matMul");[l,c]=Pn(l,c);const u=e?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?c.shape[c.rank-1]:c.shape[c.rank-2],h=e?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?c.shape[c.rank-2]:c.shape[c.rank-1],p=l.shape.slice(0,-2),m=c.shape.slice(0,-2),g=X(p),y=X(m);S(u===d,()=>`Error in fused matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${e} and transposeB=${r} must match.`);const _=tt(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([h,f]),v=F(l,e?[g,u,h]:[g,h,u]),w=F(c,r?[y,f,d]:[y,d,f]);let C,E;null!=s&&(C=I(s,"bias","fused matMul"),[C]=Pn(C,l),tt(_,C.shape)),null!=o&&(E=I(o,"prelu weights","fused matMul"));const D=(P,U)=>{const[j,q,K,$]=U,V=k_(F(P,K.shape),K,i);let L,W;return e||r?!e&&r?(L=_t(V,q,!1,!1),W=_t(V,j,!0,!1)):e&&!r?(L=_t(q,V,!1,!0),W=_t(j,V,!1,!1)):(L=_t(q,V,!0,!0),W=_t(V,j,!0,!0)):(L=_t(V,q,!1,!0),W=_t(j,V,!0,!1)),null!=s?[L,W,N_($,V)]:[L,W]},T={a:v,b:w,bias:C,preluActivationWeights:E},N={transposeA:e,transposeB:r,activation:i,leakyreluAlpha:a};return null==s?Ca((U,j,q)=>{const K=R.runKernel(Wb,T,N);return q([U,j,K]),{value:F(K,_),gradFunc:D}})(v,w):Ca((U,j,q,K)=>{const $=R.runKernel(Wb,T,N);return K([U,j,$,q]),{value:F($,_),gradFunc:D}})(v,w,C)}}),sle=A({hammingWindow_:function rle(n){return _D(n,.54,.46)}}),KB=A({hannWindow_:function ile(n){return _D(n,.5,.5)}}),XB=A({frame_:function ole(n,t,e,r=!1,s=0){let i=0;const o=[];for(;i+t<=n.size;)o.push(Mt(n,i,t)),i+=e;if(r)for(;i<n.size;){const a=i+t-n.size,l=Qn([Mt(n,i,t-a),Cd([a],s)]);o.push(l),i+=e}return 0===o.length?Gp([],[0,t]):F(Qn(o),[o.length,t])}}),lle=A({stft_:function ale(n,t,e,r,s=KB){null==r&&(r=WB(t));const i=XB(n,t,e),o=M(i,s(t));return T_(o,r)}}),ule=A({cropAndResize_:function cle(n,t,e,r,s="bilinear",i=0){const o=I(n,"image","cropAndResize"),a=I(t,"boxes","cropAndResize","float32"),l=I(e,"boxInd","cropAndResize","int32"),c=a.shape[0];return S(4===o.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),S(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),S(1===l.rank&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),S(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),S(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),S("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),R.runKernel(nI,{image:o,boxes:a,boxInd:l},{method:s,extrapolationValue:i,cropSize:r})}}),hle=A({flipLeftRight_:function dle(n){const t=I(n,"image","flipLeftRight","float32");return S(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),R.runKernel(pI,{image:t},{})}}),ple=A({grayscaleToRGB_:function fle(n){const t=I(n,"image","grayscaleToRGB"),e=t.rank-1,r=t.shape[e];S(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),S(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(t.rank);return s.fill(1,0,e),s[e]=3,Vi(t,s)}}),gle=A({rotateWithOffset_:function mle(n,t,e=0,r=.5){const s=I(n,"image","rotateWithOffset","float32");return S(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),R.runKernel(YI,{image:s},{radians:t,fillValue:e,center:r})}});function Td(n,t,e,r,s,i){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==i&&(i=0);const o=n.shape[0];return e=Math.min(e,o),S(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),S(2===n.rank,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),S(4===n.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),S(1===t.rank,()=>"scores must be a 1D tensor"),S(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),S(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:s,softNmsSigma:i}}const ble=A({nonMaxSuppression_:function yle(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const i=I(n,"boxes","nonMaxSuppression","float32"),o=I(t,"scores","nonMaxSuppression","float32"),a=Td(i,o,e,r,s);return R.runKernel(SI,{boxes:i,scores:o},{maxOutputSize:e=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}});function _le(n,t,e){const r=function vle(n,t,e){return function wle(n,t,e){let r=0,s=n.length,i=0,o=!1;for(;r<s;){i=r+(s-r>>>1);const a=e(t,n[i]);a>0?r=i+1:(s=i,o=!a)}return o?r:-r-1}(n,t,e||xle)}(n,t,e);n.splice(r<0?-(r+1):r,0,t)}function xle(n,t){return n>t?1:n<t?-1:0}function CD(n,t,e,r,s){return ED(n,t,e,r,s,0)}function SD(n,t,e,r,s,i){return ED(n,t,e,r,s,0,!1,i,!0)}function ID(n,t,e,r,s,i){return ED(n,t,e,r,s,i,!0)}function ED(n,t,e,r,s,i,o=!1,a=!1,l=!1){const c=[];for(let g=0;g<t.length;g++)t[g]>s&&c.push({score:t[g],boxIndex:g,suppressBeginIndex:0});c.sort(YB);const u=i>0?-.5/i:0,d=[],h=[];for(;d.length<e&&c.length>0;){const g=c.pop(),{score:y,boxIndex:b,suppressBeginIndex:_}=g;if(y<s)break;let v=!1;for(let w=d.length-1;w>=_;--w){const C=Cle(n,b,d[w]);if(C>=r){v=!0;break}if(g.score=g.score*Sle(r,u,C),g.score<=s)break}g.suppressBeginIndex=d.length,v||(g.score===y?(d.push(b),h.push(g.score)):g.score>s&&_le(c,g,YB))}const f=d.length,p=e-f;a&&p>0&&(d.push(...new Array(p).fill(0)),h.push(...new Array(p).fill(0)));const m={selectedIndices:d};return o&&(m.selectedScores=h),l&&(m.validOutputs=f),m}function Cle(n,t,e){const r=n.subarray(4*t,4*t+4),s=n.subarray(4*e,4*e+4),i=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(s[0],s[2]),u=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),f=(a-i)*(l-o),p=(d-c)*(h-u);if(f<=0||p<=0)return 0;const m=Math.max(i,c),g=Math.max(o,u),y=Math.min(a,d),b=Math.min(l,h),_=Math.max(y-m,0)*Math.max(b-g,0);return _/(f+p-_)}function Sle(n,t,e){const r=Math.exp(t*e*e);return e<=n?r:0}function YB(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}function DD(){return(DD=ee(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY){const i=I(n,"boxes","nonMaxSuppressionAsync"),o=I(t,"scores","nonMaxSuppressionAsync"),a=Td(i,o,e,r,s);e=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=yield Promise.all([i.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:d}=CD(c,u,e,r,s);return i!==n&&i.dispose(),o!==t&&o.dispose(),Es(d,"int32")})).apply(this,arguments)}const Tle=A({nonMaxSuppressionWithScore_:function Dle(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=I(n,"boxes","nonMaxSuppression"),a=I(t,"scores","nonMaxSuppression"),l=Td(o,a,e,r,s,i),d=R.runKernel(EI,{boxes:o,scores:a},{maxOutputSize:e=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:i=l.softNmsSigma});return{selectedIndices:d[0],selectedScores:d[1]}}});function TD(){return(TD=ee(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=I(n,"boxes","nonMaxSuppressionAsync"),a=I(t,"scores","nonMaxSuppressionAsync"),l=Td(o,a,e,r,s,i);e=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const c=yield Promise.all([o.data(),a.data()]),u=c[0],d=c[1],{selectedIndices:h,selectedScores:f}=ID(u,d,e,r,s,i);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:Es(h,"int32"),selectedScores:Es(f)}})).apply(this,arguments)}const Rle=A({nonMaxSuppressionPadded_:function Ale(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=I(n,"boxes","nonMaxSuppression"),a=I(t,"scores","nonMaxSuppression"),l=Td(o,a,e,r,s,null),p=R.runKernel(II,{boxes:o,scores:a},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:i});return{selectedIndices:p[0],validOutputs:p[1]}}});function kD(){return(kD=ee(function*(n,t,e,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=I(n,"boxes","nonMaxSuppressionAsync"),a=I(t,"scores","nonMaxSuppressionAsync"),l=Td(o,a,e,r,s,null),c=l.maxOutputSize,u=l.iouThreshold,d=l.scoreThreshold,[h,f]=yield Promise.all([o.data(),a.data()]),{selectedIndices:p,validOutputs:m}=SD(h,f,c,u,d,i);return o!==n&&o.dispose(),a!==t&&a.dispose(),{selectedIndices:Es(p,"int32"),validOutputs:Be(m,"int32")}})).apply(this,arguments)}const ZB=A({resizeBilinear_:function Ole(n,t,e=!1,r=!1){const s=I(n,"images","resizeBilinear");S(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),S(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),S(!1===r||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;3===s.rank&&(o=!0,i=F(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,c=R.runKernel(Mb,{images:i},{alignCorners:e,halfPixelCenters:r,size:t});return o?F(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),QB=A({resizeNearestNeighbor_:function $le(n,t,e=!1,r=!1){const s=I(n,"images","resizeNearestNeighbor");S(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),S(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),S("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),S(!1===r||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;3===s.rank&&(o=!0,i=F(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,c=R.runKernel(Rb,{images:i},{alignCorners:e,halfPixelCenters:r,size:t});return o?F(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),Ble=A({threshold_:function Ple(n,t="binary",e=!1,r=.5){const s=I(n,"image","threshold"),l=s.shape[0]*s.shape[1];let u,d,h,f,c=M(Es([r]),255);if(S(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),S(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),S("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),S("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===s.shape[2]){[u,d,h]=Ws(s,[1,1,1],-1);const g=M(u,.2989),y=M(d,.587),b=M(h,.114);f=le(le(g,y),b)}else f=n;"otsu"===t&&(c=function Lle(n,t){let i,o,a,l,c,u,e=Es([-1]),r=Es([0]),s=Es([0]);for(let d=0;d<n.size-1;d++){i=Mt(n,0,d+1),o=Mt(n,d+1),c=Pe(Re(i),t),u=Pe(Re(o),t);const h=Re(M(i,Ed(0,i.size)));a=Pe(h,Re(i));const f=Cd(o.shape,i.size),p=le(Ed(0,o.size),f),m=M(o,p);l=Pe(Re(m),Re(o));const g=De(a,l),y=De(a,l),b=M(c,u);s=M(M(b,g),y);const _=Hs(s,r);r=Ss(_,s,r),e=Ss(_,Es([d]),e)}return e}(sB(ve(sD(f),"int32"),mo([]),256),l));const p=e?Dc(f,c):Hs(f,c);return ve(M(p,255),"int32")}}),zle=A({transform_:function Vle(n,t,e="nearest",r="constant",s=0,i){const o=I(n,"image","transform","float32"),a=I(t,"transforms","transform","float32");return S(4===o.rank,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),S(2===a.rank&&(a.shape[0]===o.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),S(null==i||2===i.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`),R.runKernel(qI,{image:o,transforms:a},{interpolation:e,fillMode:r,fillValue:s,outputShape:i})}}),Hle=A({bandPart_:function Ule(n,t,e){S(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),S(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);const r=I(n,"a","bandPart");S(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[i,o]=r.shape.slice(-2);if(!(t<=i))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`);if(!(e<=o))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${o}).`);t<0&&(t=i),e<0&&(e=o);const a=F(Ed(0,i,1,"int32"),[-1,1]),l=Ed(0,o,1,"int32"),c=De(a,l),u=Vo(Dc(c,Be(+t,"int32")),bl(c,Be(-e,"int32"))),d=ur([i,o],r.dtype);return F(gi(Ui(F(r,[-1,i,o])).map(h=>Ss(u,h,d))),s)}}),jle=A({gramSchmidt_:function Wle(n){let t;if(Array.isArray(n)){t=!1,S(null!=n&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let i=1;i<n.length;++i)S(n[i].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${s})`)}else t=!0,n=Ws(n,n.shape[0],0).map(s=>Tc(s,[0]));S(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],r=n;for(let s=0;s<n.length;++s)e.push(R.tidy(()=>{let i=r[s];if(s>0)for(let o=0;o<s;++o){const a=M(Re(M(e[o],i)),e[o]);i=De(i,a)}return Pe(i,Lp(i,"euclidean"))}));return t?gi(e,0):e}});function JB(n,t=!1){return R.tidy(()=>{S(2===n.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],r=n.shape[1];let s=qE(e),i=wa(n);const o=Gp([[1]],[1,1]);let a=wa(o);const l=e>=r?r:e;for(let c=0;c<l;++c){const u=i,d=a,h=s;[a,i,s]=R.tidy(()=>{const f=Mt(i,[c,c],[e-c,1]),p=Lp(f),m=Mt(i,[c,c],[1,1]),g=Ss(Hs(m,0),Gp([[-1]]),Gp([[1]])),y=De(m,M(g,p)),b=Pe(f,y);a=1===b.shape[0]?wa(o):Qn([o,Mt(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const _=Cn(Pe(_t(g,y),p)),v=Mt(i,[c,0],[e-c,r]),w=M(_,a),C=Tt(a);if(0===c)i=De(v,_t(w,_t(C,v)));else{const T=De(v,_t(w,_t(C,v)));i=Qn([Mt(i,[0,0],[c,r]),T],0)}const E=Tt(w),D=Mt(s,[0,c],[e,s.shape[1]-c]);if(0===c)s=De(D,_t(_t(D,a),E));else{const T=De(D,_t(_t(D,a),E));s=Qn([Mt(s,[0,0],[e,c]),T],1)}return[a,i,s]}),Je([u,d,h])}return!t&&e>r&&(s=Mt(s,[0,0],[e,r]),i=Mt(i,[0,0],[r,r])),[s,i]})}const qle=A({qr_:function Gle(n,t=!1){if(S(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),2===n.rank)return JB(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),r=Ui(F(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],i=[];return r.forEach(l=>{const[c,u]=JB(l,t);s.push(c),i.push(u)}),[F(gi(s,0),n.shape),F(gi(i,0),n.shape)]}}});var cs=(()=>{return(n=cs||(cs={}))[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",cs;var n})();const Da=A({computeWeightedLoss_:function Kle(n,t,e=cs.SUM_BY_NONZERO_WEIGHTS){const r=I(n,"losses","computeWeightedLoss");let s=null;null!=t&&(s=I(t,"weights","computeWeightedLoss"));const i=null==s?r:M(r,s);if(e===cs.NONE)return i;if(e===cs.SUM)return Re(i);if(e===cs.MEAN){if(null==s)return Ln(i);{const o=r.size/s.size,a=Pe(Re(i),Re(s));return o>1?Pe(a,Be(o)):a}}if(e===cs.SUM_BY_NONZERO_WEIGHTS){if(null==s)return Pe(Re(i),Be(r.size));{const o=M(s,pi(r.shape)),a=ve(Re(Id(o,Be(0))),"float32");return Pe(Re(i),a)}}throw Error(`Unknown reduction: ${e}`)}}),Yle=A({absoluteDifference_:function Xle(n,t,e,r=cs.SUM_BY_NONZERO_WEIGHTS){const s=I(n,"labels","absoluteDifference"),i=I(t,"predictions","absoluteDifference");let o=null;null!=e&&(o=I(e,"weights","absoluteDifference")),Vs(s.shape,i.shape,"Error in absoluteDifference: ");const a=cr(De(s,i));return Da(a,o,r)}}),Qle=A({cosineDistance_:function Zle(n,t,e,r,s=cs.SUM_BY_NONZERO_WEIGHTS){const i=I(n,"labels","cosineDistance"),o=I(t,"predictions","cosineDistance");let a=null;null!=r&&(a=I(r,"weights","cosineDistance")),Vs(i.shape,o.shape,"Error in cosineDistance: ");const l=Be(1),c=De(l,Re(M(i,o),e,!0));return Da(c,a,s)}}),ece=A({hingeLoss_:function Jle(n,t,e,r=cs.SUM_BY_NONZERO_WEIGHTS){let s=I(n,"labels","hingeLoss");const i=I(t,"predictions","hingeLoss");let o=null;null!=e&&(o=I(e,"weights","hingeLoss")),Vs(s.shape,i.shape,"Error in hingeLoss: ");const a=Be(1);s=De(M(Be(2),s),a);const l=zo(De(a,M(s,i)));return Da(l,o,r)}}),nce=A({huberLoss_:function tce(n,t,e,r=1,s=cs.SUM_BY_NONZERO_WEIGHTS){const i=I(n,"labels","huberLoss"),o=I(t,"predictions","huberLoss");let a=null;null!=e&&(a=I(e,"weights","huberLoss")),Vs(i.shape,o.shape,"Error in huberLoss: ");const l=Be(r),c=cr(De(o,i)),u=zp(c,l),d=De(c,u),h=le(M(Be(.5),rn(u)),M(l,d));return Da(h,a,s)}}),sce=A({logLoss_:function rce(n,t,e,r=1e-7,s=cs.SUM_BY_NONZERO_WEIGHTS){const i=I(n,"labels","logLoss"),o=I(t,"predictions","logLoss");let a=null;null!=e&&(a=I(e,"weights","logLoss")),Vs(i.shape,o.shape,"Error in logLoss: ");const l=Be(1),c=Be(r),u=Cn(M(i,fi(le(o,c)))),d=M(De(l,i),fi(le(De(l,o),c))),h=De(u,d);return Da(h,a,s)}}),oce=A({meanSquaredError_:function ice(n,t,e,r=cs.SUM_BY_NONZERO_WEIGHTS){const s=I(n,"labels","meanSquaredError"),i=I(t,"predictions","meanSquaredError");let o=null;null!=e&&(o=I(e,"weights","meanSquaredError")),Vs(s.shape,i.shape,"Error in meanSquaredError: ");const a=fD(s,i);return Da(a,o,r)}}),cce=A({sigmoidCrossEntropy_:function lce(n,t,e,r=0,s=cs.SUM_BY_NONZERO_WEIGHTS){let i=I(n,"multiClassLabels","sigmoidCrossEntropy");const o=I(t,"logits","sigmoidCrossEntropy");let a=null;if(null!=e&&(a=I(e,"weights","sigmoidCrossEntropy")),Vs(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const c=Be(r),u=Be(1),d=Be(.5);i=le(M(i,De(u,c)),M(d,c))}const l=function ace(n,t){const e=I(n,"labels","sigmoidCrossEntropyWithLogits"),r=I(t,"logits","sigmoidCrossEntropyWithLogits");Vs(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=zo(r),i=M(r,e),o=g_(hi(Cn(cr(r))));return le(De(s,i),o)}(i,o);return Da(l,a,s)}}),hce=A({softmaxCrossEntropy_:function dce(n,t,e,r=0,s=cs.SUM_BY_NONZERO_WEIGHTS){let i=I(n,"onehotLabels","softmaxCrossEntropy");const o=I(t,"logits","softmaxCrossEntropy");let a=null;if(null!=e&&(a=I(e,"weights","softmaxCrossEntropy")),Vs(i.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const c=Be(r),u=Be(1),d=Be(i.shape[1]);i=le(M(i,De(u,c)),Pe(c,d))}const l=function uce(n,t,e=-1){if(-1===e&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return Ca((s,i,o)=>{const l=YE(i,[e],!0),c=De(ve(i,"float32"),l);o([s,c]);const u=Cn(M(c,s));return{value:Re(u,[e]),gradFunc:(f,p)=>{const[m,g]=p,y=Hn(f.shape,[e]);return[M(F(f,y),De(ve(m,"float32"),hi(g))),M(F(f,y),De(hi(g),ve(m,"float32")))]}}})(n,t)}(i,o);return Da(l,a,s)}}),pce=A({sparseFillEmptyRows_:function fce(n,t,e,r){const s=I(n,"indices","sparseFillEmptyRows","int32"),i=I(t,"values","sparseFillEmptyRows"),o=I(e,"denseShape","sparseFillEmptyRows","int32"),a=I(r,"defaultValue","sparseFillEmptyRows",i.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==i.rank)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(1!==o.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(0!==a.rank)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const c=R.runKernel($I,{indices:s,values:i,denseShape:o,defaultValue:a});return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}}),gce=A({sparseReshape_:function mce(n,t,e){const r=I(n,"inputIndices","sparseReshape","int32"),s=I(t,"inputShape","sparseReshape","int32"),i=I(e,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const a=R.runKernel(PI,{inputIndices:r,inputShape:s,newShape:i});return{outputIndices:a[0],outputShape:a[1]}}}),bce=A({sparseSegmentMean_:function yce(n,t,e){const r=I(n,"data","sparseSegmentMean"),s=I(t,"indices","sparseSegmentMean","int32"),i=I(e,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${i.shape}`);return R.runKernel(LI,{data:r,indices:s,segmentIds:i})}}),vce=A({sparseSegmentSum_:function _ce(n,t,e){const r=I(n,"data","sparseSegmentSum"),s=I(t,"indices","sparseSegmentSum","int32"),i=I(e,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${i.shape}`);return R.runKernel(BI,{data:r,indices:s,segmentIds:i})}}),wce=A({stringNGrams_:function xce(n,t,e,r,s,i,o,a){const l=I(n,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=I(t,"dataSplits","stringNGrams");if("int32"!==c.dtype)throw new Error("Data splits must be of datatype int32");const h=R.runKernel(HI,{data:l,dataSplits:c},{separator:e,nGramWidths:r,leftPad:s,rightPad:i,padWidth:o,preserveShortSequences:a});return{nGrams:h[0],nGramsSplits:h[1]}}}),Sce=A({stringSplit_:function Cce(n,t,e=!0){const r=I(n,"input","stringSplit","string"),s=I(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a=R.runKernel(WI,{input:r,delimiter:s},{skipEmpty:e});return{indices:a[0],values:a[1],shape:a[2]}}}),Ece=A({stringToHashBucketFast_:function Ice(n,t){const e=I(n,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");return R.runKernel(jI,{input:e},r)}}),Dce={fft:D_,ifft:jp,rfft:T_,irfft:hD},Tce={hammingWindow:sle,hannWindow:KB,frame:XB,stft:lle},Ta={flipLeftRight:hle,grayscaleToRGB:ple,resizeNearestNeighbor:QB,resizeBilinear:ZB,rotateWithOffset:gle,cropAndResize:ule,nonMaxSuppression:ble,nonMaxSuppressionAsync:function Ile(n,t,e){return DD.apply(this,arguments)},nonMaxSuppressionWithScore:Tle,nonMaxSuppressionWithScoreAsync:function kle(n,t,e){return TD.apply(this,arguments)},nonMaxSuppressionPadded:Rle,nonMaxSuppressionPaddedAsync:function Mle(n,t,e){return kD.apply(this,arguments)},threshold:Ble,transform:zle},eV={bandPart:Hle,gramSchmidt:jle,qr:qle},kce={absoluteDifference:Yle,computeWeightedLoss:Da,cosineDistance:Qle,hingeLoss:ece,huberLoss:nce,logLoss:sce,meanSquaredError:oce,sigmoidCrossEntropy:cce,softmaxCrossEntropy:hce},Nce={sparseFillEmptyRows:pce,sparseReshape:gce,sparseSegmentMean:bce,sparseSegmentSum:vce},Ace={stringNGrams:wce,stringSplit:Sce,stringToHashBucketFast:Ece};let ND=(()=>{class n extends hl{constructor(e,r,s=null){super(),this.learningRate=e,this.rho=r,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==s&&(this.epsilon=R.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=R.registeredVariables[s];null==this.accumulatedGrads[i]&&(this.accumulatedGrads[i]={originalName:`${s}/accum_grad`,variable:z(()=>Ft(o).variable(!1))}),null==this.accumulatedUpdates[i]&&(this.accumulatedUpdates[i]={originalName:`${s}/accum_var`,variable:z(()=>Ft(o).variable(!1))});const l=Array.isArray(e)?e[i].tensor:e[s];if(null==l)return;const c=this.accumulatedGrads[i].variable,u=this.accumulatedUpdates[i].variable;z(()=>{const d=le(M(c,this.rho),M(rn(l),1-this.rho)),h=M(Pe(Gr(le(u,this.epsilon)),Gr(le(c,this.epsilon))),l),f=le(M(u,this.rho),M(rn(h),1-this.rho));c.assign(d),u.assign(f);const p=le(M(h,-this.learningRate),o);o.assign(p)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Je(this.accumulatedGrads.map(e=>e.variable)),Je(this.accumulatedUpdates.map(e=>e.variable)))}getWeights(){var e=this;return ee(function*(){const r=[...e.accumulatedGrads,...e.accumulatedUpdates];return[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return ee(function*(){const s=(e=yield r.extractIterations(e)).length/2;r.accumulatedGrads=e.slice(0,s).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),r.accumulatedUpdates=e.slice(s,2*s).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,r){return new e(r.learningRate,r.rho,r.epsilon)}}return n.className="Adadelta",n})();se(ND);let AD=(()=>{class n extends hl{constructor(e,r=.1){super(),this.learningRate=e,this.initialAccumulatorValue=r,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=R.registeredVariables[s];null==this.accumulatedGrads[i]&&(this.accumulatedGrads[i]={originalName:`${s}/accumulator`,variable:z(()=>Cd(o.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[i].tensor:e[s];if(null==a)return;const l=this.accumulatedGrads[i].variable;z(()=>{const c=le(l,rn(a));l.assign(c);const u=le(M(Pe(a,Gr(le(c,R.backend.epsilon()))),-this.learningRate),o);o.assign(u)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Je(this.accumulatedGrads.map(e=>e.variable))}getWeights(){var e=this;return ee(function*(){return[yield e.saveIterations()].concat(e.accumulatedGrads.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(e){var r=this;return ee(function*(){e=yield r.extractIterations(e),r.accumulatedGrads=e.map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,r){return new e(r.learningRate,r.initialAccumulatorValue)}}return n.className="Adagrad",n})();se(AD);let RD=(()=>{class n extends hl{constructor(e,r,s,i=null){super(),this.learningRate=e,this.beta1=r,this.beta2=s,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],z(()=>{this.accBeta1=Be(r).variable(),this.accBeta2=Be(s).variable()}),null==i&&(this.epsilon=R.backend.epsilon())}applyGradients(e){const r=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);z(()=>{const s=De(1,this.accBeta1),i=De(1,this.accBeta2);r.forEach((o,a)=>{const l=R.registeredVariables[o];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:z(()=>Ft(l).variable(!1))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${o}/v`,variable:z(()=>Ft(l).variable(!1))});const u=Array.isArray(e)?e[a].tensor:e[o];if(null==u)return;const d=this.accumulatedFirstMoment[a].variable,h=this.accumulatedSecondMoment[a].variable,f=le(M(d,this.beta1),M(u,1-this.beta1)),p=le(M(h,this.beta2),M(rn(u),1-this.beta2)),m=Pe(f,s),g=Pe(p,i);d.assign(f),h.assign(p);const y=le(M(Pe(m,le(Gr(g),this.epsilon)),-this.learningRate),l);l.assign(y)}),this.accBeta1.assign(M(this.accBeta1,this.beta1)),this.accBeta2.assign(M(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Je(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&Je(this.accumulatedSecondMoment.map(e=>e.variable))}getWeights(){var e=this;return ee(function*(){const r=[...e.accumulatedFirstMoment,...e.accumulatedSecondMoment];return[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return ee(function*(){e=yield r.extractIterations(e),z(()=>{r.accBeta1.assign(yl(r.beta1,r.iterations_+1)),r.accBeta2.assign(yl(r.beta2,r.iterations_+1))});const s=e.length/2;r.accumulatedFirstMoment=e.slice(0,s).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)})),r.accumulatedSecondMoment=e.slice(s,2*s).map(o=>({originalName:o.name,variable:o.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,r){return new e(r.learningRate,r.beta1,r.beta2,r.epsilon)}}return n.className="Adam",n})();se(RD);let MD=(()=>{class n extends hl{constructor(e,r,s,i=null,o=0){super(),this.learningRate=e,this.beta1=r,this.beta2=s,this.epsilon=i,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],z(()=>{this.iteration=Be(0).variable(),this.accBeta1=Be(r).variable()}),null==i&&(this.epsilon=R.backend.epsilon())}applyGradients(e){const r=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);z(()=>{const s=De(1,this.accBeta1),i=Pe(-this.learningRate,le(M(this.iteration,this.decay),1));r.forEach((o,a)=>{const l=R.registeredVariables[o];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:Ft(l).variable(!1)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${o}/v`,variable:Ft(l).variable(!1)});const u=Array.isArray(e)?e[a].tensor:e[o];if(null==u)return;const d=this.accumulatedFirstMoment[a].variable,h=this.accumulatedWeightedInfNorm[a].variable,f=le(M(d,this.beta1),M(u,1-this.beta1)),p=M(h,this.beta2),m=cr(u),g=Ea(p,m);d.assign(f),h.assign(g);const y=le(M(Pe(i,s),Pe(f,le(g,this.epsilon))),l);l.assign(y)}),this.iteration.assign(le(this.iteration,1)),this.accBeta1.assign(M(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Je(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&Je(this.accumulatedWeightedInfNorm.map(e=>e.variable))}getWeights(){return ee(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(e){return ee(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,r){return new e(r.learningRate,r.beta1,r.beta2,r.epsilon,r.decay)}}return n.className="Adamax",n})();se(MD);let M_=(()=>{class n extends hl{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=Array.isArray(e)?e[i].tensor:e[s];if(null==o)return;const a=R.registeredVariables[s];z(()=>{const l=le(M(this.c,o),a);a.assign(l)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Dr(Be(-e))}dispose(){this.c.dispose()}getWeights(){var e=this;return ee(function*(){return[yield e.saveIterations()]})()}setWeights(e){var r=this;return ee(function*(){if(0!==(e=yield r.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,r){return new e(r.learningRate)}}return n.className="SGD",n})();se(M_);let FD=(()=>{class n extends M_{constructor(e,r,s=!1){super(e),this.learningRate=e,this.momentum=r,this.useNesterov=s,this.accumulations=[],this.m=Be(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=R.registeredVariables[s];null==this.accumulations[i]&&(this.accumulations[i]={originalName:`${s}/momentum`,variable:z(()=>Ft(o).variable(!1))});const a=this.accumulations[i].variable,l=Array.isArray(e)?e[i].tensor:e[s];null!=l&&z(()=>{let c;const u=le(M(this.m,a),l);c=le(M(this.c,this.useNesterov?le(l,M(u,this.m)):u),o),a.assign(u),o.assign(c)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Je(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}getWeights(){var e=this;return ee(function*(){return[yield e.saveIterations()].concat(e.accumulations.map(r=>({name:r.originalName,tensor:r.variable})))})()}setWeights(e){var r=this;return ee(function*(){e=yield r.extractIterations(e),r.accumulations=e.map(i=>({originalName:i.name,variable:i.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,r){return new e(r.learningRate,r.momentum,r.useNesterov)}}return n.className="Momentum",n})();se(FD);let OD=(()=>{class n extends hl{constructor(e,r=.9,s=0,i=null,o=!1){if(super(),this.learningRate=e,this.decay=r,this.momentum=s,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,null==i&&(this.epsilon=R.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const o=R.registeredVariables[s],a=!1;null==this.accumulatedMeanSquares[i]&&(this.accumulatedMeanSquares[i]={originalName:`${s}/rms`,variable:z(()=>Ft(o).variable(a))}),null==this.accumulatedMoments[i]&&(this.accumulatedMoments[i]={originalName:`${s}/momentum`,variable:z(()=>Ft(o).variable(a))}),null==this.accumulatedMeanGrads[i]&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${s}/mg`,variable:z(()=>Ft(o).variable(a))});const l=Array.isArray(e)?e[i].tensor:e[s];if(null==l)return;const c=this.accumulatedMeanSquares[i].variable,u=this.accumulatedMoments[i].variable;z(()=>{const d=le(M(c,this.decay),M(rn(l),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[i].variable,f=le(M(h,this.decay),M(l,1-this.decay)),p=Pe(M(l,this.learningRate),Gr(De(d,le(rn(f),this.epsilon)))),m=le(M(u,this.momentum),p);c.assign(d),h.assign(f),u.assign(m);const g=De(o,m);o.assign(g)}else{const h=le(M(c,this.decay),M(rn(l),1-this.decay)),f=le(M(u,this.momentum),Pe(M(l,this.learningRate),Gr(le(h,this.epsilon))));c.assign(h),u.assign(f);const p=De(o,f);o.assign(p)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Je(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&Je(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&Je(this.accumulatedMoments.map(e=>e.variable))}getWeights(){var e=this;return ee(function*(){const r=[...e.accumulatedMeanSquares,...e.accumulatedMoments];return e.centered&&r.push(...e.accumulatedMeanGrads),[yield e.saveIterations()].concat(r.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(e){var r=this;return ee(function*(){e=yield r.extractIterations(e);const s=r.centered?e.length/3:e.length/2,i=!1;r.accumulatedMeanSquares=e.slice(0,s).map(o=>({originalName:o.name,variable:o.tensor.variable(i)})),r.accumulatedMoments=e.slice(s,2*s).map(o=>({originalName:o.name,variable:o.tensor.variable(i)})),r.centered&&(r.accumulatedMeanGrads=e.slice(2*s,3*s).map(o=>({originalName:o.name,variable:o.tensor.variable(i)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,r){return new e(r.learningRate,r.decay,r.momentum,r.epsilon,r.centered)}}return n.className="RMSProp",n})();se(OD);class kc{static sgd(t){return new M_(t)}static momentum(t,e,r=!1){return new FD(t,e,r)}static rmsprop(t,e=.9,r=0,s=null,i=!1){return new OD(t,e,r,s,i)}static adam(t=.001,e=.9,r=.999,s=null){return new RD(t,e,r,s)}static adadelta(t=.001,e=.95,r=null){return new ND(t,e,r)}static adamax(t=.002,e=.9,r=.999,s=null,i=0){return new MD(t,e,r,s,i)}static adagrad(t,e=.1){return new AD(t,e)}}const kd={sgd:kc.sgd,momentum:kc.momentum,adadelta:kc.adadelta,adagrad:kc.adagrad,rmsprop:kc.rmsprop,adamax:kc.adamax,adam:kc.adam},Rce=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function tV(){return new Promise(n=>Rce(()=>n()))}function $D(n,t){const e=n[0].length;n.forEach((s,i)=>{S(s.length===e,()=>`Error in concat${e}D: rank of tensors[${i}] must be the same as the rank of the rest (${e})`)}),S(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const r=n[0];n.forEach((s,i)=>{for(let o=0;o<e;o++)S(o===t||s[o]===r[o],()=>`Error in concat${e}D: Shape of tensors[${i}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`)})}function Uo(n,t){const e=n[0].slice();for(let r=1;r<n.length;r++)e[t]+=n[r][t];return e}var Hi=(()=>{return(n=Hi||(Hi={}))[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS",Hi;var n})();function nV(n,t,e){let r=new Array;if(null==e&&null==t)return r;if(null==t)for(;r.length<n+e.length;)r.push(-1);else r=t.slice();if(null==e)return r;if(n+e.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${r.length}`);for(let s=1;s<e.length;++s){const i=e[s],o=r[r.length-e.length+s],a=r[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+n}] = ${i} but shape[${s+n}] = ${a}`)}else r[o]=i}return r}function rV(n){const t={FIRST_DIM_SIZE:Hi.FIRST_DIM_SIZE,VALUE_ROWIDS:Hi.VALUE_ROWIDS,ROW_LENGTHS:Hi.ROW_LENGTHS,ROW_SPLITS:Hi.ROW_SPLITS,ROW_LIMITS:Hi.ROW_LIMITS,ROW_STARTS:Hi.ROW_STARTS},e=[];for(const r of n){if(!(r in t))break;e.push(t[r])}return e}function sV(n){return 0===n.length?0:n[0]===Hi.FIRST_DIM_SIZE?n.length-1:n.length}function iV(n,t){if(null==n||null==t)return;const e=n.length,r=t.length;if(e>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(e,r-1);++s){const i=n[s],o=t[s+1];if(i>=0&&o>=0&&1!==i&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-n.length}] = ${i} but ragged tensor input.flatValues.shape[${s-n.length}] = ${o}`)}}const PD=30;function F_(n){return n<=PD?n:zS(n,Math.floor(Math.sqrt(n)))}function LD(n,t,e){return[e*("number"==typeof n?n:n[0]),t*("number"==typeof n?n:n[1])]}function Kp(n,t,e,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(n[0]/e),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const i=t.length;for(let o=0;o<i;++o)s=s.concat([n[o+1]/t[o],t[o]]);s=s.concat(n.slice(i+1))}return s}function Xp(n,t,e=!0){const r=[];if(e){r.push(t);for(let s=t+1;s<n;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{const s=[],i=[];for(let o=1;o<n;++o)o>=2*t+1||o%2==1?i.push(o):s.push(o);r.push(...s),r.push(0),r.push(...i)}return r}function Yp(n,t,e,r=!0){const s=[];s.push(r?n[0]/e:n[0]*e);for(let i=1;i<n.length;++i)s.push(i<=t.length?r?t[i-1]*n[i]:n[i]/t[i-1]:n[i]);return s}function BD(n,t){const e=[0];for(let r=0;r<t;++r)e.push(n[r][0]);return e}function VD(n,t,e){const r=n.slice(0,1);for(let s=0;s<e;++s)r.push(n[s+1]-t[s][0]-t[s][1]);return r}function zD(n,t){const e=n.shape.length,r=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${e}`);if(0===X(n.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=t.shape,i=s[s.length-1];let o=1;for(let d=0;d<s.length-1;++d)o*=s[d];const a=n.shape,l=s.slice();l.pop();let c=1;for(let d=i;d<e;++d)c*=a[d],l.push(a[d]);const u=[...Le(n.shape).map(d=>d/c),1].slice(0,i);return[l,o,c,u]}const O_=1.7580993408473768,$_=1.0507009873554805,UD=.3275911,HD=.254829592,WD=-.284496736,jD=1.421413741,GD=-1.453152027,qD=1.061405429;function ka(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(2*n.length);for(let r=0;r<e.length;r+=2)e[r]=n[r/2],e[r+1]=t[r/2];return e}function oV(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)t[r/2]=n[r],e[r/2]=n[r+1];return{real:t,imag:e}}function aV(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function lV(n){const t=Math.floor(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<n.length;s+=4)e[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:e,imag:r}}function KD(n,t){return{real:n[2*t],imag:n[2*t+1]}}function cV(n,t,e,r){n[2*r]=t,n[2*r+1]=e}function uV(n,t){const e=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const i=(t?2:-2)*Math.PI*(s/n);e[s]=Math.cos(i),r[s]=Math.sin(i)}return{real:e,imag:r}}function dV(n,t,e){const r=(e?2:-2)*Math.PI*(n/t);return{real:Math.cos(r),imag:Math.sin(r)}}const Mce=/->/g;function YD(n,t){const e=((n=n.replace(/\s/g,"")).length-n.replace(Mce,"").length)/"->".length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,s]=n.split("->");S(-1===r.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const i=r.split(","),o=i.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<s.length;++h){const f=s[h];if(!i.some(p=>-1!==p.indexOf(f)))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);-1===a.indexOf(f)&&a.push(f)}for(let h=0;h<r.length;++h){const f=r[h];-1===a.indexOf(f)&&","!==f&&a.push(f)}const l=new Array(i.length);for(let h=0;h<o;++h){if(new Set(i[h].split("")).size!==i[h].length)throw new Error(`Found duplicate axes in input component ${i[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let f=0;f<i[h].length;++f)l[h].push(a.indexOf(i[h][f]))}const c=a.length,d=[];for(let h=s.length;h<c;++h)d.push(h);return{allDims:a,summedDims:d,idDims:l}}function ZD(n,t){let e=new Array(n);e.fill(-1);for(let s=0;s<t.length;++s)e[t[s]]=s;const r=[];for(let s=0;s<n;++s)-1===e[s]&&r.push(s);return e=e.filter(s=>-1!==s),{permutationIndices:e,expandDims:r}}function QD(n,t,e){const r=new Array(n);for(let s=0;s<e.length;++s){const i=e[s].shape;for(let o=0;o<t[s].length;++o)void 0===r[t[s][o]]?r[t[s][o]]=i[o]:S(r[t[s][o]]===i[o],()=>`Expected dimension ${r[t[s][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function JD(n,t){const e=n,r=[];let s=0;0===n.length&&e.push(-1),s=n.length+1;for(let o=0;o<s;++o)r.push([]);const i=[];for(let o=0;o<e.length;++o){const l=Fce(t,e[o]);for(const c of l)-1===i.indexOf(c)&&(r[o].push(c),i.push(c))}return{path:e,steps:r}}function e1(n){return n.every((t,e)=>t===e)}function Fce(n,t){const e=[];for(let r=0;r<n.length;++r)(0===n[r].length||-1!==n[r].indexOf(t)||-1===t)&&e.push(r);return e}function t1(n,t,e=0){let r=[];if("number"==typeof t)S(n.shape[e]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(n.shape[e]/t);else{S(t.reduce((o,a)=>(-1===a&&(o+=1),o),0)<=1,()=>"There should be only one negative value in split array.");const i=t.indexOf(-1);if(-1!==i){const o=t.reduce((a,l)=>l>0?a+l:a);t[i]=n.shape[e]-o}S(n.shape[e]===t.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function pV(n){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${n}`}function mV(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function gV(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function yV(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function bV(n,t){return`size ${n} must be non-negative, not ${t}`}function _V(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function vV(n,t){return`Input to reshape is a SparseTensor with ${X(n)}\n  dense values, but the requested shape requires a multiple of ${X(t)}. inputShape=${n} outputShape= ${t}`}function xV(n,t){return`Input to reshape is a tensor with ${X(n)} dense values, but the requested shape has ${X(t)}. inputShape=${n} outputShape=${t}`}function n1(){return"segment ids must be >= 0"}function wV(){return"segment ids are not increasing"}function CV(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function SV(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function IV(n,t){let r,e=!1;for(n<=PD?(r=n,e=!0):r=zS(n,Math.floor(Math.sqrt(n)));!e;)r>t||r===n?e=!0:r=zS(n,r+1);return r}function EV(n,t,e){const r=[],s=n.length;for(let i=0;i<s;i++)r.push(i!==t?n[i]:e);return r}function r1(n,t,e,r){const s=t.shape.length,i=n.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>i)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${i}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let d=0;d<r;++d)if(n.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const o=n.shape[e],a=[];let l=1,c=1,u=1;for(let d=0;d<r;++d)a.push(n.shape[d]),l*=n.shape[d];for(let d=r;d<e;d++)a.push(n.shape[d]),c*=n.shape[d];for(let d=r;d<s;d++)a.push(t.shape[d]);for(let d=e+1;d<i;d++)a.push(n.shape[d]),u*=n.shape[d];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}function Nc(n){try{return n.map(t=>al(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function DV(n){return n.map(t=>ol(t))}const TV={kernelName:Hy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,Dd(ve(e,"float32"),-1))}}},Oce={kernelName:Mf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=rn(ve(e,"float32")),s=Gr(De(Be(1),r));return Cn(Pe(n,s))}}}},$ce={kernelName:Ff,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=Gr(De(rn(ve(e,"float32")),1));return Pe(n,r)}}}},Pce={kernelName:cd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=tt(e.shape,r.shape);return{a:()=>{let a=n;const l=lr(e.shape,s);return l.length>0&&(a=Re(a,l)),F(a,e.shape)},b:()=>{let a=n;const l=lr(r.shape,s);return l.length>0&&(a=Re(a,l)),F(a,r.shape)}}}},Lce={kernelName:Wy,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((r,s)=>{e[s]=()=>n.clone()}),e}},Bce={kernelName:jy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ft(e)}}},Vce={kernelName:Gy,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ft(e)}}},zce={kernelName:Of,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,Gr(De(Be(1),rn(ve(e,"float32")))))}}},Uce={kernelName:$f,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=Gr(le(Be(1),rn(ve(e,"float32"))));return Pe(n,r)}}}},Hce={kernelName:Bf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=tt(e.shape,r.shape);return{a:()=>{const a=le(rn(e),rn(r));let l=M(n,Pe(r,a));const c=lr(e.shape,s);return c.length>0&&(l=Re(l,c)),F(l,e.shape)},b:()=>{const a=le(rn(e),rn(r));let l=Cn(M(n,Pe(e,a)));const c=lr(r.shape,s);return c.length>0&&(l=Re(l,c)),F(l,r.shape)}}}},Wce={kernelName:Pf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,le(rn(ve(e,"float32")),1))}}},jce={kernelName:Lf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,De(Be(1),rn(ve(e,"float32"))))}}},qce=A({avgPool3dGrad_:function Gce(n,t,e,r,s,i){const o=I(n,"dy","avgPool3dGrad"),a=I(t,"input","avgPool3dGrad");let l=o,c=a,u=!1;4===a.rank&&(u=!0,l=F(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),S(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),S(5===c.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),ls("avgPool3dGrad",s,i);const f=R.runKernel(KS,{dy:l,input:c},{filterSize:e,strides:r,pad:s,dimRoundingMode:i});return u?F(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),Kce={kernelName:Ky,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:a}=e;return{x:()=>qce(n,r,s,i,o,a)}}},Yce=A({avgPoolGrad_:function Xce(n,t,e,r,s){const i=I(n,"dy","avgPoolGrad"),o=I(t,"input","avgPoolGrad");S(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,c=!1;3===o.rank&&(c=!0,a=F(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),S(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),S(4===a.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const h=R.runKernel(qS,{dy:l,input:a},{filterSize:e,strides:r,pad:s});return c?F(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Zce={kernelName:qy,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:s,strides:i,pad:o}=e;return{x:()=>Yce(n,r,s,i,o)}}},Qce={kernelName:Xy,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[r,s]=t,{transposeA:i,transposeB:o}=e;return i||o?!i&&o?{a:()=>_t(n,s,!1,!1),b:()=>_t(n,r,!0,!1)}:i&&!o?{a:()=>_t(s,n,!1,!0),b:()=>_t(r,n,!1,!1)}:{a:()=>_t(s,n,!0,!0),b:()=>_t(n,r,!0,!0)}:{a:()=>_t(n,s,!1,!0),b:()=>_t(r,n,!0,!1)}}},Jce={kernelName:Yy,gradFunc:(n,t,e)=>{const{blockShape:r,crops:s}=e;return{x:()=>x_(n,r,s)}}},eue={kernelName:"BroadcastTo",gradFunc:(n,t,e)=>{const s=e.inputShape,i=e.shape,o=Array.from(i);for(let l=s.length-1;l>=0;l--)if(s[l]===i[l])o[l]=1;else if(1!==s[l])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>Re(n,a,!0)}}},tue={kernelName:Vf,gradFunc:n=>({x:()=>n.clone()})},nue={kernelName:zf,gradFunc:n=>({x:()=>Ft(n)})},rue={kernelName:Uf,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{clipValueMin:s,clipValueMax:i}=e;return{x:()=>Ss(Vo(bl(r,s),Dc(r,i)),n,Ft(n))}}},sue={kernelName:Zy,inputsToSave:["x"],gradFunc:TV.gradFunc},iue={kernelName:Qy,saveAllInputs:!0,gradFunc:(n,t,e)=>{const r=t.map(l=>l.shape),{axis:s}=e,i=mt(s,t[0].shape)[0],o=r.map(l=>l[i]);return Ws(n,o,i).map(l=>()=>l)}},oue={kernelName:Jy,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,{dilations:i,strides:o,pad:a,dataFormat:l}=e;return S(pl(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>VE(r.shape,n,s,o,a,l),filter:()=>xD(r,n,s.shape,o,a,l)}}},aue={kernelName:eb,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>ml(n,s,i,o,a,1,l),filter:()=>xD(n,r,s.shape,i,o,a,l)}}},cue=A({conv3DBackpropFilter_:function lue(n,t,e,r,s){let i=n;4===n.rank&&(i=F(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=t;return 4===o.rank&&(o=F(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),S(5===i.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),S(5===o.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),S(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),S(i.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${e[3]}.`),S(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`),R.runKernel(JS,{x:i,dy:o},{strides:r,pad:s,filterShape:e})}}),uue={kernelName:tb,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:s,pad:i}=e;S(pl(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,a]=t;return{x:()=>dB(o.shape,n,a,s,i),filter:()=>cue(o,n,a.shape,s,i)}}},due={kernelName:Hf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(Cn(cD(ve(e,"float32"))),n)}}},hue={kernelName:Wf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(uD(ve(e,"float32")),n)}}},fue={kernelName:nb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s,exclusive:i,reverse:o}=e;return{x:()=>{const a=An([s],r.rank);let l=HE(n,s,i,!o);return null!=a&&(l=Tt(l,a)),l}}}},pue={kernelName:rb,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:s,pad:i,dimRoundingMode:o}=e,a=r??[1,1];S(pl(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=t;return S(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),S(4===c.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),S(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),S(Pr(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),ls("depthwiseConv2d",i,o),{x:()=>qB(l.shape,n,c,s,i,a,o),filter:()=>GB(l,n,c.shape,s,i,a,o)}}},mue={kernelName:sb,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,s]=t,i={x:r,filter:s,dy:n},o={x:r,filter:s,dy:n};return{x:()=>R.runKernel(lI,i,e),filter:()=>R.runKernel(cI,o,e)}}},gue={kernelName:Gf,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,r={dy:n,y:e};return{x:()=>R.runKernel(dI,r)}}},yue={kernelName:qf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=M(hi(Cn(rn(e))),2/Math.sqrt(Math.PI));return{x:()=>M(n,r)}}},bue={kernelName:Kf,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,e)}}},_ue={kernelName:ob,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>F(n,e.shape)}}},vue={kernelName:Xf,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,hi(e))}}},xue={kernelName:Yf,gradFunc:n=>({x:()=>Ft(n)})},wue={kernelName:Zf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=tt(e.shape,r.shape);return{a:()=>{const a=Pe(n,ve(r,"float32")),l=lr(e.shape,s);return l.length>0?F(Re(a,l),e.shape):a},b:()=>{let a=M(n,ve(e,"float32"));const l=lr(r.shape,s);l.length>0&&(a=F(Re(a,l),r.shape));const c=rn(r);return Cn(Pe(a,ve(c,"float32")))}}}},Cue={kernelName:ab,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:r}=e,[s,i,o,a]=t,l=a??Be(1),c=lr(i.shape,s.shape),u=[];if(1===i.rank){for(let v=0;v<s.shape.length-1;++v)u.push(s.shape[v]);u.push(1)}const d=De(s,i),h=M(n,l),f=iD(le(o,Be(r))),p=M(M(M(f,f),f),Be(-.5));return{x:()=>F(M(M(n,1===i.rank?Vi(F(f,[1,1,1,i.shape[0]]),u):f),l),s.shape),mean:()=>{let v=M(M(f,Be(-1)),h);return 1===i.rank&&(v=Re(v,c)),F(v,i.shape)},variance:()=>{let v=M(M(p,d),h);return 1===i.rank&&(v=Re(v,c)),F(v,i.shape)},scale:()=>{const v=M(d,f);let w=M(n,v);return 1===i.rank&&(w=Re(w,c)),F(w,i.shape)},offset:()=>{let v=n;return 1===i.rank&&(v=Re(v,c)),F(v,i.shape)}}}},Sue={kernelName:lb,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[r,s]=t,{axis:i}=e,o=mt(i,r.shape)[0];return{x:()=>{const l=r.shape,c=s.size,u=l.slice(0,o),d=u.length,h=l.slice(i,l.length).slice(1),f=h.length,p=kV(0,d),m=kV(d+1,d+1+f),g=NV([u,[c],h]),y=F(n,g),b=F(s,[c]),_=NV([[d],p,m]),v=Tt(y,_);let w=mD(v,b,r.shape[o]);const C=gl(_);return w=Tt(w,C),w},indices:()=>s}}};function kV(n,t){const e=[];for(let r=n;r<t;++r)e.push(r);return e}function NV(n){const t=[];for(let e=0;e<n.length;++e)for(let r=0;r<n[e].length;++r)t.push(n[e][r]);return t}const Iue={kernelName:Qf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>Ft(e),b:()=>Ft(r)}}},Eue={kernelName:Jf,gradFunc:n=>({x:()=>ve(n,"float32")})},Due={kernelName:ep,gradFunc:n=>({x:()=>Ft(n)})},Tue={kernelName:tp,gradFunc:n=>({x:()=>Ft(n)})},kue={kernelName:np,gradFunc:n=>({x:()=>Ft(n)})},Nue={kernelName:ub,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{alpha:s}=e,i=Hs(r,0);return{x:()=>Ss(i,n,M(n,s))}}},Aue={kernelName:sp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,le(e,1))}}},Rue={kernelName:rp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,ve(e,"float32"))}}},Mue={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e;return{logits:()=>{const o=hi(r);return De(n,M(Re(n,s,!0),o))}}}},Oue=A({localResponseNormalizationBackprop_:function Fue(n,t,e,r=5,s=1,i=1,o=.5){return R.runKernel(_I,{x:n,y:t,dy:e},{depthRadius:r,bias:s,alpha:i,beta:o})}}),$ue={kernelName:gb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{depthRadius:i,bias:o,alpha:a,beta:l}=e;return{x:()=>Oue(r,s,n,i,o,a,l)}}};function AV(n,t,e,r){return t.rank<e.rank&&(t=F(t,Hn(t.shape,r))),n.rank<e.rank&&(n=F(n,Hn(n.shape,r))),{x:()=>M(n,ve(go(e,t),n.dtype))}}const RV={kernelName:yb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{reductionIndices:s}=r,i=t[0],l=AV(n,t[1],i,mt(s,i.shape));return{x:()=>l.x()}}},Pue={kernelName:ip,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>M(n,ve(bl(e,r),"float32")),b:()=>M(n,ve(KE(e,r),"float32"))}}},Bue=A({maxPool3dGrad_:function Lue(n,t,e,r,s,i,o){const a=I(n,"dy","maxPool3dGrad"),l=I(t,"input","maxPool3dGrad"),c=I(e,"output","maxPool3dGrad");let u=a,d=l,h=c,f=!1;4===l.rank&&(f=!0,u=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=F(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=F(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),S(5===u.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),S(5===d.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),S(5===h.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),ls("maxPool3dGrad",i,o);const g=R.runKernel(xI,{dy:u,input:d,output:h},{filterSize:r,strides:s,pad:i,dimRoundingMode:o});return f?F(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),Vue={kernelName:_b,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=e;return{x:()=>Bue(n,r,s,i,o,a,l)}}},Uue=A({maxPoolGrad_:function zue(n,t,e,r,s,i,o){const a=I(n,"dy","maxPoolGrad"),l=I(t,"input","maxPoolGrad"),c=I(e,"output","maxPoolGrad");return S(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),S(4===a.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),S(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),ls("maxPoolGrad",i,o),R.runKernel(vI,{dy:a,input:l,output:c},{filterSize:r,strides:s,pad:i,dimRoundingMode:o})}}),MV={kernelName:Tb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:s}=e,i=s.map(o=>o[0]);return{x:()=>Mt(n,i,r.shape)}}};const FV={kernelName:Lb,gradFunc:(n,t,e)=>{const{blockShape:r,paddings:s}=e;return{x:()=>d_(n,r,s)}}},OV={kernelName:Bb,gradFunc:(n,t,e)=>{const{axis:r}=e;return{x:()=>Qn(n,r)}}},Lde=[TV,Oce,$ce,Pce,Lce,Bce,Vce,zce,Uce,Hce,Wce,jce,Kce,Zce,Qce,Jce,eue,tue,nue,rue,sue,iue,aue,oue,uue,due,hue,fue,pue,mue,{kernelName:jf,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=tt(e.shape,r.shape);return{a:()=>{const a=Pe(n,ve(r,"float32")),l=lr(e.shape,s);return l.length>0?F(Re(a,l),e.shape):a},b:()=>{let a=M(n,ve(e,"float32"));const l=lr(r.shape,s);l.length>0&&(a=F(Re(a,l),r.shape));const c=rn(r);return Cn(Pe(a,ve(c,"float32")))}}}},gue,yue,bue,_ue,vue,wue,xue,Cue,Sue,Iue,Eue,Due,Tue,kue,Nue,Aue,Rue,Mue,$ue,RV,RV,Pue,Vue,{kernelName:bb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,s]=t,{filterSize:i,strides:o,pad:a}=e;return{x:()=>Uue(n,r,s,i,o,a)}}},{kernelName:vb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e,i=mt(s,r.shape),l=X(kr(r.shape,i)[1]);return{x:()=>{const u=r.shape.slice();i.forEach(f=>{u[f]=1});const d=F(n,u);return Pe(M(d,pi(r.shape,"float32")),l)}}}},{kernelName:xb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{axis:s}=r,[i,o]=t,l=AV(n,o,i,mt(s,i.shape));return{x:()=>l.x()}}},{kernelName:op,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>M(n,ve(Dc(e,r),"float32")),b:()=>M(n,ve(Hs(e,r),"float32"))}}},{kernelName:wb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:s}=e,i=s.map(o=>o[0]);return{x:()=>Mt(n,i,r.shape)}}},{kernelName:ap,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=tt(e.shape,r.shape);return{a:()=>{const a=lr(e.shape,s);return a.length>0?F(Re(n,a),e.shape):n},b:()=>{const a=M(n,Cn(Bp(Pe(e,r)))),l=lr(r.shape,s);return l.length>0?F(Re(a,l),r.shape):a}}}},{kernelName:lp,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=tt(e.shape,r.shape);return{a:()=>{const a=M(n,ve(r,"float32")),l=lr(e.shape,s);return l.length>0?F(Re(a,l),e.shape):a},b:()=>{const a=M(n,ve(e,"float32")),l=lr(r.shape,s);return l.length>0?F(Re(a,l),r.shape):a}}}},{kernelName:Cb,gradFunc:n=>({x:()=>Cn(n)})},{kernelName:Eb,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>ur(e.shape,"float32")}}},{kernelName:Ib,gradFunc:n=>({x:()=>Ft(n)})},{kernelName:Db,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:r}=e;return Ui(n,r).map(i=>()=>i)}},MV,MV,{kernelName:cp,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,r,s]=t,i=e,o=r,a=tt(i.shape,o.shape);return{a:()=>{const u=ve(o,"float32");let d=M(n,M(u,yl(i,De(u,Be(1)))));const h=lr(i.shape,a);return h.length>0&&(d=Re(d,h)),F(d,i.shape)},b:()=>{const u=Hs(i,0),d=Ss(u,fi(i),Ft(i));let h=M(n,M(s,d));const f=lr(o.shape,a);return f.length>0&&(h=Re(h,f)),F(h,o.shape)}}}},{kernelName:kb,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,r]=t,s=Hs(e,0);return{x:()=>Ss(s,n,M(n,r)),alpha:()=>{let i=Ss(s,Ft(n),M(n,e));const o=lr(r.shape,n.shape);return o.length>0&&(i=Re(i,o)),F(i,r.shape)}}}},{kernelName:Nb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:s}=e;let i=[];return i=null==s?r.shape.map((o,a)=>a):"number"==typeof s?[s]:s,{x:()=>function rde(n,t,e){const r=n.shape.length,s=r-e.length,i=An(e,r);let o=n;null!=i&&(o=Tt(n,i));const a=o.shape.slice(),c=a.splice(r-e.length,e.length).reduce((h,f)=>h*f,1);a.push(c);let d=function nde(n,t,e){const r=n.shape.slice();r[e]=1;const s=F(t,r),i=f_(n,e,!0,!1),o=f_(n,e,!0,!0),a=M(i,o);return M(s,a)}(o.reshape(a),t,s);if(d=d.reshape(o.shape),null!=i){const h=gl(i);d=Tt(d,h)}return d}(r,n,i)}}},{kernelName:up,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,Cn(rn(e)))}}},{kernelName:hp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=M(Dc(e,6),Dd(e));return{x:()=>M(n,ve(r,"float32"))}}},{kernelName:dp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,ve(Dd(e),"float32"))}}},{kernelName:Ab,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>F(n,e.shape)}}},{kernelName:Mb,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,s={dy:n,images:r};return{images:()=>R.runKernel(MI,s,e)}}},{kernelName:Rb,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,s={dy:n,images:r};return{images:()=>R.runKernel(RI,s,e)}}},{kernelName:Fb,gradFunc:(n,t,e)=>{const{dims:r}=e,s=mt(r,n.shape);return{x:()=>zi(n,s)}}},{kernelName:fp,gradFunc:n=>({x:()=>Ft(n)})},{kernelName:pp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Cn(Pe(n,M(yl(e,1.5),2)))}}},{kernelName:Ob,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>ve(Ft(e),"float32"),t:()=>M(n,ve(e,n.dtype)),e:()=>M(n,ve(y_(e),n.dtype))}}},{kernelName:mp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=Hs(e,Be(0)),s=Be(O_),i=Be($_),o=M(n,i),a=M(M(n,s),hi(ve(e,"float32")));return Ss(r,o,a)}}}},{kernelName:_p,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,M(e,De(Be(1),e)))}}},{kernelName:bp,gradFunc:n=>({x:()=>Ft(n)})},{kernelName:gp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(h_(ve(e,"float32")),n)}}},{kernelName:yp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(UE(ve(e,"float32")),n)}}},{kernelName:$b,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{begin:s,size:i}=e,o=r.shape,[a,l]=o_(r,s,i),c=[];for(let u=0;u<n.rank;u++)c.push([a[u],o[u]-a[u]-l[u]]);return{x:()=>_l(n,c)}}},{kernelName:Vb,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{dim:s}=e,o=M(n,r);return{logits:()=>De(o,M(Re(o,[s],!0),r))}}},{kernelName:vp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,Bo(e))}}},FV,FV,OV,OV,{kernelName:xp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,M(Gr(ve(e,"float32")),2))}}},{kernelName:wp,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=Be(2);return{a:()=>M(n,M(s,De(e,r))),b:()=>M(n,M(s,De(r,e)))}}},{kernelName:zI,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(n,M(ve(e,"float32"),2))}}},{kernelName:Dp,gradFunc:n=>({x:()=>Ft(n)})},{kernelName:Cp,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,s=tt(e.shape,r.shape);return{a:()=>{let a=n;const l=lr(e.shape,s);return l.length>0&&(a=Re(a,l)),F(a,e.shape)},b:()=>{let a=n;const l=lr(r.shape,s);return l.length>0&&(a=Re(a,l)),F(Cn(a),r.shape)}}}},{kernelName:Pb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,s=r.shape.slice(),{axis:i}=e;mt(i,r.shape).forEach(c=>{s[c]=1});const a=F(n,s),l=M(a,pi(r.shape,"float32"));return{x:()=>l}}},{kernelName:Sp,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Pe(n,rn(h_(e)))}}},{kernelName:Ip,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>M(De(Be(1),rn(e)),n)}}},{kernelName:Ep,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{reps:s}=e;return{x:()=>{let o=Ft(r);if(1===r.rank)for(let a=0;a<s[0];++a)o=le(o,Mt(n,[a*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)o=le(o,Mt(n,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let c=0;c<s[2];++c)o=le(o,Mt(n,[a*r.shape[0],l*r.shape[1],c*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let c=0;c<s[2];++c)for(let u=0;u<s[3];++u)o=le(o,Mt(n,[a*r.shape[0],l*r.shape[1],c*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return o}}}},{kernelName:ud,gradFunc:(n,t,e)=>{const r=e,{perm:s}=r,i=gl(s);return{x:()=>Tt(n,i)}}},{kernelName:zb,gradFunc:(n,t,e)=>{const r=e,{axis:s}=r;return{value:()=>gi(n,s)}}},{kernelName:Ub,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>function $de(n,t){const e=Ea(t,Ft(t)),r=Vp(n,e);let s=bl(t,Be(0,"int32"));const i=r.rank-s.rank;for(let a=0;a<i;++a)s=Is(s,a+1);s=Vo(s,pi(r.shape,"bool"));const o=Ft(r);return Ss(s,r,o)}(n,e)}}},{kernelName:Hb,gradFunc:n=>({x:()=>Ft(n)})}];for(const n of Lde)sne(n);Y().prototype.abs=function(){return this.throwIfDisposed(),cr(this)},Y().prototype.acos=function(){return this.throwIfDisposed(),GL(this)},Y().prototype.acosh=function(){return this.throwIfDisposed(),qL(this)},Y().prototype.add=function(n){return this.throwIfDisposed(),le(this,n)},Y().prototype.all=function(n,t){return this.throwIfDisposed(),$E(this,n,t)},Y().prototype.any=function(n,t){return this.throwIfDisposed(),l_(this,n,t)},Y().prototype.argMax=function(n){return this.throwIfDisposed(),_d(this,n)},Y().prototype.argMin=function(n){return this.throwIfDisposed(),KL(this,n)},Y().prototype.asScalar=function(){return this.throwIfDisposed(),S(1===this.size,()=>"The array must have only 1 element."),F(this,[])},Y().prototype.asType=function(n){return this.throwIfDisposed(),ve(this,n)},Y().prototype.as1D=function(){return this.throwIfDisposed(),F(this,[this.size])},Y().prototype.as2D=function(n,t){return this.throwIfDisposed(),F(this,[n,t])},Y().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),F(this,[n,t,e])},Y().prototype.as4D=function(n,t,e,r){return this.throwIfDisposed(),F(this,[n,t,e,r])},Y().prototype.as5D=function(n,t,e,r,s){return this.throwIfDisposed(),F(this,[n,t,e,r,s])},Y().prototype.asin=function(){return this.throwIfDisposed(),XL(this)},Y().prototype.asinh=function(){return this.throwIfDisposed(),YL(this)},Y().prototype.atan=function(){return this.throwIfDisposed(),ZL(this)},Y().prototype.atan2=function(n){return this.throwIfDisposed(),QL(this,n)},Y().prototype.atanh=function(){return this.throwIfDisposed(),JL(this)},Y().prototype.avgPool=function(n,t,e,r){return this.throwIfDisposed(),u_(this,n,t,e,r)},Y().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),d_(this,n,t)},Y().prototype.batchNorm=function(n,t,e,r,s){return this.throwIfDisposed(),Fp(this,n,t,e,r,s)},Y().prototype.broadcastTo=function(n){return this.throwIfDisposed(),wd(this,n)},Y().prototype.cast=function(n){return this.throwIfDisposed(),ve(this,n)},Y().prototype.ceil=function(){return this.throwIfDisposed(),iB(this)},Y().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Us(this,n,t)},Y().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof bn&&(n=[n]),Qn([this,...n],t)},Y().prototype.conv1d=function(n,t,e,r,s,i){return this.throwIfDisposed(),BE(this,n,t,e,r,s,i)},Y().prototype.conv2dTranspose=function(n,t,e,r,s){return this.throwIfDisposed(),zE(this,n,t,e,r,s)},Y().prototype.conv2d=function(n,t,e,r,s,i){return this.throwIfDisposed(),ml(this,n,t,e,r,s,i)},Y().prototype.cos=function(){return this.throwIfDisposed(),h_(this)},Y().prototype.cosh=function(){return this.throwIfDisposed(),UE(this)},Y().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),f_(this,n,t,e)},Y().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),HE(this,n,t,e)},Y().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),fB(this,n,t)},Y().prototype.depthwiseConv2d=function(n,t,e,r,s,i){return this.throwIfDisposed(),Op(this,n,t,e,r,s,i)},Y().prototype.dilation2d=function(n,t,e,r,s){return this.throwIfDisposed(),pB(this,n,t,e,r,s)},Y().prototype.divNoNan=function(n){return this.throwIfDisposed(),mB(this,n)},Y().prototype.div=function(n){return this.throwIfDisposed(),Pe(this,n)},Y().prototype.dot=function(n){return this.throwIfDisposed(),gB(this,n)},Y().prototype.elu=function(){return this.throwIfDisposed(),$p(this)},Y().prototype.equal=function(n){return this.throwIfDisposed(),go(this,n)},Y().prototype.erf=function(){return this.throwIfDisposed(),yB(this)},Y().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),vB(this,n,t)},Y().prototype.exp=function(){return this.throwIfDisposed(),hi(this)},Y().prototype.expandDims=function(n){return this.throwIfDisposed(),Is(this,n)},Y().prototype.expm1=function(){return this.throwIfDisposed(),xB(this)},Y().prototype.fft=function(){return this.throwIfDisposed(),D_(this)},Y().prototype.flatten=function(){return this.throwIfDisposed(),F(this,[this.size])},Y().prototype.floor=function(){return this.throwIfDisposed(),Bp(this)},Y().prototype.floorDiv=function(n){return this.throwIfDisposed(),jE(this,n)},Y().prototype.gather=function(n,t){return this.throwIfDisposed(),Vp(this,n,t)},Y().prototype.greaterEqual=function(n){return this.throwIfDisposed(),bl(this,n)},Y().prototype.greater=function(n){return this.throwIfDisposed(),Hs(this,n)},Y().prototype.ifft=function(){return this.throwIfDisposed(),jp(this)},Y().prototype.irfft=function(){return this.throwIfDisposed(),hD(this)},Y().prototype.isFinite=function(){return this.throwIfDisposed(),wB(this)},Y().prototype.isInf=function(){return this.throwIfDisposed(),CB(this)},Y().prototype.isNaN=function(){return this.throwIfDisposed(),SB(this)},Y().prototype.leakyRelu=function(n){return this.throwIfDisposed(),m_(this,n)},Y().prototype.lessEqual=function(n){return this.throwIfDisposed(),Dc(this,n)},Y().prototype.less=function(n){return this.throwIfDisposed(),KE(this,n)},Y().prototype.localResponseNormalization=function(n,t,e,r){return this.throwIfDisposed(),IB(this,n,t,e,r)},Y().prototype.logSigmoid=function(){return this.throwIfDisposed(),EB(this)},Y().prototype.logSoftmax=function(n){return this.throwIfDisposed(),XE(this,n)},Y().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),YE(this,n,t)},Y().prototype.log=function(){return this.throwIfDisposed(),fi(this)},Y().prototype.log1p=function(){return this.throwIfDisposed(),g_(this)},Y().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Vo(this,n)},Y().prototype.logicalNot=function(){return this.throwIfDisposed(),y_(this)},Y().prototype.logicalOr=function(n){return this.throwIfDisposed(),ZE(this,n)},Y().prototype.logicalXor=function(n){return this.throwIfDisposed(),DB(this,n)},Y().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),_t(this,n,t,e)},Y().prototype.maxPool=function(n,t,e,r){return this.throwIfDisposed(),__(this,n,t,e,r)},Y().prototype.max=function(n,t){return this.throwIfDisposed(),Bi(this,n,t)},Y().prototype.maximum=function(n){return this.throwIfDisposed(),Ea(this,n)},Y().prototype.mean=function(n,t){return this.throwIfDisposed(),Ln(this,n,t)},Y().prototype.min=function(n,t){return this.throwIfDisposed(),Pp(this,n,t)},Y().prototype.minimum=function(n){return this.throwIfDisposed(),zp(this,n)},Y().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),kB(this,n,t)},Y().prototype.mod=function(n){return this.throwIfDisposed(),NB(this,n)},Y().prototype.mul=function(n){return this.throwIfDisposed(),M(this,n)},Y().prototype.neg=function(){return this.throwIfDisposed(),Cn(this)},Y().prototype.norm=function(n,t,e){return this.throwIfDisposed(),Lp(this,n,t,e)},Y().prototype.notEqual=function(n){return this.throwIfDisposed(),Id(this,n)},Y().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),JE(this,n,t,e)},Y().prototype.onesLike=function(){return this.throwIfDisposed(),mi(this)},Y().prototype.pad=function(n,t){return this.throwIfDisposed(),_l(this,n,t)},Y().prototype.pool=function(n,t,e,r,s,i){return this.throwIfDisposed(),AB(this,n,t,e,r,s,i)},Y().prototype.pow=function(n){return this.throwIfDisposed(),yl(this,n)},Y().prototype.prelu=function(n){return this.throwIfDisposed(),w_(this,n)},Y().prototype.prod=function(n,t){return this.throwIfDisposed(),RB(this,n,t)},Y().prototype.reciprocal=function(){return this.throwIfDisposed(),MB(this)},Y().prototype.relu=function(){return this.throwIfDisposed(),zo(this)},Y().prototype.relu6=function(){return this.throwIfDisposed(),rD(this)},Y().prototype.reshapeAs=function(n){return this.throwIfDisposed(),F(this,n.shape)},Y().prototype.reshape=function(n){return this.throwIfDisposed(),F(this,n)},Y().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),ZB(this,n,t,e)},Y().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),QB(this,n,t,e)},Y().prototype.reverse=function(n){return this.throwIfDisposed(),zi(this,n)},Y().prototype.rfft=function(){return this.throwIfDisposed(),T_(this)},Y().prototype.round=function(){return this.throwIfDisposed(),sD(this)},Y().prototype.rsqrt=function(){return this.throwIfDisposed(),iD(this)},Y().prototype.selu=function(){return this.throwIfDisposed(),oD(this)},Y().prototype.separableConv2d=function(n,t,e,r,s,i){return this.throwIfDisposed(),aD(this,n,t,e,r,s,i)},Y().prototype.sigmoid=function(){return this.throwIfDisposed(),Bo(this)},Y().prototype.sign=function(){return this.throwIfDisposed(),FB(this)},Y().prototype.sin=function(){return this.throwIfDisposed(),cD(this)},Y().prototype.sinh=function(){return this.throwIfDisposed(),uD(this)},Y().prototype.slice=function(n,t){return this.throwIfDisposed(),Mt(this,n,t)},Y().prototype.softmax=function(n){return this.throwIfDisposed(),E_(this,n)},Y().prototype.softplus=function(){return this.throwIfDisposed(),Sd(this)},Y().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),x_(this,n,t)},Y().prototype.split=function(n,t){return this.throwIfDisposed(),Ws(this,n,t)},Y().prototype.sqrt=function(){return this.throwIfDisposed(),Gr(this)},Y().prototype.square=function(){return this.throwIfDisposed(),rn(this)},Y().prototype.squaredDifference=function(n){return this.throwIfDisposed(),fD(this,n)},Y().prototype.squeeze=function(n){return this.throwIfDisposed(),Tc(this,n)},Y().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof bn?[this,n]:[this,...n];return gi(e,t)},Y().prototype.step=function(n){return this.throwIfDisposed(),Dd(this,n)},Y().prototype.stridedSlice=function(n,t,e,r,s,i,o,a){return this.throwIfDisposed(),OB(this,n,t,e,r,s,i,o,a)},Y().prototype.sub=function(n){return this.throwIfDisposed(),De(this,n)},Y().prototype.sum=function(n,t){return this.throwIfDisposed(),Re(this,n,t)},Y().prototype.tan=function(){return this.throwIfDisposed(),$B(this)},Y().prototype.tanh=function(){return this.throwIfDisposed(),xd(this)},Y().prototype.tile=function(n){return this.throwIfDisposed(),Vi(this,n)},Y().prototype.toBool=function(){return this.throwIfDisposed(),ve(this,"bool")},Y().prototype.toFloat=function(){return this.throwIfDisposed(),ve(this,"float32")},Y().prototype.toInt=function(){return this.throwIfDisposed(),ve(this,"int32")},Y().prototype.topk=function(n,t){return this.throwIfDisposed(),PB(this,n,t)},Y().prototype.transpose=function(n){return this.throwIfDisposed(),Tt(this,n)},Y().prototype.unique=function(n){return this.throwIfDisposed(),LB(this,n)},Y().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),mD(this,n,t)},Y().prototype.unstack=function(n){return this.throwIfDisposed(),Ui(this,n)},Y().prototype.where=function(n,t){return this.throwIfDisposed(),Ss(n,this,t)},Y().prototype.zerosLike=function(){return this.throwIfDisposed(),Ft(this)};class Ho extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Ho.prototype)}}class Wi extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Wi.prototype)}}class O extends Error{constructor(t){super(t),Object.setPrototypeOf(this,O.prototype)}}class nt extends Error{constructor(t){super(t),Object.setPrototypeOf(this,nt.prototype)}}class s1 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,s1.prototype)}}class $V extends Error{constructor(t){super(t),Object.setPrototypeOf(this,$V.prototype)}}class PV{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=t}}function Ac(n,t){if(Array.isArray(n)){let e=[];for(let r=0;r<t;r++)e=e.concat(n);return e}{const e=new Array(t);return e.fill(n),e}}function yi(n,t){if(!n)throw new s1(t)}function LV(n,t){let e=0;for(const r of n)r===t&&e++;return e}function Ds(n){return 1===n.length?n[0]:n}function cn(n){return Array.isArray(n)?n:[n]}function Na(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function Rc(n){return n.length<=1||-1===n.indexOf("_")?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let ji={};function o1(n){if(null==n)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function a1(n){if(null!=n&&"object"==typeof n)if(Array.isArray(n))n.forEach(t=>a1(t));else{const t=Object.keys(n);for(const e of t){const r=n[e];null!=r&&"object"==typeof r&&(Array.isArray(r)||"ndarray"!==r.type||"number"!=typeof r.value?a1(r):n[e]=r.value)}}}function Zp(n,t={},e={},r="object",s=!1){if("string"==typeof n){const i=n;let o;if(i in e)o=e[i];else if(i in ji)o=ji[i];else if(o=t[i],null==o)throw new O(`Unknown ${r}: ${n}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}{const i=n;if(null==i.className||null==i.config)throw new O(`${r}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);const o=i.className;let a,l;if(o in e?[a,l]=e[o]:o in ji?[a,l]=ji.className:o in t&&([a,l]=t[o]),null==a)throw new O(`Unknown ${r}: ${o}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const c={};for(const f of Object.keys(ji))c[f]=ji[f];for(const f of Object.keys(e))c[f]=e[f];i.config.customObjects=c;const d=Object.assign({},ji);for(const f of Object.keys(e))ji[f]=e[f];a1(i.config);const h=l(a,i.config,e,s);return ji=Object.assign({},d),h}{const c=Object.assign({},ji);for(const d of Object.keys(e))ji[d]=e[d];const u=new a(i.config);return ji=Object.assign({},c),u}}}function P_(n,t){return-1*function Bde(n,t){return n<t?-1:n>t?1:0}(n,t)}function vl(n){if(null==n)return n;const t=[];for(const e of n)-1===t.indexOf(e)&&t.push(e);return t}function Vde(n){if(null==n)throw new O(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function Mc(n,t,e){if(null!=e&&n.indexOf(e)<0)throw new O(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function l1(n,t,e=0,r=1/0){return yi(e>=0),yi(r>=e),Array.isArray(n)&&n.length>=e&&n.length<=r&&n.every(s=>typeof s===t)}function Nr(n,t){Array.isArray(n)?(S(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,r)=>Nr(e,`element ${r+1} of ${t}`))):S(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${BV(n)}.`)}function BV(n){return null===n?"null":Array.isArray(n)?"["+n.map(t=>BV(t)).join(",")+"]":"string"==typeof n?`"${n}"`:`${n}`}function VV(n){return"relu"===n?"relu":"linear"===n?"linear":"elu"===n?"elu":null}let Ude=0;function zV(){return Ude++}const L_={};function B_(n=""){return n in L_||(L_[n]=0),L_[n]+=1,n+L_[n].toString()}const Hde=["channelsFirst","channelsLast"],Wde=["nearest","bilinear"],jde=["valid","same","causal"],Gde=["max","avg"],qde=["sum","mul","concat","ave"],Nd=new Map;function jn(n){Mc(Hde,"DataFormat",n)}function bi(n){Mc(jde,"PaddingMode",n)}function UV(n){Mc(Gde,"PoolMode",n)}const Qp=[];function Fc(n,t){Qp.push(n);try{const e=t();return Qp.pop(),e}catch(e){throw Qp.pop(),e}}function WV(n){if(!GV(n))throw new Error("Not a valid tensor name: '"+n+"'");return function Xde(){return 0===Qp.length?"":Qp.join("/")+"/"}()+n}function jV(n){if(!GV(n))throw new Error("Not a valid tensor name: '"+n+"'");Nd.has(n)||Nd.set(n,0);const t=Nd.get(n);if(Nd.set(n,Nd.get(n)+1),t>0){const e=`${n}_${t}`;return Nd.set(e,1),e}return n}const Yde=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function GV(n){return!!n.match(Yde)}function Zde(n){return n===parseInt(n.toString(),10)}function xl(n,t,e){null==t&&(t=0),null==e&&(e=n.length);let r=1;for(let s=t;s<e;++s)r*=n[s];return r}function Ad(n){if(0===n.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r<t&&(t=r)}return t}function wl(n){if(0===n.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r>t&&(t=r)}return t}function yo(n,t){if(t<n)throw new O(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let r=n;r<t;++r)e.push(r);return e}let V_;function dr(){return null==V_&&(V_=function Rre(){return R.backend}().epsilon()),V_}function Wo(n,t){return ve(n,t)}function Jp(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),F(n,e)}function Oc(n,t,e){return z(()=>{switch(n.rank){case 1:return S_(n,t,e);case 2:return dD(n,[t,0],[e,n.shape[1]]);case 3:return I_(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return Wp(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Mt(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Mt(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new O(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function c1(n,t,e){return z(()=>{switch(n.rank){case 1:return S_(n,t,e);case 2:return dD(n,[0,t],[n.shape[0],e]);case 3:return I_(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return Wp(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new O(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function z_(n,t,e,r){return z(()=>{switch(n.rank){case 1:return S_(n,t,e);case 2:switch(r){case 1:return Oc(n,t,e);case 2:return c1(n,t,e);default:throw new O(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Oc(n,t,e);case 2:return I_(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return c1(n,t,e);default:throw new O(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Oc(n,t,e);case 2:return Wp(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return Wp(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return c1(n,t,e);default:throw new O(`The axis is not within the rank of the tensor ${r}`)}default:throw new O(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function u1(n,t=-1){let e;return t<0&&(e=n[0].rank,t=0!==e?e:0),t===n[0].rank&&(t=-1),Qn(n,t)}function KV(n,t){switch(n.rank){case 1:return oB([n,t]);case 2:return aB([n,t],0);case 3:return lB([n,t],0);case 4:return cB([n,t],0);default:throw new O(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function d1(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new O(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return Vi(n,t)}function U_(n,t=0,e=1,r,s){return nD(n,t,e,r,s)}function jo(n,t,e,r){if(n.rank<2||t.rank<2)throw new nt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3&&n.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new nt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`);if(2===n.rank&&2===t.rank)return wD({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?h1(n.rank,r,"channelsLast"):null,activation:e});{const s=n.shape.slice(),i=s.pop();n=F(n,[-1,i]);const o=t.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],u=Array.from({length:t.rank},(p,m)=>0===m?t.rank-2:m<=t.rank-2?m-1:m);t=F(Tt(t,u),[l,-1]);const d=[...s,...c];return F(wD({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?h1(n.rank,r,"channelsLast"):null,activation:e}),d)}}function XV(n,t,e){return z(()=>(t=Array.isArray(t)?Es(t,"int32"):ve(t,"int32"),Vp(n,t,e)))}function em(n){return M(n,n)}function h1(n,t,e){const r=t.shape;if(1!==t.rank&&t.rank!==n)throw new O(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(5===n){if("channelsFirst"===e)return F(t,1===r.length?[1,r[0],1,1,1]:[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===e)return F(t,1===r.length?[1,1,1,1,r[0]]:[1].concat(r))}else if(4===n){if("channelsFirst"===e)return F(t,1===r.length?[1,r[0],1,1]:[1,r[2],r[0],r[1]]);if("channelsLast"===e)return F(t,1===r.length?[1,1,1,r[0]]:[1].concat(r))}else if(3===n){if("channelsFirst"===e)return F(t,1===r.length?[1,r[0],1]:[1,r[1],r[0]]);if("channelsLast"===e)return F(t,1===r.length?[1,1,r[0]]:[1].concat(r))}else if(n<3)return t;throw new O(`Unsupported input rank by biasAdd: ${t.rank}`)}function _o(n,t,e){return z(()=>(null==e&&(e="channelsLast"),jn(e),le(n,h1(n.rank,t,e))))}function YV(n,t,e,r){return z(()=>HB(n,t,e,r))}function tm(n,t,e=!1){return e?n():t()}const ohe=["fanIn","fanOut","fanAvg"],ahe=["normal","uniform","truncatedNormal"];class Gi extends bd{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}se((()=>{class n extends Gi{apply(e,r){return ur(e,r)}}return n.className="Zeros",n})());let ZV=(()=>{class n extends Gi{apply(e,r){return pi(e,r)}}return n.className="Ones",n})();se(ZV),se((()=>{class n extends Gi{constructor(e){if(super(),"object"!=typeof e)throw new O(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new O(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return z(()=>M(Be(this.value),pi(e,r)))}getConfig(){return{value:this.value}}}return n.className="Constant",n})()),se((()=>{class n extends Gi{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return Up(e,this.minval,this.maxval,r)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return n.className="RandomUniform",n})()),se((()=>{class n extends Gi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new nt(`randomNormal does not support dType ${r}.`);return U_(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="RandomNormal",n})()),se((()=>{class n extends Gi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if("float32"!==(r=r||"float32")&&"int32"!==r)throw new nt(`truncatedNormal does not support dType ${r}.`);return pD(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="TruncatedNormal",n})()),se((()=>{class n extends Gi{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,r){return z(()=>{if(2!==e.length||e[0]!==e[1])throw new O("Identity matrix initializer can only be used for 2D square matrices.");return M(this.gain,qE(e[0]))})}getConfig(){return{gain:this.gain}}}return n.className="Identity",n})());let _i=(()=>{class n extends Gi{constructor(e){if(super(),e.scale<0)throw new O(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale??1,this.mode=e.mode??"fanIn",function lhe(n){Mc(ohe,"FanMode",n)}(this.mode),this.distribution=e.distribution??"normal",function che(n){Mc(ahe,"Distribution",n)}(this.distribution),this.seed=e.seed}apply(e,r){const s=function uhe(n,t="channelsLast"){let e,r;if(jn(t),2===n.length)e=n[0],r=n[1];else if(-1!==[3,4,5].indexOf(n.length)){if("channelsFirst"===t){const s=xl(n,2);e=n[1]*s,r=n[0]*s}else if("channelsLast"===t){const s=xl(n,0,n.length-2);e=n[n.length-2]*s,r=n[n.length-1]*s}}else{const s=xl(n);e=Math.sqrt(s),r=Math.sqrt(s)}return[e,r]}(e),i=s[0],o=s[1];let a=this.scale;if(a/="fanIn"===this.mode?Math.max(1,i):"fanOut"===this.mode?Math.max(1,o):Math.max(1,(i+o)/2),"normal"===this.distribution){const l=Math.sqrt(a);if("float32"!==(r=r||"float32")&&"int32"!==r)throw new nt(`${this.getClassName()} does not support dType ${r}.`);return pD(e,0,l,r,this.seed)}{const l=Math.sqrt(3*a);return Up(e,-l,l,r)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return n.className="VarianceScaling",n})();se(_i);let QV=(()=>{class n extends _i{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return _i.className}}return n.className="GlorotUniform",n})();se(QV);let JV=(()=>{class n extends _i{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return _i.className}}return n.className="GlorotNormal",n})();se(JV);let ez=(()=>{class n extends _i{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return _i.className}}return n.className="HeNormal",n})();se(ez);let tz=(()=>{class n extends _i{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return _i.className}}return n.className="HeUniform",n})();se(tz);let nz=(()=>{class n extends _i{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return _i.className}}return n.className="LeCunNormal",n})();se(nz);let rz=(()=>{class n extends _i{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return _i.className}}return n.className="LeCunNormal",n})();se(rz),se((()=>{class n extends Gi{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=e.gain??this.DEFAULT_GAIN,this.seed=e.seed,null!=this.seed)throw new nt("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,r){return z(()=>{if(e.length<2)throw new nt("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const i=U_(e[0]>e[1]?[e[1],e[0]]:e,0,1,"float32");let o=eV.gramSchmidt(i);return e[0]>e[1]&&(o=Tt(o)),M(this.gain,o)})}getConfig(){return{gain:this.gain,seed:this.seed}}}return n.className="Orthogonal",n})());const sz={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function iz(n,t={}){return Zp(n,Pi.getMap().classNameMap,t,"initializer")}function Rn(n){return o1(n)}function Sn(n){if("string"==typeof n){const t=n in sz?sz[n]:n;if("GlorotNormal"===t)return new JV;if("GlorotUniform"===t)return new QV;if("HeNormal"===t)return new ez;if("HeUniform"===t)return new tz;if("LeCunNormal"===t)return new nz;if("LeCunUniform"===t)return new rz;{const e={};return e.className=t,e.config={},iz(e)}}return n instanceof Gi?n:iz(n)}function f1(n){return Array.isArray(n)&&Array.isArray(n[0])}function H_(n){return 0===n.length?[]:Array.isArray(n[0])?n:[n]}function Ye(n){let t;if(Array.isArray(n)){if(1!==n.length)throw new O(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function Vt(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(1===n.length)return n[0];throw new O(`Expected exactly 1 Shape; got ${n.length}`)}return n}function W_(n){let t=0;for(const e of n)t+=0===e.shape.length?1:e.shape.reduce((r,s)=>r*s);return t}const oz="Variable";class Go{constructor(t,e="float32",r=oz,s=!0,i=null){this.dtype=e??"float32",this.shape=t.shape,this.id=zV(),this.originalName=WV(r=r??oz),this.name=jV(this.originalName),this.trainable_=s,this.constraint=i,this.val=BB(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function dhe(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function p1(n){return n.map(t=>t.read())}function m1(n){n.forEach(t=>{t[0].write(t[1])})}class hr{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class qo{constructor(t,e,r,s,i,o,a){this.dtype=t,this.shape=e,this.sourceLayer=r,this.inputs=s,this.callArgs=i,this.outputTensorIndex=a,this.id=zV(),null!=o&&(this.originalName=WV(o),this.name=jV(this.originalName)),this.rank=e.length}}let hhe=0;class j_{constructor(t,e){this.callArgs=e,this.id=hhe++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const r of t.inboundLayers)r?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let fhe=0;class vt extends bd{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=fhe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const r=this.getClassName();e=Na(r)+"_"+B_(r)}if(this.name=e,this.trainable_=t.trainable??!0,null!=t.inputShape||null!=t.batchInputShape){let r;if(null!=t.batchInputShape)r=t.batchInputShape;else if(null!=t.inputShape){let i=null;null!=t.batchSize&&(i=t.batchSize),r=[i].concat(t.inputShape)}this.batchInputShape=r;let s=t.dtype;null==s&&(s=t.inputDType),null==s&&(s="float32"),this.dtype=s}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new Wi(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new O(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Ds(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Ds(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ho(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Ho(`Layer ${this.name} is not connected, no input to return.`);return Ds(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Ho(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ho(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Ds(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=cn(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=cn(this.inputSpec);if(t.length!==e.length)throw new O(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let r=0;r<t.length;r++){const s=t[r],i=e[r];if(null==i)continue;const o=s.rank;if(null!=i.ndim&&o!==i.ndim)throw new O(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);if(null!=i.maxNDim&&o>i.maxNDim)throw new O(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);if(null!=i.minNDim&&o<i.minNDim)throw new O(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);if(null!=i.dtype&&s.dtype!==i.dtype)throw new O(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${s.dtype}.`);if(i.axes){const a=s.shape;for(const l in i.axes){const c=Number(l),u=i.axes[l],d=c>=0?a[c]:a[a.length+c];if(null!=u&&-1===[u,null].indexOf(d))throw new O(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${u} but got shape ${a}.`)}}if(null!=i.shape)for(let a=0;a<i.shape.length;++a){const l=i.shape[a],c=s.shape[a];if(null!=l&&null!=c&&l!==c)throw new O(`Input ${r} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${s.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const r=cn(t);let s=!0;for(const o of r)if(!(o instanceof qo)){s=!1;break}let i=!0;for(const o of r)if(o instanceof qo){i=!1;break}if(s===i)throw new O("Arguments to apply() must be all SymbolicTensors or all Tensors");return Fc(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const o=[];for(const a of cn(t))o.push(a.shape);this.build(Ds(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&i&&(this._refCount=1)}if(this.assertInputCompatibility(t),i){let o=this.call(t,e);const a=cn(o),l=[];for(let c of a)-1!==r.indexOf(c)&&(c=c.clone()),l.push(c);if(o=Ds(l),null!=this.activityRegularizer)throw new nt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}{const o=function phe(n){n=cn(n);const t=[];for(const e of n)t.push(e.shape);return Ds(t)}(t),a=this.computeOutputShape(o);let l;const c="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?o[0]:o),l=null!=a&&a.length>0&&Array.isArray(a[0])?a.map((u,d)=>new qo(c,u,this,cn(t),e,this.name,d)):new qo(c,a,this,cn(t),e,this.name),this.addInboundNode(t,l,null,null,o,a,e),this._refCount++,null!=this.activityRegularizer)throw new nt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,s)=>{null!=r&&null!=t[s]&&t[s]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Ho(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const r=JSON.stringify(e.outputShapes);-1===t.indexOf(r)&&t.push(r)}if(1===t.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Ho(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Wi(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return W_(this.weights)}build(t){this.built=!0}getWeights(t=!1){return p1(t?this.trainableWeights:this.weights)}setWeights(t){z(()=>{const e=this.weights;if(e.length!==t.length)throw new O(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const r=[],s=p1(e);for(let i=0;i<s.length;++i){const o=s[i],a=e[i],l=t[i];if(!Rt(o.shape,l.shape))throw new O(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}m1(r)})}addWeight(t,e,r,s,i,o,a,l){if(-1!==this._addedWeightNames.indexOf(t))throw new O(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==r&&(r="float32"),this.fastWeightInitDuringBuild&&(s=null!=l?l():Sn("zeros"));const c=s.apply(e,r),u=new Go(c,r,t,o,a);return c.dispose(),null!=i&&this.addLoss(()=>i.apply(u.read())),null==o&&(o=!0),o?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=cn(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(r=>{if(null!=r)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,r,s,i,o,a=null){const l=cn(t);e=cn(e),r=cn(r),s=cn(s),i=H_(i),o=H_(o);const c=[],u=[],d=[];for(const h of l)c.push(h.sourceLayer),u.push(h.nodeIndex),d.push(h.tensorIndex);new j_({outboundLayer:this,inboundLayers:c,nodeIndices:u,tensorIndices:d,inputTensors:l,outputTensors:e,inputMasks:r,outputMasks:s,inputShapes:i,outputShapes:o},a);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function az(n,t,e){if((null==t||null!=e&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),0===t.inboundNodes.length)return[n];{const r=t.inboundNodes[e];if(0===r.inboundLayers.length)return r.inputTensors;{const s=[];for(let i=0;i<r.inboundLayers.length;i++){const c=az(r.inputTensors[i],r.inboundLayers[i],r.nodeIndices[i]);for(const u of c)-1===s.indexOf(u)&&s.push(u)}return s}}}let G_=(()=>{class n extends vt{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:B_("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new O("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(null==r){if(null==e.inputShape)throw new O("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new O("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=r,this.dtype=s,this.inputSpec=[{shape:r}];const i=new qo(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new j_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new O(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return n.className="InputLayer",n})();se(G_);class Cl{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Cl)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,r){if(null!=this.id2Value[t.id])throw new O(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function yhe(n,t){if(null==n.dtype||n.dtype===t.dtype)return t;try{return ve(t,n.dtype)}catch{throw new O(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=r&&(this.id2Mask[t.id]=r),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof qo){if(null==this.id2Value[t.id])throw new O(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new O(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof qo){if(null==this.id2Value[t.id])throw new O(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new O(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&Je(this.id2Mask)}}const q_=new PV,K_=new PV;function nm(n,t,e,r){const s=null!=e&&e.training,i=Array.isArray(n),o=i?n:[n],a=o.map(p=>p.name),l=[],c=t.names();for(const p of a)-1!==c.indexOf(p)?l.push(t.getValue(p)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const u=a.join(",")+"|"+t.names().sort().join(",");let h,d=q_.get(u);if(null==d){const p=function _he(n,t){S(null!=n&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(1===n.length){const s=lz(n[0],t);e=s.sorted,r=s.recipientMap}else{const s=new Set;for(const i of n){const{sorted:o,recipientMap:a}=lz(i,t);for(const l of o)s.has(l.name)||(e.push(l),s.add(l.name));for(const l in a)null==r[l]&&(r[l]=new Set),a[l].forEach(c=>r[l].add(c))}}return{sorted:e,recipientCounts:vhe(r)}}(o,t);d=p.sorted,h=p.recipientCounts,q_.put(u,d),K_.put(u,h)}h={},s||Object.assign(h,K_.get(u));const f=new Cl(t);for(let p=0;p<d.length;++p){if(null!=r){const T=OE().numTensors;T>r.maxNumTensors&&(r.maxNumTensors=T),T<r.minNumTensors&&(r.minNumTensors=T)}const m=d[p],g=m.sourceLayer;if(g instanceof G_)continue;const y=[],b=[],_=[];let v=!1;for(const T of m.inputs){const N=f.getValue(T),P=f.getMask(T);y.push(N),b.push(P),null!=P&&(v=!0),s||(h[T.name]--,0===h[T.name]&&!t.hasKey(T)&&-1===a.indexOf(T.name)&&!N.isDisposed&&!0!==T.sourceLayer.stateful&&_.push(N))}v&&((e=e||{}).mask=b[0]);const w=cn(g.apply(y,e));let C=null;g.supportsMasking&&(C=g.computeMask(y,b));const E=xhe(m),D=Array.isArray(E)?E:[E];for(let T=0;T<D.length;++T){f.hasKey(D[T])||f.add(D[T],w[T],Array.isArray(C)?C[0]:C);const N=a.indexOf(D[T].name);-1!==N&&(l[N]=w[T])}s||Je(_)}return f.disposeMasks(),i?l:l[0]}function vhe(n){const t={};for(const e in n)t[e]=n[e].size;return t}function lz(n,t){const e=new Set,r=[],s={};for(const a of t.names())e.add(a);const i=[],o=[];for(i.push(n);i.length>0;){const a=i[i.length-1];if(e.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(0===a.inputs.length||l)i.pop(),r.push(a),e.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const c of a.inputs)null==s[c.name]&&(s[c.name]=new Set),s[c.name].add(a.name),!e.has(c.name)&&i.push(c)}}return{sorted:r,recipientMap:s}}function xhe(n){let t;if(1===n.sourceLayer.inboundNodes.length)t=n.sourceLayer.output;else{let e=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const s of n.sourceLayer.inboundNodes[r].outputTensors)if(s.id===n.id){e=r;break}t=n.sourceLayer.getOutputAt(e)}return t}function g1(n,t){return z(()=>Gr(Re(M(n,n),t,!0)))}G().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function bhe(n){q_?.setMaxEntries(n),K_?.setMaxEntries(n)});class rm extends bd{getConfig(){return{}}}se((()=>{class n extends rm{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return z(()=>{const r=g1(e,this.axis),s=Us(r,0,this.maxValue);return M(e,Pe(s,le(dr(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return n.className="MaxNorm",n})()),se((()=>{class n extends rm{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return z(()=>Pe(e,le(dr(),g1(e,this.axis))))}getConfig(){return{axis:this.axis}}}return n.className="UnitNorm",n})()),se((()=>{class n extends rm{apply(e){return zo(e)}}return n.className="NonNeg",n})()),se((()=>{class n extends rm{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return z(()=>{const r=g1(e,this.axis),s=le(M(this.rate,Us(r,this.minValue,this.maxValue)),M(1-this.rate,r));return M(e,Pe(s,le(dr(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return n.className="MinMaxNorm",n})());const cz={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function fr(n){return o1(n)}function uz(n,t={}){return Zp(n,Pi.getMap().classNameMap,t,"constraint")}function pr(n){return null==n?null:"string"==typeof n?uz({className:n in cz?cz[n]:n,config:{}}):n instanceof rm?n:uz(n)}function Sl(n){return y1.apply(this,arguments)}function y1(){return(y1=ee(function*(n){if(null==n)return;const t=[],e=[],r=[];for(const s in n){const i=n[s];if("number"!=typeof i){const o=i;t.push(o.data()),e.push(s),r.push(o)}}if(t.length>0){const s=yield Promise.all(t);for(let i=0;i<s.length;++i)n[e[i]]=s[i][0];Je(r)}})).apply(this,arguments)}function dz(n){if(null!=n)for(const t in n){const e=n[t];"number"!=typeof e&&e.dispose()}}class Rd{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return ee(function*(){})()}onEpochEnd(t,e){return ee(function*(){})()}onBatchBegin(t,e){return ee(function*(){})()}onBatchEnd(t,e){return ee(function*(){})()}onTrainBegin(t){return ee(function*(){})()}onTrainEnd(t){return ee(function*(){})()}setModel(t){}}class Che{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){var r=this;return ee(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochBegin(t,e)})()}onEpochEnd(t,e){var r=this;return ee(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onEpochEnd(t,e)})()}onBatchBegin(t,e){var r=this;return ee(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchBegin(t,e)})()}onBatchEnd(t,e){var r=this;return ee(function*(){null==e&&(e={});for(const s of r.callbacks)yield s.onBatchEnd(t,e)})()}onTrainBegin(t){var e=this;return ee(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainBegin(t)})()}onTrainEnd(t){var e=this;return ee(function*(){null==t&&(t={});for(const r of e.callbacks)yield r.onTrainEnd(t)})()}}class She extends Rd{constructor(){super()}onEpochBegin(t){var e=this;return ee(function*(){e.seen=0,e.totals={}})()}onBatchEnd(t,e){var r=this;return ee(function*(){null==e&&(e={});const s=e.size??0;r.seen+=s;for(const i in e){const o=e[i];if("number"==typeof o)r.totals.hasOwnProperty(i)||(r.totals[i]=0),r.totals[i]=r.totals[i]+o*s;else{let a;i in r.totals?a=r.totals[i]:r.totals[i]=0;const l=z(()=>le(r.totals[i],M(o,s)));r.totals[i]=l,a?.dispose()}}})()}onEpochEnd(t,e){var r=this;return ee(function*(){if(null!=e)for(const s of r.params.metrics)null!=r.totals[s]&&("number"==typeof r.totals[s]?e[s]=r.totals[s]/r.seen:z(()=>{const i=M(Pe(1,r.seen),r.totals[s]);e[s]=i,r.totals[s].dispose(),Dr(e[s])}))})()}}class Ihe extends Rd{onTrainBegin(t){var e=this;return ee(function*(){e.epoch=[],e.history={}})()}onEpochEnd(t,e){var r=this;return ee(function*(){null==e&&(e={}),r.epoch.push(t);for(const s in e)null==r.history[s]&&(r.history[s]=[]),r.history[s].push(e[s])})()}syncData(){var t=this;return ee(function*(){const e=[],r=[],s=[];for(const o in t.history){const a=t.history[o];for(let l=0;l<a.length;++l)"number"!=typeof a[l]&&(e.push(a[l].data()),r.push(o),s.push(l))}const i=yield Promise.all(e);for(let o=0;o<i.length;++o)t.history[r[o]][s[o]].dispose(),t.history[r[o]][s[o]]=i[o][0]})()}}class Ehe extends Rd{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||tV,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");BS(this.yieldEvery)&&(this.maybeWait=function zde(n,t,e){let s,r=null!=e?e():Cs();return(...o)=>{const a=null!=e?e():Cs();return a-r<t||(r=a,s=n(...o)),s}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,r){var s=this;return ee(function*(){const i=[];null!=s.yield&&(yield Sl(r),i.push(s.yield(t,e,r))),i.push(s.nextFrameFunc()),yield Promise.all(i)})()}onEpochBegin(t,e){var r=this;return ee(function*(){r.currentEpoch=t,null!=r.epochBegin&&(yield Sl(e),yield r.epochBegin(t,e))})()}onEpochEnd(t,e){var r=this;return ee(function*(){const s=[];null!=r.epochEnd&&(yield Sl(e),s.push(r.epochEnd(t,e))),"epoch"===r.yieldEvery&&s.push(r.nextFrameFunc()),yield Promise.all(s)})()}onBatchBegin(t,e){var r=this;return ee(function*(){null!=r.batchBegin&&(yield Sl(e),yield r.batchBegin(t,e))})()}onBatchEnd(t,e){var r=this;return ee(function*(){const s=[];null!=r.batchEnd&&(yield Sl(e),s.push(r.batchEnd(t,e))),"batch"===r.yieldEvery?s.push(r.nextFrameFunc()):BS(r.yieldEvery)&&s.push(r.maybeWait(r.currentEpoch,t,e)),yield Promise.all(s)})()}onTrainBegin(t){var e=this;return ee(function*(){null!=e.trainBegin&&(yield Sl(t),yield e.trainBegin(t))})()}onTrainEnd(t){var e=this;return ee(function*(){null!=e.trainEnd&&(yield Sl(t),yield e.trainEnd(t))})()}}function hz(n,t){return null==n&&(n={}),n instanceof Rd?[n]:Array.isArray(n)&&n[0]instanceof Rd?n:cn(n).map(r=>new Ehe(r,t))}let Dhe=(()=>{class n{constructor(){}static registerCallbackConstructor(e,r){S(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),n.checkForDuplicate(r),null==n.constructors[e]&&(n.constructors[e]=[]),n.constructors[e].push(r)}static checkForDuplicate(e){for(const r in n.constructors)n.constructors[+r].forEach(i=>{if(i===e)throw new O("Duplicate callback constructor.")})}static clear(){n.constructors={}}static createCallbacks(e){const r=[];for(const s in n.constructors){const i=+s;e>=i&&r.push(...n.constructors[i])}return r.map(s=>new s)}}return n.constructors={},n})();function fz(n,t,e,r,s,i,o,a,l){const c=new Ihe,u=[new She,...Dhe.createCallbacks(t)];null!=n&&u.push(...n),u.push(c);const d=new Che(u);return d.setParams({epochs:e,initialEpoch:r,samples:s,steps:i,batchSize:o,verbose:t,doValidation:a,metrics:l}),{callbackList:d,history:c}}function Aa(n,t={},e=!1){return Zp(n,Pi.getMap().classNameMap,t,"layer",e)}function X_(n,t){return z(()=>{"float32"!==n.dtype&&(n=ve(n,"float32"));const e=Re(em(n),t,!0),r=Cd(e.shape,dr()),s=Gr(Ea(e,r));return Pe(n,s)})}function Y_(n,t){return z(()=>Ln(em(De(t,n)),-1))}function b1(n,t){return z(()=>Ln(cr(De(t,n)),-1))}function _1(n,t){return z(()=>{const e=De(n,t),r=Us(cr(n),dr(),Number.MAX_VALUE),s=cr(Pe(e,r));return M(100,Ln(s,-1))})}function sm(n,t,e=!1){return z(()=>{if(e)t=E_(t);else{const r=Re(t,t.shape.length-1,!0);t=Pe(t,r)}return t=Us(t,dr(),1-dr()),Cn(Re(M(ve(n,"float32"),fi(t)),t.shape.length-1))})}function Z_(n,t,e=!1){return z(()=>{const r=ve(Bp(function the(n){const t=[xl(n.shape)];return F(n,t)}(n)),"int32"),s=(t=Us(t,dr(),1-dr())).shape;return sm(F(JE(r,s[s.length-1]),s),t,e)})}function Q_(n,t){return z(()=>{let e;return e=Us(t,dr(),1-dr()),e=fi(Pe(e,De(1,e))),Ln(function Mhe(n,t){if(!Rt(n.shape,t.shape))throw new O(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return z(()=>{const e=zo(t),r=Cn(cr(t));return le(De(e,M(t,n)),g_(hi(r)))})}(n,e),-1)})}function pz(n,t){return z(()=>{const e=X_(n,-1),r=X_(t,-1),s=M(e,r);return Cn(Re(s,-1))})}const J_={meanSquaredError:Y_,meanAbsoluteError:b1,meanAbsolutePercentageError:_1,meanSquaredLogarithmicError:function The(n,t){return z(()=>{const e=Us(t,dr(),Number.MAX_VALUE),r=fi(le(1,e)),s=Us(n,dr(),Number.MAX_VALUE),i=fi(le(1,s));return Ln(em(De(r,i)),-1)})},squaredHinge:function khe(n,t){return z(()=>{const e=Ea(0,De(1,M(n,t)));return Ln(em(e),-1)})},hinge:function Nhe(n,t){return z(()=>{const e=Ea(0,De(1,M(n,t)));return Ln(e,-1)})},categoricalHinge:function Ahe(n,t){return z(()=>{const e=Re(M(n,t),-1),r=Bi(M(De(1,n),t),-1);return Ea(0,le(1,De(r,e)))})},logcosh:function Rhe(n,t){return z(()=>{const e=Math.log(2),r=De(t,n),s=De(le(r,Sd(M(-2,r))),e);return Ln(s,-1)})},categoricalCrossentropy:sm,sparseCategoricalCrossentropy:Z_,binaryCrossentropy:Q_,kullbackLeiblerDivergence:function Fhe(n,t){return z(()=>{const e=Us(n,dr(),1),r=Us(t,dr(),1);return Re(M(n,fi(Pe(e,r))),-1)})},poisson:function Ohe(n,t){return z(()=>{const e=fi(le(dr(),t));return Ln(De(t,M(n,e)),-1)})},cosineProximity:pz};function v1(n){if("string"==typeof n){if(n in J_)return J_[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new O(t)}return n}function mz(n,t){return z(()=>{const e=M(.5,mi(t)),r=Wo(Hs(t,e),n.dtype);return Ln(go(n,r),-1)})}function gz(n,t){return z(()=>Wo(go(_d(n,-1),_d(t,-1)),"float32"))}function Bhe(n,t){return Q_(n,t)}function Vhe(n,t){return n.rank===t.rank&&(n=Tc(n,[n.rank-1])),(t=_d(t,-1)).dtype!==n.dtype&&(t=ve(t,n.dtype)),ve(go(n,t),"float32")}const bz=sm,_z=Z_,ev={binaryAccuracy:mz,categoricalAccuracy:gz,precision:function Lhe(n,t){return z(()=>{const e=function yz(n,t){return z(()=>ve(Re(Vo(go(n,1),go(t,1))),"float32"))}(n,t),r=function Phe(n,t){return z(()=>ve(Re(Vo(go(n,0),go(t,1))),"float32"))}(n,t),s=le(e,r);return ve(Ss(Hs(s,0),Pe(e,s),0),"float32")})},categoricalCrossentropy:bz,sparseCategoricalCrossentropy:_z,mse:Y_,MSE:Y_,mae:b1,MAE:b1,mape:_1,MAPE:_1,cosine:pz};function Khe(n){if("string"==typeof n&&n in ev)return ev[n];if("string"!=typeof n&&null!=n)return n;throw new O(`Unknown metric ${n}`)}function tv(n){if(yi(null!==n,`Unknown LossOrMetricFn ${n}`),"string"==typeof n)return n;{let t;for(const e of Object.keys(J_))if(J_[e]===n){t=e;break}if(void 0!==t)return t;for(const e of Object.keys(ev))if(ev[e]===n){t=e;break}return void 0!==t?t:n.name}}function xz(n,t,e=!1){if(null==n||"object"!=typeof n||Object.getPrototypeOf(n)!==Object.prototype||!x1(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const r=JSON.stringify(n);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function x1(n){if(null===n)return!0;if("object"==typeof n){if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if("string"!=typeof e||!x1(n[e]))return!1;return!0}if(Array.isArray(n)){for(const t of n)if(!x1(t))return!1;return!0}return!1}{const t=typeof n;return"string"===t||"number"===t||"boolean"===t}}function nv(n,t,e=console.log){let r="";for(let s=0;s<n.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=n[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);e(r)}function Jhe(n,t,e){let r,s;try{s=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}nv([`${n.name} (${n.getClassName()})`,s,r,n.countParams().toString()],t,e)}function efe(n,t,e,r){let s,i;try{i=n.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const o=[];for(const d of n.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(d)))for(let h=0;h<d.inboundLayers.length;++h)o.push(`${d.inboundLayers[h].name}[${d.nodeIndices[h]}][${d.tensorIndices[h]}]`);const a=n.name,l=n.getClassName(),c=0===o.length?"":o[0];nv([`${a} (${l})`,i,s,n.countParams().toString(),c],t,r);for(let d=1;d<o.length;++d)nv(["","","","",o[d]],t,r)}function wz(n,t,e){return("inboundNodes"===n||"outputLayers"===n||"inputLayers"===n)&&0===t&&"string"==typeof e}function w1(n,t){if(null===n)return null;if("string"==typeof n)return Rc(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];wz(t,s,i)?e.push(i):e.push(w1(i,t))}return e}{const e={};for(const r of Object.keys(n)){const s=n[r];if("name"===r&&"string"==typeof s)e[r]=s;else{const i=Rc(r);e[i]=w1(s,i)}}return e}}function C1(n,t){if(null==n)return null;if("string"==typeof n)return Na(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];wz(t,s,i)?e.push(i):e.push(C1(i,t))}return e}{const e={};for(const r of Object.keys(n)){const s=n[r];e[Na(r)]="name"!==r&&"className"!==r||"string"!=typeof s?C1(s,r):s}return e}}class vo extends vt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const b=this.getClassName().toLowerCase();this.name=B_(b)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],vl(this.inputs).length!==this.inputs.length)throw new O(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);vl(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const v=b.nodeIndex,w=b.tensorIndex;this.outputLayers.push(b.sourceLayer),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(w)}for(const b of this.inputs){const _=b.sourceLayer,v=b.nodeIndex,w=b.tensorIndex;yi(0===v,"input layer has >1 nodes"),yi(0===w,"input layer has >1 tensors"),this.inputLayers.push(_),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const _=this.inputLayers[b];if(!(_ instanceof G_))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${_.getClassName()}.`);this.inputNames.push(_.name),this.feedInputShapes.push(_.batchInputShape),this.feedInputNames.push(_.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const e={},r={},s={},i={},o={},a=[],l=(b,_,v,w,C,E)=>{(null==w||null==C||null==E)&&(w=b.sourceLayer,C=b.nodeIndex,E=b.tensorIndex);const D=w.inboundNodes[C];if(-1!==v.indexOf(D))throw new Wi(`The tensor ${b.name} at layer "${w.name}" is part of a cycle.`);if(-1!==_.indexOf(D))return;this.containerNodes.add(vo.nodeKey(w,C)),w.id in o||(o[w.id]=Object.keys(o).length),-1===v.indexOf(D)&&v.push(D);const T=D.inboundLayers.length;for(let N=0;N<T;N++)l(D.inputTensors[N],_,v,D.inboundLayers[N],D.nodeIndices[N],D.tensorIndices[N]);for(_.push(D);v.indexOf(D)>=0;)v.splice(v.indexOf(D),1);a.push(D)},c=[],u=[];for(const b of this.outputs)l(b,c,u);const d=a.slice().reverse();for(const b of d){r[b.id]=b,b.id in e||(e[b.id]=0);let _=e[b.id];_=Math.max(_,s[b.outboundLayer.id]??0),s[b.outboundLayer.id]=_,i[b.outboundLayer.id]=b.outboundLayer,e[b.id]=_;for(let w=0;w<b.inboundLayers.length;w++){const D=b.inboundLayers[w].inboundNodes[b.nodeIndices[w]];e[D.id]=Math.max(_+1,e[D.id]??0),r[D.id]=D}}const h={};for(const b in e){const _=e[b];_ in h||(h[_]=[]),h[_].push(r[b])}const f={};for(const b in s){const _=s[b];_ in f||(f[_]=[]),f[_].push(i[b])}let p=Object.keys(f).map(b=>parseInt(b,10)).sort(P_);this.layers=[];for(const b of p){const _=f[b];_.sort((v,w)=>{const C=o[v.id],E=o[w.id];return C<E?-1:C>E?1:0});for(const v of _)v instanceof vo&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=f,p=Object.keys(h).map(b=>parseInt(b,10)).sort(P_);const m=this.inputs.slice(),g=[];for(const b of p)for(const _ of h[b]){const v=_.outboundLayer;if(null!=v){for(const w of _.inputTensors)if(-1===m.indexOf(w))throw new Wi(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${v.name}". The following previous layers were accessed without issue: ${g}`);for(const w of _.outputTensors)m.push(w);g.push(v.name)}}this.nodesByDepth=h;const y=this.layers.map(b=>b.name);for(const b of y){const _=y.filter(v=>v===b).length;if(1!==_)throw new Wi(`The name "${b}" is used ${_} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new j_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new O("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.layers)e.push(...r.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const r={};let s=0;for(const o of this.layers)for(const a of o.weights){if(null!=r[a.originalName])throw new O(`Duplicate weight name: ${a.originalName}`);r[a.originalName]=a,s++}const i=[];for(const o in t){let a=o;if(null==r[o]){const l=o.split("/");a=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(null!=r[a])i.push([r[a],t[o]]);else if(e)throw new O(`Provided weight data has no target variable: ${o}`);delete r[a]}if(e){const o=[];for(const a in r)o.push(a);if(o.length>0)throw new O(`${o.length} of ${s} weights are not set: ${o}`)}m1(i)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 4.1.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const r=C1(this.updatedConfig());return e?JSON.stringify(r):r}call(t,e){return z(()=>{t=cn(t);const r=new Cl;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],t[s]);return nm(this.outputs,r,e)})}computeMask(t,e){return z(()=>{let r;return t=cn(t),r=null==e?Ac(null,t.length):cn(e),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){const e=H_(t);if(e.length!==this.inputLayers.length)throw new O(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<e.length;a++)r[this.inputLayers[a].name+"_0_0"]=e[a];const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(P_);if(s.length>1)for(const a of s){const l=this.nodesByDepth[a];for(const c of l){const u=c.outboundLayer;if(-1!==this.inputLayers.map(m=>m.id).indexOf(u.id))continue;const d=[];for(let m=0;m<c.inboundLayers.length;m++)d.push(r[`${c.inboundLayers[m].name}_${c.nodeIndices[m]}_${c.tensorIndices[m]}`]);const f=H_(u.computeOutputShape(Ds(d))),p=u.inboundNodes.indexOf(c);for(let m=0;m<f.length;m++)r[`${u.name}_${p}_${m}`]=f[m]}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++)o.push(`${this.outputLayers[a].name}_${this.outputLayersNodeIndices[a]}_${this.outputLayersTensorIndices[a]}`);for(let a=0;a<o.length;a++){const l=o[a];yi(l in r),i.push(r[l])}return Ds(i)}runInternalGraph(t,e){null==e&&(e=Ac(null,t.length));const r={};for(let l=0;l<this.inputs.length;++l)r[this.inputs[l].id]=[t[l],e[l]];const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(P_);for(const l of s){const c=this.nodesByDepth[l];for(const u of c){const d=u.outboundLayer,h=u.inputTensors,f=u.outputTensors,p=new Array;for(const m of h)m.id in r&&p.push(r[m.id]);if(p.length===h.length){let g,y,b,_,m={};if(null!=u.callArgs&&(m=u.callArgs),1===p.length){const[v,w]=p[0];null==m.mask&&(m.mask=w),b=cn(d.call(v,m)),_=cn(d.computeMask(v,w)),g=[v],y=[w]}else g=p.map(v=>v[0]),y=p.map(v=>v[1]),null==m.mask&&(m.mask=y),b=cn(d.call(g,m)),_=cn(d.computeMask(g,y));if(d.activityRegularizer)throw new nt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<f.length;++v)r[f[v].id]=[b[v],_[v]]}}}const i=[],o=[],a=[];for(const l of this.outputs){yi(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[c,u]=r[l.id];a.push(c.shape),i.push(c),o.push(u)}return[i,o,a]}buildNodeConversionMap(t){const e={};let r;for(const s of this.layers){r=s instanceof vo?1:0;for(let i=0;i<s.inboundNodes.length;i++){const o=vo.nodeKey(s,i);this.containerNodes.has(o)&&(e[o]=r,r+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new O(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new O("Provide either a layer name or layer index");for(const r of this.layers)if(r.name===t)return r;throw new O(`No such layer: ${t}`)}calculateLosses(){return z(()=>{const t=[];for(const e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){const s=vo.nodeKey(e,r);this.containerNodes.has(s)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let d=0;d<o.inboundNodes.length;d++){const h=o.inboundNodes[d],f=vo.nodeKey(o,d);let p={};if(this.containerNodes.has(f)){if(h.callArgs)try{JSON.stringify(h.callArgs),p=h.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(h.inboundLayers.length>0){const m=[];for(let g=0;g<h.inboundLayers.length;g++){const y=h.inboundLayers[g],_=h.tensorIndices[g];let w=e[vo.nodeKey(y,h.nodeIndices[g])];null==w&&(w=0),m.push([y.name,w,_,p])}c.push(m)}}}const u={};u.name=o.name,u.className=a,u.config=l,u.inboundNodes=c,r.push(u)}t.layers=r;const s=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],c=vo.nodeKey(a,this.inputLayersNodeIndices[o]);if(!this.containerNodes.has(c))continue;let u=e[c];null==u&&(u=0),s.push([a.name,u,this.inputLayersTensorIndices[o]])}t.inputLayers=s;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],c=vo.nodeKey(a,this.outputLayersNodeIndices[o]);if(!this.containerNodes.has(c))continue;let u=e[c];null==u&&(u=0),i.push([a.name,u,this.outputLayersTensorIndices[o]])}return t.outputLayers=i,t}static fromConfig(t,e,r={},s=!1){const i={},o={};function a(g,y){g.name in o?o[g.name].push(y):o[g.name]=[y]}function l(g,y){const b=[];let _;for(const v of y){const w=v[0],C=v[1],E=v[2];if(_=v[3]??{},!(w in i))return void a(g,y);const D=i[w];if(D.inboundNodes.length<=C)return void a(g,y);b.push(D.inboundNodes[C].outputTensors[E])}b.length>0&&g.apply(Ds(b),_)}function c(g){const y=g.name,b=Aa(g,null!=e.customObjects?e.customObjects:{});b.setFastWeightInitDuringBuild(s),i[y]=b,g.inboundNodes.forEach(v=>{if(!(v instanceof Array))throw new O(`Corrupted configuration, expected array for nodeData: ${v}`);a(b,v)})}const u=e.name,d=e.layers;for(const g of d)c(g);for(;!Vde(o);)for(const g of d){const y=i[g.name];if(y.name in o){const b=o[y.name];delete o[y.name];for(const _ of b)l(y,_)}}const h=[],f=[],p=e.inputLayers;for(const g of p){const y=g[0],b=g[1],_=g[2];yi(y in i),h.push(i[y].inboundNodes[b].outputTensors[_])}const m=e.outputLayers;for(const g of m){const y=g[0],b=g[1],_=g[2];yi(y in i),f.push(i[y].inboundNodes[b].outputTensors[_])}return new t({inputs:h,outputs:f,name:u})}get stateful(){if(this._stateful)throw new O("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){z(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function Sz(n,t){return function Cz(n,t,e){const r=t.length;if(null==n||Array.isArray(n)&&0===n.length)return t.map(s=>null);if(1===r)return Array.isArray(n)&&1===n.length?n:"object"==typeof n&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}if("object"==typeof n&&Object.keys(n).length>0&&"object"==typeof n[Object.keys(n)[0]]){const s=[];return t.forEach(i=>{s.push(i in n?n[i]:null)}),s}throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}(n,t,"classWeight")}function Iz(n,t,e,r){return I1.apply(this,arguments)}function I1(){return(I1=ee(function*(n,t,e,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const s=z(()=>{if(1===n.shape.length)return wa(n);if(2===n.shape.length){if(n.shape[1]>1)return _d(n,1);if(1===n.shape[1])return F(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(yield s.data());Je(s);const o=[];return i.forEach(a=>{if(null==e[a])throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(e[a])}),Es(o,"float32")}return null})).apply(this,arguments)}function tfe(n,t){return M(n,t)}function Ez(n,t){let e,r;e=t.xs,r=t.ys,S(null!=e&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const i=Dz("input",n.inputNames,e),o=Dz("output",n.outputNames,r),a=i[0].shape[0];S(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),S(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<i.length;l++)S(i[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)S(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function Dz(n,t,e){if(e instanceof bn)return[e];if(Array.isArray(e))return S(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const r=[];for(const s of t){if(null==e[s])throw new O(`The feature data generated by the dataset lacks the required ${n} key '${s}'.`);r.push(e[s])}return r}}function rfe(n){if(3===n.length)throw new nt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}function E1(){return(E1=ee(function*(n,t,e){const r=null!=e.batchesPerEpoch;if(S(null!=n.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),S(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),S(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),S(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),S(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const s=null!=e.validationData;let i,o;if(s)if(Tz(e.validationData))S(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const g=rfe(e.validationData);i=g.xs,o=g.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;c=s?l.slice().concat(l.map(g=>"val_"+g)):l.slice();const u=hz(e.callbacks,e.yieldEvery),d=e.verbose??1,{callbackList:h,history:f}=fz(u,d,e.epochs,null,null,ife(t,e),null,s,c);h.setModel(n),n.history=f,yield h.onTrainBegin(),n.stopTraining_=!1;let p=e.initialEpoch??0,m=yield t.iterator();for(;p<e.epochs;){const g={};yield h.onEpochBegin(p);let y=0,b=0;for(r||(m=yield t.iterator());!r||y<e.batchesPerEpoch;){const _=yield m.next();if(r&&_.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=_.value){const{xs:v,ys:w}=Ez(n,_.value),C={};C.batch=b,C.size=v[0].shape[0],yield h.onBatchBegin(b,C);const E=[];if(null!=e.classWeight){const N=Sz(e.classWeight,n.outputNames);for(let P=0;P<N.length;++P)E.push(yield Iz(w[P],null,N[P]))}const D=v.concat(w).concat(E),T=a(D);Je(D);for(let N=0;N<l.length;++N){const U=T[N];C[l[N]]=U,Dr(U)}yield h.onBatchEnd(b,C),dz(C),b++,y++}if(r?y>=e.batchesPerEpoch:_.done){if(s){let v;v=Tz(e.validationData)?cn(yield n.evaluateDataset(e.validationData,{batches:e.validationBatches})):cn(n.evaluate(i,o,{batchSize:e.validationBatchSize??32,verbose:0}));for(let w=0;w<n.metricsNames.length;++w)g[`val_${n.metricsNames[w]}`]=v[w]}break}if(n.stopTraining_)break}if(yield h.onEpochEnd(p,g),p++,n.stopTraining_)break}return yield h.onTrainEnd(),yield n.history.syncData(),n.history}finally{n.isTraining=!1}})).apply(this,arguments)}function ife(n,t){let e=null;return null!=t.batchesPerEpoch?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function Tz(n){return"function"==typeof n.iterator}function ofe(n){return"function"==typeof n.next}function D1(){return(D1=ee(function*(n,t,e){const r=null!=(e=e||{}).batches,s=n.testFunction;let i=[];if(e.verbose>0)throw new nt("Verbose mode is not implemented yet.");S(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=ofe(t)?t:yield t.iterator();let a=0,l=0;for(;!r||l<e.batches;){const c=yield o.next();if(i=z(()=>{if(c.value){const{xs:u,ys:d}=Ez(n,c.value),h=u.concat(d),f=z(()=>s(h));if(Je(h),0===l)for(let m=0;m<f.length;++m)i.push(Be(0));const p=h[0].shape[0];for(let m=0;m<f.length;++m){const g=f[m],y=i[m];i[m]=z(()=>le(i[m],M(p,g))),l>0&&Je(y)}Je(f),a+=p,++l}return i}),c.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<i.length;++c){const u=i[c];i[c]=Pe(i[c],a),Je(u)}return Ds(i)})).apply(this,arguments)}function T1(n){S(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function im(n,t,e){return null==n?[null]:Array.isArray(n)?n.map(r=>Oc(r,t,e-t)):Oc(n,t,e-t)}function k1(n,t){return z(()=>null==n?null:Array.isArray(n)?n.map(e=>k1(e,t)):XV(n,"int32"===t.dtype?t:ve(t,"int32")))}function N1(n,t){const e=[];let r=0,s=null;for(;r<n;)s=r+t,s>=n&&(s=n),e.push([r,s]),r=s;return e}function kz(n){const t=[];n instanceof bn&&(n=[n]);for(let e=0;e<n.length;++e){const r=n[e];if(1===r.rank)t.push(Jp(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function xo(n,t){if(null==n)return;const e=[];if(t instanceof bn)e.push(t.id);else if(Array.isArray(t))t.forEach(s=>e.push(s.id));else if(null!=t)for(const s in t)e.push(t[s].id);const r=[];if(n instanceof bn)-1===e.indexOf(n.id)&&r.push(n);else if(Array.isArray(n))n.forEach(s=>{-1===e.indexOf(s.id)&&r.push(s)});else if(null!=n)for(const s in n){const i=n[s];-1===e.indexOf(i.id)&&r.push(i)}r.forEach(s=>{s.isDisposed||s.dispose()})}function A1(n){return Array.isArray(n)}function Nz(n){return!function lfe(n){return n instanceof bn}(n)&&!A1(n)}function Az(n,t,e,r=!0,s=""){if(null==t||0===t.length){if(null!=n){let o=!1;if(A1(n)&&n.length>0)o=!0;else if(Nz(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new O(`Error when checking model ${s} expected no data, but got ${n}`)}return[]}if(null==n)return t.map(o=>null);let i;if(Nz(n)){i=[];for(const o of t){if(null==n[o])throw new O(`No data provided for "${o}". Need data for each key in: ${t}`);i.push(n[o])}}else if(A1(n)){if(n.length!==t.length)throw new O(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(t.length>1)throw new O(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=kz(i),null!=e)for(let o=0;o<t.length;++o){if(null==e[o])continue;const a=i[o];if(a.shape.length!==e[o].length)throw new O(`Error when checking ${s}: expected ${t[o]} to have ${e[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[o].length;++l){if(0===l&&!r)continue;const c=a.shape[l],u=e[o][l];if(null!=u&&u>=0&&c!==u)throw new O(`${s} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${s} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function Rz(n,t,e,r=!0,s=""){let i;if(Array.isArray(n)){if(n.length!==t.length)throw new O(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(t.length>1)throw new O(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(null!=e)for(let o=0;o<t.length;++o){if(null==e[o])continue;const a=i[o];if(a.shape.length!==e[o].length)throw new O(`Error when checking ${s}: expected ${t[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[o].length;++l){if(0===l&&!r)continue;const c=a.shape[l],u=e[o][l];if(null!=u&&u!==c)throw new O(`Error when checking ${s}: expected ${t[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}let Md=(()=>{class n extends vo{constructor(e){super(e),this.isTraining=!1}summary(e,r,s=console.log){if(!this.built)throw new O("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function Yhe(n,t,e,r=console.log){const s=function Qhe(n){let t=!0;const e=[],r=[];for(const s in n.nodesByDepth)e.push(n.nodesByDepth[s]);for(const s of e){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of n.layers){let i=!1;for(const o of s.inboundNodes)if(-1!==r.indexOf(o)){if(i){t=!1;break}i=!0}if(!t)break}return t}(n),i=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(s?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(u=>Math.floor(t*u))),!s){i.push("Receives inputs"),o=[];for(const u in n.nodesByDepth)o.push(...n.nodesByDepth[u])}r("_".repeat(t)),nv(i,e,r),r("=".repeat(t));const a=n.layers;for(let u=0;u<a.length;++u)s?Jhe(a[u],e,r):efe(a[u],e,o,r),r((u===a.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const l=function Zhe(n){let t;return t=W_(null!=n.collectedTrainableWeights?n.collectedTrainableWeights:n.trainableWeights),t}(n),c=W_(n.nonTrainableWeights);r(`Total params: ${l+c}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${c}`),r("_".repeat(t))}(this,e,r,s)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function Xhe(n){const t={Adagrad:()=>kd.adagrad(.01),Adadelta:()=>kd.adadelta(1,.95,dr()),Adam:()=>kd.adam(.001,.9,.999,dr()),Adamax:()=>kd.adamax(.002,.9,.999,dr(),0),RMSProp:()=>kd.rmsprop(.001,.9,0,dr()),SGD:()=>kd.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new O(`Unknown Optimizer ${n}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof hl))throw new O("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new O(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(l=>v1(l))}else{const a=v1(e.loss);this.outputs.forEach(l=>{r.push(a)})}else{e.loss=e.loss;for(const a in e.loss)if(-1===this.outputNames.indexOf(a))throw new O(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)null==e.loss[a]&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(v1(e.loss[a]))}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const l=this.internalOutputShapes[a];this.feedOutputNames.push(this.outputNames[a]),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Fc("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(-1!==s.indexOf(a))continue;const l=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([l,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const i=function dfe(n,t){if(null==n||Array.isArray(n)&&0===n.length)return t.map(r=>[]);let e;if("string"==typeof n||"function"==typeof n)e=[n];else{if(!Array.isArray(n)&&"object"!=typeof n)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);e=n}if(Array.isArray(e))return t.map(r=>e);{const r=[];for(const s of t){let i=e.hasOwnProperty(s)?e[s]:[];Array.isArray(i)||(i=[i]),r.push(i)}return r}}(e.metrics,this.outputNames),o=(a,l,c)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([c,a])};Fc("metric",()=>{for(let a=0;a<this.outputs.length;++a)-1===s.indexOf(a)&&(u=>{let h,f,p;for(const m of u){if("string"==typeof m&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(m)){const y=this.internalOutputShapes[a];let b;1===y[y.length-1]||this.lossFunctions[a]===Q_?-1!==["accuracy","acc"].indexOf(m)?f=mz:-1!==["crossentropy","ce"].indexOf(m)&&(f=Bhe):this.lossFunctions[a]===Z_?-1!==["accuracy","acc"].indexOf(m)?f=Vhe:-1!==["crossentropy","ce"].indexOf(m)&&(f=_z):-1!==["accuracy","acc"].indexOf(m)?f=gz:-1!==["crossentropy","ce"].indexOf(m)&&(f=bz),-1!==["accuracy","acc"].indexOf(m)?b="acc":-1!==["crossentropy","ce"].indexOf(m)&&(b="ce"),p=f,h=""+b}else p=Khe(m),h=""+tv(m);let g;Fc(h,()=>{g=p}),o(a,h,g)}})(i[a])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,s={}){const i=s.batchSize??32;T1(i);const a=this.standardizeUserDataXY(e,r,!0,i);try{const l=a[0].concat(a[1]);return this.makeTestFunction(),Ds(this.testLoop(this.testFunction,l,i,s.verbose,s.steps))}finally{xo(a[0],e),xo(a[1],r)}}evaluateDataset(e,r){var s=this;return ee(function*(){return s.makeTestFunction(),function afe(n,t,e){return D1.apply(this,arguments)}(s,e,r)})()}checkNumSamples(e,r,s,i="steps"){let o;if(null!=s){if(o=null,null!=r)throw new O(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else{if(null==e)throw new O(`Either the input data should have a defined shape, or ${i} shoud be specified.`);o=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return o}execute(e,r){if(Array.isArray(r)&&0===r.length)throw new O("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(r),o=this.retrieveSymbolicTensors(s?r:[r]),a=new Cl;if(e instanceof bn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new O(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)a.add(this.inputs[c],e[c])}else for(const c of this.inputs){const u=e[c.name];if(null==u)throw new O(`No value is provided for the model's input ${c.name}`);a.add(c,u)}const l=nm(o,a);return s?l:l[0]}retrieveSymbolicTensors(e){const r=Ac(null,e.length);let s=e.length;for(const i of this.layers){const o=Array.isArray(i.output)?i.output:[i.output],a=o.map(l=>l.name);for(let l=0;l<e.length;++l){const c=a.indexOf(e[l]);if(-1!==c&&(r[l]=o[c],s--),0===s)break}if(0===s)break}if(s>0){const i=[];throw r.forEach((o,a)=>{null==o&&i.push(e[a])}),new O(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return r}predictLoop(e,r=32,s=!1){return z(()=>{const i=this.checkNumSamples(e);if(s)throw new nt("Verbose predictLoop() is not implemented yet.");const o=N1(i,r),a=this.outputs.map(l=>[]);for(let l=0;l<o.length;++l)z(()=>{const h=im(e,o[l][0],o[l][1]),f=[];if(Array.isArray(h))for(let m=0;m<h.length;++m)f.push({key:this.inputs[m],value:h[m]});else f.push({key:this.inputs[0],value:h});const p=new Cl(f);return nm(this.outputs,p)}).forEach((u,d)=>a[d].push(u));return Ds(a.map(l=>Qn(l,0)))})}predict(e,r={}){const s=kz(e);Rz(s,this.inputNames,this.feedInputShapes,!1);try{const i=r.batchSize??32;return T1(i),this.predictLoop(s,i)}finally{xo(s,e)}}predictOnBatch(e){Rz(e,this.inputNames,this.feedInputShapes,!0);const r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,s=!0,i){if(null==this.optimizer_)throw new Wi("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let a=0;a<this.feedOutputShapes.length;++a){const l=this.feedOutputShapes[a];o.push(this.feedLossFns[a]===Z_?l.slice(0,l.length-1).concat([1]):l)}if(function cfe(n,t,e){const r=vl(n.map(i=>i.shape[0]));r.sort();const s=vl(t.map(i=>i.shape[0]));if(s.sort(),r.length>1)throw new O(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(s.length>1)throw new O(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(i=>i.shape))}`);if(r.length>0&&s.length>0&&!Rt(r,s))throw new O(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}(e=Az(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=Az(r,this.feedOutputNames,o,!1,"target")),function ufe(n,t,e){const r=[Y_,Q_,sm];for(let s=0;s<n.length;++s){const i=n[s],o=t[s],a=e[s];if(null!=o){if(o===sm&&1===i.shape[i.shape.length-1])throw new O(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(o)){const l=i.shape.slice(1),c=a.slice(1);for(let u=0;u<l.length;++u){const d=l[u],h=c[u];if(null!=h&&d!==h)throw new O(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=i&&i>0&&e[0].shape[0]%i!=0)throw new O(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,s,i,o=!0,a){var l=this;return ee(function*(){const[c,u]=l.standardizeUserDataXY(e,r,o,a);if(null!=s)throw new Error("sample weight is not supported yet.");let d=null;if(null!=i){const h=Sz(i,l.outputNames);d=[];for(let f=0;f<h.length;++f)d.push(yield Iz(u[f],null,h[f]))}return[c,u,d]})()}testLoop(e,r,s,i=0,o){return z(()=>{const a=this.checkNumSamples(r,s,o,"steps"),l=[];if(i>0)throw new nt("Verbose mode is not implemented yet.");if(null!=o)throw new nt("steps mode in testLoop() is not implemented yet");{const c=N1(a,s),u=Es(yo(0,a));for(let d=0;d<c.length;++d){const h=c[d][0],f=c[d][1],p=Oc(u,h,f-h),m=k1(r,p),g=e(m);if(0===d)for(let y=0;y<g.length;++y)l.push(Be(0));for(let y=0;y<g.length;++y)l[y]=le(l[y],M(f-h,g[y]))}for(let d=0;d<l.length;++d)l[d]=Pe(l[d],a)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,r=[];for(let s=0;s<e.length;++s){const i=e[s];let o=i;LV(e,i)>1&&(o+=`_${LV(e.slice(0,s),i)}`),r.push(o)}return r}makeTrainFunction(){return e=>{const r=[],s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],c=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(()=>{const h=[];for(let g=0;g<this.inputs.length;++g)h.push({key:this.inputs[g],value:s[g]});const f=new Cl(h),p=nm(this.outputs,f,{training:!0});let m;for(let g=0;g<this.lossFunctions.length;++g){let b=(0,this.lossFunctions[g])(i[g],p[g]);null!=o[g]&&(b=tfe(b,o[g]));const _=Ln(b);r.push(_),m=0===g?b:le(m,b)}for(let g=0;g<this.metricsTensors.length;++g){let y;if(this.outputs.length>1&&g<this.outputs.length)y=r[g];else{const _=this.metricsTensors[g][1];y=Ln((0,this.metricsTensors[g][0])(i[_],p[_]))}Dr(y),a.push(y)}return m=Ln(m),this.calculateLosses().forEach(g=>{m=le(m,g)}),m},!0,c)].concat(a)}}makeTestFunction(){this.testFunction=e=>z(()=>{const r=[];let s;const i=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let u=0;u<this.inputs.length;++u)a.push({key:this.inputs[u],value:i[u]});const l=new Cl(a),c=nm(this.outputs,l);for(let u=0;u<this.lossFunctions.length;++u){const h=Ln((0,this.lossFunctions[u])(o[u],c[u]));s=0===u?h:le(s,h),r.push(s)}for(let u=0;u<this.metricsTensors.length;++u){const h=this.metricsTensors[u][1],f=Ln((0,this.metricsTensors[u][0])(o[h],c[h]));r.push(f)}return r})}fit(e,r,s={}){var i=this;return ee(function*(){if(i.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let o,a,l,c,u,d,h,f,p;i.isTraining=!0;try{const m=s.batchSize??32;T1(m);const g=!1,y=yield i.standardizeUserData(e,r,s.sampleWeight,s.classWeight,g,m);o=y[0],a=y[1],p=y[2];let _,b=!1;if(null!=s.validationData&&s.validationData.length>0){if(b=!0,2!==s.validationData.length)throw 3===s.validationData.length?new nt("validationData including sample weights is not supported yet."):new O(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);u=s.validationData[0],d=s.validationData[1];const P=!0,U=yield i.standardizeUserData(u,d,null,null,P,m);h=U[0],f=U[1],_=h.concat(f)}else if(null!=s.validationSplit&&s.validationSplit>0&&s.validationSplit<1){b=!0;const P=Math.floor(o[0].shape[0]*(1-s.validationSplit)),U=o[0].shape[0];h=im(o,P,U),l=o,o=im(o,0,P),f=im(a,P,U),c=a,a=im(a,0,P),_=h.concat(f)}else null!=s.validationSteps&&(b=!0);const v=o.concat(a).concat(p);i.checkTrainableWeightsConsistency();const w=i.makeTrainFunction(),C=i.getDedupedMetricsNames();let E,D;b?(i.makeTestFunction(),E=i.testFunction,D=C.slice().concat(C.map(P=>"val_"+P))):(E=null,_=[],D=C.slice());const T=hz(s.callbacks,s.yieldEvery);return yield i.fitLoop(w,v,C,m,s.epochs,s.verbose,T,E,_,s.shuffle,D,s.initialEpoch,null,null)}finally{i.isTraining=!1,xo(o,e),xo(a,r),xo(l,e),xo(c,r),xo(h,u),xo(f,d),null!=p&&Je(p)}})()}fitLoop(e,r,s,i,o,a,l,c,u,d,h,f,p,m){var g=this;return ee(function*(){null==i&&(i=32),null==o&&(o=1),null==d&&(d=!0),null==f&&(f=0);let y=!1;if(null!=c&&null!=u&&(y=!0),null!=m&&(y=!0,null==p))throw new O("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const b=g.checkNumSamples(r,i,p,"steps_per_epoch");let _;null!=b&&(_=yo(0,b)),null==a&&(a=1);const{callbackList:v,history:w}=fz(l,a,o,f,b,p,i,y,h);v.setModel(g),g.history=w,yield v.onTrainBegin(),g.stopTraining_=!1;for(let C=f;C<o;++C){yield v.onEpochBegin(C);const E={};if(null!=p)throw new nt("stepsPerEpoch mode is not implemented yet.");{if("batch"===d)throw new nt("batch shuffling is not implemneted yet");d&&BP(_);const D=Es(_),T=N1(b,i);for(let N=0;N<T.length;++N){const P={};if(yield v.onBatchBegin(N,P),z(()=>{const U=T[N][0],j=T[N][1],q=Oc(D,U,j-U);P.batch=N,P.size=j-U;const K=k1(r,q),$=e(K);for(let V=0;V<s.length;++V){const W=$[V];P[s[V]]=W,Dr(W)}if(N===T.length-1&&y){const V=g.testLoop(c,u,i);for(let L=0;L<s.length;++L){const W=s[L],ne=V[L];Dr(ne),E["val_"+W]=ne}}}),yield v.onBatchEnd(N,P),dz(P),g.stopTraining_)break}D.dispose()}if(yield v.onEpochEnd(C,E),g.stopTraining_)break}return yield v.onTrainEnd(),yield g.history.syncData(),g.history})()}fitDataset(e,r){var s=this;return ee(function*(){return function sfe(n,t,e){return E1.apply(this,arguments)}(s,e,r)})()}trainOnBatch(e,r){var s=this;return ee(function*(){const i=yield s.standardizeUserData(e,r),o=i[0],a=i[1],c=s.makeTrainFunction()(o.concat(a)),u=[];for(const d of c){const h=yield d.data();u.push(h[0])}return Je(c),xo(i[0],e),xo(i[1],r),Ds(u)})()}getNamedWeights(e){const r=[],s=null!=e&&e.trainableOnly,i=s?this.trainableWeights:this.weights,o=this.getWeights(s);for(let a=0;a<i.length;++a)s&&!i[a].trainable||r.push({name:i[a].originalName,tensor:o[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const r=OE().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-OE().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=Na(this.loss);else if(Array.isArray(this.loss)){for(const r of this.loss)if("string"!=typeof r)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>Na(r))}else{const r=Object.keys(this.loss);e={};const s=this.loss;for(const i of r){if("string"!=typeof s[i])throw new Error("Serialization of non-string loss is not supported.");e[i]=Na(s[i])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Na(tv(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Na(tv(e)));{const e={};for(const r in this.metrics)e[r]=Na(tv(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const s=Aa(w1(e.optimizer_config));let i,o;if("string"==typeof e.loss)i=Rc(e.loss);else if(Array.isArray(e.loss))i=e.loss.map(a=>Rc(a));else if(null!=e.loss){i={};for(const a in e.loss)i[a]=Rc(e.loss[a])}if(Array.isArray(e.metrics))o=e.metrics.map(a=>Rc(a));else if(null!=e.metrics){o={};for(const a in e.metrics)o[a]=Rc(e.metrics[a])}this.compile({loss:i,metrics:o,optimizer:s})}save(e,r){var s=this;return ee(function*(){if("string"==typeof e){const d=yL(e);if(0===d.length)throw new O(`Cannot find any save handlers for URL '${e}'`);if(d.length>1)throw new O(`Found more than one (${d.length}) save handlers for URL '${e}'`);e=d[0]}if(null==e.save)throw new O("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const i=yield aE(s.getNamedWeights(r)),c={modelTopology:s.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v4.1.0",convertedBy:null};if(null!=r&&r.includeOptimizer&&null!=s.optimizer){c.trainingConfig=s.getTrainingConfig();const d="optimizer",{data:h,specs:f}=yield aE(yield s.optimizer.getWeights(),d);i.specs.push(...f),i.data=r_([i.data,h])}return null!=s.userDefinedMetadata&&(xz(s.userDefinedMetadata,s.name,!0),c.userDefinedMetadata=s.userDefinedMetadata),c.weightData=i.data,c.weightSpecs=i.specs,e.save(c)})()}setUserDefinedMetadata(e){xz(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return n.className="Model",n})();se(Md),se((()=>{class n extends Md{}return n.className="Functional",n})()),se((()=>{class n extends Md{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:B_("sequential_"),null!=e.layers)for(const r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new O(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const r=e instanceof n||e instanceof Md;let s;if(r){if(s=e,1!==s.outputs.length)throw new O("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==s.inputs.length)throw new O("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new O("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=function ghe(n){if(null==n.batchShape&&null==n.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=n.batchShape&&null!=n.shape)throw new O("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;null!=n.shape&&null==t&&(t=[null].concat(n.shape));let e=n.dtype;return null==e&&(e="float32"),new G_({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(r)this.outputs=s.outputs,this.inputs=s.inputs;else{if(1!==e.inboundNodes.length)throw new O(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new O("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=az(this.outputs[0])}this.inboundNodes=[],new j_({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Ac(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=e.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return null==this.model&&this.build(),this.model.call(e,r)}build(e){if(Vt(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Md({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,s=console.log){this.built||this.build(),super.summary(e,r,s)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,r,s={}){if(!this.built)throw new Wi("The model needs to be compiled before being used.");return this.model.evaluate(e,r,s)}evaluateDataset(e,r){var s=this;return ee(function*(){if(!s.built)throw new Wi("The model needs to be compiled before being used.");return s.model.evaluateDataset(e,r)})()}predict(e,r={}){return null==this.model&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,r,s={}){var i=this;return ee(function*(){if(!i.built)throw new Wi("The model needs to be compiled before being used.");return i.model.fit(e,r,s)})()}fitDataset(e,r){var s=this;return ee(function*(){if(!s.built)throw new Wi("The model needs to be compiled before being used.");return s.model.fitDataset(e,r)})()}trainOnBatch(e,r){var s=this;return ee(function*(){return s.model.trainOnBatch(e,r)})()}static fromConfig(e,r,s={},i=!1){let o,a={};if(r instanceof Array){if(null==r[0].className||"Merge"===r[0].className)throw new O("Legacy serialization format not supported yet.");o=r}else S(null!=r.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=r.layers,delete r.layers,a=r;const l=new e(a);if(!(l instanceof n))throw new nt(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const c of o){const d=Aa(c,void 0,i);i&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(e){if(null==this.model)throw new O("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new O("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const r of this.layers){const s={};s.className=r.getClassName(),s.config=r.getConfig(),e.push(s)}return{name:this.name,layers:e}}}return n.className="Sequential",n})());class Ts extends bd{getConfig(){return{}}}se((()=>{class n extends Ts{apply(e,r=1){return function rhe(n,t=1){if(1!==t)throw new nt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return $p(n)}(e,r)}}return n.className="elu",n})()),se((()=>{class n extends Ts{apply(e){return oD(e)}}return n.className="selu",n})()),se((()=>{class n extends Ts{apply(e){return zo(e)}}return n.className="relu",n})()),se((()=>{class n extends Ts{apply(e){return z(()=>zp(6,zo(e)))}}return n.className="relu6",n})()),se((()=>{class n extends Ts{apply(e){return e}}return n.className="linear",n})()),se((()=>{class n extends Ts{apply(e){return Bo(e)}}return n.className="sigmoid",n})()),se((()=>{class n extends Ts{apply(e){return function ihe(n){return z(()=>{const t=le(.5,M(.2,n));return Us(t,0,1)})}(e)}}return n.className="hardSigmoid",n})()),se((()=>{class n extends Ts{apply(e){return Sd(e)}}return n.className="softplus",n})()),se((()=>{class n extends Ts{apply(e){return function she(n){return z(()=>Pe(n,le(cr(n),1)))}(e)}}return n.className="softsign",n})()),se((()=>{class n extends Ts{apply(e){return xd(e)}}return n.className="tanh",n})());let Mz=(()=>{class n extends Ts{apply(e,r=-1){return E_(e,r)}}return n.className="softmax",n})();function Il(n){return n.getClassName()}function O1(n,t={}){return Zp(n,Pi.getMap().classNameMap,t,"activation")}function El(n){if(null==n){return O1({className:"linear",config:{}})}if("string"==typeof n){const t={};return t.className=n,t.config={},O1(t)}return n instanceof Ts?n:O1(n)}se(Mz),se((()=>{class n extends Ts{apply(e,r=-1){return XE(e,r)}}return n.className="logSoftmax",n})()),se((()=>{class n extends Ts{apply(e,r=1){return z(()=>M(Bo(M(e,r)),e))}}return n.className="swish",n})()),se((()=>{class n extends Ts{apply(e){return z(()=>M(e,xd(Sd(e))))}}return n.className="mish",n})());class Fz extends bd{}se((()=>{class n extends Fz{constructor(e){super(),function $1(n){if(null!=n&&"object"!=typeof n)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return z(()=>{let r=ur([1]);return this.hasL1&&(r=le(r,Re(M(this.l1,cr(e))))),this.hasL2&&(r=le(r,Re(M(this.l2,em(e))))),F(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return n.className="L1L2",n})());const Oz={l1l2:"L1L2"};function sn(n){return o1(n)}function $z(n,t={}){return Zp(n,Pi.getMap().classNameMap,t,"regularizer")}function In(n){return null==n?null:"string"==typeof n?$z({className:n in Oz?Oz[n]:n,config:{}}):n instanceof Fz?n:$z(n)}function Fd(n,t,e){if("number"==typeof n)return Ac(n,t);if(n.length!==t)throw new O(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let r=0;r<t;++r){const s=n[r];if(!Zde(s))throw new O(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${s}`)}return n}function wo(n,t,e,r,s=1){if(null==n)return n;let o;return o="same"===e?n:n-(t+(t-1)*(s-1))+1,Math.floor((o+r-1)/r)}function Ko(n,t,e,r){if(null==n)return null;if("valid"===r)n=n*t+wl([e-t,0]);else{if("same"!==r)throw new O(`Unsupport padding mode: ${r}.`);n*=t}return n}function L1(n,t){return z(()=>(jn(t),"channelsFirst"===t?Tt(n,[0,2,3,1]):n))}function Pz(n,t){return z(()=>(jn(t),"channelsFirst"===t?Tt(n,[0,2,3,4,1]):n))}function B1(n,t,e,r=[1,1],s="valid",i,o,a=null){return z(()=>{if(null==i&&(i="channelsLast"),jn(i),3!==n.rank&&4!==n.rank)throw new O(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(3!==t.rank&&4!==t.rank)throw new O(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=L1(n,i);if("causal"===s)throw new nt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=jB({x:l,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:a}),"channelsFirst"===i&&(l=Tt(l,[0,3,1,2])),l})}se((()=>{class n extends vt{constructor(e){super(e??{}),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,r){e=Ye(e);let s=zo(e);return null!=this.maxValue&&(s=Us(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ReLU",n})()),se((()=>{class n extends vt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=e.alpha??this.DEFAULT_ALPHA}call(e,r){const s=Ye(e);return m_(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LeakyReLU",n})()),se((()=>{class n extends vt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Sn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=In(e.alphaRegularizer),this.alphaConstraint=pr(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new O(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const r=(e=Vt(e)).slice(1);if(null!=this.sharedAxes)for(const i of this.sharedAxes)r[i-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(null!=this.sharedAxes)for(let i=1;i<e.length;++i)s[i]=e[i];this.inputSpec=[new hr({ndim:e.length,axes:s})],this.built=!0}call(e,r){return e=Ye(e),w_(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Rn(this.alphaInitializer),alphaRegularizer:sn(this.alphaRegularizer),alphaConstraint:fr(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return n.className="PReLU",n})()),se((()=>{class n extends vt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new nt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha??this.DEFAULT_ALPHA}call(e,r){const s=Ye(e);return $p(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ELU",n})()),se((()=>{class n extends vt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=e.theta??this.DEFAULT_THETA}call(e,r){const s=Ye(e);return M(s,ve(Hs(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ThresholdedReLU",n})()),se((()=>{class n extends vt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new Mz).apply,this.axis=e.axis??this.DEFAULT_AXIS}call(e,r){const s=Ye(e);return this.softmax(s,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Softmax",n})());class rv extends vt{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",rv.verifyArgs(e),this.rank=t,Nr(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new nt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Fd(e.kernelSize,t,"kernelSize"),this.strides=Fd(e.strides??1,t,"strides"),this.padding=e.padding??"valid",bi(this.padding),this.dataFormat=e.dataFormat??"channelsLast",jn(this.dataFormat),this.activation=El(e.activation),this.useBias=e.useBias??!0,this.biasInitializer=Sn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=pr(e.biasConstraint),this.biasRegularizer=In(e.biasRegularizer),this.activityRegularizer=In(e.activityRegularizer),this.dilationRate=Fd(e.dilationRate??1,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new O(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new O(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new O(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(yi("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!l1(t.kernelSize,"number",1,3))throw new O(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Il(this.activation),useBias:this.useBias,biasInitializer:Rn(this.biasInitializer),biasRegularizer:sn(this.biasRegularizer),activityRegularizer:sn(this.activityRegularizer),biasConstraint:fr(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Od extends rv{constructor(t,e){super(t,e),this.kernel=null,Od.verifyArgs(e),this.filters=e.filters,Nr(this.filters,"filters"),this.kernelInitializer=Sn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=pr(e.kernelConstraint),this.kernelRegularizer=In(e.kernelRegularizer)}build(t){t=Vt(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new O(`The channel dimension of the input should be defined. Found ${t[e]}`);const r=t[e],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(t,e){return z(()=>{let r;t=Ye(t);const s=null==this.bias?null:this.bias.read(),i=VV(this.activation.getClassName());if(null!=i&&2===this.rank)r=B1(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(1===this.rank)r=function Lz(n,t,e,r=1,s="valid",i,o=1){return z(()=>{if(null==i&&(i="channelsLast"),jn(i),3!==n.shape.length)throw new O(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(3!==t.shape.length)throw new O(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new O(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===i&&(n=Tt(n,[0,2,1])),"causal"===s)throw new nt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=BE(n,t,r,"same"===s?"same":"valid","NWC",o);return null!=e&&(a=_o(a,e)),a})}(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)r=B1(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new nt("convolutions greater than 3D are not implemented yet.");r=function Bz(n,t,e,r=[1,1,1],s="valid",i,o){return z(()=>{if(null==i&&(i="channelsLast"),jn(i),4!==n.rank&&5!==n.rank)throw new O(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(4!==t.rank&&5!==t.rank)throw new O(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=Pz(n,i);if("causal"===s)throw new nt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=uB(a,t,r,"same"===s?"same":"valid","NDHWC",o),null!=e&&(a=_o(a,e)),"channelsFirst"===i&&(a=Tt(a,[0,4,1,2,3])),a})}(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=Vt(t);const e=[],r="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let i=0;i<r.length;++i){const o=wo(r[i],this.kernelSize[i],this.padding,this.strides[i],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[i]);e.push(o)}let s=[t[0]];return"channelsLast"===this.dataFormat?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){const t={filters:this.filters,kernelInitializer:Rn(this.kernelInitializer),kernelRegularizer:sn(this.kernelRegularizer),kernelConstraint:fr(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new O(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}let Vz=(()=>{class n extends Od{constructor(e){super(2,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!l1(e.kernelSize,"number",1,2))throw new O(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv2D",n})();se(Vz);let zz=(()=>{class n extends Od{constructor(e){super(3,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new O(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv3D",n})();se(zz),se((()=>{class n extends Vz{constructor(e){if(super(e),this.inputSpec=[new hr({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new O(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Vt(e)).length)throw new O("Input should have rank 4; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new O("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new hr({ndim:4,axes:{[r]:s}})],this.built=!0}call(e,r){return z(()=>{let s=Ye(e);if(4!==s.shape.length)throw new O(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape;let a,l;"channelsFirst"===this.dataFormat?(a=2,l=3):(a=1,l=2);const u=i[l],h=this.kernelSize[1],p=this.strides[1],y=[i[0],Ko(i[a],this.strides[0],this.kernelSize[0],this.padding),Ko(u,p,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=Tt(s,[0,2,3,1]));let b=zE(s,this.kernel.read(),y,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=Tt(b,[0,3,1,2])),null!=this.bias&&(b=_o(b,this.bias.read(),this.dataFormat)),null!=this.activation&&(b=this.activation.apply(b)),b})}computeOutputShape(e){const r=(e=Vt(e)).slice();let s,i,o;"channelsFirst"===this.dataFormat?(s=1,i=2,o=3):(s=3,i=1,o=2);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.strides[0],u=this.strides[1];return r[s]=this.filters,r[i]=Ko(r[i],c,a,this.padding),r[o]=Ko(r[o],u,l,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv2DTranspose",n})()),se((()=>{class n extends zz{constructor(e){if(super(e),this.inputSpec=[new hr({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new O(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=Vt(e)).length)throw new O("Input should have rank 5; Received input shape: "+JSON.stringify(e));const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new O("The channel dimension of the inputs should be defined. Found `None`.");const s=e[r],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new hr({ndim:5,axes:{[r]:s}})],this.built=!0}call(e,r){return z(()=>{let s=Ye(e);if(5!==s.shape.length)throw new O(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape;let a,l,c;"channelsFirst"===this.dataFormat?(c=2,a=3,l=4):(c=1,a=2,l=3);const d=i[a],h=i[l],p=this.kernelSize[1],m=this.kernelSize[2],y=this.strides[1],b=this.strides[2],C=[i[0],Ko(i[c],this.strides[0],this.kernelSize[0],this.padding),Ko(d,y,p,this.padding),Ko(h,b,m,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(s=Tt(s,[0,2,3,4,1]));let E=hB(s,this.kernel.read(),C,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(E=Tt(E,[0,4,1,2,3])),null!==this.bias&&(E=_o(E,this.bias.read(),this.dataFormat)),null!==this.activation&&(E=this.activation.apply(E)),E})}computeOutputShape(e){const r=(e=Vt(e)).slice();let s,i,o,a;"channelsFirst"===this.dataFormat?(s=1,i=2,o=3,a=4):(s=4,i=1,o=2,a=3);const l=this.kernelSize[0],c=this.kernelSize[1],u=this.kernelSize[2],d=this.strides[0],h=this.strides[1],f=this.strides[2];return r[s]=this.filters,r[i]=Ko(r[i],d,l,this.padding),r[o]=Ko(r[o],h,c,this.padding),r[a]=Ko(r[a],f,u,this.padding),r}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv3DTranspose",n})());let mfe=(()=>{class n extends Od{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==r.filters)throw new O("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=r.kernelInitializer||null!=r.kernelRegularizer||null!=r.kernelConstraint)throw new O("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=r.padding&&"same"!==r.padding&&"valid"!==r.padding)throw new O(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=r.depthMultiplier??1,this.depthwiseInitializer=Sn(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=In(r.depthwiseRegularizer),this.depthwiseConstraint=pr(r.depthwiseConstraint),this.pointwiseInitializer=Sn(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=In(r.pointwiseRegularizer),this.pointwiseConstraint=pr(r.pointwiseConstraint)}build(e){if((e=Vt(e)).length<this.rank+2)throw new O(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r]||e[r]<0)throw new O(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);const s=e[r],i=this.kernelSize.concat([s,this.depthMultiplier]),o=[];for(let l=0;l<this.rank;++l)o.push(1);o.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):null,this.inputSpec=[new hr({ndim:this.rank+2,axes:{[r]:s}})],this.built=!0}call(e,r){return z(()=>{let s;if(e=Ye(e),1===this.rank)throw new nt("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Tt(e,[0,2,3,1])),s=aD(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=_o(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),"channelsFirst"===this.dataFormat&&(s=Tt(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Rn(this.depthwiseInitializer),e.pointwiseInitializer=Rn(this.pointwiseInitializer),e.depthwiseRegularizer=sn(this.depthwiseRegularizer),e.pointwiseRegularizer=sn(this.pointwiseRegularizer),e.depthwiseConstraint=fr(this.depthwiseConstraint),e.pointwiseConstraint=fr(this.pointwiseConstraint),e}}return n.className="SeparableConv",n})();function Uz(n,t,e,r){if(Array.isArray(n)){if(null!=t||null!=e)throw new O("When inputs is an array, neither initialState or constants should be provided");null!=r&&(e=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function s(i){return null==i||Array.isArray(i)?i:[i]}return{inputs:n,initialState:t=s(t),constants:e=s(e)}}function Hz(n,t,e,r=!1,s,i,o=!1,a=!1){return z(()=>{const l=t.shape.length;if(l<3)throw new O(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(yo(2,l));if(t=Tt(t,c),null!=i)throw new nt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=ve(ve(s,"bool"),"float32")).rank===l-1&&(s=Is(s,-1)),s=Tt(s,c)),r&&(t=zi(t,0),null!=s&&(s=zi(s,0)));const u=[];let d,h=e;const f=t.shape[0],p=Ui(t);let m,g;null!=s&&(m=Ui(s));for(let y=0;y<f;++y){const b=p[y],_=z(()=>n(b,h));if(null==s)d=_[0],h=_[1];else{const v=z(()=>{const w=m[y],C=De(mi(w),w);return{output:le(M(_[0],w),M(h[0],C)),newStates:h.map((T,N)=>le(M(_[1][N],w),M(T,C)))}});d=v.output,h=v.newStates}a&&u.push(d)}return a&&(g=gi(u,1)),[d,g,h]})}se((()=>{class n extends mfe{constructor(e){super(2,e)}}return n.className="SeparableConv2D",n})()),se((()=>{class n extends Od{constructor(e){super(1,e),n.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!l1(e.kernelSize,"number",1,1))throw new O(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv1D",n})()),se((()=>{class n extends vt{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return z(()=>{if(e=Ye(e),"channelsLast"===this.dataFormat){const s=z_(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return z_(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const s=z_(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return z_(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Cropping2D",n})()),se((()=>{class n extends vt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size??this.DEFAULT_SIZE,this.dataFormat=e.dataFormat??"channelsLast",jn(this.dataFormat),this.interpolation=e.interpolation??"nearest",function Kde(n){Mc(Wde,"InterpolationFormat",n)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,r){return z(()=>{let s=Ye(e);const i=s.shape;if("channelsFirst"===this.dataFormat){s=Tt(s,[0,2,3,1]);const o=this.size[0]*i[2],a=this.size[1]*i[3],l="nearest"===this.interpolation?Ta.resizeNearestNeighbor(s,[o,a]):Ta.resizeBilinear(s,[o,a]);return Tt(l,[0,3,1,2])}{const o=this.size[0]*i[1],a=this.size[1]*i[2];return"nearest"===this.interpolation?Ta.resizeNearestNeighbor(s,[o,a]):Ta.resizeBilinear(s,[o,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}}return n.className="UpSampling2D",n})()),se((()=>{class n extends rv{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier??1,this.depthwiseInitializer=Sn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=pr(e.depthwiseConstraint),this.depthwiseRegularizer=In(e.depthwiseRegularizer)}build(e){if((e=Vt(e)).length<4)throw new O(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const r="channelsFirst"===this.dataFormat?1:3;if(null==e[r]||e[r]<0)throw new O(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);const s=e[r];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return z(()=>{let s=function gfe(n,t,e=[1,1],r="valid",s,i){return z(()=>{null==s&&(s="channelsLast"),jn(s);let o=L1(n,s);if(4!==n.rank)throw new O(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(4!==t.rank)throw new O(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=Op(o,t,e,"same"===r?"same":"valid","NHWC",i),"channelsFirst"===s&&(o=Tt(o,[0,3,1,2])),o})}(e=Ye(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=_o(s,this.bias.read(),this.dataFormat)),null!=this.activation&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Vt(e);const s="channelsFirst"===this.dataFormat?e[3]:e[2],i="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,o=wo("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),a=wo(s,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],i,o,a]:[e[0],o,a,i]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Rn(this.depthwiseInitializer),e.depthwiseRegularizer=sn(this.depthwiseRegularizer),e.depthwiseConstraint=fr(this.depthwiseRegularizer),e}}return n.className="DepthwiseConv2D",n})());let om=(()=>{class n extends vt{constructor(e){let r;if(super(e),null==e.cell)throw new O("cell property is missing for the constructor of RNN.");if(r=Array.isArray(e.cell)?new Gz({cells:e.cell}):e.cell,null==r.stateSize)throw new O("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=e.returnSequences??!1,this.returnState=e.returnState??!1,this.goBackwards=e.goBackwards??!1,this._stateful=e.stateful??!1,this.unroll=e.unroll??!1,this.supportsMasking=!0,this.inputSpec=[new hr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return this.states_??yo(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(r=>null)}setStates(e){this.states_=e}computeOutputShape(e){f1(e)&&(e=e[0]);let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);const s=r[0];let i;if(i=this.returnSequences?[e[0],e[1],s]:[e[0],s],this.returnState){const o=[];for(const a of r)o.push([e[0],a]);return[i].concat(o)}return i}computeMask(e,r){return z(()=>{Array.isArray(r)&&(r=r[0]);const s=this.returnSequences?r:null;if(this.returnState){const i=this.states.map(o=>null);return[s].concat(i)}return s})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let s=0;s<e;++s)r.push(null);return r}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new nt("Constants support is not implemented in RNN yet.");f1(e)&&(e=e[0]);const s=this.stateful?e[0]:null,i=e.slice(2);this.inputSpec[0]=new hr({shape:[s,null,...i]});const o=[e[0]].concat(e.slice(2));let a;if(this.cell.build(o),a=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Rt(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new O(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new hr({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){z(()=>{if(!this.stateful)throw new Ho("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(null==s)throw new O("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(i=>ur([s,i])):[ur([s,this.cell.stateSize])];else if(null==e)Je(this.states_),null!=this.keptStates&&(Je(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>ur([s,i])):this.states_[0]=ur([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new O(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===r?this.keptStates.push(this.states_.slice()):Je(this.states_);for(let i=0;i<this.states_.length;++i){const o=e[i],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,l=[s,a];if(!Rt(o.shape,l))throw new O(`State ${i} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${o.shape}`);this.states_[i]=o}}this.states_=this.states_.map(i=>Dr(i.clone()))})}apply(e,r){let s=null==r?null:r.initialState,i=null==r?null:r.constants;null==r&&(r={});const o=Uz(e,s,i,this.numConstants);e=o.inputs,s=o.initialState,i=o.constants;let a=[],l=[];if(null!=s){r.initialState=s,a=a.concat(s),this.stateSpec=[];for(const u of s)this.stateSpec.push(new hr({shape:u.shape}));l=l.concat(this.stateSpec)}if(null!=i&&(r.constants=i,a=a.concat(i),this.numConstants=i.length),a[0]instanceof qo){const u=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(u,r);return this.inputSpec=h,f}return super.apply(e,r)}call(e,r){return z(()=>{const s=null==r?null:r.mask,i=null==r?null:r.training;let o=null==r?null:r.initialState;e=Ye(e),null==o&&(o=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==a)throw new O(`RNN Layer has ${a} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:i},u=Hz((m,g)=>{const y=this.cell.call([m].concat(g),l);return[y[0],y.slice(1)]},e,o,this.goBackwards,s,null,this.unroll,this.returnSequences),d=u[0],h=u[1],f=u[2];this.stateful&&this.resetStates(f,i);const p=this.returnSequences?h:d;return this.returnState?[p].concat(f):p})}getInitialState(e){return z(()=>{let r=ur(e.shape);return r=Re(r,[1,2]),r=Jp(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?d1(r,[1,s]):r):this.cell.stateSize>1?[d1(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(r.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===n.className&&(r.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),r)}static fromConfig(e,r,s={}){const o=Aa(r.cell,s);return new e(Object.assign(r,{cell:o}))}}return n.className="RNN",n})();se(om);class sv extends vt{}let Wz=(()=>{class n extends sv{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Nr(this.units,"units"),this.activation=El(e.activation??this.DEFAULT_ACTIVATION),this.useBias=e.useBias??!0,this.kernelInitializer=Sn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Sn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Sn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=In(e.kernelRegularizer),this.recurrentRegularizer=In(e.recurrentRegularizer),this.biasRegularizer=In(e.biasRegularizer),this.kernelConstraint=pr(e.kernelConstraint),this.recurrentConstraint=pr(e.recurrentConstraint),this.biasConstraint=pr(e.biasConstraint),this.dropout=Ad([1,wl([0,e.dropout??0])]),this.recurrentDropout=Ad([1,wl([0,e.recurrentDropout??0])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Vt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return z(()=>{if(2!==e.length)throw new O(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const i=r.training??!1;let o;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Dl({ones:()=>mi(e),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Dl({ones:()=>mi(s),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,l=this.recurrentDropoutMask;o=jo(null!=a?M(e,a):e,this.kernel.read()),null!=this.bias&&(o=_o(o,this.bias.read())),null!=l&&(s=M(s,l));let c=le(o,jo(s,this.recurrentKernel.read()));return null!=this.activation&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:Il(this.activation),useBias:this.useBias,kernelInitializer:Rn(this.kernelInitializer),recurrentInitializer:Rn(this.recurrentInitializer),biasInitializer:Rn(this.biasInitializer),kernelRegularizer:sn(this.kernelRegularizer),recurrentRegularizer:sn(this.recurrentRegularizer),biasRegularizer:sn(this.biasRegularizer),activityRegularizer:sn(this.activityRegularizer),kernelConstraint:fr(this.kernelConstraint),recurrentConstraint:fr(this.recurrentConstraint),biasConstraint:fr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),r)}}return n.className="SimpleRNNCell",n})();se(Wz),se((()=>{class n extends om{constructor(e){e.cell=new Wz(e),super(e)}call(e,r){return z(()=>(null!=this.cell.dropoutMask&&(Je(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Je(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return new e(r)}}return n.className="SimpleRNN",n})());let jz=(()=>{class n extends sv{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new O("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Nr(this.units,"units"),this.activation=El(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=El(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias??!0,this.kernelInitializer=Sn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Sn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Sn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=In(e.kernelRegularizer),this.recurrentRegularizer=In(e.recurrentRegularizer),this.biasRegularizer=In(e.biasRegularizer),this.kernelConstraint=pr(e.kernelConstraint),this.recurrentConstraint=pr(e.recurrentConstraint),this.biasConstraint=pr(e.biasConstraint),this.dropout=Ad([1,wl([0,e.dropout??0])]),this.recurrentDropout=Ad([1,wl([0,e.recurrentDropout??0])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Vt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,r){return z(()=>{if(2!==e.length)throw new O(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training??!1;let i=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Dl({ones:()=>mi(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Dl({ones:()=>mi(i),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const a=this.recurrentDropoutMask;let l,c,u;0<this.dropout&&this.dropout<1&&(e=M(e,this.dropoutMask[0]));let d=jo(e,this.kernel.read());this.useBias&&(d=_o(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=M(i,a[0]));const h=this.recurrentKernel.read(),[f,p]=Ws(h,[2*this.units,this.units],h.rank-1),m=jo(i,f),[g,y,b]=Ws(d,3,d.rank-1),[_,v]=Ws(m,2,m.rank-1);l=this.recurrentActivation.apply(le(g,_)),c=this.recurrentActivation.apply(le(y,v));const w=jo(M(c,i),p);u=this.activation.apply(le(b,w));const C=le(M(l,i),M(le(1,Cn(l)),u));return[C,C]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:Il(this.activation),recurrentActivation:Il(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Rn(this.kernelInitializer),recurrentInitializer:Rn(this.recurrentInitializer),biasInitializer:Rn(this.biasInitializer),kernelRegularizer:sn(this.kernelRegularizer),recurrentRegularizer:sn(this.recurrentRegularizer),biasRegularizer:sn(this.biasRegularizer),activityRegularizer:sn(this.activityRegularizer),kernelConstraint:fr(this.kernelConstraint),recurrentConstraint:fr(this.recurrentConstraint),biasConstraint:fr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),r)}}return n.className="GRUCell",n})();se(jz),se((()=>{class n extends om{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new jz(e),super(e)}call(e,r){return z(()=>(null!=this.cell.dropoutMask&&(Je(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Je(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="GRU",n})());let V1=(()=>{class n extends sv{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Nr(this.units,"units"),this.activation=El(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=El(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias??!0,this.kernelInitializer=Sn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Sn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Sn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=In(e.kernelRegularizer),this.recurrentRegularizer=In(e.recurrentRegularizer),this.biasRegularizer=In(e.biasRegularizer),this.kernelConstraint=pr(e.kernelConstraint),this.recurrentConstraint=pr(e.recurrentConstraint),this.biasConstraint=pr(e.biasConstraint),this.dropout=Ad([1,wl([0,e.dropout??0])]),this.recurrentDropout=Ad([1,wl([0,e.recurrentDropout??0])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;let i;if(e=Vt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,a=this.units;i=new((r=class extends Gi{apply(c,u){const d=o.apply([a]),h=(new ZV).apply([a]),f=o.apply([2*a]);return KV(KV(d,h),f)}}).className="CustomInit",r)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return z(()=>{const s=r.training??!1;if(3!==e.length)throw new O(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let i=e[1];const o=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Dl({ones:()=>mi(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Dl({ones:()=>mi(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const l=this.recurrentDropoutMask;let c,u,d,h;0<this.dropout&&this.dropout<1&&(e=M(e,this.dropoutMask[0]));let f=jo(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=M(i,l[0])),f=le(f,jo(i,this.recurrentKernel.read())),this.useBias&&(f=_o(f,this.bias.read()));const[p,m,g,y]=Ws(f,4,f.rank-1);c=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(m),d=le(M(u,o),M(c,this.activation.apply(g))),h=this.recurrentActivation.apply(y);const b=M(h,this.activation.apply(d));return[b,b,d]})}getConfig(){const e=super.getConfig(),r={units:this.units,activation:Il(this.activation),recurrentActivation:Il(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Rn(this.kernelInitializer),recurrentInitializer:Rn(this.recurrentInitializer),biasInitializer:Rn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:sn(this.kernelRegularizer),recurrentRegularizer:sn(this.recurrentRegularizer),biasRegularizer:sn(this.biasRegularizer),activityRegularizer:sn(this.activityRegularizer),kernelConstraint:fr(this.kernelConstraint),recurrentConstraint:fr(this.recurrentConstraint),biasConstraint:fr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),r)}}return n.className="LSTMCell",n})();se(V1),se((()=>{class n extends om{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new V1(e),super(e)}call(e,r){return z(()=>(null!=this.cell.dropoutMask&&(Je(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Je(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})))}static fromConfig(e,r){return 0===r.implmentation&&(r.implementation=1),new e(r)}}return n.className="LSTM",n})());let Gz=(()=>{class n extends sv{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return z(()=>{let s=e.slice(1);const i=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?i.push(s.splice(0,l.stateSize.length)):i.push(s.splice(0,1));i.reverse();const o=[];let a;for(let l=0;l<this.cells.length;++l){const c=this.cells[l];s=i[l],a=0===l?[e[0]].concat(s):[a[0]].concat(s),a=c.call(a,r),o.push(a.slice(1))}s=[];for(const l of o.slice().reverse())s.push(...l);return[a[0]].concat(s)})}build(e){let r;f1(e)&&(e=e[0]),this.cells.forEach((s,i)=>{Fc(`RNNCell_${i}`,()=>{s.build(e),r=Array.isArray(s.stateSize)?s.stateSize[0]:s.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){const e=super.getConfig(),i={cells:this.cells.map(o=>({className:o.getClassName(),config:o.getConfig()}))};return Object.assign(Object.assign({},e),i)}static fromConfig(e,r,s={}){const i=[];for(const o of r.cells)i.push(Aa(o,s));return new e({cells:i})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){const r=[];for(const s of this.cells)r.push(...s.trainableWeights);return r.concat(e)}return e}getWeights(){const e=[];for(const r of this.cells)e.push(...r.weights);return p1(e)}setWeights(e){const r=[];for(const s of this.cells){const o=e.splice(s.weights.length);for(let a=0;a<s.weights.length;++a)r.push([s.weights[a],o[a]])}m1(r)}}return n.className="StackedRNNCells",n})();function Dl(n){const{ones:t,rate:e,training:r=!1,count:s=1,dropoutFunc:i}=n,o=()=>null!=i?i(t(),e):YV(t(),e),a=()=>tm(o,t,r);return!s||s<=1?Dr(a().clone()):Array(s).fill(void 0).map(a).map(c=>Dr(c.clone()))}se(Gz);let bfe=(()=>{class n extends om{constructor(e){if(e.unroll)throw new nt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new nt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new hr({ndim:5})]}call(e,r){return z(()=>{if(null!=this.cell.dropoutMask&&(Je(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Je(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new O("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==r?null:r.mask,training:null==r?null:r.training,initialState:null==r?null:r.initialState})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return z(()=>{const{stateSize:r}=this.cell,i=this.computeSingleOutputShape(e.shape),a=ur([i[0],...i.slice(2)]);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){z(()=>{if(!this.stateful)throw new Ho("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,i=this.computeSingleOutputShape(s),o=[i[0],...i.slice(2)];if(null==s[0])throw new O("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>ur(o)):[ur(o)];else if(null==e)Je(this.states_),null!=this.keptStates&&(Je(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>ur(o)):this.states_[0]=ur(o);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new O(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):Je(this.states_);for(let l=0;l<this.states_.length;++l){const c=e[l],u=o;if(!Rt(c.shape,u))throw new O(`State ${l} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${c.shape}`);this.states_[l]=c}}this.states_=this.states_.map(l=>Dr(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:r,filters:s,kernelSize:i,padding:o,strides:a,dilationRate:l}=this.cell,c="channelsFirst"===r,d=e[c?4:3],h=wo(e[c?3:2],i[0],o,a[0],l[0]),f=wo(d,i[1],o,a[1],l[1]);return[...e.slice(0,2),...c?[s,h,f]:[h,f,s]]}}return n.className="ConvRNN2D",n})(),qz=(()=>{class n extends V1{constructor(e){const{filters:r,kernelSize:s,strides:i,padding:o,dataFormat:a,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:r})),this.filters=r,Nr(this.filters,"filters"),this.kernelSize=Fd(s,2,"kernelSize"),this.kernelSize.forEach(c=>Nr(c,"kernelSize")),this.strides=Fd(i||1,2,"strides"),this.strides.forEach(c=>Nr(c,"strides")),this.padding=o||"valid",bi(this.padding),this.dataFormat=a||"channelsLast",jn(this.dataFormat),this.dilationRate=Fd(l||1,2,"dilationRate"),this.dilationRate.forEach(c=>Nr(c,"dilationRate"))}build(e){var r;e=Vt(e);const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new O(`The channel dimension of the input should be defined. Found ${e[s]}`);const a=this.kernelSize.concat([e[s],4*this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){const u=this.biasInitializer,d=this.filters;c=new((r=class extends Gi{apply(f,p){return u1([u.apply([d]),pi([d]),u.apply([2*d])])}}).className="CustomInit",r)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return z(()=>{if(3!==e.length)throw new O(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=r.training||!1,i=e[0],o=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=Dl({ones:()=>mi(i),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const c=this.dropoutMask,u=(ie,de,ue)=>de&&de[ue]?M(de[ue],ie):ie;let d=u(i,c,0),h=u(i,c,1),f=u(i,c,2),p=u(i,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=Dl({ones:()=>mi(o),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const m=this.recurrentDropoutMask;let g=u(o,m,0),y=u(o,m,1),b=u(o,m,2),_=u(o,m,3);const[w,C,E,D]=Ws(this.kernel.read(),4,3),[T,N,P,U]=this.useBias?Ws(this.bias.read(),4):[null,null,null,null];d=this.inputConv(d,w,T,this.padding),h=this.inputConv(h,C,N,this.padding),f=this.inputConv(f,E,P,this.padding),p=this.inputConv(p,D,U,this.padding);const[j,q,K,$]=Ws(this.recurrentKernel.read(),4,3);g=this.recurrentConv(g,j),y=this.recurrentConv(y,q),b=this.recurrentConv(b,K),_=this.recurrentConv(_,$);const V=this.recurrentActivation.apply(le(d,g)),L=this.recurrentActivation.apply(le(h,y)),W=le(M(L,a),M(V,this.activation.apply(le(f,b)))),ne=M(this.recurrentActivation.apply(le(p,_)),this.activation.apply(W));return[ne,ne,W]})}getConfig(){const s=function(n,t){var e={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&t.indexOf(r)<0&&(e[r]=n[r]);if(null!=n&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(n);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(n,r[s])&&(e[r[s]]=n[r[s]])}return e}(super.getConfig(),["units"]),i={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),i)}inputConv(e,r,s,i){const o=ml(e,r,this.strides,i||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return s?_o(o,s,this.dataFormat):o}recurrentConv(e,r){return ml(e,r,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return n.className="ConvLSTM2DCell",n})();se(qz),se((()=>{class n extends bfe{constructor(e){const r=new qz(e);super(Object.assign(Object.assign({},e),{cell:r}))}static fromConfig(e,r){return new e(r)}}return n.className="ConvLSTM2D",n})());let Kz=(()=>{class n extends vt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const r=e.shape,s=[];for(let i=0;i<this.noiseShape.length;++i)s.push(this.noiseShape[i]??r[i]);return s}call(e,r){return z(()=>{this.invokeCallHook(e,r);const s=Ye(e);if(0<this.rate&&this.rate<1){const i=r.training??!1,o=this.getNoiseShape(s);return tm(()=>YV(s,this.rate,o,this.seed),()=>s,i)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return n.className="Dropout",n})();se(Kz),se((()=>{class n extends Kz{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const r=e.shape;return[r[0],1,r[2]]}}return n.className="SpatialDropout1D",n})()),se((()=>{class n extends vt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,Nr(this.units,"units"),this.activation=El(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=Sn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Sn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=pr(e.kernelConstraint),this.biasConstraint=pr(e.biasConstraint),this.kernelRegularizer=In(e.kernelRegularizer),this.biasRegularizer=In(e.biasRegularizer),this.activityRegularizer=In(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const r=(e=Vt(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){const r=(e=Vt(e)).slice();return r[r.length-1]=this.units,r}call(e,r){return z(()=>{this.invokeCallHook(e,r);const s=Ye(e),i=VV(this.activation.getClassName());let o;return null!=i?o=jo(s,this.kernel.read(),i,this.bias?this.bias.read():null):(o=jo(s,this.kernel.read()),null!=this.bias&&(o=_o(o,this.bias.read())),null!=this.activation&&(o=this.activation.apply(o))),o})}getConfig(){const e={units:this.units,activation:Il(this.activation),useBias:this.useBias,kernelInitializer:Rn(this.kernelInitializer),biasInitializer:Rn(this.biasInitializer),kernelRegularizer:sn(this.kernelRegularizer),biasRegularizer:sn(this.biasRegularizer),activityRegularizer:sn(this.activityRegularizer),kernelConstraint:fr(this.kernelConstraint),biasConstraint:fr(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dense",n})()),se((()=>{class n extends vt{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Vt(e);for(const r of e.slice(1))if(null==r)throw new O(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],xl(e,1)]}call(e,r){return z(()=>{this.invokeCallHook(e,r);let s=Ye(e);if("channelsFirst"===this.dataFormat&&s.rank>1){const i=[0];for(let o=2;o<s.rank;++o)i.push(o);i.push(1),s=Tt(s,i)}return function nhe(n){if(n.rank<=1)throw new O(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],xl(n.shape,1)];return F(n,t)}(s)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const r=super.getConfig();return Object.assign(e,r),e}}return n.className="Flatten",n})()),se((()=>{class n extends vt{constructor(e){super(e),this.supportsMasking=!0,this.activation=El(e.activation)}call(e,r){return z(()=>{this.invokeCallHook(e,r);const s=Ye(e);return this.activation.apply(s)})}getConfig(){const e={activation:Il(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Activation",n})()),se((()=>{class n extends vt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return z(()=>function ehe(n,t){return z(()=>{if(2!==n.shape.length)throw new O(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);return d1(Jp(n,1),[1,t,1])})}(e=Ye(e),this.n))}getConfig(){const e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return n.className="RepeatVector",n})()),se((()=>{class n extends vt{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,r){const s="Total size of new array must be unchanged.",i=r.slice();let o=1,a=null;for(let c=0;c<i.length;++c){const u=i[c];if(this.isUnknown(u)){if(null!==a)throw new O("Can only specifiy one unknown dimension.");a=c}else o*=u}const l=xl(e);if(null!==a){if(0===o||l%o!=0)throw new O(s);i[a]=l/o}else if(l!==o)throw new O(s);return i}computeOutputShape(e){let r=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return z(()=>{this.invokeCallHook(e,r);const s=Ye(e),i=s.shape,o=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return F(s,o)})}getConfig(){const e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Reshape",n})()),se((()=>{class n extends vt{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const r=yo(1,e.dims.length+1);if(!Rt(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new hr({ndim:this.dims.length+1})]}computeOutputShape(e){const r=(e=Vt(e)).slice();return this.dims.forEach((s,i)=>{r[i+1]=e[s]}),r}call(e,r){return Tt(Ye(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Permute",n})()),se((()=>{class n extends vt{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=null!=e?e.maskValue??0:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){const s=Ye(e);return l_(Id(s,this.maskValue),-1)}call(e,r){return z(()=>{this.invokeCallHook(e,r);const s=Ye(e),a=l_(Id(s,this.maskValue),-1,!0);return M(s,ve(a,s.dtype))})}}return n.className="Masking",n})()),se((()=>{class n extends vt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let r=null;null!=e.batchSize&&(r=e.batchSize),this.batchInputShape=null==e.inputLength?[r,null]:[r].concat(cn(e.inputLength))}this.inputDim=e.inputDim,Nr(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Nr(this.outputDim,"outputDim"),this.embeddingsInitializer=Sn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=In(e.embeddingsRegularizer),this.activityRegularizer=In(e.activityRegularizer),this.embeddingsConstraint=pr(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return z(()=>this.maskZero?(e=Ye(e),Id(e,Ft(e))):null)}computeOutputShape(e){if(e=Vt(e),null==this.inputLength)return[...e,this.outputDim];const r=cn(this.inputLength);if(r.length!==e.length-1)throw new O(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let i=0;i<r.length;++i){const o=r[i],a=e[i+1];if(null!=o&&null!=a&&o!==a)throw new O(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==o&&(r[s]=a),s++}}return[e[0],...r,this.outputDim]}call(e,r){return z(()=>{this.invokeCallHook(e,r);let s=Ye(e);"int32"!==s.dtype&&(s=Wo(s,"int32"));const i=XV(this.embeddings.read(),F(s,[s.size]));return F(i,Vt(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Rn(this.embeddingsInitializer),embeddingsRegularizer:sn(this.embeddingsRegularizer),activityRegularizer:sn(this.activityRegularizer),embeddingsConstraint:fr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Embedding",n})());class $c extends vt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new nt}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const r=t.slice(0,t.length-e.length);for(let s=0;s<e.length;++s){const i=t[t.length-e.length+s],o=e[s];if(null==i||null==o||i<0||o<0)r.push(null);else if(1===i)r.push(o);else if(1===o)r.push(i);else{if(i!==o)throw new O("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));r.push(i)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Vt(t)]),t.length<2)throw new O(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const i of t)null!=i&&null!==i[0]&&e.push(i[0]);if(e=vl(e),e.length>1)throw new O(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=null==t[0]?null:t[0].slice(1);for(let i=1;i<t.length;++i){const o=null==t[i]?null:t[i].slice(1);r=this.computeElementwiseOpOutputShape(r,o)}const s=t.map(i=>i.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==vl(s).length}call(t,e){return z(()=>{if(this.reshapeRequired){const r=[],s=t.map(i=>i.rank);if(-1===s.indexOf(null)){const i=wl(s);for(let o of t){const a=o.rank;for(let l=0;l<i-a;++l)o=Jp(o,1);r.push(o)}return this.mergeFunction(r)}{let i=!1;for(const l of t){const c=l.rank;if(null==c){const u=l.shape,d=u[0],h=u.slice(1).concat([d]);let f=F(l,[d].concat(xl(u.slice(1))));f=Tt(f,[1,0]),f=F(f,h),r.push(f),i=!0}else if(c>1){const u=yo(1,c).concat([0]);r.push(Tt(l,u)),i=!0}else r.push(l)}let o=this.mergeFunction(r);const a=o.rank;if(i)if(null==a){const l=o.shape,u=l[l.length-1],d=[u].concat(l.slice(0,l.length-1));o=F(Tt(F(o,[-1,u]),[1,0]),d)}else if(a>1){const l=[a-1].concat(yo(0,a-1));o=Tt(o,l)}return o}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let s=1;s<t.length;++s){const i=null==t[s]?null:t[s].slice(1);e=this.computeElementwiseOpOutputShape(e,i)}let r=[];for(const s of t)null!=s&&null!==s[0]&&r.push(s[0]);return r=vl(r),e=1===r.length?r.concat(e):[null].concat(e),e}computeMask(t,e){return z(()=>{if(null==e)return null;if(!Array.isArray(e))throw new O("`mask` should be an Array");if(!Array.isArray(t))throw new O("`inputs` should be an Array");if(e.length!==t.length)throw new O(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(s=>null==s))return null;let r=(e=e.map(s=>null==s?s:Is(s,0)))[0];for(let s=1;s<e.length-1;++s)r=Vo(r,e[s]);return r})}}function am(n,t){for(;n<0;)n+=t;return n}function lm(n,t,e,r,s,i=.001){let o;if(2===n.rank)o=tB(n,t,e,r,s,i);else if(3===n.rank)o=nB(n,t,e,r,s,i);else{if(4!==n.rank)throw new nt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);o=rB(n,t,e,r,s,i)}return o}function iv(n,t,e,r,s,i){return z(()=>{let o;jn(s),UV(i),bi(r),null==e&&(e=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),n=L1(n,s);const a="same"===r?"same":"valid";return o="max"===i?__(n,t,e,a):u_(n,t,e,a),"channelsFirst"===s&&(o=Tt(o,[0,3,1,2])),o})}function Xz(n,t,e,r,s,i){return z(()=>{let o;jn(s),UV(i),bi(r),null==e&&(e=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==i&&(i="max"),n=Pz(n,s);const a="same"===r?"same":"valid";return o="max"===i?TB(n,t,e,a):eB(n,t,e,a),"channelsFirst"===s&&(o=Tt(o,[0,4,1,2,3])),o})}se((()=>{class n extends $c{constructor(e){super(e)}mergeFunction(e){return z(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=le(r,e[s]);return r})}}return n.className="Add",n})()),se((()=>{class n extends $c{constructor(e){super(e)}mergeFunction(e){return z(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=M(r,e[s]);return r})}}return n.className="Multiply",n})()),se((()=>{class n extends $c{constructor(e){super(e)}mergeFunction(e){return z(()=>{let r=e[0].clone();for(let s=1;s<e.length;++s)r=le(r,e[s]);return M(1/e.length,r)})}}return n.className="Average",n})()),se((()=>{class n extends $c{constructor(e){super(e)}mergeFunction(e){return z(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=Ea(r,e[s]);return r})}}return n.className="Maximum",n})()),se((()=>{class n extends $c{constructor(e){super(e)}mergeFunction(e){return z(()=>{let r=e[0];for(let s=1;s<e.length;++s)r=zp(r,e[s]);return r})}}return n.className="Minimum",n})()),se((()=>{class n extends $c{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=e.axis??this.DEFAULT_AXIS,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new O("A `Concatenate` layer should be called on a list of at least 2 inputs");let r=!0;for(const i of e)if(null!=i){r=!1;break}if(r)return;const s=[];for(let i=0;i<e.length;++i){const o=e[i].slice();o.splice(this.axis,1);let a=!1;for(const l of s)if(Rt(l,o)){a=!0;break}a||s.push(o)}if(s.length>1)throw new O("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return z(()=>u1(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new O("A `Concatenate` layer should be called on a list of inputs.");const r=e,s=r[0].slice(),i=this.axis<0?s.length+this.axis:this.axis;for(const o of r.slice(1)){if(null==s[i]||null==o[i]){s[i]=null;break}s[i]+=o[i]}return s}computeMask(e,r){if(null==r)return null;if(!Array.isArray(r))throw new O("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new O("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new O(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return z(()=>{let s=!0;if(r.forEach(a=>{null==a||(s=!1)}),s)return null;const i=[];for(let a=0;a<e.length;++a)i.push(null==r[a]?ve(mi(e[a]),"bool"):r[a].rank<e[a].rank?Is(r[a],-1):r[a]);const o=Qn(i,this.axis);return $E(o,-1,!1)})}getConfig(){const e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Concatenate",n})()),se((()=>{class n extends $c{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize??!1,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){S(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0],s=e[1];if(r.length>3||s.length>3)throw new nt("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(r,s);if(r[i[0]]!==s[i[1]])throw new O(`Dimension incompatibility: ${r[i[0]]} !== ${s[i[1]]}`)}mergeFunction(e){if(2!==e.length)throw new O(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let i,r=e[0],s=e[1];return i=Array.isArray(this.axes)?this.axes.map((o,a)=>am(o,e[a].shape.length)):[am(this.axes,r.shape.length),am(this.axes,s.shape.length)],this.normalize&&(r=X_(r,i[0]),s=X_(s,i[1])),function _fe(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new nt("batchDot is not implemented for tensors of 4D or higher rank yet");if(S(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),S(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===n.dtype||"complex64"===t.dtype)throw new nt("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,s=t.shape.length;null==e&&(e=[r-1,s-2]);const i=e;return z(()=>{let o,a;if(r>s){o=r-s;const l=[];for(let c=0;c<o;++c)l.push(1);t=F(t,t.shape.concat(l))}else if(s>r){o=s-r;const l=[];for(let c=0;c<o;++c)l.push(1);n=F(n,n.shape.concat(l))}else o=0;if(a=2===n.shape.length&&2===t.shape.length?i[0]===i[1]?Re(M(n,t),i[0]):Re(M(Tt(n,[1,0]),t),i[1]):_t(n,t,i[0]!==n.shape.length-1,i[1]===t.shape.length-1),o>0){let l;l=r>s?r+s-3:r-1;const c=[];for(let u=l;u<l+o;++u)c.push(u);a=Tc(a,c)}return 1===a.shape.length&&(a=Is(a,1)),a})}(r,s,i)}interpretAxes(e,r){let s;return s=Array.isArray(this.axes)?this.axes:[am(this.axes,e.length),am(this.axes,r.length)],s}computeOutputShape(e){S(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0].slice(),s=e[1].slice();if(r.length>3||s.length>3)throw new nt("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(r,s);r.splice(i[0],1),s.splice(i[1],1),s.splice(0,1);const o=r.concat(s);return 1===o.length&&o.push(1),o}computeMask(e,r){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return n.className="Dot",n})()),se((()=>{class n extends vt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return z(()=>{this.invokeCallHook(e,r);const s=Ye(e);return tm(()=>le(U_(s.shape,0,this.stddev),s),()=>s,r.training||!1)})}}return n.className="GaussianNoise",n})()),se((()=>{class n extends vt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return z(()=>{this.invokeCallHook(e,r);const s=Ye(e);return this.rate>0&&this.rate<1?tm(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return M(s,U_(s.shape,1,o))},()=>s,r.training||!1):s})}}return n.className="GaussianDropout",n})()),se((()=>{class n extends vt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ye(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return z(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return tm(()=>{const o=Ye(e),c=-1.7580993408473766;let u=bl(Up(s),this.rate);u=Wo(u,"float32");const d=((1-this.rate)*(1+this.rate*c**2))**-.5,h=-d*c*this.rate,f=le(M(o,u),M(le(u,-1),c));return le(M(f,d),h)},()=>Ye(e),r.training||!1)}return e})}}return n.className="AlphaDropout",n})()),se((()=>{class n extends vt{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis??-1,this.momentum=e.momentum??.99,this.epsilon=e.epsilon??.001,this.center=e.center??!0,this.scale=e.scale??!0,this.betaInitializer=Sn(e.betaInitializer||"zeros"),this.gammaInitializer=Sn(e.gammaInitializer||"ones"),this.movingMeanInitializer=Sn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Sn(e.movingVarianceInitializer||"ones"),this.betaConstraint=pr(e.betaConstraint),this.gammaConstraint=pr(e.gammaConstraint),this.betaRegularizer=In(e.betaRegularizer),this.gammaRegularizer=In(e.gammaRegularizer)}build(e){e=Vt(e);const r=this.axis>=0?this.axis:this.axis+e.length,s=e[r];if(null==s)throw new O(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new hr({ndim:e.length,axes:{[r]:s}})];const i=[s];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return z(()=>{const s=r.training??!1,i=Ye(e),o=i.shape,a=o.length,l=yo(0,a),c=this.axis>=0?this.axis:this.axis+a;l.splice(c,1);const u=Ac(1,a);u[c]=o[c];const d=l.slice();d.sort();const h=!Rt(d,yo(0,a).slice(0,a-1));if(!s)return(()=>{if(h){const _=F(this.movingMean.read(),u),v=F(this.movingVariance.read(),u),w=this.center?F(this.beta.read(),u):null,C=this.scale?F(this.gamma.read(),u):null;return lm(i,_,v,w,C,this.epsilon)}return lm(i,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[p,m,g]=function wfe(n,t,e,r,s=.001){return Rt(r.slice().sort(),yo(0,n.rank-1))?function vfe(n,t,e,r,s=.001){return z(()=>{const i=v_(n,r),o=i.mean,a=i.variance;return[lm(n,o,a,e,t,s),o,a]})}(n,t,e,r,s):function xfe(n,t,e,r,s=.001){return z(()=>{const i=v_(n,r),o=i.mean,a=i.variance,l=[];for(const p of yo(0,n.rank))-1!==r.indexOf(p)?l.push(1):l.push(n.shape[p]);const c=F(o,l),u=F(a,l),d=null==t?null:F(t,l),h=null==e?null:F(e,l);return[lm(n,c,u,h,d,s),o,a]})}(n,t,e,r,s)}(i,this.gamma.read(),this.beta.read(),l,this.epsilon),y=(_,v,w)=>{z(()=>{const C=1-w,E=_.read(),D=M(De(E,v),C);_.write(De(E,D))})};return(()=>{y(this.movingMean,m,this.momentum),y(this.movingVariance,g,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Rn(this.betaInitializer),gammaInitializer:Rn(this.gammaInitializer),movingMeanInitializer:Rn(this.movingMeanInitializer),movingVarianceInitializer:Rn(this.movingVarianceInitializer),betaRegularizer:sn(this.betaRegularizer),gammaRegularizer:sn(this.gammaRegularizer),betaConstraint:fr(this.betaConstraint),gammaConstraint:fr(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="BatchNormalization",n})()),se((()=>{class n extends vt{constructor(e){if(null==e&&(e={}),super(e),this.axis=e.axis??-1,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=e.epsilon??.001,this.center=e.center??!0,this.scale=e.scale??!0,this.betaInitializer=Sn(e.betaInitializer||"zeros"),this.gammaInitializer=Sn(e.gammaInitializer||"ones"),this.betaRegularizer=In(e.betaRegularizer),this.gammaRegularizer=In(e.gammaRegularizer),this.supportsMasking=!0}build(e){const r=(e=Vt(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=r);for(const o of this.axis)if(o<0||o>=r)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==vl(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(o=>e[o]);this.gamma=this.scale?this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,r){const s=Ye(e),i=s.shape,o=i.length;return z(()=>{let{mean:l,variance:c}=v_(s,this.axis,!0);const u=Ac(1,o);for(const g of this.axis)u[g]=i[g];const d=g=>null!=g&&g.shape.length!==o?F(g,u):g;let h=this.scale?d(this.gamma.read()):null,f=this.center?d(this.beta.read()):null;const p=[],m=[];for(let g=0;g<o;++g)-1!==this.axis.indexOf(g)?(p.push(i[g]),m.push(1)):(p.push(1),m.push(i[g]));return l=Vi(l,p),c=Vi(c,p),null!=h&&(h=Vi(h,m)),null!=f&&(f=Vi(f,m)),lm(s,l,c,f,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Rn(this.betaInitializer),gammaInitializer:Rn(this.gammaInitializer),betaRegularizer:sn(this.betaRegularizer),gammaRegularizer:sn(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return n.className="LayerNormalization",n})()),se((()=>{class n extends vt{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=e.dataFormat??"channelsLast",null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new O(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,s;if("number"==typeof e.padding[0])r=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new O(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],2!==e.padding[1].length)throw new O(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[r,s]}this.inputSpec=[new hr({ndim:4})]}computeOutputShape(e){let r,s;return e=Vt(e),"channelsFirst"===this.dataFormat?(r=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],r,s]):(r=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,s=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],r,s,e[3]])}call(e,r){return z(()=>function Cfe(n,t,e){return z(()=>{if(4!==n.rank)throw new O(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new O("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new O(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===e?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],_l(n,r)})}(Ye(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return n.className="ZeroPadding2D",n})());class Yz extends vt{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new O(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(Nr(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new O(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}Nr(this.strides,"strides"),this.padding=t.padding??"valid",bi(this.padding),this.inputSpec=[new hr({ndim:3})]}computeOutputShape(t){const e=wo((t=Vt(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return z(()=>{this.invokeCallHook(t,e),t=Jp(Ye(t),2);const r=this.poolingFunction(Ye(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Tc(r,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}se((()=>{class n extends Yz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return jn(o),bi(i),iv(e,r,s,i,o,"max")}}return n.className="MaxPooling1D",n})()),se((()=>{class n extends Yz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return jn(o),bi(i),iv(e,r,s,i,o,"avg")}}return n.className="AveragePooling1D",n})());class Zz extends vt{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new O(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Nr(this.poolSize,"poolSize"),Nr(this.strides,"strides"),this.padding=t.padding??"valid",this.dataFormat=t.dataFormat??"channelsLast",jn(this.dataFormat),bi(this.padding),this.inputSpec=[new hr({ndim:4})]}computeOutputShape(t){t=Vt(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2];return e=wo(e,this.poolSize[0],this.padding,this.strides[0]),r=wo(r,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r]:[t[0],e,r,t[3]]}call(t,e){return z(()=>(this.invokeCallHook(t,e),this.poolingFunction(Ye(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}se((()=>{class n extends Zz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return jn(o),bi(i),iv(e,r,s,i,o,"max")}}return n.className="MaxPooling2D",n})()),se((()=>{class n extends Zz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return jn(o),bi(i),iv(e,r,s,i,o,"avg")}}return n.className="AveragePooling2D",n})());class Qz extends vt{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new O(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Nr(this.poolSize,"poolSize"),Nr(this.strides,"strides"),this.padding=t.padding??"valid",this.dataFormat=t.dataFormat??"channelsLast",jn(this.dataFormat),bi(this.padding),this.inputSpec=[new hr({ndim:5})]}computeOutputShape(t){t=Vt(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],r="channelsFirst"===this.dataFormat?t[3]:t[2],s="channelsFirst"===this.dataFormat?t[4]:t[3];return e=wo(e,this.poolSize[0],this.padding,this.strides[0]),r=wo(r,this.poolSize[1],this.padding,this.strides[1]),s=wo(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,r,s]:[t[0],e,r,s,t[4]]}call(t,e){return z(()=>(this.invokeCallHook(t,e),this.poolingFunction(Ye(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}se((()=>{class n extends Qz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return jn(o),bi(i),Xz(e,r,s,i,o,"max")}}return n.className="MaxPooling3D",n})()),se((()=>{class n extends Qz{constructor(e){super(e)}poolingFunction(e,r,s,i,o){return jn(o),bi(i),Xz(e,r,s,i,o,"avg")}}return n.className="AveragePooling3D",n})());class Jz extends vt{constructor(t){super(t),this.inputSpec=[new hr({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new nt}}se((()=>{class n extends Jz{constructor(e){super(e||{})}call(e,r){return z(()=>{const s=Ye(e);return Ln(s,1)})}}return n.className="GlobalAveragePooling1D",n})()),se((()=>{class n extends Jz{constructor(e){super(e||{})}call(e,r){return z(()=>{const s=Ye(e);return Bi(s,1)})}}return n.className="GlobalMaxPooling1D",n})());class e3 extends vt{constructor(t){super(t),this.dataFormat=t.dataFormat??"channelsLast",jn(this.dataFormat),this.inputSpec=[new hr({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new nt}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}se((()=>{class n extends e3{call(e,r){return z(()=>{const s=Ye(e);return Ln(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalAveragePooling2D",n})()),se((()=>{class n extends e3{call(e,r){return z(()=>{const s=Ye(e);return Bi(s,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalMaxPooling2D",n})());class t3 extends vt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,r={}){const i=Aa(e.layer,r);delete e.layer;const o={layer:i};return Object.assign(o,e),new t(o)}}se((()=>{class n extends t3{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Vt(e)).length<3)throw new O(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){const r=[(e=Vt(e))[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(r);return[s[0],e[1]].concat(s.slice(1))}call(e,r){return z(()=>Hz((a,l)=>[Ye(this.layer.call(a,r)),[]],e=Ye(e),[],!1,null,null,!1,!0)[1])}}return n.className="TimeDistributed",n})()),se((()=>{class n extends t3{constructor(e){super(e);const r=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=r,this.forwardLayer=Aa(s),r.goBackwards=!0!==r.goBackwards;const i={};if(i.className=e.layer.getClassName(),i.config=r,this.backwardLayer=Aa(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function Sfe(n){Mc(qde,"BidirectionalMergeMode",n)}(this.mergeMode),e.weights)throw new nt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const s=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let s,i,o,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState&&(o=r.slice(1)),s=r[0],"concat"===this.mergeMode?(s[s.length-1]*=2,i=[s]):i=null==this.mergeMode?[s,s.slice()]:[s],this.returnState?null==this.mergeMode?i.concat(o).concat(o.slice()):[s].concat(o).concat(o.slice()):Ds(i)}apply(e,r){let s=null==r?null:r.initialState,i=null==r?null:r.constants;null==r&&(r={});const o=Uz(e,s,i,this.numConstants);if(e=o.inputs,s=o.initialState,i=o.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(null==s||0===s.length)&&null==i)return super.apply(e,r);const a=[],l=[];if(null!=s){const u=s.length;if(u%2>0)throw new O("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=s,a.push(...s);const d=s.map(h=>new hr({shape:h.shape}));this.forwardLayer.stateSpec=d.slice(0,u/2),this.backwardLayer.stateSpec=d.slice(u/2),l.push(...d)}if(null!=i)throw new nt("Support for constants in Bidirectional layers is not implemented yet.");const c=a[0]instanceof qo;for(const u of a)if(u instanceof qo!==c)throw new O("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const u=[e].concat(a),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const f=super.apply(u,r);return this.inputSpec=h,f}return super.apply(e,r)}call(e,r){return z(()=>{const s=r.initialState;let i,o,a,l;if(null==s)i=this.forwardLayer.call(e,r),o=this.backwardLayer.call(e,r);else{const c=s.slice(0,s.length/2),u=s.slice(s.length/2);i=this.forwardLayer.call(e,Object.assign(r,{initialState:c})),o=this.backwardLayer.call(e,Object.assign(r,{initialState:u}))}return this.returnState&&(Array.isArray(i)&&(a=i.slice(1).concat(o.slice(1))),i=i[0],o=o[0]),this.returnSequences&&(o=zi(o,1)),"concat"===this.mergeMode?l=u1([i,o]):"sum"===this.mergeMode?l=le(i,o):"ave"===this.mergeMode?l=M(.5,le(i,o)):"mul"===this.mergeMode?l=M(i,o):null==this.mergeMode&&(l=[i,o]),this.returnState?null==this.mergeMode?l.concat(a):[l].concat(a):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Fc(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Fc(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){let s;if(Array.isArray(r)&&(r=r[0]),s=this.returnSequences?null==this.mergeMode?[r,r]:r:null==this.mergeMode?[null,null]:null,this.returnState){const o=this.forwardLayer.states.map(a=>null);return Array.isArray(s)?s.concat(o).concat(o):[s].concat(o).concat(o)}return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){const s=Aa(r.layer);if(delete r.layer,null!=r.numConstants)throw new nt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=r;return i.layer=s,new e(i)}}return n.className="Bidirectional",n})()),se((()=>{class n extends vt{constructor(e){super(e),this.scale=e.scale,this.offset=e.offset?e.offset:0}getConfig(){const e={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return z(()=>("float32"!==(e=Ye(e)).dtype&&(e=Wo(e,"float32")),le(M(e,this.scale),this.offset)))}}return n.className="Rescaling",n})());const{resizeBilinear:Efe,cropAndResize:Dfe}=Ta;se((()=>{class n extends vt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,r,s,i,o,a,l,c){return z(()=>{let u,d=!1;const g=[r/a,s/l,(i+r)/a,(o+s)/l],y=[];3===e.rank?(d=!0,u=gi([e])):u=e;for(let C=0;C<u.shape[0];C++)y.push(g);const b=mo(y,[y.length,4]),_=Ed(0,y.length,1,"int32"),w=Dfe(u,b,_,[i,o],"nearest");return Wo(d?Ye(Ui(w)):w,c)})}upsize(e,r,s,i){return z(()=>Wo(Efe(e,[r,s]),i))}call(e,r){return z(()=>{const s=Ye(e),i=s.dtype,o=s.shape,a=o[o.length-3],l=o[o.length-2];let c=0;a!==this.height&&(c=Math.floor((a-this.height)/2));let u=0;return l!==this.width&&(u=Math.floor((l-this.width)/2),0===u&&(u=1)),c>=0&&u>=0?this.centerCrop(s,c,u,this.height,this.width,a,l,i):this.upsize(e,this.height,this.width,i)})}getConfig(){const e={height:this.height,width:this.width},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){const s=(e=Vt(e)).length-2;return e[e.length-3]=this.height,e[s]=this.width,e}}return n.className="CenterCrop",n})()),se((()=>{class n extends vt{constructor(e){super(e),this.numTokens=e.numTokens,this.outputMode=e.outputMode?e.outputMode:"multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return null==(e=Vt(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,r){return z(()=>{let s;if("int32"!==(e=Ye(e)).dtype&&(e=Wo(e,"int32")),typeof r.countWeights<"u"){if("count"!==this.outputMode)throw new O(`countWeights is not used when outputMode !== count.\n              Received countWeights=${r.countWeights}`);s=Ye(r.countWeights)}const i=Bi(e),o=Pp(e),a=Hs(this.numTokens,i).bufferSync().get(0),l=bl(o,0).bufferSync().get(0);if(!a||!l)throw new O(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function Tfe(n,t,e,r){let s=Ye(n);if("int32"!==s.dtype&&(s=Wo(s,"int32")),"int"===t)return s;const i=s.shape;if(0===s.rank&&(s=Is(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=Is(s,-1)),s.rank>2)throw new O(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${s.rank}.`);const o=["multiHot","oneHot"].includes(t);let l;if(l=WE(s,typeof r<"u"&&"count"===t?r:[],e,o),"tfIdf"!==t)return l;if(r)return M(l,r);throw new O("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,s)})}}return n.className="CategoryEncoding",n})());const n3=new Set(["bilinear","nearest"]);se((()=>{class n extends vt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!n3.has(e.interpolation))throw new O(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){return e=Vt(e),[this.height,this.width,e[2]]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return z(()=>{const s=[this.height,this.width];if("bilinear"===this.interpolation)return Ta.resizeBilinear(e,s,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Ta.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...n3]} are supported`)})}}return n.className="Resizing",n})()),G().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var l3,vi=(()=>{return(n=vi||(vi={}))[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF",vi;var n})();!function(n){let t;var e;(e=t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(l3||(l3={}));const q1={};function c3(n){return q1[n]}function x(n,t,e,r,s){const i=t.inputParams[n];if(i&&void 0!==i.inputIndexStart){const a=i.inputIndexStart,l=0===i.inputIndexEnd?void 0:void 0===i.inputIndexEnd?a+1:i.inputIndexEnd;if("tensor"===i.type)return us(t.inputNames[i.inputIndexStart],e,r,s);if("tensors"===i.type)return t.inputNames.slice(a,l).map(h=>us(h,e,r,s));const c=us(t.inputNames.slice(a)[0],e,r,s),u=c.dataSync();return"number"===i.type?u[0]:$i(c.shape,u)}const o=t.attrParams[n];return o&&o.value}function us(n,t,e,r){const[s,i]=js(n);if(null!=r){const a=r.getHashTableHandleByName(s);if(null!=a)return a}const o=e.currentContextIds.find(a=>!!t[av(s,a)]);return void 0!==o?t[av(s,o)][i]:void 0}function Ra(n,t){const[e,r,s]=js(n);return[av(e,t&&t.currentContextId),r,s]}function av(n,t){return t?`${n}-${t}`:n}function js(n){const t=n.split(":");if(1===t.length)return[n,0,void 0];const r=3===t.length?t[1]:void 0;return[t[0],Number(t[t.length-1]),r]}function lv(n,t,e){let r=x("pad",n,t,e);if("explicit"===r){r=x("explicitPaddings",n,t,e);const s=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)s[i][0]=r[2*i],s[i][1]=r[2*i+1];return s}return r}function Ma(n){return n.kept?n:wa(n)}const Ffe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ofe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],$fe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Pfe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Lfe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Bfe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Vfe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],zfe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Ufe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Hfe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Wfe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],jfe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],Gfe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],qfe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Kfe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],Xfe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Yfe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Zfe=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Qfe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class u3{constructor(){const e=[].concat(...[ze,ot,Ee,H,pe,be,re,fe,Ne,$e,Ht,tr,qn,Ei,Zs,Nt,Pt,Lt,ce].map(r=>r.json));this.opMappers=e.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}static get Instance(){return this._instance||(this._instance=new this)}transformGraph(t,e={}){const s=[],i=[],o=[],a=t.node.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?s.push(m[g.name]):"Const"===g.op?i.push(m[g.name]):(null==g.input||0===g.input.length)&&o.push(m[g.name]),m),{});let l=[];const c=[];let u={},d={};null!=e&&(u=this.mapSignatureEntries(e.inputs),d=this.mapSignatureEntries(e.outputs));const h=Object.keys(a);h.forEach(m=>{const g=a[m];g.inputNames.forEach((y,b)=>{const[_,,v]=Ra(y),w=a[_];if(null!=w.outputs){const C=w.outputs.indexOf(v);-1!==C&&(g.inputNames[b]=`${_}:${C}`)}g.inputs.push(w),w.children.push(g)})}),0===Object.keys(d).length?h.forEach(m=>{const g=a[m];0===g.children.length&&c.push(g)}):Object.keys(d).forEach(m=>{const[g]=Ra(m),y=a[g];null!=y&&(y.signatureKey=d[m],c.push(y))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{const[g]=Ra(m),y=a[g];y&&(y.signatureKey=u[m],l.push(y))}):l=s;let f={};null!=t.library&&null!=t.library.function&&(f=t.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const p={nodes:a,inputs:l,outputs:c,weights:i,placeholders:s,signature:e,functions:f};return o.length>0&&(p.initNodes=o),p}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,r)=>(e[t[r].name]=r,e),{})}mapNode(t){const e=c3(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const r={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return null!=e.inputs&&(r.inputParams=e.inputs.reduce((s,i)=>(s[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},s),{})),null!=e.attrs&&(r.attrParams=e.attrs.reduce((s,i)=>{const o=i.type;let a;switch(i.type){case"string":a=K1(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=K1(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":a=nT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=nT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":a=Y1(t.attr,i.tfName,i.defaultValue||0),void 0===a&&i.tfDeprecatedName&&(a=Y1(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":a=tT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=tT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":a=X1(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=X1(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":a=sT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=sT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":a=eT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=eT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":a=rT(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=rT(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":a=Q1(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=Q1(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":a=J1(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=J1(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":a=h3(t.attr,i.tfName,i.defaultValue),void 0===a&&i.tfDeprecatedName&&(a=h3(t.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${t.op}`)}return s[i.name]={value:a,type:o},s},{})),r}mapFunction(t){const e=t.nodeDef,s=[];let i={};null!=e&&(i=e.reduce((d,h)=>(d[h.name]=this.mapNode(h),"Const"===h.op&&s.push(d[h.name]),d),{}));const o=[],a=[];t.signature.inputArg.forEach(d=>{const[h]=Ra(d.name),f={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Z1(d.type),type:"dtype"}},children:[]};f.signatureKey=d.name,o.push(f),i[h]=f}),Object.keys(i).forEach(d=>{const h=i[d];h.inputNames.forEach((f,p)=>{const[m,,g]=Ra(f),y=i[m];if(null!=y.outputs){const b=y.outputs.indexOf(g);-1!==b&&(h.inputNames[p]=`${m}:${b}`)}h.inputs.push(y),y.children.push(h)})});const c=t.ret;t.signature.outputArg.forEach(d=>{const[h,f]=Ra(c[d.name]),p=i[h];null!=p&&(p.defaultOutput=f,a.push(p))});const u=this.mapArgsToSignature(t);return{nodes:i,inputs:o,outputs:a,weights:s,placeholders:[],signature:u}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r),e),{}),outputs:t.signature.outputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r,t.ret),e),{})}}mapArgToTensorInfo(t,e){let r=t.name;return null!=e&&(r=e[r]),{name:r,dtype:t.type}}}function d3(n,t){const e=Array.isArray(n)?String.fromCharCode.apply(null,n):function Jfe(n){const t=G().global;if(typeof t.atob<"u")return t.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(n);return t?e:e.toLowerCase()}function K1(n,t,e,r=!1){const s=n[t];return null!=s?d3(s.s,r):e}function X1(n,t,e){const r=n[t];return r?r.b:e}function Y1(n,t,e){const r=n[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:e;return"number"==typeof s?s:parseInt(s,10)}function Z1(n){switch("string"==typeof n&&(n=vi[n]),n){case vi.DT_FLOAT:case vi.DT_HALF:return"float32";case vi.DT_INT32:case vi.DT_INT64:case vi.DT_INT8:case vi.DT_UINT8:return"int32";case vi.DT_BOOL:return"bool";case vi.DT_DOUBLE:return"float32";case vi.DT_STRING:return"string";default:return null}}function h3(n,t,e){const r=n[t];return r&&r.func?r.func.name:e}function Q1(n,t,e){const r=n[t];return r&&r.type?Z1(r.type):e}function J1(n,t,e){const r=n[t];return r&&r.list&&r.list.type?r.list.type.map(s=>Z1(s)):e}function f3(n){if(!n.unknownRank)return null!=n.dim?n.dim.map(t=>"number"==typeof t.size?t.size:parseInt(t.size,10)):[]}function eT(n,t,e){const r=n[t];return r&&r.shape?f3(r.shape):e}function tT(n,t,e){const r=n[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>"number"==typeof s?s:parseInt(s,10)):e}function nT(n,t,e,r=!1){const s=n[t];return s&&s.list&&s.list.s?s.list.s.map(i=>d3(i,r)):e}function rT(n,t,e){const r=n[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>f3(s)):e}function sT(n,t,e){const r=n[t];return r&&r.list&&r.list.b?r.list.b:e}class epe{constructor(t,e,r){this.node=t,this.tensorMap=e,this.context=r,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(s=>this.getInput(s)),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce((s,i)=>(s[i]=this.getAttr(i),s),{}))}getInput(t){return us(t,this.tensorMap,this.context)}getAttr(t,e){const r=this.node.rawAttrs[t];if(null!=r.tensor)return us(t,this.tensorMap,this.context);if(null!=r.i||null!=r.f)return Y1(this.node.rawAttrs,t,e);if(null!=r.s)return K1(this.node.rawAttrs,t,e);if(null!=r.b)return X1(this.node.rawAttrs,t,e);if(null!=r.shape)return eT(this.node.rawAttrs,t,e);if(null!=r.type)return Q1(this.node.rawAttrs,t,e);if(null!=r.list){if(null!=r.list.i||null!=r.list.f)return tT(this.node.rawAttrs,t,e);if(null!=r.list.s)return nT(this.node.rawAttrs,t,e);if(null!=r.list.shape)return rT(this.node.rawAttrs,t,e);if(null!=r.list.b)return sT(this.node.rawAttrs,t,e);if(null!=r.list.type)return J1(this.node.rawAttrs,t,e)}return e}}function qi(n,t,e=""){if("number"!=typeof n&&"number"!=typeof t){S(n.length===t.length,()=>e+` Shapes ${n} and ${t} must match`);for(let r=0;r<n.length;r++){const s=n[r],i=t[r];S(s<0||i<0||s===i,()=>e+` Shapes ${n} and ${t} must match`)}}}function p3(n){return!("number"==typeof n||n.some(t=>t<0))}function cm(n,t,e){let r=iT(n,e);const s=!p3(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(i=>{r=iT(i.shape,r)}),!p3(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function iT(n,t){if("number"==typeof n)return t;if("number"==typeof t)return n;if(n.length!==t.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${t}`);const e=[];for(let r=0;r<n.length;++r){const s=n[r],i=t[r];if(s>=0&&i>=0&&s!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${t}`);e[r]=s>=0?s:i}return e}class rpe{constructor(t,e,r,s,i,o,a){this.name=t,this.dtype=e,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Be(0),Dr(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=e.shape),qi(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);r.tensor=e,Dr(e),r.written=!0,this.tensors[t]=r}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((r,s)=>this.write(r,e[s]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let s=0;s<this.size();s++)t.push(s)}if(0===t.length)return mo([],[0].concat(this.elementShape));const r=this.readMany(t);return qi(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),gi(r,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return mo([],[0].concat(this.elementShape));const e=[];for(let s=0;s<this.size();s++)e.push(s);const r=this.readMany(e);return qi(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Qn(r,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const r=Math.max(...t);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(t,Ui(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let r=0;const s=t.map(l=>(r+=l,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const i=0===r?0:e.size/r,o=[];z(()=>{e=F(e,[1,r,i]);for(let l=0;l<t.length;++l)o[l]=F(Mt(e,[0,0===l?0:s[l-1],0],[1,t[l],i]),this.elementShape);return o});const a=[];for(let l=0;l<t.length;l++)a[l]=l;this.writeMany(a,o)}}class Pc{constructor(t,e,r,s=-1){this.tensors=t,this.elementShape=e,this.elementDtype=r,t?.forEach(i=>{if(r!==i.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${i.dtype}`);qi(e,i.shape,"TensorList shape mismatch: "),Dr(i)}),this.idTensor=Be(0),this.maxNumElements=s,Dr(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Pc([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,r=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==r&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);qi(t,this.elementShape,"TensorList shape mismatch: ");const s=cm(this.elementShape,this.tensors,t);return z(()=>{const i=this.tensors.map(o=>F(o,s));return gi(i,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const r=cm(this.elementShape,this.tensors,t),s=this.tensors.pop();return s.kept=!1,qi(s.shape,t,"TensorList shape mismatch: "),F(s,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(qi(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Dr(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new Pc([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)e.tensors[r]=this.tensors[r];return e}getItem(t,e,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);qi(this.tensors[t].shape,e,"TensorList shape mismatch: ");const s=cm(this.elementShape,this.tensors,e);return F(this.tensors[t],s)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);qi(this.elementShape,e.shape,"TensorList shape mismatch: "),Dr(e),null!=this.tensors[t]&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,r){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);qi(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());const s=cm(this.elementShape,this.tensors,r);return 0===t.length?mo([],[0].concat(s)):z(()=>{const i=t.map(o=>F(this.tensors[o],s));return gi(i,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);qi(this.elementShape,e,"TensorList shape mismatch: ");const r=cm(this.elementShape,this.tensors,e);return 0===this.size()?mo([],[0].concat(r)):z(()=>{const s=this.tensors.map(i=>F(i,r));return Qn(s,0)})}}const lpe=function(){var n=ee(function*(t,e,r){switch(t.op){case"If":case"StatelessIf":{const s=x("thenBranch",t,e,r),i=x("elseBranch",t,e,r),o=x("cond",t,e,r),a=x("args",t,e,r);return(yield o.data())[0]?r.functionMap[s].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap):r.functionMap[i].executeFunctionAsync(a,r.tensorArrayMap,r.tensorListMap)}case"While":case"StatelessWhile":{const s=x("body",t,e,r),i=x("cond",t,e,r),o=x("args",t,e,r),a=yield r.functionMap[i].executeFunctionAsync(o,r.tensorArrayMap,r.tensorListMap),l=o.map(d=>d.id);let c=yield a[0].data();a.forEach(d=>{!d.kept&&-1===l.indexOf(d.id)&&d.dispose()});let u=o;for(;c[0];){const d=u;u=yield r.functionMap[s].executeFunctionAsync(u,r.tensorArrayMap,r.tensorListMap);const h=u.map(p=>p.id);d.forEach(p=>{!p.kept&&-1===l.indexOf(p.id)&&-1===h.indexOf(p.id)&&p.dispose()});const f=yield r.functionMap[i].executeFunctionAsync(u,r.tensorArrayMap,r.tensorListMap);c=yield f[0].data(),f.forEach(p=>{!p.kept&&-1===l.indexOf(p.id)&&-1===h.indexOf(p.id)&&p.dispose()})}return u}case"LoopCond":return[Ma(x("pred",t,e,r))];case"Switch":{const s=x("pred",t,e,r);let i=x("data",t,e,r);return i.kept||(i=Ma(i)),(yield s.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const s=t.inputNames.find(i=>void 0!==us(i,e,r));return s?[Ma(us(s,e,r))]:void 0}case"Enter":{const s=x("frameName",t,e,r),i=x("tensor",t,e,r);return r.enterFrame(s),[Ma(i)]}case"Exit":{const s=x("tensor",t,e,r);return r.exitFrame(),[Ma(s)]}case"NextIteration":{const s=x("tensor",t,e,r);return r.nextIteration(),[Ma(s)]}case"TensorArrayV3":{const s=x("size",t,e,r),i=x("dtype",t,e,r),o=x("elementShape",t,e,r),a=x("dynamicSize",t,e,r),l=x("clearAfterRead",t,e,r),c=x("identicalElementShapes",t,e,r),u=x("name",t,e,r),d=new rpe(u,i,s,o,c,a,l);return r.addTensorArray(d),[d.idTensor,Be(1)]}case"TensorArrayWriteV3":{const s=x("tensorArrayId",t,e,r),i=x("index",t,e,r),o=x("tensor",t,e,r),a=r.getTensorArray(s.id);return a.write(i,o),[a.idTensor]}case"TensorArrayReadV3":{const s=x("tensorArrayId",t,e,r),i=x("index",t,e,r);return[r.getTensorArray(s.id).read(i)]}case"TensorArrayGatherV3":{const s=x("tensorArrayId",t,e,r),i=x("indices",t,e,r),o=x("dtype",t,e,r);return[r.getTensorArray(s.id).gather(i,o)]}case"TensorArrayScatterV3":{const s=x("tensorArrayId",t,e,r),i=x("indices",t,e,r),o=x("tensor",t,e,r),a=r.getTensorArray(s.id);return a.scatter(i,o),[a.idTensor]}case"TensorArrayConcatV3":{const s=x("tensorArrayId",t,e,r),i=r.getTensorArray(s.id),o=x("dtype",t,e,r);return[i.concat(o)]}case"TensorArraySplitV3":{const s=x("tensorArrayId",t,e,r),i=x("tensor",t,e,r),o=x("lengths",t,e,r),a=r.getTensorArray(s.id);return a.split(o,i),[a.idTensor]}case"TensorArraySizeV3":{const s=x("tensorArrayId",t,e,r);return[Be(r.getTensorArray(s.id).size(),"int32")]}case"TensorArrayCloseV3":{const s=x("tensorArrayId",t,e,r),i=r.getTensorArray(s.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const s=x("tensorListId",t,e,r),i=x("index",t,e,r),o=x("tensor",t,e,r),a=r.getTensorList(s.id);return a.setItem(i,o),[a.idTensor]}case"TensorListGetItem":{const s=x("tensorListId",t,e,r),i=x("index",t,e,r),o=x("elementShape",t,e,r),a=x("elementDType",t,e,r);return[r.getTensorList(s.id).getItem(i,o,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=x("indices",t,e,r),l=function ope(n,t,e,r){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const i=new Pc([],e,n.dtype,r),o=Ui(n,0);return t.forEach((a,l)=>{i.setItem(a,o[l])}),i}(x("tensor",t,e,r),s,x("elementShape",t,e,r),x("numElements",t,e,r));return r.addTensorList(l),[l.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=x("elementShape",t,e,r),i=x("elementDType",t,e,r);let o;o="TensorListReserve"===t.op?"numElements":"maxNumElements";const a=x(o,t,e,r),c=function ipe(n,t,e,r){return new Pc([],n,t,r)}(s,i,0,"TensorListReserve"===t.op?-1:a);return r.addTensorList(c),[c.idTensor]}case"TensorListGather":{const s=x("tensorListId",t,e,r),i=x("indices",t,e,r),o=x("elementShape",t,e,r),a=x("elementDType",t,e,r);return[r.getTensorList(s.id).gather(i,a,o)]}case"TensorListStack":{const s=x("tensorListId",t,e,r),i=x("elementShape",t,e,r),o=x("elementDType",t,e,r),a=x("numElements",t,e,r);return[r.getTensorList(s.id).stack(i,o,a)]}case"TensorListFromTensor":{const a=function spe(n,t,e){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);qi(n.shape.slice(1),t,"TensorList shape mismatch: ");const i=Ui(n);return new Pc(i,t,r)}(x("tensor",t,e,r),x("elementShape",t,e,r),x("elementDType",t,e,r));return r.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=x("tensorListId",t,e,r),i=r.getTensorList(s.id),o=x("dtype",t,e,r),a=x("elementShape",t,e,r);return[i.concat(o,a)]}case"TensorListPushBack":{const s=x("tensorListId",t,e,r),i=x("tensor",t,e,r),o=r.getTensorList(s.id);return o.pushBack(i),[o.idTensor]}case"TensorListPopBack":{const s=x("tensorListId",t,e,r),i=x("elementShape",t,e,r),o=x("elementDType",t,e,r);return[r.getTensorList(s.id).popBack(i,o)]}case"TensorListSplit":{const s=x("tensor",t,e,r),i=x("elementShape",t,e,r),a=function ape(n,t,e){let r=0;const s=t.map(u=>(r+=u,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${n.shape}`);const o=iT(n.shape.slice(1),e),a=0===r?0:n.size/r,l=z(()=>{const u=[];n=F(n,[1,r,a]);for(let d=0;d<t.length;++d)u[d]=F(Mt(n,[0,0===d?0:s[d-1],0],[1,t[d],a]),o);return n.dispose(),u}),c=new Pc([],e,n.dtype,t.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}(s,x("lengths",t,e,r),i);return r.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=x("tensorListId",t,e,r);return[Be(r.getTensorList(s.id).size(),"int32")]}case"TensorListResize":{const s=x("tensorListId",t,e,r),i=x("size",t,e,r),a=r.getTensorList(s.id).resize(i);return r.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s){return n.apply(this,arguments)}}();function m3(n,t,e){const[r,s]=x("fusedOps",n,t,e),i="biasadd"===r,o=!i,a="prelu"===s,l="fusedbatchnorm"===r,c=x("numArgs",n,t,e);if(i){if(a&&2!==c)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i&&1!==c)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=x("strides",n,t,e),d=lv(n,t,e),h=x("dataFormat",n,t,e).toUpperCase(),f=x("dilations",n,t,e);let[p,m]=x("args",n,t,e);return o&&(m=p,p=void 0),{stride:u,pad:d,dataFormat:h,dilations:f,biasArg:p,preluArg:m,activationFunc:s,leakyreluAlpha:x("leakyreluAlpha",n,t,e)}}function oT(n,t,e){return{boxes:x("boxes",n,t,e),scores:x("scores",n,t,e),maxOutputSize:x("maxOutputSize",n,t,e),iouThreshold:x("iouThreshold",n,t,e),scoreThreshold:x("scoreThreshold",n,t,e),softNmsSigma:x("softNmsSigma",n,t,e)}}const dpe=function(){var n=ee(function*(t,e,r,s,i=J){switch(t.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:a,maxOutputSize:l,iouThreshold:c,scoreThreshold:u,softNmsSigma:d}=oT(t,e,r),h=yield i.image.nonMaxSuppressionWithScoreAsync(o,a,l,c,u,d);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:a,maxOutputSize:l,iouThreshold:c,scoreThreshold:u}=oT(t,e,r),d=x("padToMaxOutputSize",t,e,r),h=yield i.image.nonMaxSuppressionPaddedAsync(o,a,l,c,u,d);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:a,maxOutputSize:l,iouThreshold:c,scoreThreshold:u}=oT(t,e,r);return[yield i.image.nonMaxSuppressionAsync(o,a,l,c,u)]}case"Where":{const o=i.cast(x("condition",t,e,r),"bool"),a=[yield i.whereAsync(o)];return o.dispose(),a}case"ListDiff":return i.setdiff1dAsync(x("x",t,e,r),x("y",t,e,r));default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s,i){return n.apply(this,arguments)}}();class ppe{constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=Be(0),this.tensorMap=new Map,Dr(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Be(this.size(),"int32")}import(t,e){var r=this;return ee(function*(){r.checkKeyAndValueTensor(t,e);const s=yield t.data();return r.tensorMap.forEach(i=>i.dispose()),r.tensorMap.clear(),z(()=>{const i=Ui(e),o=s.length,a=i.length;S(o===a,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${a} elements.`);for(let l=0;l<o;l++){const c=s[l],u=i[l];Dr(u),r.tensorMap.set(c,u)}return r.handle})})()}find(t,e){var r=this;return ee(function*(){r.checkKeyAndValueTensor(t,e);const s=yield t.data();return z(()=>{const i=[];for(let o=0;o<s.length;o++){const l=r.findWithDefault(s[o],e);i.push(l)}return gi(i)})})()}findWithDefault(t,e){return this.tensorMap.get(t)??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}const mpe=function(){var n=ee(function*(t,e,r,s){switch(t.op){case"HashTable":case"HashTableV2":{const i=s.getHashTableHandleByName(t.name);if(null!=i)return[i];{const o=x("keyDType",t,e,r),a=x("valueDType",t,e,r),l=new ppe(o,a);return s.addHashTable(t.name,l),[l.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const i=x("tableHandle",t,e,r,s),o=x("keys",t,e,r),a=x("values",t,e,r);return[yield s.getHashTableById(i.id).import(o,a)]}case"LookupTableFind":case"LookupTableFindV2":{const i=x("tableHandle",t,e,r,s),o=x("keys",t,e,r),a=x("defaultValue",t,e,r);return[yield s.getHashTableById(i.id).find(o,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=x("tableHandle",t,e,r,s);return[s.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,r,s,i){return n.apply(this,arguments)}}();function g3(n,t,e,r,s=z){const i=((o,a,l)=>{switch(o.category){case"arithmetic":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(x("a",n,t,e),x("b",n,t,e))];case"AddN":return[r.addN(x("tensors",n,t,e))];case"FloorMod":case"Mod":return[r.mod(x("a",n,t,e),x("b",n,t,e))];case"Mul":return[r.mul(x("a",n,t,e),x("b",n,t,e))];case"RealDiv":case"Div":return[r.div(x("a",n,t,e),x("b",n,t,e))];case"DivNoNan":return[r.divNoNan(x("a",n,t,e),x("b",n,t,e))];case"FloorDiv":return[r.floorDiv(x("a",n,t,e),x("b",n,t,e))];case"Sub":return[r.sub(x("a",n,t,e),x("b",n,t,e))];case"Minimum":return[r.minimum(x("a",n,t,e),x("b",n,t,e))];case"Maximum":return[r.maximum(x("a",n,t,e),x("b",n,t,e))];case"Pow":return[r.pow(x("a",n,t,e),x("b",n,t,e))];case"SquaredDifference":return[r.squaredDifference(x("a",n,t,e),x("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"basic_math":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(x("x",n,t,e))];case"Acos":return[r.acos(x("x",n,t,e))];case"Acosh":return[r.acosh(x("x",n,t,e))];case"Asin":return[r.asin(x("x",n,t,e))];case"Asinh":return[r.asinh(x("x",n,t,e))];case"Atan":return[r.atan(x("x",n,t,e))];case"Atan2":return[r.atan2(x("x",n,t,e),x("y",n,t,e))];case"Atanh":return[r.atanh(x("x",n,t,e))];case"Ceil":return[r.ceil(x("x",n,t,e))];case"Complex":return[r.complex(x("real",n,t,e),x("imag",n,t,e))];case"Cos":return[r.cos(x("x",n,t,e))];case"Cosh":return[r.cosh(x("x",n,t,e))];case"Elu":return[r.elu(x("x",n,t,e))];case"Erf":return[r.erf(x("x",n,t,e))];case"Exp":return[r.exp(x("x",n,t,e))];case"Expm1":return[r.expm1(x("x",n,t,e))];case"Floor":return[r.floor(x("x",n,t,e))];case"Log":return[r.log(x("x",n,t,e))];case"Log1p":return[r.log1p(x("x",n,t,e))];case"Imag":return[r.imag(x("x",n,t,e))];case"Neg":return[r.neg(x("x",n,t,e))];case"Reciprocal":return[r.reciprocal(x("x",n,t,e))];case"Real":return[r.real(x("x",n,t,e))];case"Relu":return[r.relu(x("x",n,t,e))];case"Round":return[r.round(x("x",n,t,e))];case"Selu":return[r.selu(x("x",n,t,e))];case"Sigmoid":return[r.sigmoid(x("x",n,t,e))];case"Sin":return[r.sin(x("x",n,t,e))];case"Sign":return[r.sign(x("x",n,t,e))];case"Sinh":return[r.sinh(x("x",n,t,e))];case"Softplus":return[r.softplus(x("x",n,t,e))];case"Sqrt":return[r.sqrt(x("x",n,t,e))];case"Square":return[r.square(x("x",n,t,e))];case"Tanh":return[r.tanh(x("x",n,t,e))];case"Tan":return[r.tan(x("x",n,t,e))];case"ClipByValue":return[r.clipByValue(x("x",n,t,e),x("clipValueMin",n,t,e),x("clipValueMax",n,t,e))];case"Relu6":return[r.relu6(x("x",n,t,e))];case"Rsqrt":return[r.rsqrt(us(n.inputNames[0],t,e))];case"Prod":return[r.prod(x("x",n,t,e),x("axes",n,t,e))];case"LeakyRelu":return[r.leakyRelu(x("x",n,t,e),x("alpha",n,t,e))];case"Prelu":return[r.prelu(x("x",n,t,e),x("alpha",n,t,e))];case"IsNan":return[r.isNaN(us(n.inputNames[0],t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"control":return lpe(o,a,l);case"convolution":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"Conv1D":{const s=x("stride",n,t,e),i=x("pad",n,t,e),o=x("dataFormat",n,t,e).toUpperCase(),a=x("dilation",n,t,e);return[r.conv1d(x("x",n,t,e),x("filter",n,t,e),s,i,o,a)]}case"Conv2D":{const s=x("strides",n,t,e),i=lv(n,t,e),o=x("dataFormat",n,t,e).toUpperCase(),a=x("dilations",n,t,e);return[r.conv2d(x("x",n,t,e),x("filter",n,t,e),[s[1],s[2]],i,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:d}=m3(n,t,e);return[r.fused.conv2d({x:x("x",n,t,e),filter:x("filter",n,t,e),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:d}=m3(n,t,e);return[r.fused.depthwiseConv2d({x:x("x",n,t,e),filter:x("filter",n,t,e),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=x("outputShape",n,t,e),i=x("strides",n,t,e),o=lv(n,t,e);return[r.conv2dTranspose(x("x",n,t,e),x("filter",n,t,e),s,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=x("strides",n,t,e),i=lv(n,t,e),o=x("dilations",n,t,e),a=x("dataFormat",n,t,e).toUpperCase();return[r.depthwiseConv2d(x("input",n,t,e),x("filter",n,t,e),[s[1],s[2]],i,a,[o[1],o[2]])]}case"Conv3D":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("dataFormat",n,t,e).toUpperCase(),a=x("dilations",n,t,e);return[r.conv3d(x("x",n,t,e),x("filter",n,t,e),[s[1],s[2],s[3]],i,o,[a[1],a[2],a[3]])]}case"AvgPool":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("kernelSize",n,t,e);return[r.avgPool(x("x",n,t,e),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPool":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("kernelSize",n,t,e);return[r.maxPool(x("x",n,t,e),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPoolWithArgmax":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("kernelSize",n,t,e),a=x("includeBatchInIndex",n,t,e),{result:l,indexes:c}=r.maxPoolWithArgmax(x("x",n,t,e),[o[1],o[2]],[s[1],s[2]],i,a);return[l,c]}case"AvgPool3D":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("kernelSize",n,t,e);return[r.avgPool3d(x("x",n,t,e),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"MaxPool3D":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("kernelSize",n,t,e);return[r.maxPool3d(x("x",n,t,e),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"Dilation2D":{const s=x("strides",n,t,e),i=x("pad",n,t,e),o=x("dilations",n,t,e),a=s[1],l=s[2],c=o[1],u=o[2];return[r.dilation2d(x("x",n,t,e),x("filter",n,t,e),[a,l],i,[c,u],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"creation":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"Fill":{const s=x("shape",n,t,e),i=x("dtype",n,t,e),o=x("value",n,t,e);return[r.fill(s,o,i)]}case"LinSpace":{const s=x("start",n,t,e),i=x("stop",n,t,e),o=x("num",n,t,e);return[r.linspace(s,i,o)]}case"Multinomial":{const s=x("logits",n,t,e),i=x("numSamples",n,t,e),o=x("seed",n,t,e);return[r.multinomial(s,i,o)]}case"OneHot":{const s=x("indices",n,t,e),i=x("depth",n,t,e),o=x("onValue",n,t,e),a=x("offValue",n,t,e),l=x("dtype",n,t,e);return[r.oneHot(s,i,o,a,l)]}case"Ones":return[r.ones(x("shape",n,t,e),x("dtype",n,t,e))];case"OnesLike":return[r.onesLike(x("x",n,t,e))];case"RandomStandardNormal":return[r.randomStandardNormal(x("shape",n,t,e),x("dtype",n,t,e),x("seed",n,t,e))];case"RandomUniform":return[r.randomUniform(x("shape",n,t,e),x("minval",n,t,e),x("maxval",n,t,e),x("dtype",n,t,e))];case"Range":{const s=x("start",n,t,e),i=x("stop",n,t,e),o=x("step",n,t,e);return[r.range(s,i,o,x("dtype",n,t,e))]}case"TruncatedNormal":{const s=x("shape",n,t,e),i=x("mean",n,t,e),o=x("stdDev",n,t,e),a=x("seed",n,t,e);return[r.truncatedNormal(s,i,o,x("dtype",n,t,e),a)]}case"Zeros":return[r.zeros(x("shape",n,t,e),x("dtype",n,t,e))];case"ZerosLike":return[r.zerosLike(x("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"dynamic":return dpe(o,a,l);case"evaluation":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"LowerBound":{const s=x("sortedSequence",n,t,e),i=x("values",n,t,e);return[r.lowerBound(s,i)]}case"TopKV2":{const s=x("x",n,t,e),i=x("k",n,t,e),o=x("sorted",n,t,e),a=r.topk(s,i,o);return[a.values,a.indices]}case"UpperBound":{const s=x("sortedSequence",n,t,e),i=x("values",n,t,e);return[r.upperBound(s,i)]}case"Unique":{const s=x("x",n,t,e),i=r.unique(s);return[i.values,i.indices]}case"UniqueV2":{const s=x("x",n,t,e),i=x("axis",n,t,e),o=r.unique(s,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"image":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"ResizeBilinear":{const s=x("images",n,t,e),i=x("size",n,t,e),o=x("alignCorners",n,t,e),a=x("halfPixelCenters",n,t,e);return[r.image.resizeBilinear(s,[i[0],i[1]],o,a)]}case"ResizeNearestNeighbor":{const s=x("images",n,t,e),i=x("size",n,t,e),o=x("alignCorners",n,t,e),a=x("halfPixelCenters",n,t,e);return[r.image.resizeNearestNeighbor(s,[i[0],i[1]],o,a)]}case"CropAndResize":{const s=x("image",n,t,e),i=x("boxes",n,t,e),o=x("boxInd",n,t,e),a=x("cropSize",n,t,e),l=x("method",n,t,e),c=x("extrapolationValue",n,t,e);return[r.image.cropAndResize(s,i,o,a,l,c)]}case"ImageProjectiveTransformV3":{const s=x("images",n,t,e),i=x("transforms",n,t,e),o=x("outputShape",n,t,e),a=x("fillValue",n,t,e),l=x("interpolation",n,t,e),c=x("fillMode",n,t,e);return[r.image.transform(s,i,l.toLowerCase(),c.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"graph":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":const s=x("default",n,t,e);return[us(n.name,t,e)||s];case"Placeholder":return[us(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Ma(x("x",n,t,e))];case"IdentityN":return x("x",n,t,e).map(u=>Ma(u));case"Shape":return[r.tensor1d(x("x",n,t,e).shape,"int32")];case"ShapeN":return x("x",n,t,e).map(u=>r.tensor1d(u.shape));case"Size":return[r.scalar(x("x",n,t,e).size,"int32")];case"Rank":return[r.scalar(x("x",n,t,e).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=x("x",n,t,e),a=x("data",n,t,e),l=x("message",n,t,e),c=x("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<a.length;u++)console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"logical":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"Equal":return[r.equal(x("a",n,t,e),x("b",n,t,e))];case"NotEqual":return[r.notEqual(x("a",n,t,e),x("b",n,t,e))];case"Greater":return[r.greater(x("a",n,t,e),x("b",n,t,e))];case"GreaterEqual":return[r.greaterEqual(x("a",n,t,e),x("b",n,t,e))];case"Less":return[r.less(x("a",n,t,e),x("b",n,t,e))];case"LessEqual":return[r.lessEqual(x("a",n,t,e),x("b",n,t,e))];case"LogicalAnd":return[r.logicalAnd(x("a",n,t,e),x("b",n,t,e))];case"LogicalNot":return[r.logicalNot(x("a",n,t,e))];case"LogicalOr":return[r.logicalOr(x("a",n,t,e),x("b",n,t,e))];case"Select":case"SelectV2":return[r.where(x("condition",n,t,e),x("a",n,t,e),x("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"matrices":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(x("a",n,t,e),x("b",n,t,e),x("transposeA",n,t,e),x("transposeB",n,t,e))];case"Einsum":return[r.einsum(x("equation",n,t,e),...x("tensors",n,t,e))];case"Transpose":return[r.transpose(x("x",n,t,e),x("perm",n,t,e))];case"_FusedMatMul":const[s,i]=x("fusedOps",n,t,e),o="biasadd"===s,a="prelu"===i,l=x("numArgs",n,t,e),c=x("leakyreluAlpha",n,t,e);if(o){if(a&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,d]=x("args",n,t,e);return[r.fused.matMul({a:x("a",n,t,e),b:x("b",n,t,e),transposeA:x("transposeA",n,t,e),transposeB:x("transposeB",n,t,e),bias:u,activation:i,preluActivationWeights:d,leakyreluAlpha:c})];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"normalization":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(x("x",n,t,e),x("axis",n,t,e),x("keepDims",n,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(x("x",n,t,e),x("mean",n,t,e),x("variance",n,t,e),x("offset",n,t,e),x("scale",n,t,e),x("epsilon",n,t,e))];case"LRN":return[r.localResponseNormalization(x("x",n,t,e),x("radius",n,t,e),x("bias",n,t,e),x("alpha",n,t,e),x("beta",n,t,e))];case"Softmax":return[r.softmax(x("x",n,t,e))];case"LogSoftmax":return[r.logSoftmax(x("x",n,t,e))];case"SparseToDense":return[r.sparseToDense(x("sparseIndices",n,t,e),x("outputShape",n,t,e),x("sparseValues",n,t,e),x("defaultValue",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"ragged":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:i}=r.raggedGather(x("paramsNestedSplits",n,t,e),x("paramsDenseValues",n,t,e),x("indices",n,t,e),x("outputRaggedRank",n,t,e));return s.concat(i)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:i}=r.raggedRange(x("starts",n,t,e),x("limits",n,t,e),x("splits",n,t,e));return[s,i]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(x("shape",n,t,e),x("values",n,t,e),x("defaultValue",n,t,e),x("rowPartitionTensors",n,t,e),x("rowPartitionTypes",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"reduction":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"Max":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.max(x("x",n,t,e),a,l)]}case"Mean":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.mean(x("x",n,t,e),a,l)]}case"Min":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.min(x("x",n,t,e),a,l)]}case"Sum":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.sum(x("x",n,t,e),a,l)]}case"All":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.all(x("x",n,t,e),a,l)]}case"Any":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.any(x("x",n,t,e),a,l)]}case"ArgMax":{const a=x("axis",n,t,e);return[r.argMax(x("x",n,t,e),a)]}case"ArgMin":{const a=x("axis",n,t,e);return[r.argMin(x("x",n,t,e),a)]}case"Prod":{const a=x("axis",n,t,e),l=x("keepDims",n,t,e);return[r.prod(x("x",n,t,e),a,l)]}case"Cumprod":{const a=x("axis",n,t,e),l=x("exclusive",n,t,e),c=x("reverse",n,t,e);return[r.cumprod(x("x",n,t,e),a,l,c)]}case"Cumsum":{const a=x("axis",n,t,e),l=x("exclusive",n,t,e),c=x("reverse",n,t,e);return[r.cumsum(x("x",n,t,e),a,l,c)]}case"Bincount":const s=x("x",n,t,e),i=x("weights",n,t,e),o=x("size",n,t,e);return[r.bincount(s,i,o)];case"DenseBincount":{const a=x("x",n,t,e),l=x("weights",n,t,e),c=x("size",n,t,e),u=x("binaryOutput",n,t,e);return[r.denseBincount(a,l,c,u)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"slice_join":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=x("n",n,t,e),i=x("axis",n,t,e);let o=x("tensors",n,t,e);return o=o.slice(0,s),[r.concat(o,i)]}case"Gather":{const s=x("x",n,t,e),i=x("indices",n,t,e);return[r.gather(s,r.cast(i,"int32"),0)]}case"GatherV2":{const s=x("axis",n,t,e),i=x("batchDims",n,t,e),o=x("x",n,t,e),a=x("indices",n,t,e);return[r.gather(o,r.cast(a,"int32"),s,i)]}case"Reverse":{const s=x("dims",n,t,e),i=[];for(let a=0;a<s.length;a++)s[a]&&i.push(a);const o=x("x",n,t,e);return[r.reverse(o,i)]}case"ReverseV2":{const s=x("axis",n,t,e),i=x("x",n,t,e);return[r.reverse(i,s)]}case"Slice":{const s=x("begin",n,t,e),i=x("size",n,t,e);return[r.slice(x("x",n,t,e),s,i)]}case"StridedSlice":{const s=x("begin",n,t,e),i=x("end",n,t,e),o=x("strides",n,t,e),a=x("beginMask",n,t,e),l=x("endMask",n,t,e),c=x("ellipsisMask",n,t,e),u=x("newAxisMask",n,t,e),d=x("shrinkAxisMask",n,t,e),h=x("x",n,t,e);return[r.stridedSlice(h,s,i,o,a,l,c,u,d)]}case"Pack":return z(()=>{const s=x("axis",n,t,e),i=x("tensors",n,t,e),o=i[0].shape,a=r.squeeze(i[0]).shape,l=i.map(c=>{const u=Rt(c.shape,o);if(!u&&!Rt(r.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return u?c:r.reshape(c,o)});return[r.stack(l,s)]});case"Unpack":{const s=x("axis",n,t,e),i=x("tensor",n,t,e);return r.unstack(i,s)}case"Tile":{const s=x("reps",n,t,e);return[r.tile(x("x",n,t,e),s)]}case"Split":case"SplitV":{const s=x("axis",n,t,e),i=x("numOrSizeSplits",n,t,e),o=x("x",n,t,e);return r.split(o,i,s)}case"ScatterNd":{const s=x("indices",n,t,e),i=x("values",n,t,e),o=x("shape",n,t,e);return[r.scatterND(s,i,o)]}case"GatherNd":{const s=x("x",n,t,e),i=x("indices",n,t,e);return[r.gatherND(s,i)]}case"SparseToDense":{const s=x("sparseIndices",n,t,e),i=x("outputShape",n,t,e),o=x("sparseValues",n,t,e),a=x("defaultValue",n,t,e);return[r.sparseToDense(s,o,i,o.dtype===a.dtype?a:r.cast(a,o.dtype))]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"sparse":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:i,emptyRowIndicator:o,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(x("indices",n,t,e),x("values",n,t,e),x("denseShape",n,t,e),x("defaultValue",n,t,e));return[s,i,o,a]}case"SparseReshape":{const{outputIndices:s,outputShape:i}=r.sparse.sparseReshape(x("inputIndices",n,t,e),x("inputShape",n,t,e),x("newShape",n,t,e));return[s,i]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(x("data",n,t,e),x("indices",n,t,e),x("segmentIds",n,t,e))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(x("data",n,t,e),x("indices",n,t,e),x("segmentIds",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"spectral":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"FFT":return[r.fft(x("x",n,t,e))];case"IFFT":return[r.ifft(x("x",n,t,e))];case"RFFT":return[r.rfft(x("x",n,t,e))];case"IRFFT":return[r.irfft(x("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"string":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"StringNGrams":{const{nGrams:s,nGramsSplits:i}=r.string.stringNGrams(x("data",n,t,e),x("dataSplits",n,t,e),x("separator",n,t,e),x("nGramWidths",n,t,e),x("leftPad",n,t,e),x("rightPad",n,t,e),x("padWidth",n,t,e),x("preserveShortSequences",n,t,e));return[s,i]}case"StringSplit":{const{indices:s,values:i,shape:o}=r.string.stringSplit(x("input",n,t,e),x("delimiter",n,t,e),x("skipEmpty",n,t,e));return[s,i,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(x("input",n,t,e),x("numBuckets",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"transformation":return s(()=>((n,t,e,r=J)=>{switch(n.op){case"Cast":return[r.cast(x("x",n,t,e),x("dtype",n,t,e))];case"ExpandDims":{const s=x("axis",n,t,e);return[r.expandDims(x("x",n,t,e),s)]}case"Squeeze":{const s=x("axis",n,t,e);return[r.squeeze(x("x",n,t,e),s)]}case"Reshape":return[r.reshape(x("x",n,t,e),x("shape",n,t,e))];case"MirrorPad":return[r.mirrorPad(x("x",n,t,e),x("padding",n,t,e),x("mode",n,t,e))];case"PadV2":case"Pad":return[r.pad(x("x",n,t,e),x("padding",n,t,e),x("constantValue",n,t,e))];case"SpaceToBatchND":{const s=x("blockShape",n,t,e),i=x("paddings",n,t,e);return[r.spaceToBatchND(x("x",n,t,e),s,i)]}case"BatchToSpaceND":{const s=x("blockShape",n,t,e),i=x("crops",n,t,e);return[r.batchToSpaceND(x("x",n,t,e),s,i)]}case"DepthToSpace":{const s=x("blockSize",n,t,e),i=x("dataFormat",n,t,e).toUpperCase();return[r.depthToSpace(x("x",n,t,e),s,i)]}case"BroadcastTo":return[r.broadcastTo(x("x",n,t,e),x("shape",n,t,e))];case"BroadcastArgs":return[r.broadcastArgs(x("s0",n,t,e),x("s1",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(o,a,l));case"hash_table":return mpe(o,a,l,r);case"custom":const c=c3(o.op);if(c&&c.customExecutor)return c.customExecutor(new epe(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return ld(i)?i.then(o=>[].concat(o)):[].concat(i)}class y3{constructor(t={},e={},r={},s={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=r,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const r=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(r))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function b3(n,t,e,r){const s=new Set,i=[];let o=null,a=null;const l=new Set,c=Object.keys(n).map(h=>js(h)[0]);let u=[];null!=r&&(u=r.map(h=>js(h.name)[0]));const d=[...t];for(;d.length>0;){const h=d.pop();if((_3(h)||Ape(h)||Rpe(h))&&null==o&&(o=h,a=o.children.map(f=>f.name).filter(f=>s.has(f))),s.add(h.name),null==e[h.name]&&-1===c.indexOf(h.name)&&-1===u.indexOf(h.name)){if(0===h.inputs.length){i.push(h.name);continue}h.inputs.forEach(f=>{l.has(f.name)||(l.add(f.name),d.push(f))})}}return{inputs:n,outputs:t,usedNodes:s,missingInputs:i,dynamicNode:o,syncInputs:a}}const Tpe=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],kpe=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Npe=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function _3(n){return Tpe.indexOf(n.op)>=0}function Ape(n){return kpe.indexOf(n.op)>=0}function Rpe(n){return Npe.indexOf(n.op)>=0}class cv{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new cv(t.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(r=>t[r].map(s=>s.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}getCompilationKey(t,e){const r=t.map(i=>i.name).sort(),s=e.map(i=>i.name).sort();return r.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(t,e){const r=b3(t,e,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:i,syncInputs:o}=r;if(null!=i)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(s.length>0){const a=e.map(c=>c.name),l=Object.keys(t);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${l}]. Missing the following inputs: [${s}]`)}return function Dpe(n,t,e){const{usedNodes:r,inputs:s}=e,i=[],o=Object.keys(s).map(u=>js(u)[0]).map(u=>n.nodes[u]),a=n.initNodes;o.forEach(u=>{r.has(u.name)&&i.push(u)}),n.weights.forEach(u=>{r.has(u.name)&&i.push(u)}),a?.forEach(u=>{r.has(u.name)&&i.push(u)});const l=new Set,c=[];for(;i.length>0;){const u=i.pop();l.add(u.name),t[u.name]||c.push(u),u.children.forEach(d=>{!l.has(d.name)&&r.has(d.name)&&d.inputs.every(h=>l.has(h.name))&&i.push(d)})}return c}(this.graph,this.weightMap,r)}cloneAndKeepTensor(t){if(null==t)return null;const e=t.clone();return Dr(e),e}cloneTensorList(t){return t?t.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,r])=>[e,this.cloneTensorList(r)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const s=r.map(d=>this.graph.nodes[js(d)[0]]),i=e.map(d=>js(d)[0]);let o=i.map(d=>this.graph.nodes[d]);0===o.length&&(o=this._outputs);const a=this.getCompilationKey(s,o);let l=this.compiledMap.get(a);null==l&&(l=this.compile(t,o),this.compiledMap.set(a,l));try{this.keepIntermediateTensors=G().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const c={},u={};return z(()=>{const d=new y3(this.weightMap,c,u,this.functionExecutorMap),h=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(m=>{const[g,y]=js(m),b=[];b[y]=t[m],h[g]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[g]=this.cloneTensorList(b))});const f=this.getFrozenTensorIds(h),p={};for(let m=0;m<l.length;m++){const g=l[m];if(!h[g.name]){const y=g3(g,h,d,this._resourceManager);if(ld(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);h[g.name]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[g.name]=this.cloneTensorList(y)),this.checkTensorForDisposal(g.name,g,h,d,f,i,p)}}return null==this.parent&&d.dispose(f),e.map(m=>us(m,h,d))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(s=>s.id)));return new Set(e)}checkTensorForDisposal(t,e,r,s,i,o,a){"control"===e.category||-1!==o.indexOf(t)||(r[t].forEach(l=>{null!=l&&(a[l.id]=(a[l.id]||0)+e.children.length)}),e.inputs.forEach(l=>{if("control"!==l.category){const c=function Mfe(n,t,e){return t[av(n,e.currentContextId)]}(l.name,r,s);c?.forEach(u=>{if(u&&!u.kept&&!i.has(u.id)){const d=a[u.id];1===d?(u.dispose(),delete a[u.id]):null!=d&&a[u.id]--}})}}))}executeAsync(t,e){var r=this;return ee(function*(){return r._executeAsync(t,e)})()}disposeIntermediateTensors(){!this.clonedTensorsMap||(Object.values(this.clonedTensorsMap).forEach(t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(t,e,r=!1,s={},i={}){var o=this;return ee(function*(){o.disposeIntermediateTensors(),r||(t=o.mapInputs(t),o.checkInputs(t),o.checkInputShapeAndType(t),e=o.mapOutputs(e),o.checkOutputs(e));try{o.keepIntermediateTensors=G().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){o.keepIntermediateTensors=!1,console.warn(f.message)}const a=new y3(o.weightMap,s,i,o.functionExecutorMap);o.keepIntermediateTensors&&(o.clonedTensorsMap=o.cloneTensorMap(o.weightMap));const l=yield o.executeWithControlFlow(t,a,e,r),c=e.map(f=>us(f,l,a)),u=c.map(f=>f.id),d=Object.keys(t).map(f=>t[f].id),h=new Set([...u,...d,...o.weightIds]);return Object.values(l).forEach(f=>{f.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),null==o.parent&&a.dispose(h),c})()}executeFunctionAsync(t,e,r){var s=this;return ee(function*(){const i=t.reduce((o,a,l)=>(o[s.inputs[l].name]=a,o),{});return s._executeAsync(i,s.outputNodes,!0,e,r)})()}executeWithControlFlow(t,e,r,s){var i=this;return ee(function*(){const o=Object.keys(t),a=o.map(v=>i.graph.nodes[js(v)[0]]),l=r.map(v=>js(v)[0]);let c=l.map(v=>i.graph.nodes[v]);0===c.length&&(c=i._outputs);const{usedNodes:u,missingInputs:d,dynamicNode:h,syncInputs:f}=b3(t,c,i.weightMap,i._initNodes),p=[...a,...i.graph.weights,...i._initNodes||[]].map(v=>({node:v,contexts:e.currentContext})),m=Object.assign({},i.weightMap);Object.keys(t).forEach(v=>{const[w,C]=js(v),E=[];E[C]=t[v],m[w]=E});const g={},y=i.getFrozenTensorIds(m),b={};for(;p.length>0;){const v=i.processStack(a,p,e,m,b,y,l,g,u);yield Promise.all(v)}null==h&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const _=c.filter(v=>!_3(v)&&!us(v.name,m,e)).map(v=>v.name);if(_.length>0){let v="";throw null!=h&&(v=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${_}] from the provided inputs [${o}]. Consider providing the following inputs: [${d}]. ${v}`)}return m})()}processStack(t,e,r,s,i,o,a,l,c){const u=[];for(;e.length>0;){const d=e.pop();r.currentContext=d.contexts;let h="";if("Enter"===d.node.op&&x("isConstant",d.node,s,r)&&([h]=Ra(d.node.name,r)),null==s[d.node.name]){const f=g3(d.node,s,r,this._resourceManager);h||([h]=Ra(d.node.name,r));const p=r.currentContext;ld(f)?u.push(f.then(m=>(s[h]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(m)),r.currentContext=p,this.checkTensorForDisposal(h,d.node,s,r,o,a,l),this.processChildNodes(d.node,e,r,s,i,c),m))):(s[h]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(f)),this.checkTensorForDisposal(h,d.node,s,r,o,a,l),this.processChildNodes(d.node,e,r,s,i,c))}else this.processChildNodes(d.node,e,r,s,i,c)}return u}processChildNodes(t,e,r,s,i,o){t.children.forEach(a=>{const[l]=Ra(a.name,r);i[l]||!o.has(a.name)||("Merge"===a.op?a.inputNames.some(c=>!!us(c,s,r))&&(i[l]=!0,e.push({contexts:r.currentContext,node:a})):a.inputNames.every(c=>!!us(c,s,r))&&(i[l]=!0,e.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const r=t[e],[s]=js(e),i=this.graph.nodes[s];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value;S(o.length===r.shape.length&&r.shape.every((l,c)=>-1===o[c]||o[c]===l),()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&S(r.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var e,r;const s={};for(const i in t){const o=null===(r=null===(e=this._signature)||void 0===e?void 0:e.inputs)||void 0===r?void 0:r[i];null!=o?s[o.name]=t[i]:s[i]=t[i]}return s}checkInputs(t){const e=Object.keys(t).filter(r=>{const[s]=js(r);return null==this.graph.nodes[s]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var r,s;const i=null===(s=null===(r=this._signature)||void 0===r?void 0:r.outputs)||void 0===s?void 0:s[e];return null!=i?i.name:e},{})}checkOutputs(t){t.forEach(e=>{const[r]=js(e);if(!this.graph.nodes[r])throw new Error(`The output '${e}' is not found in the graph`)})}}class Mpe{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}class v3{constructor(t,e={},r=He){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=r,null==e&&(this.loadOptions={}),this.resourceManager=new Mpe}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return ld(t)?t.then(e=>this.loadSync(e)):this.loadSync(t)}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const i=this.artifacts.userDefinedMetadata;null!=i.signature&&(r=i.signature),null!=i.structuredOutputKeys&&(this.structuredOutputKeys=i.structuredOutputKeys)}this.signature=r,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const s=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new cv(u3.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const i=u3.Instance.transformGraph(t.modelInitializer);this.initializer=new cv(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}save(t,e){var r=this;return ee(function*(){if("string"==typeof t){const s=r.io.getSaveHandlers(t);if(0===s.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${t}'`);t=s[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(r.artifacts)})()}addStructuredOutputNames(t){if(this.structuredOutputKeys){const r={};return(t instanceof bn?[t]:t).forEach((s,i)=>r[this.structuredOutputKeys[i]]=s),r}return t}predict(t,e){const r=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(r)}predictAsync(t,e){var r=this;return ee(function*(){const s=yield r.executeAsync(t,r.outputNodes);return r.addStructuredOutputNames(s)})()}normalizeInputs(t){var e;if(!(t instanceof bn||Array.isArray(t))){const i=null===(e=this.signature)||void 0===e?void 0:e.inputs;if(null!=i)for(const o in i){const a=i[o];null!=a.resourceId&&(t[o]=this.resourceIdToCapturedInput[a.resourceId])}return t}t=Array.isArray(t)?t:[t];const r=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${t.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((i,o)=>{var a,l,c;const u=null===(c=null===(l=null===(a=this.signature)||void 0===a?void 0:a.inputs)||void 0===l?void 0:l[o])||void 0===c?void 0:c.resourceId;return i[o]=null!=u?this.resourceIdToCapturedInput[u]:t[s++],i},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return null==this.initializer?[]:this.initializer.execute({},null==this.initializerSignature?[]:Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){var t=this;return ee(function*(){return null==t.initializer?[]:t.initializer.executeAsync({},null==t.initializerSignature?[]:Object.keys(t.initializerSignature.outputs))})()}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,r=Object.keys(e);for(let s=0;s<r.length;s++)this.resourceIdToCapturedInput[e[r[s]].resourceId]=t[s]}}execute(t,e){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const r=this.executor.execute(t,e);return r.length>1?r:r[0]}executeAsync(t,e){var r=this;return ee(function*(){null==r.resourceIdToCapturedInput&&r.setResourceIdToCapturedInput(yield r.executeInitializerGraphAsync()),t=r.normalizeInputs(t),e=r.normalizeOutputs(e);const s=yield r.executor.executeAsync(t,e);return s.length>1?s:s[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,r)=>(e[r]=[t[r]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Je(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}function aT(){return(aT=ee(function*(n,t={},e=He){if(null==n)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof n&&(n=Ppe(n));const r=new v3(n,t,e);return yield r.load(),r})).apply(this,arguments)}function Ppe(n){return n.endsWith("/")||(n+="/"),`${n}model.json?tfjs-format=file`}function Te(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&S("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const dme=gD;let hme=(()=>{class n extends OS{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new LP(this,Lo())}nextDataId(){return n.nextDataId++}write(e,r,s){this.firstUse&&(this.firstUse=!1,G().get("IS_NODE")&&ui("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const i={id:this.nextDataId()};return this.data.set(i,{values:e,dtype:s,refCount:1}),i}makeTensorInfo(e,r,s){let i;if("string"===r&&null!=s&&s.length>0&&Af(s[0])){const o=s.map(a=>ol(a));i=this.write(o,e,r)}else i=this.write(s,e,r);return{dataId:i,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,r,s,i,o){this.data.set(e,{values:r,dtype:i,refCount:o})}numDataIds(){return this.data.numDataIds()}read(e){var r=this;return ee(function*(){return r.readSync(e)})()}readSync(e){const{dtype:r,complexTensorInfos:s}=this.data.get(e);return"complex64"===r?ka(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):this.data.get(e).values}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(i=>al(i));return lt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return lt(e.shape,e.dtype,r)}makeOutput(e,r,s){return Lo().makeTensorFromTensorInfo(this.makeTensorInfo(r,s,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);null!=s&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return ee(function*(){const r=Cs();return e(),{kernelMs:Cs()-r}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Te([e],"where");const r=this.readSync(e.dataId);return dme(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();function Xt(n,t,e){return({inputs:r,attrs:s,backend:i})=>{const{x:o}=r;if(Te(o,n),"string"===o.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=i,l=a.data.get(o.dataId).values,c=X(o.shape),u=e||o.dtype,d=Zn(u,c);for(let h=0;h<c;++h)d[h]=t(l[h],s);return a.makeTensorInfo(o.shape,u,d)}}function $d(n,t,e){return({inputs:r,attrs:s,backend:i})=>{const{x:o}=r;if(Te(o,n),"string"===o.dtype||"string"===e)throw new Error("unaryKernelFunc does not support string input/output");const a=i,l=a.data.get(o.dataId).values,c=e||o.dtype,u=t(l,c,s);return a.makeTensorInfo(o.shape,c,u)}}jL("cpu",()=>new hme,1);const A3=Xt(Gf,n=>n>=0?n:Math.exp(n)-1),pme={kernelName:Gf,backendName:"cpu",kernelFunc:A3};function Xo(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const mme={kernelName:Jf,backendName:"cpu",kernelFunc:Xo};function R3(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:i}=r;Te([s],"leakyRelu");const o=X(s.shape),a=e.data.get(s.dataId).values,l=Sr("float32",o);for(let c=0;c<a.length;c++)l[c]=a[c]<0?i*a[c]:a[c];return e.makeTensorInfo(s.shape,"float32",l)}const gme={kernelName:ub,backendName:"cpu",kernelFunc:R3};function Jn(n){return(t,e,r,s,i)=>{const o=tt(t,e),a=o.length,l=Le(o),u=Sr(i,X(o)),d=t.length,h=e.length,f=Le(t),p=Le(e),m=yd(t,o),g=yd(e,o);if(m.length+g.length===0)for(let y=0;y<u.length;++y)u[y]=n(r[y%r.length],s[y%s.length]);else for(let y=0;y<u.length;++y){const b=ad(y,a,l),_=b.slice(-d);m.forEach(E=>_[E]=0);const v=$o(_,d,f),w=b.slice(-h);g.forEach(E=>w[E]=0);const C=$o(w,h,p);u[y]=n(r[v],s[C])}return[u,o]}}const yme=Jn((n,t)=>n<0?t*n:n);function M3(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t;Te([r,s],"prelu");const i=e.data.get(r.dataId).values,o=e.data.get(s.dataId).values,[a,l]=yme(r.shape,s.shape,i,o,"float32");return e.makeTensorInfo(l,"float32",a)}const bme={kernelName:kb,backendName:"cpu",kernelFunc:M3},F3=Xt(dp,n=>Math.max(0,n)),_me={kernelName:dp,backendName:"cpu",kernelFunc:F3},O3=Xt(hp,n=>Math.min(Math.max(0,n),6)),vme={kernelName:hp,backendName:"cpu",kernelFunc:O3};function Tl(n){return(t,e,r)=>{const s=Sr(e,t.length);for(let i=0;i<t.length;++i)s[i]=n(t[i],r);return s}}const xme=Tl(n=>1/(1+Math.exp(-n))),$3=Xt(_p,n=>1/(1+Math.exp(-n))),wme={kernelName:_p,backendName:"cpu",kernelFunc:$3};function fv(n,t,e,r,s){if("linear"===e)return Xo({inputs:{x:t},backend:n});if("relu"===e)return F3({inputs:{x:t},backend:n});if("elu"===e)return A3({inputs:{x:t},backend:n});if("relu6"===e)return O3({inputs:{x:t},backend:n});if("prelu"===e)return M3({inputs:{x:t,alpha:r},backend:n});if("leakyrelu"===e)return R3({inputs:{x:t},backend:n,attrs:{alpha:s}});if("sigmoid"===e)return $3({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Gs(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,i=e.data.get(r.dataId).values,o=e.data.get(s.dataId).values,a=e.makeTensorInfo(r.shape,"complex64");return e.data.get(a.dataId).complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",i),imag:e.makeTensorInfo(s.shape,"float32",o)},a}const Cme={kernelName:ZS,backendName:"cpu",kernelFunc:Gs};function pv(n,t,e="float32"){if("complex64"===e)return Gs({inputs:{real:pv(n,t,"float32"),imag:pv(n,t,"float32")},backend:n});const r=jr(X(t),e);return n.makeTensorInfo(t,e,r)}function Lc(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.real,i=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,i)}const Sme={kernelName:AI,backendName:"cpu",kernelFunc:Lc};function P3(n,t,e,r){if("int32"===r)return[t,"int32",Int32Array.from(n)];if("bool"===r){const s=wc([0],e),[i,o]=Jn((a,l)=>a!==l?1:0)(t,[],n,s,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function kl(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:i}=r;if("complex64"===i){if("complex64"===s.dtype)return Xo({inputs:{x:s},backend:e});const u=pv(e,s.shape,s.dtype),d=kl({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),h=Gs({inputs:{real:d,imag:u},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),h}if("complex64"===s.dtype){const u=Lc({inputs:{input:s},backend:e}),d=kl({inputs:{x:u},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(u),d}if(!UP(s.dtype,i)){const u=Xo({inputs:{x:s},backend:e});return{dataId:u.dataId,shape:u.shape,dtype:i}}const o=e.data.get(s.dataId).values,[a,l,c]=P3(o,s.shape,s.dtype,i);return e.makeTensorInfo(a,l,c)}const Ime={kernelName:Vf,backendName:"cpu",kernelFunc:kl};function Ar(n,t,e,r){return null==e?({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;Te([o,a],n);const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,d="string"===o.dtype?Nc(c):c,h="string"===o.dtype?Nc(u):u,f=r||o.dtype,[p,m]=t(o.shape,a.shape,d,h,f);return l.makeTensorInfo(m,f,p)}:({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;if("complex64"===o.dtype||"complex64"===a.dtype){const c=kl({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),h=u.complexTensorInfos.imag,f=l.data.get(u.complexTensorInfos.real.dataId).values,p=l.data.get(h.dataId).values,m=kl({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),b=g.complexTensorInfos.imag,_=l.data.get(g.complexTensorInfos.real.dataId).values,v=l.data.get(b.dataId).values,[w,C,E]=e(o.shape,a.shape,f,p,_,v),D=l.makeTensorInfo(E,"float32",w),T=l.makeTensorInfo(E,"float32",C),N=Gs({inputs:{real:D,imag:T},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(D),l.disposeIntermediateTensorInfo(T),N}{const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,d=r||o.dtype,[h,f]=t(o.shape,a.shape,c,u,d);return l.makeTensorInfo(f,d,h)}}}function pT(n){return(t,e,r,s,i,o)=>{const a=tt(t,e),l=X(a),c=a.length,u=Le(a),d=Sr("float32",l),h=Sr("float32",l),f=yd(t,a),p=yd(e,a),m=ka(r,s),g=ka(i,o),y=t.length,b=Le(t),_=e.length,v=Le(e);if(f.length+p.length===0)for(let w=0;w<d.length;w++){const C=w%m.length,E=w%g.length,D=n(m[2*C],m[2*C+1],g[2*E],g[2*E+1]);d[w]=D.real,h[w]=D.imag}else for(let w=0;w<d.length;w++){const C=ad(w,c,u),E=C.slice(-y);f.forEach(U=>E[U]=0);const D=$o(E,y,b),T=C.slice(-_);p.forEach(U=>T[U]=0);const N=$o(T,_,v),P=n(m[2*D],m[2*D+1],g[2*N],g[2*N+1]);d[w]=P.real,h[w]=P.imag}return[d,h,a]}}const L3=Jn((n,t)=>n+t),Eme=pT((n,t,e,r)=>({real:n+e,imag:t+r})),Pd=Ar(cd,L3,Eme),Dme={kernelName:cd,backendName:"cpu",kernelFunc:Pd};function un(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:i}=r,o=X(s.shape),a=zP(i,o),l=X(a);S(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.incRef(s.dataId);const c=e.data.get(s.dataId);if(null!=c.complexTensorInfos){const d=c.complexTensorInfos.imag;c.complexTensorInfos.real.shape=a,d.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const Tme={kernelName:Ab,backendName:"cpu",kernelFunc:un};function B3(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i}=t,{transposeA:o,transposeB:a}=r;Te([s,i],"matMul");const l=s.shape.length,c=i.shape.length,u=o?s.shape[l-2]:s.shape[l-1],d=a?i.shape[c-1]:i.shape[c-2],h=o?s.shape[l-1]:s.shape[l-2],f=a?i.shape[c-2]:i.shape[c-1],p=s.shape.slice(0,-2),m=i.shape.slice(0,-2),g=X(p),y=X(m),_=tt(s.shape.slice(0,-2),i.shape.slice(0,-2)).concat([h,f]);S(u===d,()=>`Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${s.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const w=a?[y,f,d]:[y,d,f],C=un({inputs:{x:s},backend:e,attrs:{shape:o?[g,u,h]:[g,h,u]}}),E=un({inputs:{x:i},backend:e,attrs:{shape:w}}),D=o?C.shape[1]:C.shape[2],T=o?C.shape[2]:C.shape[1],N=a?E.shape[1]:E.shape[2],P=Math.max(g,y),U=e.data.get(C.dataId).values,j=e.data.get(E.dataId).values,q=Le(C.shape),K=Le(E.shape),[$,V,L]=o?[q[0],1,q[1]]:[q[0],q[1],1],[W,ne,ie]=a?[1,K[1],K[0]]:[K[1],1,K[0]],de=T*N,ue=lt([P,T,N],C.dtype),he=ue.values,ge=e.blockSize;for(let Ie=0;Ie<P;Ie++)for(let _e=0;_e<T;_e+=ge)for(let Oe=0;Oe<N;Oe+=ge)for(let ke=0;ke<D;ke+=ge){const Ze=Math.min(_e+ge,T),ct=Math.min(Oe+ge,N),Yt=Math.min(ke+ge,D);for(let hn=_e;hn<Ze;hn++)for(let _n=Oe;_n<ct;_n++){let En=0;for(let tn=ke;tn<Yt;tn++){const Bn=Math.min(Ie,g-1)*$,Gn=Math.min(Ie,y-1)*ie;En+=U[Bn+hn*V+tn*L]*j[tn*W+_n*ne+Gn]}he[Ie*de+(hn*N+_n)]+=En}}return e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo(E),e.makeTensorInfo(_,ue.dtype,ue.values)}const kme={kernelName:Xy,backendName:"cpu",kernelFunc:B3},Ame={kernelName:Wb,backendName:"cpu",kernelFunc:function Nme(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:d}=r;let h,f,p;const m=[];h=B3({inputs:{a:s,b:i},attrs:{transposeA:l,transposeB:c},backend:e}),o&&(f=Pd({inputs:{a:h,b:o},backend:e}),m.push(h),h=f),u&&(p=fv(e,h,u,a,d),m.push(h),h=p);for(const y of m)e.disposeIntermediateTensorInfo(y);return h}};function V3(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const Rme={kernelName:Hy,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend;Te(t,"abs");let r=new Float32Array(X(t.shape));return r=V3(e.data.get(t.dataId).values),e.makeOutput(r,t.shape,t.dtype)}},Mme=Xt(Mf,n=>Math.acos(n)),Fme={kernelName:Mf,backendName:"cpu",kernelFunc:Mme},Ome=Xt(Ff,n=>Math.acosh(n)),$me={kernelName:Ff,backendName:"cpu",kernelFunc:Ome},Lme={kernelName:Wy,backendName:"cpu",kernelFunc:function Pme(n){const{inputs:t,backend:e}=n,r=t;Te(t,"addN");const s=r.map(a=>e.data.get(a.dataId).values),i=lt(r[0].shape,r[0].dtype),o=i.values;for(let a=0;a<r.length;a++){const l=s[a];for(let c=0;c<o.length;c++)o[c]+=l[c]}return e.makeTensorInfo(i.shape,i.dtype,i.values)}};function mT(n,t,e,r,s){const i=t.length,o=X(t),a=Le(t),l=Le(s),c=Sr(e,X(s));for(let u=0;u<o;++u){const d=ad(u,i,a),h=new Array(d.length);for(let p=0;p<h.length;p++)h[p]=d[r[p]];c[$o(h,i,l)]=n[u]}return c}function ks(n){const{inputs:t,attrs:e,backend:r}=n,{x:s}=t,{perm:i}=e;Te(s,"transpose");const a=new Array(s.shape.length);for(let d=0;d<a.length;d++)a[d]=s.shape[i[d]];const c=mT(r.data.get(s.dataId).values,s.shape,s.dtype,i,a);return{dataId:r.write(c,a,s.dtype),shape:a,dtype:s.dtype}}const Bme={kernelName:ud,backendName:"cpu",kernelFunc:ks},zme={kernelName:"All",backendName:"cpu",kernelFunc:function Vme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;Te(s,"all");const a=mt(i,s.shape);let l=a;const c=An(l,s.shape.length);let u=s;null!=c&&(u=ks({inputs:{x:s},backend:e,attrs:{perm:c}}),l=Wn(l.length,s.shape.length)),Lr("all",l,u.shape.length);const[d,h]=kr(u.shape,l),f=X(h),p=jr(X(d),u.dtype),m=e.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let _=m[b];for(let v=0;v<f;++v){const w=m[b+v];_=_&&w}p[y]=_}null!=c&&e.disposeIntermediateTensorInfo(u);const g=e.makeTensorInfo(d,u.dtype,p);if(o){const b=un({inputs:{x:g},backend:e,attrs:{shape:Hn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},Hme={kernelName:"Any",backendName:"cpu",kernelFunc:function Ume(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;Te(s,"any");const a=mt(i,s.shape);let l=a;const c=An(l,s.shape.length);let u=s;null!=c&&(u=ks({inputs:{x:s},backend:e,attrs:{perm:c}}),l=Wn(l.length,s.shape.length)),Lr("any",l,u.shape.length);const[d,h]=kr(u.shape,l),f=X(h),p=jr(X(d),u.dtype),m=e.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let _=m[b];for(let v=0;v<f;++v){const w=m[b+v];_=_||w}p[y]=_}null!=c&&e.disposeIntermediateTensorInfo(u);const g=e.makeTensorInfo(d,u.dtype,p);if(o){const b=un({inputs:{x:g},backend:e,attrs:{shape:Hn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},jme={kernelName:jy,backendName:"cpu",kernelFunc:function Wme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;Te(s,"argMax");let o=mt(i,s.shape);const a=An(o,s.shape.length);let l=s;const c=[];null!=a&&(l=ks({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),o=Wn(o.length,l.shape.length)),o=[o[0]],Lr("argMax",o,l.shape.length);const[u,d]=kr(l.shape,o),f=jr(X(u),"int32"),p=X(d),m=e.data.get(l.dataId).values;for(let g=0;g<f.length;++g){const y=g*p;let b=m[y],_=0;for(let v=0;v<p;++v){const w=m[y+v];w>b&&(b=w,_=v)}f[g]=_}return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(u,"int32",f)}},qme={kernelName:Gy,backendName:"cpu",kernelFunc:function Gme(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;Te(s,"argMin");let o=mt(i,s.shape);const a=An(o,s.shape.length);let l=s;const c=[];null!=a&&(l=ks({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),o=Wn(o.length,l.shape.length)),o=[o[0]],Lr("argMin",o,l.shape.length);const[u,d]=kr(l.shape,o),f=jr(X(u),"int32"),p=X(d),m=e.data.get(l.dataId).values;for(let g=0;g<f.length;++g){const y=g*p;let b=m[y],_=0;for(let v=0;v<p;++v){const w=m[y+v];w<b&&(b=w,_=v)}f[g]=_}return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(u,"int32",f)}},Kme=Xt(Of,n=>Math.asin(n)),Xme={kernelName:Of,backendName:"cpu",kernelFunc:Kme},Yme=Xt($f,n=>Math.asinh(n)),Zme={kernelName:$f,backendName:"cpu",kernelFunc:Yme},Qme=Xt(Pf,n=>Math.atan(n)),Jme={kernelName:Pf,backendName:"cpu",kernelFunc:Qme},ege=Jn((n,t)=>Math.atan2(n,t)),tge=Ar(Bf,ege),nge={kernelName:Bf,backendName:"cpu",kernelFunc:tge},rge=Xt(Lf,n=>Math.atanh(n)),sge={kernelName:Lf,backendName:"cpu",kernelFunc:rge};function gT(n,t,e,r,s,i){const o=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,c=s.dilationWidth,u=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,f=s.padInfo.left,p="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=lt(s.outShape,e),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],_=s.outShape[3];for(let v=0;v<s.batchSize;++v){const w=v*y,C=v*r[0];for(let E=0;E<s.inChannels;++E)for(let D=0;D<s.outHeight;++D){const T=D*o-h,N=Math.max(0,T),P=Math.min(s.inHeight,u+T),U=w+D*b;for(let j=0;j<s.outWidth;++j){const q=j*a-f,K=Math.max(0,q),$=Math.min(s.inWidth,d+q);let V=p,L=0,W=0;for(let ie=N;ie<P;ie+=l){const de=C+ie*r[1];for(let ue=K;ue<$;ue+=c){const ge=n[de+ue*r[2]+E];"max"===i&&ge>V?V=ge:"avg"===i&&(L+=ge,W++)}if(isNaN(V))break}g[U+j*_+E]="avg"===i?L/W:V}}}return m}function z3(n,t,e,r,s=!1,i=!1){const o=lt(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,f=r.padInfo.top,p=r.padInfo.left,m=lt(t,e,n);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){const _=b*a-f;let v=_;for(;v<0;)v+=c;const w=Math.min(r.inHeight,d+_);for(let C=0;C<r.outWidth;++C){const E=C*l-p;let D=E;for(;D<0;)D+=u;const T=Math.min(r.inWidth,h+E);let N=Number.NEGATIVE_INFINITY,P=-1;for(let U=v;U<w;U+=c){const j=U-_;for(let q=D;q<T;q+=u){const K=q-E,$=m.get(g,U,q,y);$>N&&(N=$,P=s?i?((g*r.inHeight+U)*r.inWidth+q)*r.inChannels+y:(U*r.inWidth+q)*r.inChannels+y:j*h+K)}}o.set(P,g,b,C,y)}}return o}function U3(n,t,e,r,s,i){const o=s.strideDepth,a=s.strideHeight,l=s.strideWidth,c=s.dilationDepth,u=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,f=s.effectiveFilterHeight,p=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,_=lt(s.outShape,e),v=_.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],C=s.outShape[2]*s.outShape[3]*s.outShape[4],E=s.outShape[3]*s.outShape[4],D=s.outShape[4];for(let T=0;T<s.batchSize;++T){const N=T*w,P=T*r[0];for(let U=0;U<s.inChannels;++U)for(let j=0;j<s.outDepth;++j){const q=j*o-m;let K=q;for(;K<0;)K+=c;const $=Math.min(s.inDepth,h+q),V=N+j*C;for(let L=0;L<s.outHeight;++L){const W=L*a-g;let ne=W;for(;ne<0;)ne+=u;const ie=Math.min(s.inHeight,f+W),de=V+L*E;for(let ue=0;ue<s.outWidth;++ue){const he=ue*l-y;let ge=he;for(;ge<0;)ge+=d;const Ie=Math.min(s.inWidth,p+he),_e=de+ue*D;let Oe=b,ke=0,Ze=0;for(let Yt=K;Yt<$;Yt+=c){const hn=P+Yt*r[1];for(let _n=ne;_n<ie;_n+=u){const En=hn+_n*r[2];for(let tn=ge;tn<Ie;tn+=d){const Gn=n[En+tn*r[3]+U];if("max"===i&&Gn>Oe?Oe=Gn:"avg"===i&&(ke+=Gn,Ze++),isNaN(Oe))break}if(isNaN(Oe))break}if(isNaN(Oe))break}v[_e+U]="avg"===i?ke/Ze:Oe}}}}return _}const age={kernelName:qy,backendName:"cpu",kernelFunc:function oge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Te(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r;S(Pr(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=Li(s.shape,i,o,1,a,l);let d;if(1===u.filterWidth&&1===u.filterHeight&&Rt(u.inShape,u.outShape))d=Xo({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,f=Le(s.shape),p=gT(h,0,s.dtype,f,u,"avg");d=e.makeTensorInfo(u.outShape,s.dtype,p.values)}return d}},cge={kernelName:Ky,backendName:"cpu",kernelFunc:function lge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r;Te(s,"avgPool3d");const u=Sa(s.shape,i,o,1,a,l,c),h=U3(e.data.get(s.dataId).values,0,s.dtype,Le(s.shape),u,"avg");return e.makeTensorInfo(h.shape,"float32",h.values)}},dge={kernelName:KS,backendName:"cpu",kernelFunc:function uge(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;Te([s,i],"avgPool3DGrad");const u=Sa(i.shape,o,a,1,l,c),d=u.strideDepth,h=u.strideHeight,f=u.strideWidth,p=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,_=u.dilationWidth,v=u.effectiveFilterDepth,w=u.effectiveFilterHeight,C=u.effectiveFilterWidth,E=v-1-u.padInfo.front,D=C-1-u.padInfo.left,T=w-1-u.padInfo.top,N=lt(i.shape,"float32"),P=1/(p*m*g),U=e.bufferSync(s);for(let j=0;j<u.batchSize;++j)for(let q=0;q<u.inChannels;++q)for(let K=0;K<u.inDepth;++K)for(let $=0;$<u.inHeight;++$)for(let V=0;V<u.inWidth;++V){const L=K-E,W=$-T,ne=V-D;let ie=0;for(let de=0;de<v;de+=y){const ue=(L+de)/d;if(!(ue<0||ue>=u.outDepth||Math.floor(ue)!==ue))for(let he=0;he<w;he+=b){const ge=(W+he)/h;if(!(ge<0||ge>=u.outHeight||Math.floor(ge)!==ge))for(let Ie=0;Ie<C;Ie+=_){const _e=(ne+Ie)/f;_e<0||_e>=u.outWidth||Math.floor(_e)!==_e||(ie+=U.get(j,ue,ge,_e,q))}}}N.set(ie*P,j,K,$,V,q)}return e.makeTensorInfo(N.shape,N.dtype,N.values)}},fge={kernelName:qS,backendName:"cpu",kernelFunc:function hge(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i;Te([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=Li(o.shape,a,l,1,c),d=u.strideHeight,h=u.strideWidth,f=u.filterHeight,p=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,_=b-1-u.padInfo.left,v=y-1-u.padInfo.top,w=lt(o.shape,"float32"),C=1/(f*p),E=e.data.get(s.dataId).values,D=lt(s.shape,"float32",E);for(let T=0;T<u.batchSize;++T)for(let N=0;N<u.inChannels;++N)for(let P=0;P<u.inHeight;++P)for(let U=0;U<u.inWidth;++U){const j=P-v,q=U-_;let K=0;for(let $=0;$<y;$+=m){const V=(j+$)/d;if(!(V<0||V>=u.outHeight||Math.floor(V)!==V))for(let L=0;L<b;L+=g){const W=(q+L)/h;W<0||W>=u.outWidth||Math.floor(W)!==W||(K+=D.get(T,V,W,N))}}w.set(K*C,T,P,U,N)}return e.makeTensorInfo(w.shape,w.dtype,w.values)}},mge={kernelName:ab,backendName:"cpu",kernelFunc:function pge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,scale:i,offset:o,mean:a,variance:l}=t;S(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==o||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==i||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Te([s,a,l,i,o],"batchNorm");let{varianceEpsilon:c}=r;null==c&&(c=.001);const u=e.data.get(s.dataId).values,d=e.data.get(a.dataId).values,h=e.data.get(l.dataId).values,f=i?e.data.get(i.dataId).values:new Float32Array([1]),p=o?e.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=p.length,y=f.length,b=h.length,_=d.length;let v=0,w=0,C=0,E=0;for(let D=0;D<u.length;++D)m[D]=p[v++]+(u[D]-d[w++])*f[C++]/Math.sqrt(h[E++]+c),v>=g&&(v=0),w>=_&&(w=0),C>=y&&(C=0),E>=b&&(E=0);return e.makeTensorInfo(s.shape,s.dtype,m)}};function H3(n,t,e,r,s){const i=RE(r,t,e),o=X(e),a=Le(r);if(i){const d=ME(t,a);return"string"===s?n.slice(d,d+o):n.subarray(d,d+o)}const c=lt(r,s,"string"===s?Nc(n):n),u=lt(e,s);for(let d=0;d<u.size;++d){const h=u.indexToLoc(d),f=h.map((p,m)=>p+t[m]);u.set(c.get(...f),...h)}return"string"===s?DV(u.values):u.values}function Bc(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,size:o}=r;Te(s,"slice");const[a,l]=o_(s,i,o);NE(s,a,l);const u=H3(e.data.get(s.dataId).values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,u)}const gge={kernelName:$b,backendName:"cpu",kernelFunc:Bc},bge={kernelName:Yy,backendName:"cpu",kernelFunc:function yge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,crops:o}=r;Te([s],"batchToSpaceND");const a=i.reduce((y,b)=>y*b),l=Kp(s.shape,i,a),c=Xp(l.length,i.length),u=Yp(s.shape,i,a),d=BD(o,i.length),h=VD(u,o,i.length),f=un({inputs:{x:s},backend:e,attrs:{shape:l}}),p=ks({inputs:{x:f},backend:e,attrs:{perm:c}}),m=un({inputs:{x:p},backend:e,attrs:{shape:u}}),g=Bc({inputs:{x:m},backend:e,attrs:{begin:d,size:h}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),g}};function yT(n,t,e,r,s){const i=X(r),o=jr(s,e);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(o[l]+=i>0?t[a]:1)}return o}function W3(n,t,e,r=!1){const s=n.shape[0],i=n.shape[1],o=lt([s,e],t.dtype);for(let a=0;a<s;a++)for(let l=0;l<i;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=e||o.set(r?1:t.size>0?o.get(a,c)+t.get(a,l):o.get(a,c)+1,a,c)}return o}const vge={kernelName:XS,backendName:"cpu",kernelFunc:function _ge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o}=r,c=yT(e.data.get(s.dataId).values,e.data.get(i.dataId).values,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,c)}},wge={kernelName:YS,backendName:"cpu",kernelFunc:function xge(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,i=e.data.get(r.dataId).values,o=e.data.get(s.dataId).values,a=tt(Array.from(i),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},j3=Tl(n=>Math.ceil(n)),Cge=$d(zf,j3),Sge={kernelName:zf,backendName:"cpu",kernelFunc:Cge},Ige=Xt(Uf,(n,t)=>n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n),Ege={kernelName:Uf,backendName:"cpu",kernelFunc:Ige},Dge={kernelName:Zy,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend,r=new Float32Array(X(t.shape)),s=e.data.get(t.dataId),o=s.complexTensorInfos.imag,a=e.data.get(s.complexTensorInfos.real.dataId).values,l=e.data.get(o.dataId).values;for(let c=0;c<a.length;c++)r[c]=Math.hypot(a[c],l[c]);return e.makeOutput(r,t.shape,"float32")}};function G3(n,t,e,r){const s=Zn(e,X(t));if(r&&"string"!==e){let i=0;n.forEach(o=>{const a=X(o.shape);s.set(o.vals,i),i+=a})}else{let i=0;n.forEach(o=>{const a="string"===e?Nc(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const u=c*t[1]+i;for(let d=0;d<o.shape[1];++d)s[u+d]=a[l++]}i+=o.shape[1]})}return s}function Ld(n){const{inputs:t,backend:e}=n,{input:r}=t,s=e.data.get(r.dataId).complexTensorInfos.imag,i=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,i)}const Tge={kernelName:yI,backendName:"cpu",kernelFunc:Ld};function Bd(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,i=mt(s,t[0].shape)[0];$D(t.map(m=>m.shape),i);let a=Uo(t.map(m=>m.shape),i);if(0===X(a))return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(m=>X(m.shape)>0);if(1===l.length)return Xo({inputs:{x:l[0]},backend:e});if("complex64"===l[0].dtype){const m=l.map(v=>Lc({inputs:{input:v},backend:e})),g=l.map(v=>Ld({inputs:{input:v},backend:e})),y=Bd({inputs:m,backend:e,attrs:{axis:i}}),b=Bd({inputs:g,backend:e,attrs:{axis:i}}),_=Gs({inputs:{real:y,imag:b},backend:e});return m.forEach(v=>e.disposeIntermediateTensorInfo(v)),g.forEach(v=>e.disposeIntermediateTensorInfo(v)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),_}const c=l.map(m=>{const y=[-1,X(m.shape.slice(i))];return un({inputs:{x:m},backend:e,attrs:{shape:y}})}),u=c.map(m=>({vals:e.data.get(m.dataId).values,shape:m.shape}));a=Uo(c.map(m=>m.shape),1);const h=G3(u,a,t[0].dtype,1===c[0].shape[0]),f=Uo(l.map(m=>m.shape),i),p=e.makeTensorInfo(f,t[0].dtype,h);return c.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}const kge={kernelName:Qy,backendName:"cpu",kernelFunc:Bd};function q3(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r;Te([s,i],"conv2d");const d=Ia(l),h=Tr(s.shape,i.shape,o,c,a,u,!1,d),f=h.filterHeight,p=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,_="channelsLast"===h.dataFormat,v=new Er(h.outShape,s.dtype),w=Le(s.shape),C=Le(i.shape),E=w[0],D=_?w[1]:w[2],T=_?w[2]:1,N=_?1:w[1],P=v.strides[0],U=_?v.strides[1]:v.strides[2],j=_?v.strides[2]:1,q=_?1:v.strides[1],K=e.data.get(s.dataId).values,$=e.data.get(i.dataId).values,V=v.values;for(let L=0;L<h.batchSize;++L){const W=L*E,ne=L*P;for(let ie=0;ie<h.outHeight;++ie){const de=ne+ie*U,ue=ie*h.strideHeight-b;for(let he=0;he<f;++he){const ge=ue+he*m;if(ge<0||ge>=h.inHeight)continue;const Ie=he*C[0],_e=W+ge*D;for(let Oe=0;Oe<h.outWidth;++Oe){const ke=de+Oe*j,Ze=Oe*h.strideWidth-y;for(let ct=0;ct<p;++ct){const Yt=Ze+ct*g;if(Yt<0||Yt>=h.inWidth)continue;const _n=_e+Yt*T;let En=Ie+ct*C[1];for(let tn=0;tn<h.inChannels;++tn){const Bn=K[_n+tn*N];for(let Gn=0;Gn<h.outChannels;++Gn)V[ke+Gn*q]+=Bn*$[En+Gn];En+=h.outChannels}}}}}}return e.makeTensorInfo(v.shape,v.dtype,V)}const Nge={kernelName:Jy,backendName:"cpu",kernelFunc:q3},Rge={kernelName:QS,backendName:"cpu",kernelFunc:function Age(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r;Te([s,i],"conv2dBackpropFilter");const d=Ia(l),h=Tr(s.shape,u,o,1,a,c,!1,d),{strideHeight:f,strideWidth:p,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,b=new Er(h.filterShape,"float32"),_=h.padInfo.left,v=h.padInfo.top,w=e.data.get(s.dataId).values,C=e.data.get(i.dataId).values,E=new Er(s.shape,s.dtype,w),D=new Er(i.shape,i.dtype,C);for(let T=0;T<m;++T){const N=Math.max(0,Math.ceil((v-T)/f)),P=Math.min(h.outHeight,(h.inHeight+v-T)/f);for(let U=0;U<g;++U){const j=Math.max(0,Math.ceil((_-U)/p)),q=Math.min(h.outWidth,(h.inWidth+_-U)/p);for(let K=0;K<h.inChannels;++K)for(let $=0;$<h.outChannels;++$){let V=0;for(let L=0;L<h.batchSize;++L)for(let W=N;W<P;++W){const ne=T+W*f-v;for(let ie=j;ie<q;++ie){const de=U+ie*p-_;V+=y?E.get(L,ne,de,K)*D.get(L,W,ie,$):E.get(L,K,ne,de)*D.get(L,$,W,ie)}}b.set(V,T,U,K,$)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},Fge={kernelName:eb,backendName:"cpu",kernelFunc:function Mge(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r;Te([s,i],"conv2dBackpropInput");const d=Le(i.shape),h=Le(s.shape);let f=Ia(c);const p=Tr(o,i.shape,a,1,l,u,!1,f),m=new Er(p.inShape,"float32"),g=m.values,y=e.data.get(s.dataId).values,b=e.data.get(i.dataId).values,[_,v,w]=d,{batchSize:C,filterHeight:E,filterWidth:D,inChannels:T,inHeight:N,inWidth:P,outChannels:U,outHeight:j,outWidth:q,strideHeight:K,strideWidth:$}=p;f=p.dataFormat;const V=E-1-p.padInfo.top,L=D-1-p.padInfo.left,W="channelsLast"===f,ne=m.strides[0],ie=W?m.strides[1]:m.strides[2],de=W?m.strides[2]:1,ue=W?1:m.strides[1],he=h[0],ge=W?h[1]:h[2],Ie=W?h[2]:1,_e=W?1:h[1];for(let Oe=0;Oe<C;++Oe)for(let ke=0;ke<T;++ke)for(let Ze=0;Ze<N;++Ze){const ct=Ze-V,Yt=Math.max(0,Math.ceil(ct/K)),hn=Math.min(j,(E+ct)/K);for(let _n=0;_n<P;++_n){const En=_n-L,tn=Math.max(0,Math.ceil(En/$)),Bn=Math.min(q,(D+En)/$);let Gn=0;for(let Vr=Yt;Vr<hn;++Vr){const Ul=Vr*K-ct;for(let Ii=tn;Ii<Bn;++Ii){const So=he*Oe+ge*Vr+Ie*Ii,Va=_*(E-1-Ul)+v*(D-1-(Ii*$-En))+w*ke;for(let Hl=0;Hl<U;++Hl)Gn+=y[So+_e*Hl]*b[Va+Hl]}}g[ne*Oe+ie*Ze+de*_n+ue*ke]=Gn}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}},$ge={kernelName:tb,backendName:"cpu",kernelFunc:function Oge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l}=r;Te([s,i],"conv3d");const c=fl(s.shape,i.shape,o,l,a),{filterDepth:u,filterHeight:d,filterWidth:h,dilationDepth:f,dilationHeight:p,dilationWidth:m,padInfo:g}=c,y=g.front,b=g.left,_=g.top,v=new Er(c.outShape,s.dtype),w=e.data.get(s.dataId).values,C=e.data.get(i.dataId).values,E=v.values,D=Le(s.shape),T=Le(i.shape);for(let N=0;N<c.batchSize;++N){const P=N*D[0],U=N*v.strides[0];for(let j=0;j<c.outDepth;++j){const q=U+j*v.strides[1],K=j*c.strideDepth-y;for(let $=0;$<u;++$){const V=K+$*f;if(V<0||V>=c.inDepth)continue;const L=$*T[0],W=P+V*D[1];for(let ne=0;ne<c.outHeight;++ne){const ie=q+ne*v.strides[2],de=ne*c.strideHeight-_;for(let ue=0;ue<d;++ue){const he=de+ue*p;if(he<0||he>=c.inHeight)continue;const ge=L+ue*T[1],Ie=W+he*D[2];for(let _e=0;_e<c.outWidth;++_e){const Oe=ie+_e*c.outChannels,ke=_e*c.strideWidth-b;for(let Ze=0;Ze<h;++Ze){const ct=ke+Ze*m;if(ct<0||ct>=c.inWidth)continue;const hn=Ie+ct*c.inChannels;let _n=ge+Ze*T[2];for(let En=0;En<c.inChannels;++En){const tn=w[hn+En];for(let Bn=0;Bn<c.outChannels;++Bn)E[Oe+Bn]+=tn*C[_n+Bn];_n+=c.outChannels}}}}}}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}},Lge={kernelName:JS,backendName:"cpu",kernelFunc:function Pge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,filterShape:l}=r;Te([s,i],"conv3dBackpropFilterV2");const c=Le(s.shape),u=Le(i.shape),d=fl(s.shape,l,o,1,a),h=d.strideDepth,f=d.strideHeight,p=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new Er(d.filterShape,"float32"),_=b.values,[v,w,C,E]=b.strides,D=e.data.get(i.dataId).values,[T,N,P,U]=u,j=e.data.get(s.dataId).values,[q,K,$,V]=c,L=d.padInfo.front,W=d.padInfo.left,ne=d.padInfo.top;for(let ie=0;ie<m;++ie){const de=Math.max(0,Math.ceil((L-ie)/h)),ue=Math.min(d.outDepth,(d.inDepth+L-ie)/h),he=ie*v;for(let ge=0;ge<g;++ge){const Ie=Math.max(0,Math.ceil((ne-ge)/f)),_e=Math.min(d.outHeight,(d.inHeight+ne-ge)/f),Oe=ge*w+he;for(let ke=0;ke<y;++ke){const Ze=Math.max(0,Math.ceil((W-ke)/p)),ct=Math.min(d.outWidth,(d.inWidth+W-ke)/p),Yt=ke*C+Oe;for(let hn=0;hn<d.inChannels;++hn){const _n=hn*E+Yt;for(let En=0;En<d.outChannels;++En){let tn=0;for(let Bn=0;Bn<d.batchSize;++Bn){const Gn=Bn*q,Ba=Bn*T;for(let Vr=de;Vr<ue;++Vr){const Ii=(ie+Vr*h-L)*K+Gn,Jc=Vr*N+Ba;for(let So=Ie;So<_e;++So){const Hl=(ge+So*f-ne)*$+Ii,Wl=So*P+Jc;for(let jl=Ze;jl<ct;++jl)tn+=j[(ke+jl*p-W)*V+Hl+hn]*D[jl*U+Wl+En]}}}_[_n+En]=tn}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},Vge={kernelName:eI,backendName:"cpu",kernelFunc:function Bge(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{pad:o,strides:a,inputShape:l}=r;Te([s],"conv3dBackpropInputV2");const c=Le(s.shape),u=Le(i.shape),d=fl(l,i.shape,a,1,o),h=new Er(d.inShape,"float32"),f=h.values,[p,m,g,y]=h.strides,b=e.data.get(s.dataId).values,[_,v,w,C]=c,E=e.data.get(i.dataId).values,[D,T,N,P]=u,{batchSize:U,filterDepth:j,filterHeight:q,filterWidth:K,inChannels:$,inDepth:V,inHeight:L,inWidth:W,outChannels:ne,outDepth:ie,outHeight:de,outWidth:ue,strideDepth:he,strideHeight:ge,strideWidth:Ie}=d,_e=j-1-d.padInfo.front,Oe=q-1-d.padInfo.top,ke=K-1-d.padInfo.left;for(let Ze=0;Ze<U;++Ze)for(let ct=0;ct<$;++ct)for(let Yt=0;Yt<V;++Yt){const hn=Yt-_e,_n=Math.max(0,Math.ceil(hn/he)),En=Math.min(ie,(j+hn)/he);for(let tn=0;tn<L;++tn){const Bn=tn-Oe,Gn=Math.max(0,Math.ceil(Bn/ge)),Ba=Math.min(de,(q+Bn)/ge);for(let Vr=0;Vr<W;++Vr){const Ul=Vr-ke,Ii=Math.max(0,Math.ceil(Ul/Ie)),Jc=Math.min(ue,(K+Ul)/Ie);let So=0;for(let Va=_n;Va<En;++Va){const Hl=Va*he-hn;for(let Wl=Gn;Wl<Ba;++Wl){const jl=Wl*ge-Bn;for(let Hm=Ii;Hm<Jc;++Hm){const mN=_*Ze+v*Va+w*Wl+C*Hm,z$e=D*(j-1-Hl)+T*(q-1-jl)+N*(K-1-(Hm*Ie-Ul))+P*ct;for(let Ux=0;Ux<ne;++Ux)So+=b[mN+Ux]*E[z$e+Ux]}}}f[p*Ze+m*Yt+g*tn+y*Vr+ct]=So}}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}},zge=Xt(Hf,n=>Math.cos(n)),Uge={kernelName:Hf,backendName:"cpu",kernelFunc:zge},Hge=Xt(Wf,n=>Math.cosh(n)),Wge={kernelName:Wf,backendName:"cpu",kernelFunc:Hge},Gge={kernelName:nI,backendName:"cpu",kernelFunc:function jge(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:i,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:c}=r,[u,d,h,f]=s.shape,p=i.shape[0],[m,g]=a,y=lt([p,m,g,f],"float32"),b=e.data.get(i.dataId).values,_=e.data.get(o.dataId).values,v=e.data.get(s.dataId).values,w=Le(s.shape),C=Le(y.shape);for(let E=0;E<p;E++){const D=4*E,T=b[D],N=b[D+1],P=b[D+2],U=b[D+3],j=_[E];if(j>=u)continue;const q=m>1?(P-T)*(d-1)/(m-1):0,K=g>1?(U-N)*(h-1)/(g-1):0;for(let $=0;$<m;$++){const V=m>1?T*(d-1)+$*q:.5*(T+P)*(d-1);if(V<0||V>d-1)for(let L=0;L<g;L++)for(let W=0;W<f;W++)y.values[W+L*C[2]+$*C[1]+E*C[0]]=c;else if("bilinear"===l){const L=Math.floor(V),W=Math.ceil(V),ne=V-L;for(let ie=0;ie<g;ie++){const de=g>1?N*(h-1)+ie*K:.5*(N+U)*(h-1);if(de<0||de>h-1){for(let Ie=0;Ie<f;Ie++)y.values[Ie+ie*C[2]+$*C[1]+E*C[0]]=c;continue}const ue=Math.floor(de),he=Math.ceil(de),ge=de-ue;for(let Ie=0;Ie<f;Ie++){let _e=Ie+ue*w[2]+L*w[1]+j*w[0];const Oe=v[_e];_e=Ie+he*w[2]+L*w[1]+j*w[0];const ke=v[_e];_e=Ie+ue*w[2]+W*w[1]+j*w[0];const Ze=v[_e];_e=Ie+he*w[2]+W*w[1]+j*w[0];const ct=v[_e],Yt=Oe+(ke-Oe)*ge;_e=Ie+ie*C[2]+$*C[1]+E*C[0],y.values[_e]=Yt+(Ze+(ct-Ze)*ge-Yt)*ne}}}else for(let L=0;L<g;++L){const W=g>1?N*(h-1)+L*K:.5*(N+U)*(h-1);if(W<0||W>h-1){for(let de=0;de<f;de++)y.values[de+L*C[2]+$*C[1]+E*C[0]]=c;continue}const ne=Math.round(W),ie=Math.round(V);for(let de=0;de<f;de++)y.values[de+L*C[2]+$*C[1]+E*C[0]]=v[de+ne*w[2]+ie*w[1]+j*w[0]]}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},Kge={kernelName:tI,backendName:"cpu",kernelFunc:function qge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;Te(s,"cumprod");const l=An([i],s.shape.length);let c=s;null!=l&&(c=ks({inputs:{x:s},backend:e,attrs:{perm:l}}));const u=Wn(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const d=zs(c.dtype,"int32"),h=US(X(c.shape),d),f=e.data.get(c.dataId).values,p=c.shape[c.shape.length-1],m=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=p)for(let b=0;b<p;b++){const _=m(y,b);if(0===b)h[_]=o?1:f[_];else{const v=m(y,b-1);h[_]=o?f[v]*h[v]:f[_]*h[v]}}const g=e.makeTensorInfo(c.shape,d,h);if(null!=l){const b=ks({inputs:{x:g},backend:e,attrs:{perm:gl(l)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(c),b}return g}},Yge={kernelName:nb,backendName:"cpu",kernelFunc:function Xge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;Te(s,"cumsum");const l=An([i],s.shape.length);let c=s;null!=l&&(c=ks({inputs:{x:s},backend:e,attrs:{perm:l}}));const u=Wn(1,s.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const d=zs(c.dtype,"int32"),h=jr(X(c.shape),d),f=e.data.get(c.dataId).values,p=c.shape[c.shape.length-1],m=a?(y,b)=>y+p-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=p)for(let b=0;b<p;b++){const _=m(y,b);if(0===b)h[_]=o?0:f[_];else{const v=m(y,b-1);h[_]=o?f[v]+h[v]:f[_]+h[v]}}const g=e.makeTensorInfo(c.shape,d,h);if(null!=l){const b=ks({inputs:{x:g},backend:e,attrs:{perm:gl(l)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(c),b}return g}},Qge={kernelName:rI,backendName:"cpu",kernelFunc:function Zge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o,binaryOutput:a}=r;if(1===s.shape.length){const u=yT(e.data.get(s.dataId).values,e.data.get(i.dataId).values,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,u)}if(2===s.shape.length){const u=W3(e.bufferSync(s),e.bufferSync(i),o,a);return e.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},eye={kernelName:sI,backendName:"cpu",kernelFunc:function Jge(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:i,dataFormat:o}=r;S("NHWC"===o,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=s.shape[0],l=s.shape[1],c=s.shape[2],u=s.shape[3],d=l*i,h=c*i,f=u/(i*i),p=e.data.get(s.dataId).values,m=new Float32Array(a*d*h*f);let g=0;for(let y=0;y<a;++y)for(let b=0;b<d;++b){const _=Math.floor(b/i),v=b%i;for(let w=0;w<h;++w){const C=Math.floor(w/i),D=(v*i+w%i)*f;for(let T=0;T<f;++T)m[g++]=p[T+D+u*(C+c*(_+l*y))]}}return e.makeTensorInfo([a,d,h,f],s.dtype,m)}};function K3(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;Te([s,i],"depthwiseConv2DNative");const u=Le(s.shape),d=Le(i.shape);let h=l;null==h&&(h=[1,1]),S(Pr(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const f=Tr(s.shape,i.shape,o,h,a,c,!0),{filterHeight:p,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=f,_=b.left,v=b.top,w=f.outChannels/f.inChannels,C=new Er(f.outShape,s.dtype),E=e.data.get(s.dataId).values,D=e.data.get(i.dataId).values,T=C.values;for(let N=0;N<f.batchSize;++N){const P=N*u[0],U=N*C.strides[0];for(let j=0;j<f.outHeight;++j){const q=U+j*C.strides[1],K=j*f.strideHeight-v;for(let $=0;$<p;++$){const V=K+$*g;if(V<0||V>=f.inHeight)continue;const L=$*d[0],W=P+V*u[1];for(let ne=0;ne<f.outWidth;++ne){const ie=q+ne*C.strides[2],de=ne*f.strideWidth-_;for(let ue=0;ue<m;++ue){const he=de+ue*y;if(he<0||he>=f.inWidth)continue;const Ie=W+he*f.inChannels;let _e=ie,Oe=L+ue*d[1];for(let ke=0;ke<f.inChannels;++ke){const Ze=E[Ie+ke];for(let ct=0;ct<w;++ct)T[_e+ct]+=Ze*D[Oe+ct];_e+=w,Oe+=w}}}}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}const tye={kernelName:rb,backendName:"cpu",kernelFunc:K3},rye={kernelName:iI,backendName:"cpu",kernelFunc:function nye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r;Te([s,i],"depthwiseConv2dNativeBackpropFilter");const d=Tr(s.shape,u,o,a,l,c,!0),{strideHeight:h,strideWidth:f,filterHeight:p,filterWidth:m}=d,g=new Er(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,_=d.outChannels/d.inChannels,v=e.data.get(s.dataId).values,w=new Er(s.shape,s.dtype,v),C=e.data.get(i.dataId).values,E=new Er(i.shape,i.dtype,C);for(let D=0;D<p;++D){const T=Math.max(0,Math.ceil((b-D)/h)),N=Math.min(d.outHeight,(d.inHeight+b-D)/h);for(let P=0;P<m;++P){const U=Math.max(0,Math.ceil((y-P)/f)),j=Math.min(d.outWidth,(d.inWidth+y-P)/f);for(let q=0;q<d.outChannels;++q){const K=Math.trunc(q/_),$=q%_;let V=0;for(let L=0;L<d.batchSize;++L)for(let W=T;W<N;++W){const ne=D+W*h-b;for(let ie=U;ie<j;++ie)V+=w.get(L,ne,P+ie*f-y,K)*E.get(L,W,ie,q)}g.set(V,D,P,K,$)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}},iye={kernelName:oI,backendName:"cpu",kernelFunc:function sye(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r;Te([s,i],"depthwiseConv2DNativeBackpropInput");const d=Le(s.shape),h=Le(i.shape),f=Tr(u,i.shape,o,a,l,c,!0),p=new Er(f.inShape,"float32"),m=p.values,[g,y,b]=p.strides,_=e.data.get(s.dataId).values,[v,w,C]=d,E=e.data.get(i.dataId).values,[D,T,N]=h,{batchSize:P,filterHeight:U,filterWidth:j,inChannels:q,inHeight:K,inWidth:$,outChannels:V,outHeight:L,outWidth:W,strideHeight:ne,strideWidth:ie}=f,de=U-1-f.padInfo.top,ue=j-1-f.padInfo.left,he=V/q;for(let ge=0;ge<P;++ge)for(let Ie=0;Ie<q;++Ie)for(let _e=0;_e<K;++_e){const Oe=_e-de,ke=Math.max(0,Math.ceil(Oe/ne)),Ze=Math.min(L,(U+Oe)/ne);for(let ct=0;ct<$;++ct){const Yt=ct-ue,hn=Math.max(0,Math.ceil(Yt/ie)),_n=Math.min(W,(j+Yt)/ie);let En=0;for(let tn=ke;tn<Ze;++tn){const Bn=tn*ne-Oe;for(let Gn=hn;Gn<_n;++Gn){const Vr=v*ge+w*tn+C*Gn,Ul=D*(U-1-Bn)+T*(j-1-(Gn*ie-Yt))+N*Ie;for(let Ii=0;Ii<he;++Ii)En+=_[Vr+(Ie*he+Ii)]*E[Ul+Ii]}}m[g*ge+y*_e+b*ct+Ie]=En}}return e.makeTensorInfo(p.shape,p.dtype,p.values)}},aye={kernelName:aI,backendName:"cpu",kernelFunc:function oye(n){const{inputs:t,backend:e}=n,{x:r}=t,s=X(r.shape),i=e.data.get(r.dataId).values,o=lt([s,s],r.dtype),a=o.values;for(let c=0;c<i.length;c++)a[c*s+c]=i[c];const l=[...r.shape,...r.shape];return e.makeTensorInfo(l,o.dtype,o.values)}},lye={kernelName:sb,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s}=n,{strides:i,pad:o,dilations:a}=e,l=t,c=l.data.get(r.dataId).values,u=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:f,inHeight:p,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:_,strideHeight:v,strideWidth:w,filterHeight:C,filterWidth:E,dilationHeight:D,dilationWidth:T,outShape:N}=Mp(r.shape,s.shape,i,o,"NHWC",a),P=X(N),U=N.length,j=Zn(r.dtype,P);for(let K=0;K<f;++K)for(let $=0;$<y;++$){const V=$*v-_.top;for(let L=0;L<b;++L){const W=L*w-_.left;for(let ne=0;ne<g;++ne){let ie=Number.MIN_SAFE_INTEGER;for(let ue=0;ue<C;++ue){const he=V+ue*D;if(he>=0&&he<p)for(let ge=0;ge<E;++ge){const Ie=W+ge*T;if(Ie>=0&&Ie<m){const _e=$o([K,he,Ie,ne],u,Le(r.shape)),Oe=$o([ue,ge,ne],h,Le(s.shape)),ke=c[_e]+d[Oe];ke>ie&&(ie=ke)}}}j[$o([K,$,L,ne],U,Le(N))]=ie}}}return{dataId:l.write(wc(j,r.dtype),N,r.dtype),shape:N,dtype:r.dtype}}},cye={kernelName:cI,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:l}=e,c=t,u=$i(r.shape,c.data.get(r.dataId).values),d=$i(s.shape,c.data.get(s.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:_,strideWidth:v,filterHeight:w,filterWidth:C,dilationHeight:E,dilationWidth:D,outShape:T}=Mp(r.shape,s.shape,o,a,"NHWC",l);S(i.rank===T.length,()=>`Error in ${cI}, dy must have the same rank as output ${T.length}, but got ${i.rank}`);const N=$i(T,c.data.get(i.dataId).values),P=WP(s.shape,s.dtype);for(let j=0;j<h;++j)for(let q=0;q<g;++q){const K=q*_-b.top;for(let $=0;$<y;++$){const V=$*v-b.left;for(let L=0;L<m;++L){let W=Number.MIN_SAFE_INTEGER,ne=0,ie=0;for(let de=0;de<w;++de){const ue=K+de*E;if(ue>=0&&ue<f)for(let he=0;he<C;++he){const ge=V+he*D;if(ge>=0&&ge<p){const Ie=u[j][ue][ge][L]+d[de][he][L];Ie>W&&(W=Ie,ne=de,ie=he)}}}P[ne][ie][L]+=N[j][q][$][L]}}}return{dataId:c.write(wc(P,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},uye={kernelName:lI,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:l}=e,c=t,u=$i(r.shape,c.data.get(r.dataId).values),d=$i(s.shape,c.data.get(s.dataId).values),{batchSize:h,inHeight:f,inWidth:p,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:_,strideWidth:v,filterHeight:w,filterWidth:C,dilationHeight:E,dilationWidth:D,outShape:T}=Mp(r.shape,s.shape,o,a,"NHWC",l);S(i.rank===T.length,()=>`Error in ${lI}, dy must have the same rank as output ${T.length}, but got ${i.rank}`);const N=$i(T,c.data.get(i.dataId).values),P=WP(r.shape,r.dtype);for(let j=0;j<h;++j)for(let q=0;q<g;++q){const K=q*_-b.top;for(let $=0;$<y;++$){const V=$*v-b.left;for(let L=0;L<m;++L){let W=Number.MIN_SAFE_INTEGER,ne=K<0?0:K,ie=V<0?0:V;for(let de=0;de<w;++de){const ue=K+de*E;if(ue>=0&&ue<f)for(let he=0;he<C;++he){const ge=V+he*D;if(ge>=0&&ge<p){const Ie=u[j][ue][ge][L]+d[de][he][L];Ie>W&&(W=Ie,ne=ue,ie=ge)}}}P[j][ne][ie][L]+=N[j][q][$][L]}}}return{dataId:c.write(wc(P,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},bT=Jn((n,t)=>n*t),dye=pT((n,t,e,r)=>({real:n*e-t*r,imag:n*r+t*e})),mv=Ar(lp,bT,dye),hye={kernelName:lp,backendName:"cpu",kernelFunc:mv};function hm(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;let a;Te(s,"sum"),a="bool"===s.dtype?kl({inputs:{x:s},backend:e,attrs:{dtype:"int32"}}):Xo({inputs:{x:s},backend:e});const l=a.shape.length,c=mt(i,a.shape),u=An(c,l);let d=c,h=a;null!=u&&(h=ks({inputs:{x:a},backend:e,attrs:{perm:u}}),d=Wn(d.length,l)),Lr("sum",d,h.shape.length);const[f,p]=kr(h.shape,d);let g=pv(e,f,zs(h.dtype,"int32"));const y=X(p),b=e.data.get(g.dataId).values,_=e.data.get(h.dataId).values;for(let v=0;v<b.length;++v){const w=v*y;let C=0;for(let E=0;E<y;++E)C+=_[w+E];b[v]=C}if(o){const w=g;g=un({inputs:{x:g},backend:e,attrs:{shape:Hn(g.shape,c)}}),e.disposeIntermediateTensorInfo(w)}return e.disposeIntermediateTensorInfo(a),null!=u&&e.disposeIntermediateTensorInfo(h),g}const fye={kernelName:Pb,backendName:"cpu",kernelFunc:hm},mye={kernelName:uI,backendName:"cpu",kernelFunc:function pye(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,i=t,{allDims:o,summedDims:a,idDims:l}=YD(s,i.length);QD(o.length,l,i);const{path:c,steps:u}=JD(a,l),d=u.length;let h=null,f=o.length;const p=[];for(let m=0;m<d;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=ZD(f,l[g]);let _;e1(y)?_=i[g]:(_=ks({inputs:{x:i[g]},backend:e,attrs:{perm:y}}),p.push(_));const v=_.shape.slice();for(let w=0;w<b.length;++w)v.splice(b[w],0,1);Rt(_.shape,v)||(_=un({inputs:{x:_},backend:e,attrs:{shape:v}}),p.push(_)),null===h?h=_:(h=mv({inputs:{a:_,b:h},backend:e}),p.push(h))}m<d-1&&(c[m]>=0&&(h=hm({inputs:{x:h},backend:e,attrs:{axis:c[m]-(o.length-f),keepDims:!1}}),p.push(h)),f--)}for(const m of p)m!==h&&e.disposeIntermediateTensorInfo(m);return h}},yye={kernelName:dI,backendName:"cpu",kernelFunc:function gye(n){const{inputs:t,backend:e}=n,{dy:r,y:s}=t;Te([r,s],"eluGrad");const i=new Float32Array(X(s.shape)),o=e.data.get(s.dataId).values,a=e.data.get(r.dataId).values;for(let l=0;l<o.length;++l){const c=o[l];i[l]=c>=1?a[l]:a[l]*(c+1)}return e.makeTensorInfo(s.shape,"float32",i)}},X3=Jn((n,t)=>n===t?1:0),Y3=Ar(ib,X3,null,"bool"),bye={kernelName:ib,backendName:"cpu",kernelFunc:Y3},_ye=UD,vye=HD,xye=WD,wye=jD,Cye=GD,Sye=qD,Iye=Xt(qf,n=>{const t=Math.sign(n),e=Math.abs(n),r=1/(1+_ye*e);return t*(1-((((Sye*r+Cye)*r+wye)*r+xye)*r+vye)*r*Math.exp(-e*e))}),Eye={kernelName:qf,backendName:"cpu",kernelFunc:Iye},Z3=Tl(n=>Math.exp(n)),Q3=$d(Kf,Z3,"float32"),Dye={kernelName:Kf,backendName:"cpu",kernelFunc:Q3};function gv(n){const{inputs:t,backend:e,attrs:r}=n,{input:s}=t,{dim:i}=r,o=s.shape.length,a=s.shape.slice();let l=i;return i<0&&(S(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),un({inputs:{x:s},backend:e,attrs:{shape:a}})}const Tye={kernelName:ob,backendName:"cpu",kernelFunc:gv},J3=Tl(n=>Math.expm1(n)),kye=$d(Xf,J3),Nye={kernelName:Xf,backendName:"cpu",kernelFunc:kye},Aye=Jn((n,t)=>n/t),_T=Ar(jf,Aye),vT={kernelName:jf,backendName:"cpu",kernelFunc:_T},eU=Jn((n,t)=>n-t),Rye=pT((n,t,e,r)=>({real:n-e,imag:t-r})),xT=Ar(Cp,eU,Rye),Mye={kernelName:Cp,backendName:"cpu",kernelFunc:xT};function tU(n,t,e){const r=n.shape,s=r[0],i=r[1],o=e.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[s,i],u=X(c),d=Sr("float32",u),h=Sr("float32",u);for(let g=0;g<s;g++){const y=Bc({inputs:{x:a},backend:e,attrs:{begin:[g,0],size:[1,i]}}),b=Bc({inputs:{x:l},backend:e,attrs:{begin:[g,0],size:[1,i]}}),_=Gs({inputs:{real:y,imag:b},backend:e}),{real:v,imag:w}=Fye(_,t,e),C=ka(v,w);for(let E=0;E<i;E++){const D=KD(C,E);d[g*i+E]=D.real,h[g*i+E]=D.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(_)}const f=e.makeTensorInfo(c,"float32",d),p=e.makeTensorInfo(c,"float32",h),m=Gs({inputs:{real:f,imag:p},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),m}function Fye(n,t,e){const r=X(n.shape),s=e.data.get(n.dataId),i=e.data.get(s.complexTensorInfos.real.dataId).values,o=e.data.get(s.complexTensorInfos.imag.dataId).values;if(function Oye(n){return 0==(n&n-1)}(r)){const a=wT(i,o,r,t,e),l=[n.shape[0],n.shape[1]];if(t){const c=e.makeTensorInfo(l,"float32",a.real),u=e.makeTensorInfo(l,"float32",a.imag),d=e.makeTensorInfo([],"float32",il(r,"float32")),h=Xo({inputs:{x:d},backend:e}),f=vT.kernelFunc({inputs:{a:c,b:d},backend:e}),p=vT.kernelFunc({inputs:{a:u,b:h},backend:e}),m=e.data.get(f.dataId).values,g=e.data.get(p.dataId).values;return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),{real:m,imag:g}}return a}{const l=function $ye(n,t,e){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let i=0,o=0;for(let a=0;a<t;a++){const l=dV(s*a,t,e),c=KD(n,a);i+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}e&&(i/=t,o/=t),cV(r,i,o,s)}return r}(ka(i,o),r,t);return oV(l)}}function wT(n,t,e,r,s){if(1===e)return{real:n,imag:t};const i=ka(n,t),o=e/2,a=aV(i),l=a.real,c=a.imag,u=[l.length],d=s.makeTensorInfo(u,"float32",l),h=s.makeTensorInfo(u,"float32",c),f=Gs({inputs:{real:d,imag:h},backend:s}),p=lV(i),m=p.real,g=p.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),_=s.makeTensorInfo(y,"float32",g),v=Gs({inputs:{real:b,imag:_},backend:s}),w=wT(l,c,o,r,s),C=w.real,E=w.imag,D=[C.length],T=s.makeTensorInfo(D,"float32",C),N=s.makeTensorInfo(D,"float32",E),P=Gs({inputs:{real:T,imag:N},backend:s}),U=wT(m,g,o,r,s),j=U.real,q=U.imag,K=[j.length],$=s.makeTensorInfo(K,"float32",j),V=s.makeTensorInfo(K,"float32",q),L=Gs({inputs:{real:$,imag:V},backend:s}),W=uV(e,r),ne=[W.real.length],ie=s.makeTensorInfo(ne,"float32",W.real),de=s.makeTensorInfo(ne,"float32",W.imag),ue=Gs({inputs:{real:ie,imag:de},backend:s}),he=mv({inputs:{a:ue,b:L},backend:s}),ge=Pd({inputs:{a:P,b:he},backend:s}),Ie=xT({inputs:{a:P,b:he},backend:s}),_e=Lc({inputs:{input:ge},backend:s}),Oe=Lc({inputs:{input:Ie},backend:s}),ke=Ld({inputs:{input:ge},backend:s}),Ze=Ld({inputs:{input:Ie},backend:s}),ct=Bd({inputs:[_e,Oe],backend:s,attrs:{axis:0}}),Yt=Bd({inputs:[ke,Ze],backend:s,attrs:{axis:0}}),hn=s.data.get(ct.dataId).values,_n=s.data.get(Yt.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(f),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo(ie),s.disposeIntermediateTensorInfo(de),s.disposeIntermediateTensorInfo(ue),s.disposeIntermediateTensorInfo(he),s.disposeIntermediateTensorInfo(ge),s.disposeIntermediateTensorInfo(Ie),s.disposeIntermediateTensorInfo(_e),s.disposeIntermediateTensorInfo(ke),s.disposeIntermediateTensorInfo(Oe),s.disposeIntermediateTensorInfo(Ze),s.disposeIntermediateTensorInfo(ct),s.disposeIntermediateTensorInfo(Yt),{real:hn,imag:_n}}const Lye={kernelName:"FFT",backendName:"cpu",kernelFunc:function Pye(n){const{inputs:t,backend:e}=n,{input:r}=t,s=X(r.shape),i=r.shape[r.shape.length-1],a=un({inputs:{x:r},backend:e,attrs:{shape:[s/i,i]}}),l=tU(a,!1,e),c=un({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}};function CT(n){const{backend:t,attrs:e}=n,{shape:r,value:s,dtype:i}=e,o=i||Rf(s),a=Zn(o,X(r));return function Vye(n,t,e){n.fill(t)}(a,s),t.makeTensorInfo(r,o,a)}const Bye={kernelName:fI,backendName:"cpu",kernelFunc:CT},zye={kernelName:pI,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{image:r}=n,s=e,i=Sr(r.dtype,X(r.shape)),[o,a,l,c]=r.shape,u=s.data.get(r.dataId).values;for(let h=0;h<o;h++){const f=h*l*a*c;for(let p=0;p<a;p++){const m=p*(l*c);for(let g=0;g<l;g++){const y=g*c;for(let b=0;b<c;b++){const _=Math.round(l-g-1),v=f+m+y+b;let w=u[v];_>=0&&_<l&&(w=u[f+m+_*c+b]),i[v]=w}}}}return{dataId:s.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},nU=Tl(n=>Math.floor(n)),Uye=$d(Yf,nU),Hye={kernelName:Yf,backendName:"cpu",kernelFunc:Uye},Wye=Jn((n,t)=>Math.floor(n/t)),jye=Ar(Zf,Wye,null,"int32"),Gye={kernelName:Zf,backendName:"cpu",kernelFunc:jye},Kye={kernelName:jb,backendName:"cpu",kernelFunc:function qye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r;let m=q3({inputs:{x:s,filter:i},backend:e,attrs:{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h}});if(o){const g=m;if("NCHW"===u&&1===o.shape.length&&1!==o.shape[0]){const y=un({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});m=Pd({inputs:{a:m,b:y},backend:e}),e.disposeIntermediateTensorInfo(y)}else m=Pd({inputs:{a:m,b:o},backend:e});e.disposeIntermediateTensorInfo(g)}if(f){const g=m;if("NCHW"===u&&"prelu"===f&&1===a.shape.length&&1!==a.shape[0]){const y=un({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});m=fv(e,m,f,y,p),e.disposeIntermediateTensorInfo(y)}else m=fv(e,m,f,a,p);e.disposeIntermediateTensorInfo(g)}return m}},Yye={kernelName:Gb,backendName:"cpu",kernelFunc:function Xye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r;let m=K3({inputs:{x:s,filter:i},backend:e,attrs:{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h}});if(o){const g=m;m=Pd({inputs:{a:m,b:o},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){const g=m;m=fv(e,m,f,a,p),e.disposeIntermediateTensorInfo(g)}return m}};function rU(n,t,e,r,s,i,o,a,l){const c=lt([r,i],e);for(let u=0;u<r;u++){const d=[];let h=0;for(let f=0;f<s;f++){const p=n[u*s+f];h+=p*o[f],d.push(p)}if(h<0||h>=l/i)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let f=0;f<i;f++)c.values[u*i+f]=t.get(...t.indexToLoc(h*i+f))}return c}const Qye={kernelName:mI,backendName:"cpu",kernelFunc:function Zye(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,i=X(r.shape),o=s.shape,a=o[o.length-1],[l,c,u,d]=zD(r,s);if(0===c)return e.makeTensorInfo(l,r.dtype,[]);const p=rU(e.data.get(s.dataId).values,e.bufferSync(r),r.dtype,c,a,u,d,r.shape,i);return e.makeTensorInfo(l,r.dtype,p.values)}};function sU(n,t,e){const r=lt(e,n.dtype);for(let s=0;s<r.size;++s){const o=r.indexToLoc(s).slice(),c=t.locToIndex([o[0],o[2]]);o[2]=t.values[c];const u=n.locToIndex(o);0<=u&&u<n.values.length&&(r.values[s]=n.values[u])}return r}const ebe={kernelName:lb,backendName:"cpu",kernelFunc:function Jye(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:i}=t,{axis:o,batchDims:a}=r;Te([s,i],"gatherV2");const l=mt(o,s.shape)[0],c=e.data.get(i.dataId).values,u=s.shape[l];for(let v=0;v<c.length;++v){const w=c[v];S(w<=u-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${u-1}]`)}let d=a;null==a&&(d=0);const h=X(i.shape),f=r1(s,i,l,d),p=un({inputs:{x:s},backend:e,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),m=un({inputs:{x:i},backend:e,attrs:{shape:[f.batchSize,h/f.batchSize]}}),g=[f.batchSize,f.outerSize,h/f.batchSize,f.sliceSize],y=e.bufferSync(m),_=sU(e.bufferSync(p),y,g);return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.makeTensorInfo(f.outputShape,_.dtype,_.values)}},iU=Jn((n,t)=>n>t?1:0),tbe=Ar(cb,iU,null,"bool"),nbe={kernelName:cb,backendName:"cpu",kernelFunc:tbe},oU=Jn((n,t)=>n>=t?1:0),rbe=Ar(Qf,oU,null,"bool"),sbe={kernelName:Qf,backendName:"cpu",kernelFunc:rbe},obe={kernelName:gI,backendName:"cpu",kernelFunc:function ibe(n){const{inputs:t,backend:e}=n,{input:r}=t,s=X(r.shape),i=r.shape[r.shape.length-1],a=un({inputs:{x:r},backend:e,attrs:{shape:[s/i,i]}}),l=tU(a,!0,e),c=un({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}},abe=Xt(ep,n=>Number.isFinite(n)?1:0,"bool"),lbe={kernelName:ep,backendName:"cpu",kernelFunc:abe},cbe=Xt(tp,n=>Math.abs(n)===1/0?1:0,"bool"),ube={kernelName:tp,backendName:"cpu",kernelFunc:cbe},dbe=Xt(np,n=>Number.isNaN(n)?1:0,"bool"),hbe={kernelName:np,backendName:"cpu",kernelFunc:dbe},aU=Jn((n,t)=>n<t?1:0),fbe=Ar(db,aU,null,"bool"),pbe={kernelName:db,backendName:"cpu",kernelFunc:fbe},lU=Jn((n,t)=>n<=t?1:0),mbe=Ar(hb,lU,null,"bool"),gbe={kernelName:hb,backendName:"cpu",kernelFunc:mbe};function cU(n,t,e){const r=(t-n)/(e-1),s=jr(e,"float32");s[0]=n;for(let i=1;i<s.length;i++)s[i]=s[i-1]+r;return s}const bbe={kernelName:bI,backendName:"cpu",kernelFunc:function ybe(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:i}=e,o=cU(r,s,i);return t.makeTensorInfo([o.length],"float32",o)}},uU=Tl(n=>Math.log(n)),_be=$d(rp,uU),vbe={kernelName:rp,backendName:"cpu",kernelFunc:_be},xbe=Xt(sp,n=>Math.log1p(n)),wbe={kernelName:sp,backendName:"cpu",kernelFunc:xbe},Cbe=Jn((n,t)=>n&&t),Sbe=Ar(fb,Cbe,null,"bool"),Ibe={kernelName:fb,backendName:"cpu",kernelFunc:Sbe},Ebe=Xt(pb,n=>n?0:1,"bool"),Dbe={kernelName:pb,backendName:"cpu",kernelFunc:Ebe},Tbe=Jn((n,t)=>n||t),kbe=Ar(mb,Tbe,null,"bool"),Nbe={kernelName:mb,backendName:"cpu",kernelFunc:kbe},Rbe={kernelName:gb,backendName:"cpu",kernelFunc:function Abe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:i,bias:o,alpha:a,beta:l}=r;Te(s,"LRN");const c=s.shape[3],u=c-1,d=e.data.get(s.dataId).values,h=X(s.shape),f=new Float32Array(h);function p(m){const g=m%c;let y=m-g+Math.max(0,g-i);const b=m-g+Math.min(g+i,u);let _=0;for(;y<=b;y++){const v=d[y];_+=v*v}return _}for(let m=0;m<h;m++){const g=p(m),y=d[m]*Math.pow(o+a*g,-l);f[m]=y}return e.makeTensorInfo(s.shape,s.dtype,f)}},Fbe={kernelName:_I,backendName:"cpu",kernelFunc:function Mbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,y:i,dy:o}=t,{depthRadius:a,bias:l,alpha:c,beta:u}=r;Te(o,"LRNGrad");const d=X(o.shape),h=o.shape[3],f=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,m=e.data.get(i.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){const _=b%h,v=b-_+Math.max(0,_-a),w=b-_+Math.min(h,_+a+1);let C=0;for(let E=v;E<w;E++)C+=Math.pow(p[E],2);C=c*C+l;for(let E=v;E<w;E++){let D=-2*c*u*p[E]*m[b]/C;b===E&&(D+=Math.pow(C,-u)),D*=f[b],g[E]+=D}}return e.makeTensorInfo(o.shape,s.dtype,g)}};function dU(n,t,e,r){const s=Sr(r,X(e));for(let i=0;i<s.length;++i){const o=i*t;let a=n[o];for(let l=0;l<t;++l){const c=n[o+l];(Number.isNaN(c)||c>a)&&(a=c)}s[i]=a}return s}function hU(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:i,keepDims:o}=r,a=e;let l=s.shape;const c=l.length,u=mt(i,l);let d=u;const h=An(d,c);let f=a.data.get(s.dataId).values;if(null!=h){const v=new Array(c);for(let w=0;w<v.length;w++)v[w]=l[h[w]];f=mT(f,l,s.dtype,h,v),d=Wn(d.length,c),l=v}Te(s,"max"),Lr("max",d,c);const[p,m]=kr(l,d),y=dU(f,X(m),p,s.dtype),b=a.write(y,p,s.dtype);let _=p;return o&&(_=Hn(p,u)),{dataId:b,shape:_,dtype:s.dtype}}const Obe={kernelName:yb,backendName:"cpu",kernelFunc:hU},fU=Jn((n,t)=>Math.max(n,t)),$be=Ar(ip,fU),Pbe={kernelName:ip,backendName:"cpu",kernelFunc:$be},Bbe={kernelName:bb,backendName:"cpu",kernelFunc:function Lbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;Te(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r;S(Pr(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=Li(s.shape,i,o,1,a,l);let d;if(1===u.filterWidth&&1===u.filterHeight&&Rt(u.inShape,u.outShape))d=Xo({inputs:{x:s},backend:e});else{const h=e.data.get(s.dataId).values,f=Le(s.shape),p=gT(h,0,s.dtype,f,u,"max");d=e.makeTensorInfo(u.outShape,s.dtype,p.values)}return d}},zbe={kernelName:_b,backendName:"cpu",kernelFunc:function Vbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r;Te(s,"maxPool3d");const u=Sa(s.shape,i,o,1,a,l,c),h=U3(e.data.get(s.dataId).values,0,s.dtype,Le(s.shape),u,"max");return e.makeTensorInfo(h.shape,"float32",h.values)}},Hbe={kernelName:xI,backendName:"cpu",kernelFunc:function Ube(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=r;Te([s,i],"maxPool3DGrad");const u=Sa(i.shape,o,a,1,l,c),h=function ige(n,t){const e=lt(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,i=t.strideWidth,o=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,c=t.effectiveFilterDepth,u=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,f=t.padInfo.top,p=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-h;let _=b;for(;_<0;)_+=o;const v=Math.min(t.inDepth,c+b);for(let w=0;w<t.outHeight;++w){const C=w*s-f;let E=C;for(;E<0;)E+=a;const D=Math.min(t.inHeight,u+C);for(let T=0;T<t.outWidth;++T){const N=T*i-p;let P=N;for(;P<0;)P+=l;const U=Math.min(t.inWidth,d+N);let j=Number.NEGATIVE_INFINITY,q=-1;for(let K=_;K<v;K+=o){const $=K-b;for(let V=E;V<D;V+=a){const L=V-C;for(let W=P;W<U;W+=l){const ne=W-N,ie=n.get(m,K,V,W,g);ie>=j&&(j=ie,q=$*u*d+L*u+ne)}}}e.set(q,m,y,w,T,g)}}}return e}(e.bufferSync(i),u),f=u.strideDepth,p=u.strideHeight,m=u.strideWidth,g=u.dilationDepth,y=u.dilationHeight,b=u.dilationWidth,_=u.effectiveFilterDepth,v=u.effectiveFilterHeight,w=u.effectiveFilterWidth,C=_-1-u.padInfo.front,E=w-1-u.padInfo.left,D=v-1-u.padInfo.top,T=lt(i.shape,"float32"),N=e.bufferSync(s);for(let P=0;P<u.batchSize;++P)for(let U=0;U<u.inChannels;++U)for(let j=0;j<u.inDepth;++j)for(let q=0;q<u.inHeight;++q)for(let K=0;K<u.inWidth;++K){const $=j-C,V=q-D,L=K-E;let W=0;for(let ne=0;ne<_;ne+=g){const ie=($+ne)/f;if(!(ie<0||ie>=u.outDepth||Math.floor(ie)!==ie))for(let de=0;de<v;de+=y){const ue=(V+de)/p;if(!(ue<0||ue>=u.outHeight||Math.floor(ue)!==ue))for(let he=0;he<w;he+=b){const ge=(L+he)/m;if(ge<0||ge>=u.outWidth||Math.floor(ge)!==ge)continue;const Oe=_*v*w-1-h.get(P,ie,ue,ge,U)===ne*v*w+de*w+he?1:0;0!==Oe&&(W+=N.get(P,ie,ue,ge,U)*Oe)}}}T.set(W,P,j,q,K,U)}return e.makeTensorInfo(T.shape,T.dtype,T.values)}},jbe={kernelName:vI,backendName:"cpu",kernelFunc:function Wbe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i,output:o}=t,a=i;Te([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=r,h=Li(a.shape,l,c,1,u,d),f=e.data.get(a.dataId).values,p=lt(h.outShape,a.dtype,z3(f,a.shape,a.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,_=h.effectiveFilterHeight,v=h.effectiveFilterWidth,w=v-1-h.padInfo.left,C=_-1-h.padInfo.top,E=lt(a.shape,"float32"),D=e.data.get(s.dataId).values,T=lt(s.shape,"float32",D);for(let N=0;N<h.batchSize;++N)for(let P=0;P<h.inChannels;++P)for(let U=0;U<h.inHeight;++U)for(let j=0;j<h.inWidth;++j){const q=U-C,K=j-w;let $=0;for(let V=0;V<_;V+=y){const L=(q+V)/m;if(!(L<0||L>=h.outHeight||Math.floor(L)!==L))for(let W=0;W<v;W+=b){const ne=(K+W)/g;if(ne<0||ne>=h.outWidth||Math.floor(ne)!==ne)continue;const ue=_*v-1-p.get(N,L,ne,P)===V*v+W?1:0;0!==ue&&($+=T.get(N,L,ne,P)*ue)}}E.set($,N,U,j,P)}return e.makeTensorInfo(E.shape,E.dtype,E.values)}},qbe={kernelName:wI,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=t,l=e;Te(r,"MaxPoolWithArgmax");const c=l.data.get(r.dataId).values,u=Li(r.shape,s,i,[1,1],o),[d,h]=function Gbe(n,t,e,r,s){const o=gT(n,0,e,Le(t),s,"max"),a=z3(n,t,e,s,!0,r);return[o.values,a.values]}(c,r.shape,r.dtype,a,u),f=l.write(d,u.outShape,r.dtype),p=l.write(h,u.outShape,r.dtype);return[{dataId:f,shape:u.outShape,dtype:r.dtype},{dataId:p,shape:u.outShape,dtype:"int32"}]}},Xbe={kernelName:vb,backendName:"cpu",kernelFunc:function Kbe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=mt(i,s.shape),u=X(kr(s.shape,a)[1]),d=[],h=e.makeTensorInfo([],"float32",new Float32Array([u]));d.push(h);const f=kl({inputs:{x:s},backend:e,attrs:{dtype:"float32"}});d.push(f);const p=_T({inputs:{a:f,b:h},backend:e});d.push(p);const m=hm({inputs:{x:p},backend:e,attrs:{axis:i,keepDims:o}});return d.forEach(g=>e.disposeIntermediateTensorInfo(g)),m}},Zbe={kernelName:xb,backendName:"cpu",kernelFunc:function Ybe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;Te(s,"min");const a=mt(i,s.shape);let l=a;const c=An(l,s.shape.length);let u=s;null!=c&&(u=ks({inputs:{x:s},backend:e,attrs:{perm:c}}),l=Wn(l.length,s.shape.length)),Lr("min",l,u.shape.length);const[d,h]=kr(u.shape,l),f=X(h),p=jr(X(d),u.dtype),m=e.data.get(u.dataId).values;for(let y=0;y<p.length;++y){const b=y*f;let _=m[b];for(let v=0;v<f;++v){const w=m[b+v];(Number.isNaN(w)||w<_)&&(_=w)}p[y]=_}null!=c&&e.disposeIntermediateTensorInfo(u);const g=e.makeTensorInfo(d,u.dtype,p);if(o){const b=un({inputs:{x:g},backend:e,attrs:{shape:Hn(d,a)}});return e.disposeIntermediateTensorInfo(g),b}return g}},pU=Jn((n,t)=>Math.min(n,t)),Qbe=Ar(op,pU),Jbe={kernelName:op,backendName:"cpu",kernelFunc:Qbe},t_e={kernelName:wb,backendName:"cpu",kernelFunc:function e_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:i,mode:o}=r;Te(s,"mirrorPad");const a=i.map((_,v)=>_[0]+s.shape[v]+_[1]),l=i.map(_=>_[0]),c=i.map((_,v)=>_[0]+s.shape[v]),u="reflect"===o?0:1,d=e.data.get(s.dataId).values,h=s.shape.length,f=Le(s.shape),p=X(a),m=a.length,g=Le(a),y=Sr(s.dtype,p);for(let _=0;_<p;_++){let v=ad(_,m,g);for(let C=0;C<m;C++)v[C]<l[C]?v[C]=2*l[C]-v[C]-u:v[C]>=c[C]&&(v[C]=2*(c[C]-1)-v[C]+u);v=v.map((C,E)=>C-l[E]);const w=$o(v,h,f);y[_]=d[w]}return{dataId:e.write(y,a,s.dtype),shape:a,dtype:s.dtype}}},n_e=Jn((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),r_e=Ar(ap,n_e),s_e={kernelName:ap,backendName:"cpu",kernelFunc:r_e};function mU(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:i}=r,o=s.shape.length;let a=i;if(-1===a&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=mt([a],s.shape),c=hU({inputs:{x:s},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),u=Hn(c.shape,l),d=un({inputs:{x:c},backend:e,attrs:{shape:u}}),h=xT({inputs:{a:s,b:d},backend:e}),f=Q3({inputs:{x:h},backend:e}),p=hm({inputs:{x:f},backend:e,attrs:{axis:l,keepDims:!1}}),m=un({inputs:{x:p},backend:e,attrs:{shape:u}}),g=_T({inputs:{a:f,b:m},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),g}const i_e={kernelName:Vb,backendName:"cpu",kernelFunc:mU},a_e={kernelName:CI,backendName:"cpu",kernelFunc:function o_e(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:i,seed:o,normalized:a}=r;Te(s,"multinomial");const l=a?s:mU({inputs:{logits:s},backend:e,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],d=e.data.get(l.dataId).values,h=[c,i],f=jr(X(h),"int32");for(let p=0;p<c;++p){const m=p*u,g=new Float32Array(u-1);g[0]=d[m];for(let _=1;_<g.length;++_)g[_]=g[_-1]+d[m+_];const y=C_.alea(o.toString()),b=p*i;for(let _=0;_<i;++_){const v=y();f[b+_]=g.length;for(let w=0;w<g.length;w++)if(v<g[w]){f[b+_]=w;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(h,"int32",f)}};function gU(n,t,e){const r=il(-1,e);return bT([],t,r,n,e)}const c_e={kernelName:Cb,backendName:"cpu",kernelFunc:function l_e(n){const{inputs:t,backend:e}=n,{x:r}=t;Te(r,"neg");const s=e.data.get(r.dataId).values,[i,o]=gU(s,r.shape,r.dtype);return e.makeTensorInfo(o,r.dtype,i)}},u_e=CD,h_e={kernelName:SI,backendName:"cpu",kernelFunc:function d_e(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r;Te(s,"NonMaxSuppression");const c=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values,{selectedIndices:d}=u_e(c,u,o,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},f_e=SD,m_e={kernelName:II,backendName:"cpu",kernelFunc:function p_e(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r;Te(s,"NonMaxSuppressionPadded");const u=e.data.get(s.dataId).values,d=e.data.get(i.dataId).values,{selectedIndices:h,validOutputs:f}=f_e(u,d,o,a,l,c);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},g_e=ID,b_e={kernelName:EI,backendName:"cpu",kernelFunc:function y_e(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r;Te(s,"NonMaxSuppressionWithScore");const u=e.data.get(s.dataId).values,d=e.data.get(i.dataId).values,h=o,f=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=g_e(u,d,h,f,p,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},yU=Jn((n,t)=>n!==t?1:0),__e=Ar(Sb,yU,null,"bool"),v_e={kernelName:Sb,backendName:"cpu",kernelFunc:__e},w_e={kernelName:Eb,backendName:"cpu",kernelFunc:function x_e(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{dtype:i,depth:o,onValue:a,offValue:l}=r;Te(s,"oneHot");const c=X(s.shape),u=new Float32Array(c*o);u.fill(l);const d=e.data.get(s.dataId).values;for(let h=0;h<c;++h)d[h]>=0&&d[h]<o&&(u[h*o+d[h]]=a);return e.makeTensorInfo([...s.shape,o],i,u)}};function yv(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const s=Lc({inputs:{input:r},backend:e}),i=yv({inputs:{x:s},backend:e}),o=Ld({inputs:{input:r},backend:e}),a=yv({inputs:{x:o},backend:e}),l=Gs({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return CT({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const C_e={kernelName:Hb,backendName:"cpu",kernelFunc:yv},S_e={kernelName:Ib,backendName:"cpu",kernelFunc:function bU(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const s=Lc({inputs:{input:r},backend:e}),i=bU({inputs:{x:s},backend:e}),o=Ld({inputs:{input:r},backend:e}),a=yv({inputs:{x:o},backend:e}),l=Gs({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return CT({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function _U(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return gv({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const i=t[0].shape,o=t[0].dtype;t.forEach(u=>{Vs(i,u.shape,"All tensors passed to stack must have matching shapes"),S(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=Bd({inputs:t.map(u=>{const d=gv({inputs:{input:u},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(u=>e.disposeIntermediateTensorInfo(u)),c}const I_e={kernelName:Db,backendName:"cpu",kernelFunc:_U},vU={kernelName:Tb,backendName:"cpu",kernelFunc:function E_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:i,constantValue:o}=r;Te(s,"pad");const a=i.map((b,_)=>b[0]+s.shape[_]+b[1]),l=i.map(b=>b[0]),c=e.data.get(s.dataId).values,u=X(s.shape),d=s.shape.length,h=Le(s.shape),f=X(a),p=a.length,m=Le(a),g=Sr(s.dtype,f);0!==o&&g.fill(o);for(let b=0;b<u;b++)g[$o(ad(b,d,h).map((C,E)=>C+l[E]),p,m)]=c[b];return{dataId:e.write(g,a,s.dtype),shape:a,dtype:s.dtype}}},D_e=Jn((n,t)=>Math.pow(n,t)),T_e=Ar(cp,D_e),k_e={kernelName:cp,backendName:"cpu",kernelFunc:T_e};function xU(n,t,e,r){const[s,i]=kr(n,r),o=zs(t,"int32"),a=jr(X(s),o),l=X(i);for(let c=0;c<a.length;++c){const u=c*l;let d=1;for(let h=0;h<l;++h)d*=e[u+h];a[c]=d}return{outVals:a,outShape:s,outDtype:o}}const A_e={kernelName:Nb,backendName:"cpu",kernelFunc:function N_e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;Te(s,"prod");const a=s.shape.length,l=mt(i,s.shape),c=An(l,a);let u=l,d=s;const h=[];null!=c&&(d=ks({inputs:{x:s},backend:e,attrs:{perm:c}}),h.push(d),u=Wn(u.length,a));const f=e.data.get(d.dataId).values,{outVals:p,outShape:m,outDtype:g}=xU(d.shape,d.dtype,f,u);let y=m;return o&&(y=Hn(m,l)),h.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(y,g,p)}};function wU(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let r=t;r<n.length;r++)e[t-1]*=n[r];return e}function CU(n,t,e,r,s,i,o,a){if(0===n.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function R_e(n,t,e){n.forEach((r,s)=>{if(r<0||r>=e){const i=ad(s,t.length,Le(t)).join(",");throw new Error(`indices[${i}] = ${r} is not in [0, ${e})`)}})}(i,o,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:u,valueSlices:d,numValues:h}=function F_e(n,t,e,r){const s=[];let i=0;const a=new Array(t.length-1+e.length).fill(null).map(()=>[0]);!function M_e(n,t){for(let e=0;e<n.length;++e){const r=n[e],s=e===n.length-1?t:n[e+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let i=1;i<r.length;++i)if(r[i-1]>r[i])throw new Error("Ragged splits must be sorted in ascending order")}}(e,r);let l=1;for(let c=0;c<t.length-1;++c){l*=t[c];const u=t[c+1];for(let d=1;d<l+1;++d)a[c].push(d*u)}for(let c=0;c<n.length;++c){let u=n[c],d=n[c]+1;for(let h=0;h<e.length;++h){const f=e[h],p=h+t.length-1;if(p>=0){const m=a[p],g=m[m.length-1]-f[u];for(let y=u;y<d;++y)a[p].push(f[y+1]+g)}u=f[u],d=f[d]}d!==u&&(s.push([u,d]),i+=d-u)}return{outSplits:a,valueSlices:s,numValues:i}}(i,o,n,c),f=function O_e(n){const t=[];for(let e=0;e<n.length;++e){const s=Zn("int32",n[e].length);t.push(s),n[e].forEach((i,o)=>s[o]=i)}return t}(u),p=function P_e(n,t,e,r,s){const i=t.slice();i[0]=s;const o=Zn(e,X(i)),a=n.length;return function $_e(n,t,e,r,s,i){const o=wU(t,2)[1],a=wU(i,2)[1];let l=0;for(const c of e)for(let u=c[0];u<c[1];++u){for(let d=0;d<r;++d)s[l*a+d]=n[u*o+d];++l}}(n,t,r,0===a?0:a/t[0],o,i),[o,i]}(e,r,s,d,h);return[f,p[0],p[1]]}const B_e={kernelName:DI,backendName:"cpu",kernelFunc:function L_e(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=t,l=s.map(y=>e.data.get(y.dataId).values),c=s.map(y=>y.shape),u=e.data.get(i.dataId).values,d=e.data.get(o.dataId).values,[h,f,p]=CU(l,c,u,i.shape,i.dtype,d,o.shape),m=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),g=e.makeTensorInfo(p,i.dtype,f);return m.concat([g])}},SU=2147483647;function IU(n,t,e,r,s,i,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=0===t.length,l=0===s.length,c=0===o.length,u=[];a||u.push(t[0]),l||u.push(s[0]),c||u.push(o[0]);for(let g=1;g<u.length;++g)if(u[g]!==u[g-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===u.length?1:u[0],h=Zn("int32",d+1);h[0]=0;for(let g=0;g<d;++g){const y=a?n[0]:n[g],b=l?r[0]:r[g],_=c?i[0]:i[g];if(0===_)throw new Error("Requires delta != 0");let v;if(_>0&&b<y||_<0&&b>y)v=0;else if(v=Math.ceil(Math.abs((b-y)/_)),v>SU)throw new Error(`Requires ((limit - start) / delta) <= ${SU}`);h[g+1]=h[g]+v}const p=Zn(e,h[d]);let m=0;for(let g=0;g<d;++g){const y=h[g+1]-h[g];let b=a?n[0]:n[g];const _=c?i[0]:i[g];for(let v=0;v<y;++v)p[m++]=b,b+=_}return[h,p]}const z_e={kernelName:TI,backendName:"cpu",kernelFunc:function V_e(n){const{inputs:t,backend:e}=n,{starts:r,limits:s,deltas:i}=t,o=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,[c,u]=IU(o,r.shape,r.dtype,a,s.shape,l,i.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([u.length],r.dtype,u)]}};var Ki=Hi;class bv{constructor(t,e,r,s,i,o,a,l,c,u){this.shape=t,this.shapeShape=e,this.values=r,this.valuesShape=s,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=rV(u),this.raggedRank=sV(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Ki.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Ki.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Ki.VALUE_ROWIDS:return bv.getMaxWidthValueRowID(e);case Ki.ROW_SPLITS:return bv.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Ki[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let r=0;for(let s=0;s<e-1;++s){const i=t[s+1]-t[s];i>r&&(r=i)}return r}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let r=0,s=t[0],i=0;for(let o=1;o<e;++o){const a=t[o];a!==s&&(s=a,i=Math.max(o-r,i),r=o)}return Math.max(e-r,i)}tensorShapeFromTensor(t,e,r=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return DU(t,r)}calculateOutputSize(t){const e=this.valuesShape;iV(this.defaultValueShape,e);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=nV(this.raggedRank,s,e);o[0]<0&&(o[0]=t);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(t,e,r){const s=Math.min(t,r),i=[];let o=0;for(let a=0;a<s;++a,o+=e)i.push(o);for(let a=s;a<t;++a)i.push(-1);return S(i.length===t,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(t,e,r,s){const i=t.length,o=[];for(let a=0;a<i-1;++a){const l=t[a+1]-t[a];let c=Math.min(s,l),u=e[a];-1===u&&(c=0);for(let d=0;d<c;++d)o.push(u),u+=r;for(let d=0;d<l-c;++d)o.push(-1)}if(i>0&&o.length!==t[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,e,r,s){const i=t.length,o=[];if(0===i)return[];let a=0,l=t[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let c=e[l];o.push(c);for(let u=1;u<i;++u){const d=t[u];if(d===l)c>=0&&(++a,a<s?c+=r:c=-1);else{if(a=0,l=d,d>=e.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${e.length}`);c=e[d]}o.push(c)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,e,r,s){const i=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case Ki.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,e,r,s);case Ki.ROW_SPLITS:if(i.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(i,e,r,s);default:throw new Error(`Unsupported partition type: ${Ki[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case Ki.FIRST_DIM_SIZE:return t[0];case Ki.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ki.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ki[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const i=DU(r,!1),o=Zn(this.valuesDType,X(i));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(e,s[0],r[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,s[c],r[c]);this.setOutput(this.raggedRank,l,o,i)}return[i,o]}setOutput(t,e,r,s){if(0===r.length)return;const i=this.values,o=r;let a=s.slice();a=a.slice(t+1);const l=X(a),c=e.length;let u=this.defaultValue;if(u.length!==l&&1!==u.length){const p=this.defaultValueShape;z(()=>{const m=F(u,p);u=wd(m,a).dataSync()})}let d=0,h=0,f=0;for(let p=0;p<=c;++p){let m=p<c?e[p]:-1;if(m!==f){if(h<f){const g=i.subarray(d*l);EU(o.subarray(h*l),g,(f-h)*l)}if(p>=c&&(m=Math.floor(r.length/l)),m>f)if(1===this.defaultValue.length)o.subarray(f*l,m*l).fill(this.defaultValue[0]),f=m;else for(;m>f;)EU(o.slice(f*l),u,l),++f;m<0?(d=p+1,h=f):(d=p,h=f,f=h+1)}else++f}}}function EU(n,t,e){for(let r=0;r<e;r++)n[r]=t[r]}function DU(n,t){const e=[];for(let r of n){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function TU(n,t,e,r,s,i,o,a,l,c){return new bv(n,t,e,r,s,i,o,a,l,c).compute()}const H_e={kernelName:kI,backendName:"cpu",kernelFunc:function U_e(n){const{inputs:t,backend:e,attrs:r}=n,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=r,c=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values,d=e.data.get(o.dataId).values,h=a.map(g=>e.data.get(g.dataId).values),f=a.map(g=>g.shape),[p,m]=TU(c,s.shape,u,i.shape,i.dtype,d,o.shape,h,f,l);return e.makeTensorInfo(p,i.dtype,m)}};function kU(n,t,e,r){if(n===t||n<t&&e<0||t<n&&e>1)return jr(0,r);const l=jr(Math.abs(Math.ceil((t-n)/e)),r);t<n&&1===e&&(e=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+e;return l}const j_e={kernelName:NI,backendName:"cpu",kernelFunc:function W_e(n){const{backend:t,attrs:e}=n,{start:r,stop:s,dtype:i,step:o}=e,a=kU(r,s,o,i);return t.makeTensorInfo([a.length],i,a)}},G_e=Xt(up,n=>1/n),q_e={kernelName:up,backendName:"cpu",kernelFunc:G_e},X_e={kernelName:Mb,backendName:"cpu",kernelFunc:function K_e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r;Te(s,"resizeBilinear");const l=Le(s.shape),[c,u]=a,[d,h,f,p]=s.shape,m=e.data.get(s.dataId).values,g=new Float32Array(X([d,c,u,p])),y=[i&&c>1?h-1:h,i&&u>1?f-1:f],b=[i&&c>1?c-1:c,i&&u>1?u-1:u];let _=0;const v=y[0]/b[0],w=y[1]/b[1];for(let C=0;C<d;C++)for(let E=0;E<c;E++){let D;D=o?v*(E+.5)-.5:v*E;const T=Math.max(0,Math.floor(D)),N=D-T,P=Math.min(h-1,Math.ceil(D)),U=C*l[0]+T*l[1],j=C*l[0]+P*l[1];for(let q=0;q<u;q++){let K;K=o?w*(q+.5)-.5:w*q;const $=Math.max(0,Math.floor(K)),V=K-$,L=Math.min(f-1,Math.ceil(K)),W=U+$*l[2],ne=j+$*l[2],ie=U+L*l[2],de=j+L*l[2];for(let ue=0;ue<p;ue++){const he=m[W+ue],ge=m[ne+ue],Oe=he+(m[ie+ue]-he)*V;g[_++]=Oe+(ge+(m[de+ue]-ge)*V-Oe)*N}}}return e.makeTensorInfo([d,c,u,p],"float32",g)}},Z_e={kernelName:MI,backendName:"cpu",kernelFunc:function Y_e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r;Te([i,s],"resizeBilinearGrad");const a=Le(s.shape),[l,c,u,d]=s.shape,[,h,f]=i.shape,p=new Float32Array(l*c*u*d),m=[o&&h>1?c-1:c,o&&f>1?u-1:u],g=[o&&h>1?h-1:h,o&&f>1?f-1:f],y=m[0]/g[0],b=m[1]/g[1],_=e.data.get(i.dataId).values;let v=0;for(let w=0;w<l;w++){const C=w*a[0];for(let E=0;E<h;E++){const D=E*y,T=Math.floor(D),N=Math.min(Math.ceil(D),c-1),P=C+T*a[1],U=C+N*a[1],j=D-T,q=1-j;for(let K=0;K<f;K++){const $=K*b,V=Math.floor($),L=Math.min(Math.ceil($),u-1),W=$-V,ne=1-W,ie=P+V*a[2],de=P+L*a[2],ue=U+V*a[2],he=U+L*a[2],ge=q*ne,Ie=q*W,_e=j*ne,Oe=j*W;for(let ke=0;ke<d;ke++){const Ze=_[v++];p[ie+ke]+=Ze*ge,p[de+ke]+=Ze*Ie,p[ue+ke]+=Ze*_e,p[he+ke]+=Ze*Oe}}}}return e.makeTensorInfo([l,u,c,d],"float32",p)}},J_e={kernelName:Rb,backendName:"cpu",kernelFunc:function Q_e(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r;Te(s,"resizeNearestNeighbor");const l=Le(s.shape),[c,u]=a,[d,h,f,p]=s.shape,m=e.data.get(s.dataId).values,g=new Float32Array(d*c*u*p),y=[i&&c>1?h-1:h,i&&u>1?f-1:f],b=[i&&c>1?c-1:c,i&&u>1?u-1:u],_=y[0]/b[0],v=y[1]/b[1];let w=0;for(let C=0;C<d;C++){const E=C*l[0];for(let D=0;D<c;D++){const T=o?_*(D+.5):_*D;let N=Math.min(h-1,i?Math.round(T):Math.floor(T));o&&(N=Math.max(0,N));const P=E+N*l[1];for(let U=0;U<u;U++){const j=o?v*(U+.5):v*U;let q=Math.min(f-1,i?Math.round(j):Math.floor(j));o&&(q=Math.max(0,q));const K=P+q*l[2];for(let $=0;$<p;$++)g[w++]=m[K+$]}}}return e.makeTensorInfo([d,c,u,p],s.dtype,g)}},tve={kernelName:RI,backendName:"cpu",kernelFunc:function eve(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r;Te([i,s],"resizeNearestNeighborGrad");const a=Le(s.shape),l=Le(i.shape),[c,u,d,h]=s.shape,[,f,p]=i.shape,m=new Float32Array(c*u*d*h),g=e.data.get(i.dataId).values,y=[o&&f>1?u-1:u,o&&p>1?d-1:d],b=[o&&f>1?f-1:f,o&&p>1?p-1:p],_=y[0]/b[0],v=y[1]/b[1],w=1/_,C=1/v,E=2*Math.ceil(w)+2,D=2*Math.ceil(C)+2;for(let T=0;T<c;T++){const N=T*a[0];for(let P=0;P<u;P++){const U=N+P*a[1],j=Math.floor(P*w),q=Math.floor(j-E/2);for(let K=0;K<d;K++){const $=U+K*a[2],V=Math.floor(K*C),L=Math.floor(V-D/2);for(let W=0;W<h;W++){let ne=0;for(let ie=0;ie<E;ie++){const de=ie+q;if(de<0||de>=f)continue;const ue=N+de*l[1],he=de*_;if(P===Math.min(u-1,o?Math.round(he):Math.floor(he)))for(let Ie=0;Ie<D;Ie++){const _e=Ie+L;if(_e<0||_e>=p)continue;const Oe=ue+_e*l[2],ke=_e*v;K===Math.min(d-1,o?Math.round(ke):Math.floor(ke))&&(ne+=g[Oe+W])}}m[$+W]=ne}}}}return e.makeTensorInfo(s.shape,s.dtype,m)}},rve={kernelName:Fb,backendName:"cpu",kernelFunc:function nve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:i}=r;Te(s,"reverse");const o=s.shape.length,a=mt(i,s.shape);if(0===o)return Xo({inputs:{x:s},backend:e});const l=new Er(s.shape,s.dtype),c=e.bufferSync(s);for(let u=0;u<l.size;u++){const d=l.indexToLoc(u),h=d.slice();a.forEach(f=>h[f]=s.shape[f]-1-h[f]),l.set(c.get(...h),...d)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}},sve={kernelName:YI,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=t,a=e,l=Sr(r.dtype,X(r.shape)),[c,u,d,h]=r.shape,[f,p]=LD(o,u,d),g=Math.sin(s),y=Math.cos(s),b=a.data.get(r.dataId).values;for(let v=0;v<c;v++){const w=v*d*u*h;for(let C=0;C<u;C++){const E=C*(d*h);for(let D=0;D<d;D++){const T=D*h;for(let N=0;N<h;N++){const P=[c,C,D,N],U=P[2],j=P[1];let q=(U-f)*y-(j-p)*g,K=(U-f)*g+(j-p)*y;q=Math.round(q+f),K=Math.round(K+p);let $=i;"number"!=typeof i&&($=3===N?255:i[N]),q>=0&&q<d&&K>=0&&K<u&&($=b[w+K*(d*h)+q*h+N]),l[w+E+T+N]=$}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},ive=Xt(fp,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2==0?t:t+1}),ove={kernelName:fp,backendName:"cpu",kernelFunc:ive},NU=Tl(n=>1/Math.sqrt(n)),ave=$d(pp,NU),lve={kernelName:pp,backendName:"cpu",kernelFunc:ave};function Vd(n,t,e,r,s,i,o,a,l,c){const u=[r/s,s],d=n.values,h=t.values;if(0===r)return lt(e,t.dtype);const f=lt(u,t.dtype);"string"==typeof l||"number"==typeof l?f.values.fill(l):"boolean"==typeof l&&f.values.fill(+l);for(let p=0;p<i;p++){const m=[];let g=0;for(let y=0;y<o;y++){const b=d[p*o+y];m.push(b),g+=b*a[y]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${e}`);for(let y=0;y<s;y++)c?f.values[g*s+y]+=h[p*s+y]:f.values[g*s+y]=0===t.rank?h[0]:h[p*s+y]}return f}const uve={kernelName:FI,backendName:"cpu",kernelFunc:function cve(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:i}=t,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=qp(0,s,o),m=Vd(e.bufferSync(s),e.bufferSync(i),o,d,c,l,a,u,0,!0);return e.makeTensorInfo(o,m.dtype,m.values)}};function dve(n,t){let e=0,r=n.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),n[s]<t?e=s+1:r=s;return r}function hve(n,t){let e=0,r=n.length,s=0;for(;e<r;)s=Math.floor((e+r)/2),n[s]<=t?e=s+1:r=s;return r}const mve={kernelName:OI,backendName:"cpu",kernelFunc:function pve(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:s,values:i}=t,{side:o}=r,c=function fve(n,t,e,r,s,i){const o=Zn("int32",e*s);for(let a=0;a<e;++a){const l=n.slice(a*r,(a+1)*r),c=a*s;for(let u=0;u<s;++u)o[c+u]="left"===i?dve(l,t[u+c]):hve(l,t[u+c])}return o}(e.data.get(s.dataId).values,e.data.get(i.dataId).values,s.shape[0],s.shape[1],i.shape[1],o);return e.makeTensorInfo(i.shape,"int32",c)}},yve={kernelName:Ob,backendName:"cpu",kernelFunc:function gve(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:i}=t;Te([r,s,i],"select");const o=r.shape.length,a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values,u=zs(s.dtype,i.dtype),d=jr(X(s.shape),u);let h=0;const f=0===o||o>1||1===s.shape.length?1:X(s.shape.slice(1));for(let p=0;p<a.length;p++)for(let m=0;m<f;m++)d[h++]=1===a[p]?l[p]:c[p];return e.makeTensorInfo(s.shape,u,d)}},bve=O_,_ve=$_,vve=Xt(mp,n=>n>=0?_ve*n:bve*(Math.exp(n)-1)),xve={kernelName:mp,backendName:"cpu",kernelFunc:vve},wve=Xt(bp,n=>n<0?-1:n>0?1:0),Cve={kernelName:bp,backendName:"cpu",kernelFunc:wve},Sve=Xt(gp,n=>Math.sin(n)),Ive={kernelName:gp,backendName:"cpu",kernelFunc:Sve},Eve=Xt(yp,n=>Math.sinh(n)),Dve={kernelName:yp,backendName:"cpu",kernelFunc:Eve},AU=Math.log(1.1920928955078125e-7)+2,Tve=Xt(vp,n=>{const t=n>-AU,e=n<AU,r=Math.exp(n);let s;return s=e?r:t?n:Math.log(1+r),s}),kve={kernelName:vp,backendName:"cpu",kernelFunc:Tve},Ave={kernelName:Lb,backendName:"cpu",kernelFunc:function Nve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,paddings:o}=r;Te([s],"spaceToBatchND");const a=X(i),l=[[0,0]];l.push(...o);for(let C=1+i.length;C<s.shape.length;++C)l.push([0,0]);const c=vU.kernelFunc({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),u=Kp(c.shape,i,a,!1),d=Xp(u.length,i.length,!1),h=Yp(c.shape,i,a,!1),m=un({inputs:{x:c},backend:e,attrs:{shape:u}}),b=ks({inputs:{x:m},backend:e,attrs:{perm:d}}),w=un({inputs:{x:b},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(b),w}};function RU(n,t,e,r,s,i,o){const a=t[0],l=i[0],c=new Array(l),u=new Array(a),d=t[1];if(0===l){if(0!==a)throw new Error(pV(a));return[Zn(e,0),[0,d],Zn(s,0),c,u]}let h=!0,f=0;const p=new Array(l).fill(0);for(let g=0;g<a;++g){const y=n[g*d];if(y<0)throw new Error(mV(g,y));if(y>=l)throw new Error(gV(g,y,l));++p[y],h=h&&y>=f,f=y}let m=!0;for(let g=0;g<l;++g){const y=0===p[g];c[g]=y,m=m&&!y,p[g]=Math.max(p[g],1),g>0&&(p[g]+=p[g-1])}if(m&&h){const g=n,y=r;for(let b=0;b<a;++b)u[b]=b;return[g,[a,d],y,c,u]}{const g=p[l-1],y=Zn(e,g*d),b=Zn(s,g),_=new Array(l).fill(0);for(let v=0;v<a;++v){const w=n[v*d],E=(0===w?0:p[w-1])+_[w];_[w]++;for(let D=0;D<d;++D)y[E*d+D]=n[v*d+D];b[E]=r[v],u[v]=E}for(let v=0;v<l;++v)if(0===_[v]){const C=0===v?0:p[v-1];y[C*d+0]=v;for(let E=1;E<d;++E)y[C*d+E]=0;b[C]=o}return[y,[g,d],b,c,u]}}const Mve={kernelName:$I,backendName:"cpu",kernelFunc:function Rve(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.data.get(r.dataId).values,l=e.data.get(s.dataId).values,c=e.data.get(i.dataId).values,u=e.data.get(o.dataId).values[0],[d,h,f,p,m]=RU(a,r.shape,r.dtype,l,s.dtype,c,u);return[e.makeTensorInfo(h,r.dtype,d),e.makeTensorInfo([h[0]],s.dtype,f),e.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),e.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function MU(n,t,e,r,s){const i=X(r),o=t[0],a=s.length,l=[];let c=1,u=-1;for(let g=0;g<a;++g){const y=s[g];if(-1===y){if(-1!==u)throw new Error(yV(u,g));u=g,l.push(1)}else{if(y<0)throw new Error(bV(g,y));c*=y,l.push(y)}}if(-1!==u){if(c<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const g=Math.trunc(i/c);if(c*g!==i)throw new Error(vV(r,l));l[u]=g}if(X(l)!==i)throw new Error(xV(r,l));const h=r.length,f=[];if(h>0){f[h-1]=1;for(let g=h-2;g>=0;--g)f[g]=f[g+1]*r[g+1]}const p=[];if(a>0){p[a-1]=1;for(let g=a-2;g>=0;--g)p[g]=p[g+1]*l[g+1]}const m=Zn(e,o*a);for(let g=0;g<o;++g){let y=0;for(let b=0;b<h;++b)y+=n[g*h+b]*f[b];for(let b=0;b<a;++b)m[g*a+b]=Math.trunc(y/p[b]),y%=p[b]}return[m,[o,a],l]}const Ove={kernelName:PI,backendName:"cpu",kernelFunc:function Fve(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.data.get(s.dataId).values),a=e.data.get(r.dataId).values,l=Array.from(e.data.get(i.dataId).values),[c,u,d]=MU(a,r.shape,r.dtype,o,l);return[e.makeTensorInfo(u,r.dtype,c),e.makeTensorInfo([d.length],i.dtype,new Int32Array(d))]}};function ST(n,t,e,r,s,i=!1,o=0){const a=r.length,l=[t[0],n.length/t[0]],c=l[1],d=a>0?s[a-1]+1:0;if(d<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=d;const p=Zn(e,h.reduce((_,v)=>_*v,1));if(0===a)return d>0&&p.fill(o),[p,h];if(d<=0)throw new Error("segment ids must be >= 0");let m=0,g=1,y=0,b=s[m];for(;;){let _=0;if(g<a){if(_=s[g],b===_){++g;continue}if(b>=_)throw new Error("segment ids are not increasing")}if(b<0||b>=d)throw new Error(CV(b,d));b>y&&p.fill(o,y*c,b*c);for(let v=m;v<g;++v){const w=r[v];if(w<0||w>=l[0])throw new Error(SV(v,r[v],l[0]));for(let C=0;C<c;C++)p[b*c+C]+=n[w*c+C]}if(i)for(let v=0;v<c;v++)p[b*c+v]/=g-m;if(m=g,++g,y=b+1,b=_,g>a)break}return y<d&&p.fill(o,y*c,d*c),[p,h]}const Pve={kernelName:LI,backendName:"cpu",kernelFunc:function $ve(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,[c,u]=ST(o,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(u,r.dtype,c)}},Bve={kernelName:BI,backendName:"cpu",kernelFunc:function Lve(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(r.dataId).values,a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values,[c,u]=ST(o,r.shape,r.dtype,a,l);return e.makeTensorInfo(u,r.dtype,c)}},zve={kernelName:VI,backendName:"cpu",kernelFunc:function Vve(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=t,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:h}=qp(0,s,a),f=!1,p=e.bufferSync(s);let m;switch(i.dtype){case"bool":m=Vd(p,e.bufferSync(i),a,h,u,c,l,d,Boolean(e.data.get(o.dataId).values[0]),f);break;case"float32":case"int32":m=Vd(p,e.bufferSync(i),a,h,u,c,l,d,e.data.get(o.dataId).values[0],f);break;case"string":m=Vd(p,e.bufferSync(i),a,h,u,c,l,d,al(e.data.get(o.dataId).values[0]),f);break;default:throw new Error(`Unsupported type ${i.dtype}`)}return e.makeTensorInfo(a,m.dtype,m.values)}},Hve={kernelName:Bb,backendName:"cpu",kernelFunc:function Uve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:i,axis:o}=r,a=mt(o,s.shape)[0],l=t1(s,i,a),c=new Array(s.shape.length).fill(0),u=s.shape.slice();return l.map(d=>{const h=[...u];h[a]=d;const f=Bc({inputs:{x:s},backend:e,attrs:{begin:c,size:h}});return c[a]+=d,f})}},Wve=Tl(n=>Math.sqrt(n)),jve=Xt(xp,n=>Math.sqrt(n)),Gve={kernelName:xp,backendName:"cpu",kernelFunc:jve},qve={kernelName:zI,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,r=t;Te(e,"square");const s=r.data.get(e.dataId).values,i=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];i[a]=l*l}return{dataId:r.write(i,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},FU=Jn((n,t)=>{const e=n-t;return e*e}),Kve=Ar(wp,FU),Xve={kernelName:wp,backendName:"cpu",kernelFunc:Kve},Yve=Xt(Dp,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),Zve={kernelName:Dp,backendName:"cpu",kernelFunc:Yve};function OU(n,t,e,r){const s=lt(n,t.dtype);for(let i=0;i<s.size;i++){const o=s.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*e[l]+r[l];s.set(t.get(...a),...o)}return s}const Jve={kernelName:UI,backendName:"cpu",kernelFunc:function Qve(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=r;Te(s,"stridedSlice");const{finalShapeSparse:f,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:_,strides:v}=FE(s.shape,i,o,a,l,c,u,d,h);let w;if(m)w=un({inputs:{x:s},backend:e,attrs:{shape:p}});else if(g||y){S(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const C=AE(b,_,v),E=Bc({inputs:{x:s},backend:e,attrs:{begin:b,size:C}});w=un({inputs:{x:E},backend:e,attrs:{shape:p}}),e.disposeIntermediateTensorInfo(E)}else{const E=OU(f,e.bufferSync(s),v,b);w=e.makeTensorInfo(p,E.dtype,E.values)}return w}};class exe{constructor(t,e,r,s,i,o){this.separator=ol(t),this.nGramWidths=e,this.leftPad=ol(r),this.rightPad=ol(s),this.padWidth=i,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const r=this.getPadWidth(e);return Math.max(0,t+2*r-e+1)}createNGrams(t,e,r,s,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),u=Math.max(0,l-(i-(a+1))),d=o-(c+u),h=e+(c>0?0:a-l);let f=0;f+=c*this.leftPad.length;for(let b=0;b<d;++b)f+=t[h+b].length;f+=u*this.rightPad.length,f+=(c+u+d-1)*this.separator.length,r[s+a]=new Uint8Array(f);const m=r[s+a];let g=0;const y=b=>b.forEach(_=>m[g++]=_);for(let b=0;b<c;++b)y(this.leftPad),y(this.separator);for(let b=0;b<d-1;++b)y(t[h+b]),y(this.separator);if(d>0){y(t[h+d-1]);for(let b=0;b<u;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<u-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,e){const r=t.length,s=e.length;if(s>0){let l=e[0];if(0!==l)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<s;++c){let u=e[c]>=l;if(u=u&&e[c]<=r,!u)throw new Error(`Invalid split value ${e[c]}, must be in [${l}, ${r}]`);l=e[c]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const i=s-1,o=Zn("int32",s);if(0===r||0===s){const l=new Array(r);for(let c=0;c<=i;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const c=e[l]-e[l-1];let u=0;this.nGramWidths.forEach(d=>{u+=this.getNumNGrams(c,d)}),this.preserveShort&&c>0&&0===u&&(u=1),o[l]=o[l-1]+u}const a=new Array(o[i]);for(let l=0;l<i;++l){const c=e[l];let u=o[l];if(this.nGramWidths.forEach(d=>{const f=this.getNumNGrams(e[l+1]-e[l],d);this.createNGrams(t,c,a,u,f,d),u+=f}),this.preserveShort&&u===o[l]){const d=e[l+1]-e[l];if(0===d)continue;this.createNGrams(t,c,a,u,1,d+2*this.padWidth)}}return[a,o]}}function $U(n,t,e,r,s,i,o,a){return new exe(e,r,s,i,o,a).compute(n,t)}const nxe={kernelName:HI,backendName:"cpu",kernelFunc:function txe(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:d}=t,h=e.data.get(u.dataId).values,f=e.data.get(d.dataId).values,[p,m]=$U(h,f,s,i,o,a,l,c);return[e.makeTensorInfo([p.length],"string",p),e.makeTensorInfo(d.shape,"int32",m)]}};function rxe(n,t,e,r){if(!n.length)return;if(0===t.length){for(let i=0;i<n.length;++i)r.push(n.subarray(i,i+1));return}if(1===t.length){const i=t[0];let o=n.indexOf(i);for(;-1!==o;){const a=n.subarray(0,o);(!e||0!==a.length)&&r.push(a),o=(n=n.subarray(o+1)).indexOf(i)}return void((!e||0!==n.length)&&r.push(n))}let s=0;for(let i=0;i<n.length+1;i++)if(i===n.length||-1!==t.indexOf(n[i])){const o=n.subarray(s,i);(!e||0!==o.length)&&r.push(o),s=i+1}}function PU(n,t,e){const r=n.length,s=[];let i=0,o=0;const a=new Array(r);for(let h=0;h<r;++h){const f=s.length;rxe(n[h],t,e,s);const p=s.length-f;a[h]=p,i+=p,o=Math.max(o,p)}const l=Zn("int32",2*i),c=new Array(i),u=[r,o];let d=0;for(let h=0;h<r;++h)for(let f=0;f<a[h];++f)l[2*d]=h,l[2*d+1]=f,c[d]=s[d],++d;return[l,c,u]}const ixe={kernelName:WI,backendName:"cpu",kernelFunc:function sxe(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.data.get(i.dataId).values,l=e.data.get(o.dataId).values[0],[c,u,d]=PU(a,l,s),h=u.length;return[e.makeTensorInfo([h,2],"int32",c),e.makeTensorInfo([h],"string",u),e.makeTensorInfo([2],"int32",new Int32Array(d))]}};function LU(n,t){const e=Zn("int32",n.length);for(let r=0;r<n.length;++r)e[r]=une(n[r]).modulo(t).getLowBitsUnsigned();return e}const axe={kernelName:jI,backendName:"cpu",kernelFunc:function oxe(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const a=LU(e.data.get(i.dataId).values,s);return e.makeTensorInfo(i.shape,"int32",a)}},lxe=Xt(Sp,n=>Math.tan(n)),cxe={kernelName:Sp,backendName:"cpu",kernelFunc:lxe},uxe=Xt(Ip,n=>Math.tanh(n));function BU(n,t){const e=new Array(n.rank);for(let s=0;s<e.length;s++)e[s]=n.shape[s]*t[s];const r=lt(e,n.dtype);for(let s=0;s<r.values.length;++s){const i=r.indexToLoc(s),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%n.shape[l];const a=n.locToIndex(o);r.values[s]=n.values[a]}return r}const fm=(n,t)=>{const e=t.value-n.value;return 0===e?n.index-t.index:e};function VU(n,t,e=0,r=n.length-1){for(;r>e;){if(r-e>600){const a=r-e+1,l=t-e+1,c=Math.log(a),u=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2);VU(n,t,Math.max(e,Math.floor(t-l*u/a+d)),Math.min(r,Math.floor(t+(a-l)*u/a+d)))}const s=n[t];let i=e,o=r;for(nl(n,e,t),fm(n[r],s)>0&&nl(n,e,r);i<o;){for(nl(n,i,o),i++,o--;fm(n[i],s)<0;)i+=1;for(;fm(n[o],s)>0;)o-=1}0===fm(n[e],s)?nl(n,e,o):(o+=1,nl(n,o,r)),o<=t&&(e=o+1),t<=o&&(r=o-1)}}function zU(n,t,e,r,s){const i=t[t.length-1],[o,a]=[n.length/i,i],l=Sr(e,o*r),c=Sr("int32",o*r);for(let d=0;d<o;d++){const h=d*a,f=n.subarray(h,h+a);let p=new Array(f.length);f.forEach((b,_)=>p[_]={value:b,index:_}),r<p.length&&(VU(p,r),p=p.slice(0,r)),s&&p.sort(fm);const m=d*r,g=l.subarray(m,m+r),y=c.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=p[b].value,y[b]=p[b].index}const u=t.slice();return u[u.length-1]=r,[lt(u,e,l),lt(u,"int32",c)]}function UU(n,t,e){switch(e){case"reflect":return function bxe(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const r=2*t;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-t?e+r:-e-1}else if(e>t-1)if(t<=1)e=0;else{const r=2*t;e-=r*Math.trunc(e/r),e>=t&&(e=r-e-1)}return _c(0,e,t-1)}(n,t);case"wrap":return function _xe(n,t){let e=n;return e<0?t<=1?e=0:e+=t*(Math.trunc(-e/(t-1))+1):e>t-1&&(t<=1?e=0:e-=t*Math.trunc(e/(t-1))),_c(0,e,t-1)}(n,t);case"nearest":return function xxe(n,t){return _c(0,n,t-1)}(n,t);default:return function vxe(n,t){return n}(n)}}function pm(n,t,e,r,s,i,o,a,l,c,u){return 0<=a&&a<t&&0<=l&&l<e?n[o*r+a*s+l*i+c]:u}function wxe(n,t,e,r,s,i,o,a,l,c,u){return pm(n,t,e,r,s,i,o,Math.round(a),Math.round(l),c,u)}function Cxe(n,t,e,r,s,i,o,a,l,c,u){const d=Math.floor(a),h=Math.floor(l),f=d+1,p=h+1;return(f-a)*((p-l)*pm(n,t,e,r,s,i,o,d,h,c,u)+(l-h)*pm(n,t,e,r,s,i,o,d,p,c,u))+(a-d)*((p-l)*pm(n,t,e,r,s,i,o,f,h,c,u)+(l-h)*pm(n,t,e,r,s,i,o,f,p,c,u))}function HU(n,t,e,r){const s=mt(t,e)[0],i=[1,e[0],1];for(let p=0;p<s;p++)i[0]*=e[p];i[1]=e[s];for(let p=s+1;p<e.length;p++)i[2]*=e[p];const o={},a=new Int32Array(e[s]),l=new Er(i,r,n),c=[],u=1===i[0]&&1===i[2];for(let p=0;p<e[s];p++){let m;if(u)m=n[p].toString();else{const g=[];for(let y=0;y<i[0];y++)for(let b=0;b<i[2];b++)g.push(l.get(y,p,b));m=g.join(",")}if(void 0!==o[m])a[p]=o[m];else{const g=Object.keys(o).length;o[m]=g,a[p]=g,c.push(p)}}const d=i.slice();d[1]=Object.keys(o).length;const h=new Er(d,r);c.forEach((p,m)=>{for(let g=0;g<i[0];g++)for(let y=0;y<i[2];y++)h.set(l.get(g,p,y),g,m,y)});const f=e.slice();return f[s]=d[1],{outputValues:h.values,outputShape:f,indices:a}}const Nxe=[Ame,Rme,Fme,$me,Dme,Lme,zme,Hme,jme,qme,Xme,Zme,Jme,nge,sge,age,cge,dge,fge,kme,mge,bge,vge,wge,Ime,Sge,Ege,Cme,Dge,kge,Nge,Rge,Fge,$ge,Lge,Vge,Uge,Wge,Gge,Kge,Yge,Qge,eye,tye,rye,iye,aye,lye,cye,uye,mye,pme,yye,bye,Eye,Dye,Tye,Nye,Lye,Bye,zye,Hye,Gye,Kye,Yye,Qye,ebe,nbe,sbe,mme,obe,Tge,lbe,ube,hbe,gme,pbe,gbe,bbe,vbe,wbe,Ibe,Dbe,Nbe,Rbe,Fbe,Obe,Pbe,Bbe,zbe,Hbe,jbe,qbe,Xbe,Zbe,Jbe,t_e,s_e,a_e,hye,c_e,h_e,m_e,b_e,v_e,w_e,S_e,I_e,vU,k_e,bme,A_e,B_e,z_e,H_e,j_e,Sme,vT,q_e,_me,vme,Tme,X_e,Z_e,J_e,tve,rve,sve,ove,lve,uve,mve,yve,xve,wme,Cve,Ive,Dve,gge,i_e,kve,Ave,Mve,Ove,Pve,Bve,zve,Hve,Gve,qve,Xve,Zve,Jve,nxe,ixe,axe,Mye,fye,cxe,{kernelName:Ip,backendName:"cpu",kernelFunc:uxe},{kernelName:Ep,backendName:"cpu",kernelFunc:function hxe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:i}=r;Te(s,"tile");const o=BU(e.bufferSync(s),i);return e.makeTensorInfo(o.shape,o.dtype,o.values)}},{kernelName:GI,backendName:"cpu",kernelFunc:function pxe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:i,sorted:o}=r;Te(s,"topk");const a=e.data.get(s.dataId).values,[l,c]=zU(a,s.shape,s.dtype,i,o);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}},{kernelName:qI,backendName:"cpu",kernelFunc:function gxe(n){const{inputs:t,attrs:e,backend:r}=n,{image:s,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=e,[u,d,h,f]=s.shape,[p,m]=c??[d,h],g=[u,p,m,f],y=Le(s.shape),b=y[0],_=y[1],v=y[2],w=Le(g),C=w[0],E=w[1],D=w[2],T=Sr(s.dtype,X(g));T.fill(l);const N=r.data.get(s.dataId).values,P=r.data.get(i.dataId).values;for(let j=0;j<u;++j){const q=1===i.shape[0]?P:P.subarray(8*j,8*j+8);for(let K=0;K<p;++K)for(let $=0;$<m;++$)for(let V=0;V<f;++V){let L;const W=q[6]*$+q[7]*K+1;if(0===W)continue;const ie=(q[3]*$+q[4]*K+q[5])/W,de=UU((q[0]*$+q[1]*K+q[2])/W,h,a),ue=UU(ie,d,a);switch(o){case"nearest":L=wxe(N,d,h,b,_,v,j,ue,de,V,l);break;case"bilinear":L=Cxe(N,d,h,b,_,v,j,ue,de,V,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}T[j*C+K*E+$*D+V]=L}return r.makeTensorInfo(g,s.dtype,T)}return{dataId:r.write(T,g,s.dtype),shape:s.shape,dtype:s.dtype}}},Bme,{kernelName:KI,backendName:"cpu",kernelFunc:function Sxe(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:i}=t;Te(i,"unique");const o=r.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:c}=HU(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},{kernelName:zb,backendName:"cpu",kernelFunc:function Exe(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s.shape.length,a=s.shape[i],l=new Array(o-1);let c=0;for(let f=0;f<o;f++)f!==i&&(l[c++]=s.shape[f]);const u=new Array(o).fill(0),d=s.shape.slice();d[i]=1;const h=new Array(a);for(let f=0;f<h.length;f++){u[i]=f;const p=Bc({inputs:{x:s},backend:e,attrs:{begin:u,size:d}});h[f]=un({inputs:{x:p},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(p)}return h}},{kernelName:Ub,backendName:"cpu",kernelFunc:function Txe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:i}=t,{numSegments:o}=r;Te(s,"unsortedSegmentSum");const c=[],u=[],d=s.shape.length-i.shape.length;let h=i;for(let p=0;p<d;++p){const m=gv({inputs:{input:h},backend:e,attrs:{dim:p+1}});h=m,u.push(m)}for(let p=0;p<o;++p){const m=il(p,"int32"),g=e.makeTensorInfo([],"int32",m),y=Y3({inputs:{a:g,b:h},backend:e}),b=kl({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),_=mv({inputs:{a:b,b:s},backend:e}),v=hm({inputs:{x:_},backend:e,attrs:{axis:0,keepDims:!1}});c.push(v),u.push(g),u.push(y),u.push(b),u.push(_),u.push(v)}const f=_U({inputs:c,backend:e,attrs:{axis:0}});return u.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}},C_e];for(const n of Nxe)JI(n);const Nl={},_v={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Co(n,t){if(!(n in Nl)||null!=t){const r=function Mxe(n,t){if(1!==n&&2!==n)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??function Rxe(n){if(typeof OffscreenCanvas<"u"&&2===n)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(n);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Nl[n]},!1),G().getBool("SOFTWARE_WEBGL_ENABLED")&&(_v.failIfMajorPerformanceCaveat=!1),1===n?e.getContext("webgl",_v)||e.getContext("experimental-webgl",_v):e.getContext("webgl2",_v)}(n,t);if(null===r)return console.log("Could not get context for WebGL version",n),null;Nl[n]=r}const e=Nl[n];return null==e||e.isContextLost()?(delete Nl[n],Co(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Nl[n])}var zd=(()=>{return(n=zd||(zd={}))[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH",zd;var n})(),qs=(()=>{return(n=qs||(qs={}))[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD",qs;var n})(),Rr=(()=>{return(n=Rr||(Rr={}))[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",Rr;var n})();function mm(n,t){return[t,n]}function vv(n){const t=X(n);return PS(Math.ceil(t/4))}function Ud(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function IT(n,t){const e=n;let r,s,i,o,a,l,c,u,d,h;return 2===G().getNumber("WEBGL_VERSION")?(r=e.R32F,s=e.R16F,i=e.RGBA16F,o=e.RGBA32F,a=e.RED,c=4,u=1,d=e.HALF_FLOAT,h=e.FLOAT,l=e.RGBA8):(r=n.RGBA,s=n.RGBA,i=n.RGBA,o=e.RGBA,a=n.RGBA,c=4,u=4,d=null!=t?t.HALF_FLOAT_OES:null,h=n.FLOAT,l=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:h}}function ye(n,t){const e=t();return G().getBool("DEBUG")&&function $xe(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+function Vxe(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(n,t))}(n),e}function Bxe(n){return!!(G().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||5.96e-8<Math.abs(n)&&Math.abs(n)<65504)}function xv(n,t){return Fa(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const Hxe=/ERROR: [0-9]+:([0-9]+):/g;function WU(n,t){const e=Hxe.exec(t);if(null==e)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(n);const r=+e[1],s=n.split("\n"),i=s.length.toString().length+2,o=s.map((d,h)=>od((h+1).toString(),i)+d);let a=0;for(let d=0;d<o.length;d++)a=Math.max(o[d].length,a);const l=o.slice(0,r-1),c=o.slice(r-1,r),u=o.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${od(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function ET(n,t){if(ye(n,()=>n.validateProgram(t)),!1===n.getProgramParameter(t,n.VALIDATE_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function jU(n,t,e,r,s,i,o){const a=n.getAttribLocation(t,e);return-1!==a&&(ye(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),ye(n,()=>n.vertexAttribPointer(a,s,n.FLOAT,!1,i,o)),ye(n,()=>n.enableVertexAttribArray(a)),!0)}function e0e(n,t,e,r){ye(n,()=>function Zxe(n,t,e){(function qU(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+n.TEXTURE0;if(r<n.TEXTURE0||r>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(n,e),ye(n,()=>n.activeTexture(n.TEXTURE0+e)),ye(n,()=>n.bindTexture(n.TEXTURE_2D,t))}(n,t,r)),ye(n,()=>n.uniform1i(e,r))}function DT(n,t,e){ye(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),ye(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function GU(n,t){ye(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),ye(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function wv(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function t0e(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(n,t))}function Fa(n,t,e){const r=ye(n,()=>t());if(null==r)throw new Error(e);return r}function Hd(n,t=2){return X(n.slice(0,n.length-t))}function Wd(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Cv(n){let t=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(t=[Hd(n),...Wd(n)]),t}function Sv(n){return n%2==0}function Iv(n,t){if(Rt(n=n.slice(-2),t=t.slice(-2))||!n.length||!t.length||0===n[0]||0===n[1]||0===t[0]||0===t[1])return!0;if(n.length!==t.length){const e=n.slice(-1)[0],r=t.slice(-1)[0];if(e===r||Sv(e)&&Sv(r)&&(1===n[0]||1===t[0]))return!0}return n[1]===t[1]&&Sv(n[0])&&Sv(t[0])}let Ev,Dv;function Xi(n,t){return null!=n.getExtension(t)}function KU(n){try{if(null!=Co(n))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function TT(n){const t=IT(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(i),o}function gm(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&S("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const Fe=G();function ds(){let n,t,e,r,s,i,o,a,l,c;return 2===G().getNumber("WEBGL_VERSION")?(n="#version 300 es",t="in",e="out",r="in",s="texture",i="outputColor",o="out vec4 outputColor;",a=G().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(n="",t="attribute",e="varying",r="varying",s="texture2D",i="gl_FragColor",o="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:n,attribute:t,varyingVs:e,varyingFs:r,texture2D:s,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}function Vc(n,t,e="index"){const r=Le(t);return r.map((s,i)=>`int ${n[i]} = ${e} / ${s}; ${i===r.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * ${s}`:`index -= ${n[i]} * ${s}`};`).join("")}function Tv(n,t,e="index"){const r=Le(t);return r.map((s,i)=>`int ${n[i]} = ${e} / outShapeStrides[${i}]; ${i===r.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`};`).join("")}function kT(n){const t=Le(n).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Fe.registerFlag("HAS_WEBGL",()=>Fe.getNumber("WEBGL_VERSION")>0),Fe.registerFlag("WEBGL_VERSION",()=>KU(2)?2:KU(1)?1:0),Fe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Fe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===Fe.get("WEBGL_VERSION")),Fe.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Fe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Fe.registerFlag("WEBGL_PACK",()=>Fe.getBool("HAS_WEBGL")),Fe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Fe.getBool("WEBGL_PACK")),Fe.registerFlag("WEBGL_PACK_CLIP",()=>Fe.getBool("WEBGL_PACK")),Fe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Fe.getBool("WEBGL_PACK")),Fe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Fe.getBool("WEBGL_PACK")),Fe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Fe.getBool("WEBGL_PACK")),Fe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Fe.getBool("WEBGL_PACK")),Fe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Fe.getBool("WEBGL_PACK")),Fe.registerFlag("WEBGL_PACK_REDUCE",()=>Fe.getBool("WEBGL_PACK")),Fe.registerFlag("WEBGL_LAZILY_UNPACK",()=>Fe.getBool("WEBGL_PACK")),Fe.registerFlag("WEBGL_CONV_IM2COL",()=>Fe.getBool("WEBGL_PACK")),Fe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function r0e(n){if(null==Ev){const t=Co(n);Ev=t.getParameter(t.MAX_TEXTURE_SIZE)}return Ev}(Fe.getNumber("WEBGL_VERSION"))),Fe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function s0e(n){if(null==Dv){const t=Co(n);Dv=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Dv)}(Fe.getNumber("WEBGL_VERSION"))),Fe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Fe.getNumber("WEBGL_VERSION");return 0===n?0:function i0e(n){if(0===n)return 0;let t;const e=Co(n);return t=Xi(e,"EXT_disjoint_timer_query_webgl2")&&2===n?2:Xi(e,"EXT_disjoint_timer_query")?1:0,t}(n)}),Fe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Fe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!oL()),Fe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function o0e(n){if(0===n)return!1;const t=Co(n);if(1===n){if(!Xi(t,"OES_texture_float"))return!1}else if(!Xi(t,"EXT_color_buffer_float"))return!1;return TT(t)}(Fe.getNumber("WEBGL_VERSION"))),Fe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Fe.getBool("WEBGL_FORCE_F16_TEXTURES")&&Fe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Fe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function a0e(n){if(0===n)return!1;const t=Co(n);if(1!==n){if(Xi(t,"EXT_color_buffer_float"))return TT(t);const r="EXT_color_buffer_half_float";if(Xi(t,r)){const s=t.getExtension(r);return function l0e(n,t){const e=IT(n,t),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(o),a}(t,s)}return!1}return!(!Xi(t,"OES_texture_float")||!Xi(t,"WEBGL_color_buffer_float"))&&TT(t)}(Fe.getNumber("WEBGL_VERSION"))),Fe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function c0e(n){return 2===n&&null!=Co(n).fenceSync}(Fe.getNumber("WEBGL_VERSION"))),Fe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Fe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Fe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),Fe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>oL()?1:-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)}),Fe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),Fe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),Fe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),Fe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),Fe.registerFlag("WEBGL_EXP_CONV",()=>!1),Fe.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Fe.getBool("IS_TEST")),Fe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),Fe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),Fe.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),Fe.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const XU="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:YU}=ut;function h0e(n,t,e){const r=[];if(n.forEach(f=>{const p=X(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?r.push(`uniform float ${f.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${f.name};`),r.push(`uniform int offset${f.name};`)),e.enableShapeUniforms){const{uniformShape:m}=AT(e.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${f.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${f.name}Shape;`)}r.push(`uniform ivec2 ${f.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(f=>{r.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});const s=r.join("\n"),i=n.map(f=>function f0e(n,t,e=!1,r){let s="";return s+=e?ZU(n,r):jd(n,r),n.shapeInfo.logicalShape.length<=t.logicalShape.length&&(s+=e?function G0e(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=t.logicalShape.length,a=YU(n.shapeInfo.logicalShape,t.logicalShape),l=dn(o),c=o-i;let u;const d=["x","y","z","w","u","v"];u=0===i?"":o<2&&a.length>=1?"coords = 0;":a.map(b=>`coords.${d[b+c]} = 0;`).join("\n");let h="";h=o<2&&i>0?"coords":n.shapeInfo.logicalShape.map((b,_)=>`coords.${d[_+c]}`).join(", ");let f="return outputValue;";const m=1===X(n.shapeInfo.logicalShape),y=1===X(t.logicalShape);if(1!==i||m||y){if(m&&!y)f=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const b=i-2,_=i-1;a.indexOf(b)>-1&&a.indexOf(_)>-1?f="return vec4(outputValue.x);":a.indexOf(b)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(_)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${u}\n      vec4 outputValue = get${r}(${h});\n      ${f}\n    }\n  `}(n,t):function q0e(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),s="get"+r+"AtOutCoords",a=n.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&null==n.shapeInfo.flatOffset&&Rt(n.shapeInfo.texShape,t.texShape))return`\n      float ${s}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const c=dn(l),u=YU(n.shapeInfo.logicalShape,t.logicalShape),d=l-a;let h;const f=["x","y","z","w","u","v"];h=0===a?"":l<2&&u.length>=1?"coords = 0;":u.map(m=>`coords.${f[m+d]} = 0;`).join("\n");let p="";return p=l<2&&a>0?"coords":n.shapeInfo.logicalShape.map((m,g)=>`coords.${f[g+d]}`).join(", "),`\n    float ${s}() {\n      ${c} coords = getOutputCoords();\n      ${h}\n      return get${r}(${p});\n    }\n  `}(n,t)),s}(f,t,e.packedInputs,e.enableShapeUniforms)).join("\n"),o=t.texShape,a=ds(),l=function g0e(n){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `}(a);let c,u,d=function _0e(n){return`${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${v0e}\n    ${x0e}\n    ${w0e}\n  `}(a);return t.isPacked?(c=function p0e(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function S0e(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,e);case 2:return function R0e(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Rt(n,t))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(n[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function E0e(n,t,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[2]/2),i=s*Math.ceil(n[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(n,t,e);default:return function T0e(n,t,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(n[n.length-1]/2),i=s*Math.ceil(n[n.length-2]/2);let o=i,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`\n      int b${c} = index / ${o};\n      index -= b${c} * ${o};\n    `+a,l=`b${c}, `+l;return`\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${n.length}(${l});\n    }\n  `}(n,t,e)}}(t.logicalShape,o,e.enableShapeUniforms),u=function b0e(n){return`\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `}(a)):(c=function m0e(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function I0e(n,t,e){return 1===t[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,e);case 2:return function M0e(n,t,e){return Rt(n,t)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===n[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function D0e(n,t,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${Tv(["r","c","d"],n)}\n    return ivec3(r, c, d);\n  }\n`;const r=Vc(["r","c","d"],n);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(n,t,e);case 4:return function k0e(n,t,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${Tv(["r","c","d","d2"],n)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=Vc(["r","c","d","d2"],n);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(n,t,e);case 5:return function N0e(n,t){const e=Vc(["r","c","d","d2","d3"],n);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(n,t);case 6:return function A0e(n,t){const e=Vc(["r","c","d","d2","d3","d4"],n);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}(t.logicalShape,o,e.enableShapeUniforms),u=function y0e(n){return`\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `}(a)),e.packedInputs&&(d+=C0e),[d,l,u,s,c,i,e.userCode].join("\n")}function jd(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return function O0e(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[s,i]=n.shapeInfo.texShape;if(1===s&&1===i)return`\n      float ${r}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=zc(e);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[a,l]=n.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${l}, ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 1:return function P0e(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${Gd(n)}\n      }\n    `;const s=n.shapeInfo.texShape,i=s[0],o=s[1];if(1===o&&1===i)return`\n      float ${r}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const a=zc(e);return 1===o?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 2:return function B0e(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape;if(null!=i&&Rt(e,i))return t?`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${i[0]}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const{newShape:o,keptDims:a}=rl(e);if(o.length<e.length){const f=["row","col"];return`\n      ${jd(qd(n,o),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${Kd(f,a)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Gd(n)}\n      }\n    `;const c=i[0],u=i[1],d=zc(r);return 1===u?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===c?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${c}, ${u}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(n,t);case 3:return function z0e(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e[1]*e[2],o=e[2],{newShape:a,keptDims:l}=rl(e);if(a.length<e.length){const g=["row","col","depth"];return`\n        ${jd(qd(n,a),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${Kd(g,l)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${o}, 1)));\n        ${Gd(n)}\n      }\n    `;const u=n.shapeInfo.texShape,d=u[0],h=u[1],f=n.shapeInfo.flatOffset;if(h===i&&null==f)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===o&&null==f)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const p=zc(r);return t?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${p};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${o} + depth + ${p};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(n,t);case 4:return function H0e(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=e[3],o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:c}=rl(e);if(l.length<e.length){const _=["row","col","depth","depth2"];return`\n      ${jd(qd(n,l),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${Kd(_,c)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${a}, ${o}, ${i}, 1)));\n        ${Gd(n)}\n      }\n    `;const u=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],f=d[1],p=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(f===a&&null==u)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${p}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(f===i&&null==u)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=zc(r);return t?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${p}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${f}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(n,t);case 5:return function W0e(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t[4],i=t[3]*s,o=t[2]*i,a=t[1]*o,{newShape:l,keptDims:c}=rl(t);if(l.length<t.length){const g=["row","col","depth","depth2","depth3"];return`\n      ${jd(qd(n,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${Kd(g,c)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${o}, ${i}, ${s})) +\n          depth3;\n        ${Gd(n)}\n      }\n    `;const u=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],f=d[1];if(f===a&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(f===s&&null==u)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${o} + depth * ${i} +\n          depth2 * ${s} + depth3 + ${zc(e)};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 6:return function j0e(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:s,keptDims:i}=rl(t);if(s.length<t.length){const y=["row","col","depth","depth2","depth3","depth4"];return`\n      ${jd(qd(n,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${Kd(y,i)});\n      }\n    `}const o=t[5],a=t[4]*o,l=t[3]*a,c=t[2]*l,u=t[1]*c;if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${u}, ${c}, ${l}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${Gd(n)}\n      }\n    `;const d=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],p=h[1];if(p===u&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${l}, ${a}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(p===o&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${c} + depth * ${l} +\n          depth2 * ${a} + depth3 * ${o} + depth4 + ${zc(e)};\n      vec2 uv = uvFromFlat(${f}, ${p}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function ZU(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return function F0e(n){const t=n.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${ds().texture2D}(${t}, halfCR);\n    }\n  `}(n);case 1:return function $0e(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=n.shapeInfo.texShape,i=ds();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `;const o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${i.texture2D}(${e}, uv);\n    }\n  `}(n,t);case 2:return function L0e(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=i[0],a=i[1],l=ds();if(null!=i&&Rt(e,i))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${c[0]}, ${c[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(n,t);case 3:return function V0e(n,t){const e=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===e[0]){const f=[1,2],m=["b","row","col"];return`\n        ${ZU(qd(n,e.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${Kd(m,f)});\n        }\n      `}const a=ds();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `;const l=o[0],c=o[1],u=Math.ceil(e[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${c}, ${u*Math.ceil(e[1]/2)}, ${u}, b, row, col);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `}(n,t);default:return function U0e(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),s=ds();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${e}, uv);\n    }\n  `;const i=n.shapeInfo.logicalShape,o=i.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],d=Math.ceil(i[o-1]/2);let h=d*Math.ceil(i[o-2]/2),f="int b, int row, int col",p=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<o-1;m++)f=`int b${m}, `+f,h*=i[o-m-1],p=`b${m} * ${h} + `+p;return`\n    vec4 ${r}(${f}) {\n      int index = ${p};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(n,t)}}const v0e="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",x0e="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",w0e="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",C0e="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function zc(n){return`offset${n}`}function Gd(n){const t=n.name,e=X(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function dn(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function AT(n,t,e){const{newShape:r,keptDims:s}=rl(t),i=t.length,o=n&&3===i&&1===t[0],a=o?t.slice(1):r,l=!n&&i>1&&!Rt(t,e)&&r.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:t,keptDims:s}}function qd(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function Kd(n,t){return t.map(e=>n[e]).join(", ")}function JU(n,t,e){const r={},s={},i={},o=[];let a,l,c,u=null,d=null;d=n.getUniformLocation(e,"NAN",!1),1===G().getNumber("WEBGL_VERSION")&&(u=n.getUniformLocation(e,"INFINITY",!1));const h=!1;for(let f=0;f<t.variableNames.length;f++){const p=t.variableNames[f];r[p]=n.getUniformLocation(e,p,h),r[`offset${p}`]=n.getUniformLocation(e,`offset${p}`,h),t.enableShapeUniforms&&(s[`${p}Shape`]=n.getUniformLocation(e,`${p}Shape`,h),i[`${p}TexShape`]=n.getUniformLocation(e,`${p}TexShape`,h))}return t.enableShapeUniforms&&(a=n.getUniformLocation(e,"outShape",h),c=n.getUniformLocation(e,"outShapeStrides",h),l=n.getUniformLocation(e,"outTexShape",h)),t.customUniforms&&t.customUniforms.forEach((f,p)=>{o[p]=n.getUniformLocation(e,f.name,h)}),{uniformLocations:r,customUniformLocations:o,infLoc:u,nanLoc:d,inShapesLocations:s,inTexShapesLocations:i,outShapeLocation:a,outShapeStridesLocation:c,outTexShapeLocation:l}}function e4(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,r)=>{const s=e.logicalShape,i=t[r],o=i.shape;if(!Rt(s,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${o} must match`);if(e.isUniform&&i.isUniform)return;const a=e.texShape,l=i.isUniform?null:i.texData.texShape;if(!Rt(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function hs(n){return G().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class Z0e{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=zd.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=ds();this.outputShape=t,this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Tv(["r","c","d"],t):Vc(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class Q0e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=zd.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=ds();this.outputShape=t,this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Tv(["r","c","d"],t):Vc(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class J0e{constructor(t){this.variableNames=["A"],this.outTexUsage=qs.DOWNLOAD;const e=ds();this.outputShape=t,this.userCode=`\n      ${XU}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class ewe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=qs.DOWNLOAD;const e=ds();this.outputShape=t,this.userCode=`\n      ${XU}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const twe={R:0,G:1,B:2,A:3};class t4{constructor(t,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=ds();this.outputShape=t,this.enableShapeUniforms=hs(this.outputShape.length);let i="result";e&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<r.length;a++)o+=`\n          if(offset == ${a}) {\n            result = values[${twe[r[a]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":kT(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${r.length});\n\n        flatIndex = idiv(flatIndex, ${r.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${s.texture2D}(A, uv);\n          ${o}\n        }\n        ${s.output} = vec4(${i}, 0., 0., 0.);\n      }\n    `}}class nwe{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=ds();this.outputShape=t,this.enableShapeUniforms=hs(this.outputShape.length);let s="",i="result";e&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=2*o+a;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${a};\n          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${o};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${r.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${l}] = values[0];\n            } else if (offset == 1) {\n              result[${l}] = values[1];\n            } else if (offset == 2) {\n              result[${l}] = values[2];\n            } else {\n              result[${l}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":kT(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${r.output} = ${i};\n        }\n    `}}function ym(n,t,e,r,s,i){!function Xxe(n,t){const e=G().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0)throw new Error(`Requested texture size [${n}x${t}] is invalid.`);if(n>e||t>e)throw new Error(`Requested texture size [${n}x${t}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(t,e);const o=function Kxe(n){return Fa(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}(n),a=n.TEXTURE_2D;return ye(n,()=>n.bindTexture(a,o)),ye(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),ye(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),ye(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),ye(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),1===G().getNumber("WEBGL_VERSION")?ye(n,()=>n.texImage2D(a,0,r,t,e,0,s,i,null)):ye(n,()=>n.texStorage2D(a,1,r,t,e)),ye(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[e,t]}}function n4(n){return n.internalFormatFloat}function r4(n){return n.internalFormatHalfFloat}function s4(n){return n.downloadTextureFormat}function o4(n){return n.internalFormatPackedFloat}function a4(n){return n.internalFormatPackedHalfFloat}class RT{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=G().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function Axe(n,t){Nl[n]=t}(e,t)):this.gl=Co(e),t=this.gl,2===G().getNumber("WEBGL_VERSION")){const i=t;this.createVertexArray=()=>ye(i,()=>i.createVertexArray()),this.bindVertexArray=o=>ye(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>ye(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>ye(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(null!=t){const i=t.getExtension("OES_vertex_array_object");if(null==i)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ye(t,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>ye(t,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>ye(t,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>ye(t,()=>t.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===G().getNumber("WEBGL_VERSION")){const o="OES_texture_half_float";if(this.textureFloatExtension=xv(this.gl,"OES_texture_float"),Xi(this.gl,o))this.textureHalfFloatExtension=xv(this.gl,o);else if(G().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Xi(this.gl,s))this.colorBufferHalfFloatExtension=xv(this.gl,s);else if(G().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Xi(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!Xi(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=function swe(n){return function Gxe(n,t){const e=Fa(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ye(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),ye(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function iwe(n){return function qxe(n,t){const e=Fa(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ye(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),ye(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function Yxe(n){return Fa(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=IT(this.gl,this.textureHalfFloatExtension)}get debug(){return G().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;ye(t,()=>t.finish()),ye(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),ye(t,()=>t.deleteFramebuffer(this.framebuffer)),ye(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),ye(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),ye(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function owe(n,t,e,r){const[s,i]=mm(t,e);return ym(n,s,i,n4(r),r.textureFormatFloat,n.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function awe(n,t,e,r){const[s,i]=mm(t,e);return ym(n,s,i,r4(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function lwe(n,t,e,r){const[s,i]=mm(t,e);return ym(n,s,i,s4(r),n.RGBA,n.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function fwe(n,t,e){ye(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?2===G().getNumber("WEBGL_VERSION")?ye(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):ye(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):2===G().getNumber("WEBGL_VERSION")?ye(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):ye(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),ye(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,r,s){this.throwIfDisposed(),function hwe(n,t,e,r,s,i){let o,a,l;ye(n,()=>n.bindTexture(n.TEXTURE_2D,t)),s instanceof Uint8Array?(o=new Uint8Array(e*r*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(e*r*4),a=n.FLOAT,l=i.internalFormatPackedFloat),o.set(s),2===G().getNumber("WEBGL_VERSION")?ye(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,r,n.RGBA,a,o)):ye(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,e,r,0,n.RGBA,a,o)),ye(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function uwe(n,t,e,r){const[s,i]=Ud(t,e);return ym(n,s,i,a4(r),n.RGBA,r.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function cwe(n,t,e,r){const[s,i]=Ud(t,e);return ym(n,s,i,o4(r),n.RGBA,n.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(GU(this.gl,this.framebuffer),this.outputTexture=null),ye(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function gwe(n,t,e,r){const[s,i]=mm(t,e),a=new Uint8Array(function Fxe(n,t){return n*t}(t*e,4));return ye(n,()=>n.readPixels(0,0,s,i,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,r,s,i,o){return function ywe(n,t,e,r,s,i,o,a){const l=n,c=new Float32Array(function Oxe(n,t){const[e,r]=Ud(n,t);return e*r*4}(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}(this.gl,t,0,0,0,i,o)}downloadFloat32MatrixFromBuffer(t,e){return function mwe(n,t,e){const r=n,s=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,t,e)}createBufferFromTexture(t,e,r){this.bindTextureToFrameBuffer(t);const s=function pwe(n,t,e,r){const s=n.createBuffer();ye(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const a=16*t*e;return ye(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),ye(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),ye(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}(this.gl,e,r);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,r;if(G().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,i=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{const o=s.clientWaitSync(i,0,0);return o===s.ALREADY_SIGNALED||o===s.CONDITION_SATISFIED},e=i}else G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(t,e,r){return this.downloadMatrixDriver(t,()=>function bwe(n,t,e){const r=new Float32Array(t*e*4);return ye(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,r)),r}(this.gl,e,r))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function rwe(n){const t=ds();return function zxe(n,t){const e=Fa(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ye(n,()=>n.shaderSource(e,t)),ye(n,()=>n.compileShader(e)),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(n,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const r=function Wxe(n){return Fa(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}(e);let s;return ye(e,()=>e.attachShader(r,this.vertexShader)),ye(e,()=>e.attachShader(r,t)),function jxe(n,t){if(ye(n,()=>n.linkProgram(t)),!G().get("ENGINE_COMPILE_ONLY")&&!1===n.getProgramParameter(t,n.LINK_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(e,r),s=Object.assign(r,{vao:this.createVertexArray()}),this.bindVertexArray(s.vao),ye(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(function dwe(n,t,e){return ye(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),jU(n,t,"clipSpacePos",e,3,20,0)&&jU(n,t,"uv",e,2,20,12)}(e,s,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&ET(e,s),this.setProgram(s),s}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(ye(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&(this.bindVertexArray(this.program.vao),this.debug&&ET(this.gl,this.program)),ye(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,r=!0){return this.throwIfDisposed(),r?function Qxe(n,t,e){return Fa(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}(this.gl,t,e):function Jxe(n,t,e){return n.getUniformLocation(t,e)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),ye(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),e0e(this.gl,t,e,r)}setOutputMatrixTexture(t,e,r){this.setOutputMatrixTextureDriver(t,r,e)}setOutputPackedMatrixTexture(t,e,r){this.throwIfDisposed();const[s,i]=Ud(e,r);this.setOutputMatrixTextureDriver(t,s,i)}setOutputMatrixWriteRegion(t,e,r,s){this.setOutputMatrixWriteRegionDriver(r,t,s,e)}setOutputPackedMatrixWriteRegion(t,e,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&ET(this.gl,this.program),wv(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ye(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ye(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=xv(this.gl,2===G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,i),i}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();return void e.endQuery(r.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return ee(function*(){return yield VP(()=>e.disposed||e.isQueryAvailable(t,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function _we(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in G().platform&&(r=G().platform.setTimeoutCustom.bind(G().platform)),VP(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),DT(this.gl,t,this.framebuffer),this.debug&&wv(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(DT(this.gl,this.outputTexture,this.framebuffer),this.debug&&wv(this.gl)):GU(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,e,r){this.throwIfDisposed();const s=this.gl;DT(s,t,this.framebuffer),this.debug&&wv(s),this.outputTexture=t,ye(s,()=>s.viewport(0,0,e,r)),ye(s,()=>s.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(t,e,r,s){this.throwIfDisposed(),ye(this.gl,()=>this.gl.scissor(t,e,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:vwe,bincountImpl:l4,bincountReduceImpl:xwe,castImpl:wwe,ceilImpl:Cwe,concatImpl:Swe,equalImpl:Iwe,expImpl:Ewe,expm1Impl:Dwe,floorImpl:Twe,gatherNdImpl:kwe,gatherV2Impl:Nwe,greaterImpl:Awe,greaterEqualImpl:Rwe,lessImpl:Mwe,lessEqualImpl:Fwe,linSpaceImpl:Owe,logImpl:$we,maxImpl:Pwe,maximumImpl:Lwe,minimumImpl:Bwe,multiplyImpl:Vwe,negImpl:zwe,notEqualImpl:Uwe,prodImpl:Hwe,raggedGatherImpl:Wwe,raggedRangeImpl:jwe,raggedTensorToTensorImpl:Gwe,rangeImpl:qwe,rsqrtImpl:Kwe,scatterImpl:Xwe,sigmoidImpl:Ywe,simpleAbsImpl:c4,sliceImpl:Zwe,sparseFillEmptyRowsImpl:Qwe,sparseReshapeImpl:Jwe,sparseSegmentReductionImpl:u4,sqrtImpl:eCe,stridedSliceImpl:tCe,stringNGramsImpl:nCe,stringSplitImpl:rCe,stringToHashBucketFastImpl:sCe,subImpl:iCe,tileImpl:oCe,topKImpl:aCe,transposeImpl:MT,uniqueImpl:lCe}=k;function d4(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function fs(n,t){return 1===t?[n]:d4(n,t)}class uCe{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=hs(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=fs("rc",this.rank),r=dn(this.rank),s=this.getOutOfBoundsCondition(e),i=this.getSetup(e),o=this.getOutput(e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let i=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${t[t.length-1-o]},`+i;e.push(i)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class h4{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=hs(this.outputShape.length);let r="";for(let s=0;s<4;s++){let i="thisRC = rc;";s%2==1&&(i+="thisRC.z += 1;"),s>1&&(i+="thisRC.y += 1;"),r+=`\n        ${i}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}this.userCode=`\n      ${function dCe(n,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?function d0e(n,t,e="index"){const s=function u0e(n,t){const e=n.length,r=n.map(i=>`${t}[${i}]`),s=new Array(e-1);s[e-2]=r[e-1];for(let i=e-3;i>=0;--i)s[i]=`(${s[i+1]} * ${r[i+1]})`;return s}(n.map((i,o)=>o),t);return s.map((i,o)=>`int ${n[o]} = ${e} / ${s[o]}; ${o===s.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${s[o]}`:`index -= ${n[o]} * ${s[o]}`};`).join("")}(["r","c","d"],"inputShape"):Vc(["r","c","d"],n)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":kT(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${r}\n\n        setOutput(result);\n      }\n    `}}class hCe{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,r){const s=p4(e,r),i=m4(t,s,r);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=f4(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].shift();return this.usedTextures[i].push(l),l}let a;return s===Rr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===Rr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===Rr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===Rr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===Rr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(t,e,r,s){if(null==this.freeTextures)return;const i=p4(r,s),o=m4(e,i,s);o in this.freeTextures||(this.freeTextures[o]=[]);const a=f4(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=G().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],u=c.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(u,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function f4(n,t,e,r,s){const i=function pCe(n,t){switch(n){case Rr.PACKED_2X2_FLOAT32:return o4(t);case Rr.PACKED_2X2_FLOAT16:return a4(t);case Rr.UNPACKED_FLOAT32:return n4(t);case Rr.UNPACKED_FLOAT16:return r4(t);case Rr.PACKED_4X1_UNSIGNED_BYTE:return s4(t);default:throw new Error(`Unknown physical texture type ${n}`)}}(t,r);let o;if(s){const[l,c]=Ud(n[0],n[1]);o=l*c}else{const[l,c]=mm(n[0],n[1]);o=l*c}const a=function fCe(n,t){if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(e,i);return o*a}function p4(n,t){if(n===qs.UPLOAD)return Rr.PACKED_2X2_FLOAT32;if(n===qs.RENDER||null==n)return function mCe(n){return G().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Rr.PACKED_2X2_FLOAT32:Rr.UNPACKED_FLOAT32:n?Rr.PACKED_2X2_FLOAT16:Rr.UNPACKED_FLOAT16}(t);if(n===qs.DOWNLOAD||n===qs.PIXELS)return Rr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function m4(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class Yo{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const g4="return abs(x);",Al="return x;";class Rl{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class ECe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=hs(this.outputShape.length);const e=t.length,r=fs("rc",e),s=dn(e),i=function cCe(n,t){if(1===n)return"rc";let e="";for(let r=0;r<n;r++)e+=t[r],r<n-1&&(e+=",");return e}(e,r),o=r.slice(-2),a=e<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${i});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const DCe=gD,Nv={},ACe=G().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let FCe=(()=>{class n extends OS{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!G().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=e){if(e instanceof RT)r=e;else{const s=Co(G().getNumber("WEBGL_VERSION"),e);r=new RT(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Co(G().getNumber("WEBGL_VERSION"));r=new RT(s),this.binaryCache=function NCe(n){return n in Nv||(Nv[n]={}),Nv[n]}(G().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new hCe(this.gpgpu),this.numMBBeforeWarning=function MCe(){return null==G().global.screen?1024:G().global.screen.height*G().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new LP(this,Lo())}nextDataId(){return n.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,s,i,o,a){const l=this.makeTensorInfo(r,s),c=this.texData.get(l.dataId);c.isPacked=!1,c.texture={texture:e,texShape:[i,o]},c.texShape=[i,o];const u=Cv(r),d=new t4(u,!1,a),h=this.runWebGLProgram(d,[l],s,[[i,o]]);return h.shape=r,c.texture=null,this.disposeIntermediateTensorInfo(l),h.dataId}write(e,r,s){if((G().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||G().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===s&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:r,dtype:s,values:e,usage:qs.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,r,s,i,o){if(G().getBool("DEBUG")&&this.checkNumericalProblems(r),"complex64"===i)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:i,values:r,usage:qs.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const r=this.texData.get(e),{values:s,dtype:i,complexTensorInfos:o,slice:a,shape:l,isPacked:c}=r;if(null!=a){let f;f=c?new Rl(l,Al):new Yo(l,Al);const p=this.runWebGLProgram(f,[{dataId:e,shape:l,dtype:i}],i),m=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),m}if(null!=s)return this.convertAndCacheOnCPU(e);if("string"===i)return s;const u=null!=this.activeTimers;let d,h;return u&&(d=Cs()),h="complex64"===i?ka(this.readSync(o.real.dataId),this.readSync(o.imag.dataId)):this.getValuesFromTexture(e),u&&(this.downloadWaitMs+=Cs()-d),this.convertAndCacheOnCPU(e,h)}read(e){var r=this;return ee(function*(){if(r.pendingRead.has(e)){const g=r.pendingRead.get(e);return new Promise(y=>g.push(y))}const s=r.texData.get(e),{values:i,shape:o,slice:a,dtype:l,complexTensorInfos:c,isPacked:u}=s;if(null!=a){let g;g=u?new Rl(o,Al):new Yo(o,Al);const y=r.runWebGLProgram(g,[{dataId:e,shape:o,dtype:l}],l),b=r.read(y.dataId);return r.disposeIntermediateTensorInfo(y),b}if(null!=i)return r.convertAndCacheOnCPU(e);if(G().getBool("DEBUG")&&!G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===G().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h,f,d=null;if("complex64"!==l&&G().get("WEBGL_BUFFER_SUPPORTED")){h=r.decode(e);const g=r.texData.get(h.dataId);d=r.gpgpu.createBufferFromTexture(g.texture.texture,...vv(o))}if(r.pendingRead.set(e,[]),"complex64"!==l&&(yield r.gpgpu.createAndWaitForFence()),"complex64"===l){const g=yield Promise.all([r.read(c.real.dataId),r.read(c.imag.dataId)]);f=ka(g[0],g[1])}else if(null==d)f=r.getValuesFromTexture(e);else{const g=X(o);f=r.gpgpu.downloadFloat32MatrixFromBuffer(d,g)}if(null!=h&&r.disposeIntermediateTensorInfo(h),null!=d){const g=r.gpgpu.gl;ye(g,()=>g.deleteBuffer(d))}const p=r.convertAndCacheOnCPU(e,f),m=r.pendingRead.get(e);return r.pendingRead.delete(e),m.forEach(g=>g(p)),r.pendingDisposal.has(e)&&(r.pendingDisposal.delete(e),r.disposeData(e)&&Lo().removeDataId(e,r),r.pendingDeletes--),p})()}readToGPU(e,r={}){const s=this.texData.get(e),{values:i,shape:o,slice:a,dtype:l,isPacked:c,texture:u}=s;if("complex64"===l)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let p;p=c?new Rl(o,Al):new Yo(o,Al);const m=this.runWebGLProgram(p,[{dataId:e,shape:o,dtype:l}],l),g=this.readToGPU(m,r);return this.disposeIntermediateTensorInfo(m),g}if(null==u)throw null!=i?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,r.customTexShape),h=Lo().makeTensorFromTensorInfo(d),f=this.texData.get(d.dataId);return Object.assign({tensorRef:h},f.texture)}bufferSync(e){const r=this.readSync(e.dataId);if("string"===e.dtype)try{const s=r.map(i=>al(i));return lt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return lt(e.shape,e.dtype,r)}checkNumericalProblems(e){if(null!=e)for(let r=0;r<e.length;r++){const s=e[r];if(!Bxe(s))throw G().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:r,dtype:s,isPacked:i}=this.texData.get(e),o=X(r);if(G().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),p=this.texData.get(f.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...vv(r)).subarray(0,o);return this.disposeIntermediateTensorInfo(f),m}const a=G().getBool("WEBGL_PACK")&&!0===i,l=a?Cv(r):r,c=a?new ewe(l):new J0e(l),u=this.runWebGLProgram(c,[{shape:l,dtype:s,dataId:e}],"float32"),d=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var r=this;const s=this.activeTimers,i=[];let o=!1;null==this.programTimersStack?(this.programTimersStack=i,o=!0):this.activeTimers.push(i),this.activeTimers=i,e();const a=sd(this.activeTimers.map(u=>u.query)).filter(u=>null!=u),l=sd(this.activeTimers.map(u=>u.name)).filter(u=>null!=u);this.activeTimers=s,o&&(this.programTimersStack=null);const c={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return ee(function*(){if(G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=yield Promise.all(a);c.kernelMs=function Wte(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}(u),c.getExtraProfileInfo=()=>u.map((d,h)=>({name:l[h],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else c.kernelMs={error:"WebGL query timers are not supported in this environment."};return r.uploadWaitMs=0,r.downloadWaitMs=0,c})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Cs(),endMs:null}}endTimer(e){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Cs(),e)}getQueryTime(e){var r=this;return ee(function*(){return G().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?r.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return null!=s&&(this.disposeData(s.real.dataId,r),this.disposeData(s.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:r,dtype:s,texShape:i,usage:o,isPacked:a,slice:l}=this.texData.get(e),c=l&&l.origDataId||e,u=this.dataRefCount.get(c);u>1?this.dataRefCount.set(c,u-1):(this.dataRefCount.delete(c),null!=r&&(this.numBytesInGPU-=this.computeBytes(i,s),this.textureManager.releaseTexture(r,i,o,a)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=ACe){return G().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>null==this.texData.get(s.dataId).texture&&X(s.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){ui("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const r=e.dataSync();return DCe(e.shape,r)}packedUnaryOp(e,r,s){const i=new Rl(e.shape,r),o=this.compileAndRun(i,[e],s);return Lo().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const i=c4(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(G().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,g4,e.dtype);const r=new Yo(e.shape,g4),s=this.compileAndRun(r,[e]);return Lo().makeTensorFromTensorInfo(s)}makeTensorInfo(e,r,s){let i;if("string"===r&&null!=s&&s.length>0&&Af(s[0])){const o=s.map(a=>ol(a));i=this.write(o,e,r)}else i=this.write(s,e,r);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:r}}makeOutput(e,r,s){return Lo().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,s),this)}unpackTensor(e){const r=new ECe(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){const r=new uCe(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){const s=[Hd(e.shape),...Wd(e.shape)],i={dtype:e.dtype,shape:s,dataId:e.dataId},o=[Hd(r),...Wd(r)],a=new h4(o,s),u=this.runWebGLProgram(a,[i],e.dtype,[s],!0);return{dataId:u.dataId,shape:r,dtype:u.dtype}}decode(e,r){const s=this.texData.get(e),{isPacked:i,shape:o,dtype:a}=s;null!=r&&S(X(o)<=r[0]*r[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const l=Cv(o);let c;c=i?new Q0e(l):new Z0e(l);const d=[r??vv(l)];return{dtype:a,shape:o,dataId:this.runWebGLProgram(c,[{shape:l,dtype:a,dataId:e}],a,d,!0,r).dataId}}runWebGLProgram(e,r,s,i,o=!1,a){const l=this.makeTensorInfo(e.outputShape,s),c=this.texData.get(l.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===zd.DENSE){const b=a??vv(e.outputShape);c.texShape=b.map(_=>2*_)}if(null!=e.outTexUsage&&(c.usage=e.outTexUsage),0===X(l.shape))return c.values=Sr(l.dtype,0),l;const u=[],d=r.map(b=>{if("complex64"===b.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let _=this.texData.get(b.dataId);if(null==_.texture){if(!e.packedInputs&&X(b.shape)<=G().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:_.values};e.packedInputs&&(_.isPacked=!0,_.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!_.isPacked!=!!e.packedInputs)b=_.isPacked?this.unpackTensor(b):this.packTensor(b),u.push(b),_=this.texData.get(b.dataId);else if(_.isPacked&&!Iv(_.shape,b.shape)){const v=b,w=b.shape;b.shape=_.shape,b=this.packedReshape(b,w),u.push(b),_=this.texData.get(b.dataId),v.shape=w}return{shape:b.shape,texData:_,isUniform:!1}});this.uploadToGPU(l.dataId);const h={shape:l.shape,texData:c,isUniform:!1},f=function Y0e(n,t,e){let r="";t.concat(e).forEach(o=>{const a=null!=o.texData&&null!=o.texData.slice&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:d}=AT(n.packedInputs,o.shape,l);let h="",f="",p="";if(1===u.length&&n.packedInputs){const w=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${w[0]>1}_${w[1]>1}`}else if(2!==u.length||n.packedInputs){if(u.length>2&&!n.packedInputs){const w=Le(u);p=`${w[0]===l[1]}_${w[w.length-1]===l[1]}`}}else f=`${u[0]>1}_${u[1]>1}`;const m=o.shape.length,g=2===u.length&&Rt(o.shape,l),y=1===X(o.shape),b=yd(o.shape,e.shape),_=!n.packedInputs&&m===e.shape.length&&Rt(l,e.texData.texShape);r+=`${m}_${_}_${c?d:""}_${u.length}_${y}_${b}_${g}_${h}_${f}_${p}_${n.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`}_${a}`}else r+=`${o.shape}_${o.isUniform?"uniform":o.texData.texShape}_${a}`});let i=n.constructor.name;return i+="_"+r+"_"+n.userCode+`${G().getNumber("WEBGL_VERSION")}`,i}(e,d,h),p=this.getAndSaveBinary(f,()=>function K0e(n,t,e,r){const s=e.map((u,d)=>{const h={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:!u.isUniform&&u.texData.isPacked,flatOffset:null};return null!=u.texData&&null!=u.texData.slice&&u.texData.slice.flatOffset>0&&(h.flatOffset=u.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:h}}),i=s.map(u=>u.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=h0e(s,o,t),l=function Uxe(n,t){const e=Fa(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ye(n,()=>n.shaderSource(e,t)),ye(n,()=>n.compileShader(e)),G().get("ENGINE_COMPILE_ONLY"))return e;if(!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw WU(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(n.gl,a),c=n.createProgram(l);return G().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:i,outShapeInfo:o},JU(n,t,c))}(this.gpgpu,e,d,h)),m=null!=this.activeTimers;let g;m&&(g=this.startTimer()),G().get("ENGINE_COMPILE_ONLY")||function X0e(n,t,e,r,s){t.program.enableShapeUniforms||(e4(t.inShapeInfos,e),e4([t.outShapeInfo],[r]));const i=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(t.webGLProgram),1===G().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&n.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&n.gl.uniform1f(t.nanLoc,NaN),e.forEach((l,c)=>{const u=t.program.variableNames[c],d=t.uniformLocations[u],h=t.uniformLocations[`offset${u}`],f=t.inShapesLocations[`${u}Shape`],p=t.inTexShapesLocations[`${u}TexShape`];if(f){const{uniformShape:m}=AT(t.program.packedInputs,l.shape,l.texData.texShape);switch(m.length){case 1:n.gl.uniform1iv(f,new Int32Array(m));break;case 2:n.gl.uniform2iv(f,new Int32Array(m));break;case 3:n.gl.uniform3iv(f,new Int32Array(m));break;case 4:n.gl.uniform4iv(f,new Int32Array(m))}}if(p&&n.gl.uniform2i(p,l.texData.texShape[0],l.texData.texShape[1]),null!=d){if(l.isUniform){if(X(l.shape)<2)n.gl.uniform1f(d,l.uniformValues[0]);else{let m=l.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),n.gl.uniform1fv(d,m)}return}null!=l.texData.slice&&null!=h&&n.gl.uniform1i(h,l.texData.slice.flatOffset),n.setInputMatrixTexture(l.texData.texture.texture,d,c)}});const a=t.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const l=Le(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l))}}t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s&&t.program.customUniforms.forEach((l,c)=>{const u=t.customUniformLocations[c],d=s[c];if("float"===l.type)n.gl.uniform1fv(u,d);else if("vec2"===l.type)n.gl.uniform2fv(u,d);else if("vec3"===l.type)n.gl.uniform3fv(u,d);else if("vec4"===l.type)n.gl.uniform4fv(u,d);else if("int"===l.type)n.gl.uniform1iv(u,d);else if("ivec2"===l.type)n.gl.uniform2iv(u,d);else if("ivec3"===l.type)n.gl.uniform3iv(u,d);else{if("ivec4"!==l.type)throw Error(`uniform type ${l.type} is not supported yet.`);n.gl.uniform4iv(u,d)}}),n.executeProgram()}(this.gpgpu,p,d,h,i),u.forEach(b=>this.disposeIntermediateTensorInfo(b)),m&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const y=G().get("WEBGL_FLUSH_THRESHOLD");if(y>0){const b=Cs();b-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!G().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&!1===o){const b=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),b}return l}compileAndRun(e,r,s,i,o=!1){return this.runWebGLProgram(e,r,s=s||r[0].dtype,i,o)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(G().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=z(()=>{if(!G().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=G().getBool("DEBUG");G().set("DEBUG",!1);const r=this.abs(Be(1e-8)).dataSync()[0];if(G().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const r=this.texData.get(e),{shape:s,dtype:i,values:o,texture:a,usage:l,isPacked:c}=r;if(null!=a)return;const u=null!=this.activeTimers;let d;u&&(d=Cs());let h=r.texShape;if(null==h&&(h=function n0e(n,t=!1){let e=G().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=G().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&G().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),t&&(e*=2,r*=2,1===(n=n.map((a,l)=>l>=n.length-2?$S(n[l]):n[l])).length&&(n=[2,n[0]])),2!==n.length&&(n=rl(n).newShape);let s=X(n),i=null;n.length<=1&&s<=e?i=[1,s]:2===n.length&&n[0]<=e&&n[1]<=e?i=n:3===n.length&&n[0]*n[1]<=e&&n[2]<=e?i=[n[0]*n[1],n[2]]:3===n.length&&n[0]<=e&&n[1]*n[2]<=e?i=[n[0],n[1]*n[2]]:4===n.length&&n[0]*n[1]*n[2]<=e&&n[3]<=e?i=[n[0]*n[1]*n[2],n[3]]:4===n.length&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(i=[n[0],n[1]*n[2]*n[3]]);const o=null!=i&&Math.max(...i)>r&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(null==i||o)if(t){const a=Hd(n);let l=2,c=2;n.length&&([l,c]=Wd(n)),s=a*(l/2)*(c/2),i=PS(s).map(u=>2*u)}else i=PS(s);return i}(s,c),r.texShape=h),null!=o){const f=Cv(s);let p,m=h[1],g=h[0];const y=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(c||!y)&&([m,g]=Ud(h[0],h[1])),p=c?new nwe(f,y):new t4(f,y);const b=y?[g,m]:h,_=this.makeTensorInfo(b,i),v=this.texData.get(_.dataId);v.usage=y?qs.PIXELS:qs.UPLOAD,v.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(_.dataId),m,g,o);const E=this.runWebGLProgram(p,[_],i,[[g,m]],!0),D=this.texData.get(E.dataId);r.texShape=D.texShape,r.isPacked=D.isPacked,r.usage=D.usage,G().get("ENGINE_COMPILE_ONLY")?this.disposeData(E.dataId):(r.texture=D.texture,r.values=null,this.texData.delete(E.dataId)),this.disposeIntermediateTensorInfo(_),u&&(this.uploadWaitMs+=Cs()-d)}else{const f=this.acquireTexture(h,l,i,c);r.texture=f}}convertAndCacheOnCPU(e,r){const s=this.texData.get(e),{dtype:i}=s;return null!=r&&(s.values=function OCe(n,t){if("float32"===t||"complex64"===t)return n;if("int32"===t||"bool"===t){const e="int32"===t?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<e.length;++r)e[r]=Math.round(n[r]);return e}throw new Error(`Unknown dtype ${t}`)}(r,i)),s.values}acquireTexture(e,r,s,i){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,i)}computeBytes(e,r){return e[0]*e[1]*LS(r)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return ee(function*(){const r=[];if(e.gpgpu.parallelCompilationExtension){for(const[,s]of Object.entries(e.binaryCache))r.push(e.checkCompletionAsync_(s));return Promise.all(r)}for(const[,s]of Object.entries(e.binaryCache)){const i=new Promise(o=>{try{e.checkCompletion_(s),o(!0)}catch(a){throw a}});r.push(i)}return Promise.all(r)})()}checkCompletionAsync_(e){var r=this;return ee(function*(){return r.gpgpu.gl.getProgramParameter(e.webGLProgram,r.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?r.checkCompletion_(e):(yield tV(),r.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(WU(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:r,customUniformLocations:s,infLoc:i,nanLoc:o,inShapesLocations:a,inTexShapesLocations:l,outShapeLocation:c,outShapeStridesLocation:u,outTexShapeLocation:d}=JU(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=r,e.customUniformLocations=s,e.infLoc=i,e.nanLoc=o,e.inShapesLocations=a,e.inTexShapesLocations=l,e.outShapeLocation=c,e.outShapeStridesLocation=u,e.outTexShapeLocation=d}}createTensorFromTexture(e,r,s){const{texture:i,height:o,width:a,channels:l}=e,c=Lo().backend;if(!c.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=c.writeTexture(i,r,s,o,a,l);return Lo().makeTensorFromDataId(u,r,s,c)}}return n.nextDataId=0,n})();aL()&&jL("webgl",()=>new FCe,2);class Xd{constructor(t,e,r){this.variableNames=["A","B"],this.outputShape=tt(e,r),this.enableShapeUniforms=hs(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class _m{constructor(t,e,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=tt(e,r);const i=this.outputShape.length;this.enableShapeUniforms=hs(i);let o="";if(s)if(0===i||1===X(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(o=`\n          ${dn(i)} coords = getOutputCoords();\n        `,1===i)o+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const l=fs("coords",i);o+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${l[i-2]} + 1) >= outShape[${i} - 2];\n            bool nextColOutOfBounds =\n              (${l[i-1]} + 1) >= outShape[${i} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};\n            bool nextColOutOfBounds =\n              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${o}\n\n        setOutput(result);\n      }\n    `}}function Ks(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const LCe={kernelName:Jf,backendName:"webgl",kernelFunc:Ks};function Ml(n){const{inputs:t,backend:e}=n,{real:r,imag:s}=t,i=e.makeTensorInfo(r.shape,"complex64"),o=e.texData.get(i.dataId),a=Ks({inputs:{x:r},backend:e}),l=Ks({inputs:{x:s},backend:e});return o.complexTensorInfos={real:a,imag:l},i}const BCe={kernelName:ZS,backendName:"webgl",kernelFunc:Ml},y4="return (a < 0.) ? b * a : a;",b4="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",zCe={kernelName:ub,backendName:"webgl",kernelFunc:function VCe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{alpha:i}=r,o=e.makeTensorInfo([],"float32",il(i,"float32")),a=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new _m(b4,s.shape,o.shape):new Xd(y4,s.shape,o.shape),l=e.runWebGLProgram(a,[s,o],"float32");return e.disposeIntermediateTensorInfo(o),l}},_4="return (a < 0.) ? b * a : a;",v4="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",HCe={kernelName:kb,backendName:"webgl",kernelFunc:function UCe(n){const{inputs:t,backend:e}=n,{x:r,alpha:s}=t,i=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new _m(v4,r.shape,s.shape):new Xd(_4,r.shape,s.shape);return e.runWebGLProgram(i,[r,s],"float32")}};function Ot({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:r}){return({inputs:s,backend:i})=>{const{x:o}=s,a=i,l=r||o.dtype;if(a.shouldExecuteOnCPU([o])&&null!=e){const d=a.texData.get(o.dataId),h=e(d.values,l);return a.makeTensorInfo(o.shape,l,h)}let u;return u=G().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new Rl(o.shape,t):new Yo(o.shape,n),a.runWebGLProgram(u,[o],l)}}function Br({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(r&&"complex64"===l.dtype){const p=u.texData.get(l.dataId),m=u.texData.get(c.dataId),[g,y]=[[p.complexTensorInfos.real,m.complexTensorInfos.real],[p.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(_=>{const[v,w]=_,C={dataId:v.dataId,dtype:v.dtype,shape:l.shape},E={dataId:w.dataId,dtype:w.dtype,shape:c.shape},D=new Xd(n,l.shape,c.shape);return u.runWebGLProgram(D,[C,E],zs(v.dtype,w.dtype))}),b=Ml({inputs:{real:g,imag:y},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(y),b}const d=i||zs(l.dtype,c.dtype);if(("string"===l.dtype||"string"===c.dtype||u.shouldExecuteOnCPU([l,c]))&&null!=s){const p=u.texData.get(l.dataId).values,m=u.texData.get(c.dataId).values,g="string"===l.dtype?Nc(p):p,y="string"===l.dtype?Nc(m):m,[b,_]=s(l.shape,c.shape,g,y,d),v=u.makeTensorInfo(_,d);return u.texData.get(v.dataId).values=b,v}let f;return f=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new _m(t,l.shape,c.shape,e):new Xd(n,l.shape,c.shape),u.runWebGLProgram(f,[l,c],d)}}function vm(n,t=!1){if("linear"===n)return"return x;";if("relu"===n)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===n)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===n)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===n)return t?v4:_4;if("leakyrelu"===n)return t?b4:y4;if("sigmoid"===n)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class x4{constructor(t,e,r,s=!1,i=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=hs(this.outputShape.length);const d=Math.ceil((s?t[1]:t[2])/2),h=s?"i * 2, rc.y":"rc.y, i * 2",f=i?"rc.z, i * 2":"i * 2, rc.z",p=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";a&&(g=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:c?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,y="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let _="rc.x",v="rc.x";t[0]<e[0]?_=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(v=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`\n      ${g}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${d}; i++) {\n          int batchA = ${_};\n          int batchB = ${v};\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${f});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${m[0]});\n          result += (${p[1]} * ${m[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${y}\n\n        setOutput(result);\n      }\n    `}}class C4{constructor(t,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=tt(e,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const S4="return a * b;";function OT(n){const{inputs:t,backend:e}=n,{a:r,b:s}=t,i=zs(r.dtype,s.dtype);if("complex64"===r.dtype){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),c=new C4("return areal * breal - aimag * bimag;",r.shape,s.shape),u=new C4("return areal * bimag + aimag * breal;",r.shape,s.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],h=e.runWebGLProgram(c,d,"float32"),f=e.runWebGLProgram(u,d,"float32"),p=Ml({inputs:{real:h,imag:f},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}if(e.shouldExecuteOnCPU([r,s])){const a=e.texData.get(r.dataId),l=e.texData.get(s.dataId),[c,u]=Vwe(r.shape,s.shape,a.values,l.values,i),d=e.makeTensorInfo(u,i);return e.texData.get(d.dataId).values=c,d}let o;return o=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new _m(S4,r.shape,s.shape):new Xd(S4,r.shape,s.shape),e.runWebGLProgram(o,[r,s],i)}const WCe={kernelName:lp,backendName:"webgl",kernelFunc:OT};function xe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{shape:i}=r,o=e,a=X(s.shape),l=zP(i,a),c=X(l);S(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const u=o.texData.get(s.dataId);return!u.isPacked||Iv(s.shape,l)||null!==u.texture&&Iv(u.shape,l)?(o.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function jCe(n,t,e){const r=[Hd(n.shape),...Wd(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},i=[Hd(t),...Wd(t)],o=new h4(i,r),c=e.runWebGLProgram(o,[s],n.dtype,[r],!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(s,l,o)}const GCe={kernelName:Ab,backendName:"webgl",kernelFunc:xe};class I4{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=t;this.outputShape=[s,o];const a=4*Math.floor(r/4),l=r%4;let c="sumValue += dot(values, ones);";if(null!=e){const d=1/e;c=`sumValue += dot(values * ${id(d)?d.toPrecision(2):d}, ones);`}let u="";i%r>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${c}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${c}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}class qCe{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=t;this.outputShape=[s,o];let a="0.0",l="";"prod"===e?a="1.0":"min"===e?(a="1.0 / 1e-20",l="min"):"max"===e&&(a="-1.0 / 1e-20",l="max");let c=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?c="sumValue":"prod"===e?c="prodValue":"all"===e?c="allValue":"any"===e&&(c="anyValue");const u=4*Math.floor(r/4),d=r%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${l}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${l}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,f="vec4";"all"===e?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",f="bvec4"):"any"===e&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",f="bvec4");let p="";i%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${c});\n      }\n    `}}function Uc(n,t,e,r){const s=function KCe(n){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const e=t.length?t[t.length-1].outSize:n[1],r=F_(e);t.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return t}(n.shape);let i=n;for(let o=0;o<s.length;o++){const{inSize:a,windowSize:l,outSize:c}=s[o];let u,d;u="mean"===e?0===o?new I4({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new I4({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):new qCe({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},e),d=i,i=r.runWebGLProgram(u,[i],t),d.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(d)}return i}class XCe{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let o=0;o<r.length;o++)r[o]=t[e[o]];this.outputShape=r,this.rank=r.length;const s=dn(this.rank),i=function YCe(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<n.length;s++)r[n[s]]=e[s];return r.join()}(e);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${i}));\n    }\n    `}}class ZCe{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(t.length);for(let u=0;u<r.length;u++)r[u]=t[e[u]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=dn(this.rank),i=d4("rc",this.rank),o=new Array(this.rank);for(let u=0;u<e.length;u++)o[e[u]]=i[u];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${l}) {\n        result[1] = ${c};\n      }\n      --${i[this.rank-1]};\n      if(++${i[this.rank-2]} < ${r[this.rank-2]}) {\n        result[2] = ${c};\n        if(${l}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Av(n,t,e){const r=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ZCe(n.shape,t):new XCe(n.shape,t);return e.runWebGLProgram(r,[n],n.dtype)}function Rv(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r;return function QCe(n,t,e,r){const i=n.shape.length,o=mt(t,n.shape);let a=o;const l=An(a,i),c=null!=l;let u=n;c&&(u=Av(n,l,r),a=Wn(a.length,i)),Lr("sum",a,i);const[d,h]=kr(u.shape,a);let f=d;e&&(f=Hn(d,o));const p=X(h),y=xe({inputs:{x:u},attrs:{shape:[X(n.shape)/p,p]},backend:r}),_=Uc(y,rE(n.dtype),"sum",r),v=xe({inputs:{x:_},attrs:{shape:f},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(_),c&&r.disposeIntermediateTensorInfo(u),v}(s,i,o,e)}const JCe={kernelName:Pb,backendName:"webgl",kernelFunc:Rv};function ps(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{perm:i}=r,o=e,l=new Array(s.shape.length);for(let u=0;u<l.length;u++)l[u]=s.shape[i[u]];let c;if(o.shouldExecuteOnCPU([s])){const d=o.texData.get(s.dataId).values,h=MT(d,s.shape,s.dtype,i,l);c=o.makeTensorInfo(l,s.dtype),o.texData.get(c.dataId).values=h}else c=Av(s,i,o);return c}const eSe={kernelName:ud,backendName:"webgl",kernelFunc:ps};function Mv({a:n,b:t,transposeA:e,transposeB:r,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=t.shape.length,d=e?n.shape[c-2]:n.shape[c-1],h=r?t.shape[u-1]:t.shape[u-2],f=e?n.shape[c-1]:n.shape[c-2],p=r?t.shape[u-2]:t.shape[u-1],m=n.shape.slice(0,-2),g=t.shape.slice(0,-2),y=X(m),b=X(g),v=tt(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,p]);S(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${r} must match.`);const w=e?[y,d,f]:[y,f,d],C=r?[b,p,h]:[b,h,p],E=xe({inputs:{x:n},backend:s,attrs:{shape:w}}),D=xe({inputs:{x:t},backend:s,attrs:{shape:C}}),T=[E,D],N=Math.max(y,b),P=e?E.shape[1]:E.shape[2],U=null!=i,j=null!=o,q="leakyrelu"===l,K=null!=l?vm(l,!0):null;let V;if((1===f||1===p)&&P>1e3&&!1===(U||j||q||null!=K)){let W=E,ne=D;e&&(W=ps({inputs:{x:E},backend:s,attrs:{perm:[0,2,1]}}),T.push(W)),r&&(ne=ps({inputs:{x:D},backend:s,attrs:{perm:[0,2,1]}}),T.push(ne));const de=1===p;let ue=W;1!==p&&(ue=xe({inputs:{x:W},backend:s,attrs:{shape:[N,P,1]}}),T.push(ue));const he=1===p?2:1;let ge=ne;de&&(ge=xe({inputs:{x:ne},backend:s,attrs:{shape:[N,1,P]}}),T.push(ge));const Ie=OT({inputs:{a:ue,b:ge},backend:s});V=Rv({inputs:{x:Ie},backend:s,attrs:{axis:he,keepDims:!0}}),T.push(Ie)}else{const W=zs(n.dtype,t.dtype),ne=new x4(w,C,[N,f,p],e,r,U,K,j,q),ie=[E,D];if(null!=i&&ie.push(i),j&&ie.push(o),q){const de=s.makeTensorInfo([],"float32",il(a,"float32"));ie.push(de),T.push(de)}V=s.runWebGLProgram(ne,ie,W)}const L=xe({inputs:{x:V},backend:s,attrs:{shape:v}});T.push(V);for(const W of T)s.disposeIntermediateTensorInfo(W);return L}const nSe={kernelName:Wb,backendName:"webgl",kernelFunc:function tSe(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=t,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:d}=r;return Mv({a:s,b:i,transposeA:l,transposeB:c,backend:e,bias:o,preluActivationWeights:a,leakyreluAlpha:d,activation:u})}},D4="return abs(x);",sSe={kernelName:Hy,backendName:"webgl",kernelFunc:function rSe(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const i=e.texData.get(r.dataId),o=c4(i.values);return e.makeTensorInfo(r.shape,r.dtype,o)}let s;return s=G().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Rl(r.shape,D4):new Yo(r.shape,D4),e.runWebGLProgram(s,[r],r.dtype)}},oSe=Ot({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),aSe={kernelName:Mf,backendName:"webgl",kernelFunc:oSe},cSe=Ot({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),uSe={kernelName:Ff,backendName:"webgl",kernelFunc:cSe},T4="return a + b;",dSe=Br({opSnippet:T4,packedOpSnippet:T4,supportsComplex:!0,cpuKernelImpl:vwe}),hSe={kernelName:cd,backendName:"webgl",kernelFunc:dSe};class fSe{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`float v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class pSe{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`vec4 v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`\n      void main() {\n        ${r.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const mSe={kernelName:Wy,backendName:"webgl",kernelFunc:function Fv(n){const{inputs:t,backend:e}=n,r=t;if(1===r.length)return Ks({inputs:{x:r[0]},backend:e});if(r.length>G().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),c=Fv({inputs:r.slice(0,l),backend:e}),u=Fv({inputs:r.slice(l),backend:e});return Fv({inputs:[c,u],backend:e})}const s=r.map(l=>l.dtype).reduce((l,c)=>zs(l,c)),i=r.map(l=>l.shape),a=G().getBool("WEBGL_PACK")?new pSe(r[0].shape,i):new fSe(r[0].shape,i);return e.runWebGLProgram(a,r,s)}},ySe={kernelName:"All",backendName:"webgl",kernelFunc:function gSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,l=mt(i,s.shape);let c=l;const u=An(c,a);let d=s;null!=u&&(d=ps({inputs:{x:s},backend:e,attrs:{perm:u}}),c=Wn(c.length,a)),Lr("all",c,a);const[h,f]=kr(d.shape,c),m=xe({inputs:{x:d},backend:e,attrs:{shape:[-1,X(f)]}}),g=Uc(m,m.dtype,"all",e);let y;return y=xe(o?{inputs:{x:g},backend:e,attrs:{shape:Hn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=u&&e.disposeIntermediateTensorInfo(d),y}},_Se={kernelName:"Any",backendName:"webgl",kernelFunc:function bSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,l=mt(i,s.shape);let c=l;const u=An(c,a);let d=s;null!=u&&(d=ps({inputs:{x:s},backend:e,attrs:{perm:u}}),c=Wn(c.length,a)),Lr("any",c,a);const[h,f]=kr(d.shape,c),m=xe({inputs:{x:d},backend:e,attrs:{shape:[-1,X(f)]}}),g=Uc(m,m.dtype,"any",e);let y;return y=xe(o?{inputs:{x:g},backend:e,attrs:{shape:Hn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=u&&e.disposeIntermediateTensorInfo(d),y}};class vSe{constructor(t,e,r){this.variableNames=["A"];const{windowSize:s,batchSize:i,outSize:o}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class xSe{constructor(t,e,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,S(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const o=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),o>1&&this.outputShape.push(o),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=dn(l),u=fs("coords",l);let d,h;if(1===o){h=l+1;const D=dn(h);d=`\n        ${D} sourceLocR = ${D}(${u.join()}, 0);\n        ++${u[l-1]};\n        ${D} sourceLocG = ${D}(${u.join()}, 0);\n        ++${u[l-2]};\n        ${D} sourceLocA = ${D}(${u.join()}, 0);\n        --${u[l-1]};\n        ${D} sourceLocB = ${D}(${u.join()}, 0);\n        --${u[l-2]};`}else h=l,d=`\n        ${c} sourceLocR = coords;\n        ++${u[l-1]};\n        ${c} sourceLocG = coords;\n        ++${u[l-2]};\n        ${c} sourceLocA = coords;\n        --${u[l-1]};\n        ${c} sourceLocB = coords;\n        --${u[l-2]};`;const f=["x","y","z","w","u","v"].slice(0,h),p="."+f[h-1],m=f.map(D=>"int "+D),g=fs("sourceLocR",h-1).concat("inIdx.r"),y=fs("sourceLocG",h-1).concat("inIdx.g"),b=fs("sourceLocB",h-1).concat("inIdx.b"),_=fs("sourceLocA",h-1).concat("inIdx.a"),v="max"===r?"greaterThan":"lessThan",w=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${_.join()})));`,C=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${y.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${_.join()}) : 0.)`,E=s?"":`\n      float getBestIndicesAChannel(${m.join()}) {\n        return getChannel(getBestIndicesA(${f.join()}),\n                                          vec2(${f.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${m.join()}) {\n        return getChannel(getA(${f.join()}),\n                               vec2(${f.slice(-2).join()}));\n      }\n      ${E}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};\n        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${C};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${C};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function k4(n,t,e,r=null){let s=t.shape[0],i=t.shape[1];null!=r&&(s=r.shape[0],i=r.shape[1]);const o=F_(i),a={windowSize:o,inSize:i,batchSize:s,outSize:Math.ceil(i/o)},l=new vSe(a,e,null==r),c=[t];null!=r&&c.push(r);const u=n.runWebGLProgram(l,c,"int32");if(1===u.shape[1])return u;const d=k4(n,t,e,u);return n.disposeIntermediateTensorInfo(u),d}function N4(n,t,e,r=null){const s=null!=r?r.shape:t.shape,o=F_(s[s.length-1]),a=new xSe(s,o,e,null==r),c=n.runWebGLProgram(a,null==r?[t]:[t,r],"int32");if(c.shape.length===t.shape.length){const u=N4(n,t,e,c);return n.disposeIntermediateTensorInfo(c),u}return c}function A4(n,t,e,r){const s=[e];if(Lr("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!G().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const i=[],o=n.texData.get(t.dataId);let l=t;null!==o&&o.isPacked&&(l=n.unpackTensor(t),i.push(l));const[c,u]=kr(l.shape,s),d=X(u),h=xe({inputs:{x:l},backend:n,attrs:{shape:[-1,d]}});i.push(h);const f=k4(n,h,r);i.push(f);const p=xe({inputs:{x:f},backend:n,attrs:{shape:c}});return i.forEach(m=>n.disposeIntermediateTensorInfo(m)),p}return N4(n,t,r)}const CSe={kernelName:jy,backendName:"webgl",kernelFunc:function wSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;let o=mt(i,s.shape);const a=An(o,s.shape.length);let l=s;const c=[];null!=a&&(l=ps({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),o=Wn(o.length,l.shape.length)),Lr("argMax",[o[0]],l.shape.length);const u=A4(e,l,o[0],"max");return c.forEach(d=>e.disposeIntermediateTensorInfo(d)),u}},ISe={kernelName:Gy,backendName:"webgl",kernelFunc:function SSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i}=r;let o=mt(i,s.shape);const a=An(o,s.shape.length);let l=s;const c=[];null!=a&&(l=ps({inputs:{x:s},backend:e,attrs:{perm:a}}),c.push(l),o=Wn(o.length,l.shape.length)),Lr("argMin",[o[0]],l.shape.length);const u=A4(e,l,o[0],"min");return c.forEach(d=>e.disposeIntermediateTensorInfo(d)),u}},DSe=Ot({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),TSe={kernelName:Of,backendName:"webgl",kernelFunc:DSe},NSe=Ot({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),ASe={kernelName:$f,backendName:"webgl",kernelFunc:NSe},MSe=Ot({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),FSe={kernelName:Pf,backendName:"webgl",kernelFunc:MSe},PSe=Br({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),LSe={kernelName:Bf,backendName:"webgl",kernelFunc:PSe},VSe=Ot({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),zSe={kernelName:Lf,backendName:"webgl",kernelFunc:VSe};class xm{constructor(t,e,r,s=!1,i=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideHeight,l=t.strideWidth,c=t.dilationHeight,u=t.dilationWidth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,f=t.padInfo.top,p=t.padInfo.left;this.outputShape=t.outShape;const m="avg"===e;let b="0.0";if(m||(b="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${l});\n        const ivec2 pads = ivec2(${f}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?i?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let v=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(v="avgValue / count");const w=4*Math.floor(o/4),C=o%4,E=`\n      if (${m}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${l});\n      const ivec2 pads = ivec2(${f}, ${p});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${c}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${w}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${E}\n          }\n\n          int xC = xCCorner + ${w};\n          if (${1===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${E}\n          } else if (${2===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${E}\n          } else if (${3===C}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${E}\n          }\n        }\n        setOutput(${v});\n      }\n    `}}class $T{constructor(t,e,r,s=!1,i=!1){if(this.variableNames=["x"],"avg"===e&&r)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,a=t.strideDepth,l=t.strideHeight,c=t.strideWidth,u=t.dilationDepth,d=t.dilationHeight,h=t.dilationWidth,f=t.effectiveFilterDepth,p=t.effectiveFilterHeight,m=t.effectiveFilterWidth,g=t.padInfo.front,y=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const _="avg"===e;let v="0.0";if(_||(v="-1.0 / 1e-20"),r)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${l}, ${c});\n        const ivec3 pads = ivec3(${g}, ${y}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${f};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${m};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?i?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${p} * ${m} +\n                      wR * ${m} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let C=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(C="avgValue / count");const E=4*Math.floor(o/4),D=o%4,T=`\n      if (${_}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${l}, ${c});\n      const ivec3 pads = ivec3(${g}, ${y}, ${b});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${f};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${E}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${T}\n            }\n\n            int xC = xCCorner + ${E};\n            if (${1===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${T}\n            } else if (${2===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${T}\n            } else if (${3===D}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${T}\n            }\n          }\n          setOutput(${C});\n        }\n      }\n    `}}const HSe={kernelName:qy,backendName:"webgl",kernelFunc:function USe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;gm(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r;S(Pr(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=Li(s.shape,i,o,1,a,l);if(1===u.filterWidth&&1===u.filterHeight&&Rt(u.inShape,u.outShape))return Ks({inputs:{x:s},backend:e});const d=new xm(u,"avg",!1);return e.runWebGLProgram(d,[s],"float32")}},jSe={kernelName:Ky,backendName:"webgl",kernelFunc:function WSe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r,d=Sa(s.shape,i,o,[1,1,1],a,l,c),h=new $T(d,"avg",!1);return e.runWebGLProgram(h,[s],"float32")}};class GSe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const l=t.effectiveFilterHeight,c=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${l-1-t.padInfo.top}, ${c-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${c};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class qSe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const d=t.effectiveFilterDepth,h=t.effectiveFilterHeight,f=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${d-1-t.padInfo.front}, ${h-1-t.padInfo.top}, ${f-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${f};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const XSe={kernelName:KS,backendName:"webgl",kernelFunc:function KSe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=Sa(o.shape,a,l,[1,1,1],c,u),f=new qSe(h);return e.runWebGLProgram(f,[s],o.dtype)}},ZSe={kernelName:qS,backendName:"webgl",kernelFunc:function YSe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i;gm([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=Li(o.shape,a,l,1,c),d=new GSe(u);return e.runWebGLProgram(d,[s],o.dtype)}},JSe={kernelName:Xy,backendName:"webgl",kernelFunc:function QSe(n){const{inputs:t,backend:e,attrs:r}=n,{a:s,b:i}=t,{transposeA:o,transposeB:a}=r;return Mv({a:s,b:i,transposeA:o,transposeB:a,backend:e})}};class eIe{constructor(t,e,r,s,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],tt(t,e),tt(t,r);let a="0.0";null!=s&&(tt(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";null!=i&&(tt(t,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${o}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class tIe{constructor(t,e,r,s,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],tt(t,e),tt(t,r);let a="vec4(0.0)";null!=s&&(tt(t,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=i&&(tt(t,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${o}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const nIe={kernelName:ab,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,mean:s,variance:i,offset:o,scale:a}=n;S(s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),S(null==o||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),S(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;null==l&&(l=.001);const c=[r,s,i];let u=null;null!=o&&(u=o.shape,c.push(o));let d=null;null!=a&&(d=a.shape,c.push(a));const h=G().getBool("WEBGL_PACK_NORMALIZATION")?new tIe(r.shape,s.shape,i.shape,u,d,l):new eIe(r.shape,s.shape,i.shape,u,d,l);return t.runWebGLProgram(h,c,c[0].dtype)}};class rIe{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=dn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=function sIe(n){if(1===n)return"sourceLoc";if(n<=6)return PT.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}(this.rank);let s;s=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((o,a)=>`sourceLoc.${PT[a]} = start[${a}] + coords.${PT[a]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}}const PT=["x","y","z","w","u","v"];class iIe{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=dn(this.rank),r=fs("coords",this.rank),s=fs("sourceLoc",this.rank),i=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,o=`getChannel(getSource(${s.join()}), ${i})`,a=`\n      result.x = ${o};\n      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${o};\n        --${s[this.rank-1]};\n      }\n    `,l=1===this.rank?"":`\n      --${r[this.rank-1]};\n      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${o};\n        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,c=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((u,d)=>`start[${d}]`).join()});`:t.map((u,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${c}\n        vec4 result = vec4(0.);\n        ${a}\n        ${l}\n        setOutput(result);\n      }\n    `}}function Zd(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,size:o}=r,[a,l]=o_(s,i,o);if(NE(s,a,l),0===X(l))return e.makeTensorInfo(l,s.dtype,[]);if(e.shouldExecuteOnCPU([s])||"string"===s.dtype){const d=e.texData.get(s.dataId),h=Zwe(d.values,a,l,s.shape,s.dtype);return e.makeTensorInfo(l,s.dtype,h)}const{isPacked:c}=e.texData.get(s.dataId),u=RE(s.shape,a,l);if(c||!u){const d=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new iIe(l):new rIe(l);return e.runWebGLProgram(d,[s],s.dtype,[a])}return e.uploadToGPU(s.dataId),function oIe(n,t,e,r){const s=r.texData.get(n.dataId),i=r.makeTensorInfo(e,n.dtype),o=r.texData.get(i.dataId);Object.assign(o,s),o.refCount=1,o.shape=e,o.dtype=n.dtype;let a=ME(t,Le(n.shape));s.slice&&(a+=s.slice.flatOffset),o.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||n.dataId};const l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),i}(s,a,l,e)}const aIe={kernelName:$b,backendName:"webgl",kernelFunc:Zd},lIe={kernelName:Yy,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,crops:o}=r;S(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((b,_)=>b*_),l=Kp(s.shape,i,a),c=Xp(l.length,i.length),u=Yp(s.shape,i,a),d=BD(o,i.length),h=VD(u,o,i.length),f=[],p=xe({inputs:{x:s},backend:e,attrs:{shape:l}}),m=ps({inputs:{x:p},backend:e,attrs:{perm:c}}),g=xe({inputs:{x:m},backend:e,attrs:{shape:u}}),y=Zd({inputs:{x:g},backend:e,attrs:{begin:d,size:h}});return f.push(p),f.push(m),f.push(g),f.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}},uIe={kernelName:XS,backendName:"webgl",kernelFunc:function cIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o}=r,a=e.readSync(s.dataId),l=e.readSync(i.dataId),c=l4(a,l,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,c)}},hIe={kernelName:YS,backendName:"webgl",kernelFunc:function dIe(n){const{inputs:t,backend:e}=n,{s0:r,s1:s}=t,i=e.readSync(r.dataId),o=e.readSync(s.dataId),a=tt(Array.from(i),Array.from(o));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}},R4=Br({opSnippet:"return float(a != b);",cpuKernelImpl:Uwe,dtype:"bool"}),fIe={kernelName:Sb,backendName:"webgl",kernelFunc:R4};function wm(n){const{inputs:t,backend:e}=n,{input:r}=t;return Ks({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.real},backend:e})}const pIe={kernelName:AI,backendName:"webgl",kernelFunc:wm},yIe={kernelName:Vf,backendName:"webgl",kernelFunc:function LT(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dtype:i}=r;if("complex64"===i){if("complex64"===s.dtype)return Ks({inputs:{x:s},backend:e});const o=ur(s.shape),a=LT({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),l=Ml({inputs:{real:a,imag:o},backend:e});return o.dispose(),e.disposeIntermediateTensorInfo(a),l}if("complex64"===s.dtype){const o=wm({inputs:{input:s},backend:e}),a=LT({inputs:{x:o},backend:e,attrs:{dtype:i}});return e.disposeIntermediateTensorInfo(o),a}if(!UP(s.dtype,i)){const o=Ks({inputs:{x:s},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(e.shouldExecuteOnCPU([s])){const o=e.texData.get(s.dataId).values,[a,l,c]=wwe(o,s.shape,s.dtype,i);return e.makeTensorInfo(a,l,c)}if("int32"===i)return function gIe(n,t){const e=new Yo(n.shape,"return float(int(x));"),r=t.runWebGLProgram(e,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(s,e);if("bool"===i){const o=e.makeTensorInfo([],"bool",Sr("bool",1)),l=R4({inputs:{a:s,b:o},backend:e});return e.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}},M4="return ceil(x);",bIe=Ot({opSnippet:M4,packedOpSnippet:M4,cpuKernelImpl:Cwe}),_Ie={kernelName:zf,backendName:"webgl",kernelFunc:bIe};class vIe{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class xIe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const CIe={kernelName:Uf,backendName:"webgl",kernelFunc:function wIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{clipValueMin:i,clipValueMax:o}=r;let a;return a=G().getBool("WEBGL_PACK_CLIP")?new xIe(s.shape):new vIe(s.shape),e.runWebGLProgram(a,[s],s.dtype,[[i],[o]])}};class SIe{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function F4(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}const EIe={kernelName:Zy,backendName:"webgl",kernelFunc:function IIe(n){const{inputs:t,backend:e}=n,{x:r}=t,s=e.texData.get(r.dataId),i=new SIe(r.shape),o=[F4(r,s.complexTensorInfos.real),F4(r,s.complexTensorInfos.imag)];return e.runWebGLProgram(i,o,o[0].dtype)}};class DIe{constructor(t){this.outputShape=[],this.outputShape=Uo(t,1),this.variableNames=t.map((o,a)=>`T${a}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let o=1;o<e.length;o++)e[o]=e[o-1]+t[o][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<e.length;o++)r.push(`else if (yC < ${e[o]}) setOutput(getT${o}(yR, yC-${e[o-1]}));`);r.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${r.join("\n        ")}\n      }\n    `}}class TIe{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Uo(t,e);const r=this.outputShape,s=r.length,i=dn(s),o=fs("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((m,g)=>`T${g}`);const l=new Array(t.length-1);l[0]=t[0][e];for(let m=1;m<l.length;m++)l[m]=l[m-1]+t[m][e];const c=a[e],u=a.slice(-2),d=a.join();let h=`if (${c} < ${l[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${u.join()}));\n        }`;for(let m=1;m<l.length;m++){const g=l[m-1];h+=`\n        if (${c} < ${l[m]}  && ${c} >= ${l[m-1]}) {\n          return getChannel(\n            getT${m}(${Ov(a,c,g)}),\n            vec2(${Ov(u,c,g)}));\n        }`}const p=l[l.length-1];h+=`\n        return getChannel(\n          getT${l.length}(${Ov(a,c,p)}),\n          vec2(${Ov(u,c,p)}));`,this.userCode=`\n      float getValue(${a.map(m=>"int "+m)}) {\n        ${h}\n      }\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${o}), 0., 0., 0.);\n\n        ${o[s-1]} = ${o[s-1]} + 1;\n        if (${o[s-1]} < ${r[s-1]}) {\n          result.g = getValue(${o});\n        }\n\n        ${o[s-2]} = ${o[s-2]} + 1;\n        if (${o[s-2]} < ${r[s-2]}) {\n          result.a = getValue(${o});\n        }\n\n        ${o[s-1]} = ${o[s-1]} - 1;\n        if (${o[s-2]} < ${r[s-2]} &&\n            ${o[s-1]} < ${r[s-1]}) {\n          result.b = getValue(${o});\n        }\n        setOutput(result);\n      }\n    `}}function Ov(n,t,e){const r=n.indexOf(t);return n.map((i,o)=>o===r?`${i} - ${e}`:i).join()}function $v(n){const{inputs:t,backend:e}=n,{input:r}=t;return Ks({inputs:{x:e.texData.get(r.dataId).complexTensorInfos.imag},backend:e})}const kIe={kernelName:yI,backendName:"webgl",kernelFunc:$v};function Cm(n,t,e){const r=n[0].dtype;if("complex64"===r){const f=n.map(b=>wm({inputs:{input:b},backend:e})),p=n.map(b=>$v({inputs:{input:b},backend:e})),m=Cm(f,t,e),g=Cm(p,t,e),y=Ml({inputs:{real:m,imag:g},backend:e});return f.forEach(b=>e.disposeIntermediateTensorInfo(b)),p.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),y}let s=e.shouldExecuteOnCPU(n);if("string"===r&&(s=!0),s){const f=n.map(v=>{const C=[-1,X(v.shape.slice(t))];return xe({inputs:{x:v},backend:e,attrs:{shape:C}})}),p=f.map(v=>({vals:e.readSync(v.dataId),shape:v.shape})),m=Uo(f.map(v=>v.shape),1),y=Swe(p,m,r,1===f[0].shape[0]),b=Uo(n.map(v=>v.shape),t),_=e.makeTensorInfo(b,r,y);return f.forEach(v=>e.disposeIntermediateTensorInfo(v)),_}const i=n.filter(f=>X(f.shape)>0),o=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(1===i.length){const f=o?new Yo(n[0].shape,Al):new Rl(n[0].shape,Al);return e.runWebGLProgram(f,n,r)}const a=G().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const f=[];for(let m=0;m<i.length;m+=a){const g=i.slice(m,m+a);f.push(Cm(g,t,e))}const p=Cm(f,t,e);for(const m of f)e.disposeIntermediateTensorInfo(m);return p}if(o){const f=new TIe(i.map(p=>p.shape),t);return e.runWebGLProgram(f,i,r)}const{tensors2D:l,outShape:c}=function NIe(n,t,e){const r=Uo(n.map(i=>i.shape),t);return{tensors2D:n.map(i=>xe({inputs:{x:i},attrs:{shape:[-1,X(i.shape.slice(t))]},backend:e})),outShape:r}}(i,t,e),u=new DIe(l.map(f=>f.shape)),d=e.runWebGLProgram(u,l,r);l.forEach(f=>e.disposeIntermediateTensorInfo(f));const h=xe({inputs:{x:d},attrs:{shape:c},backend:e});return e.disposeIntermediateTensorInfo(d),h}function O4(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r,i=mt(s,t[0].shape)[0];$D(t.map(c=>c.shape),i);const a=Uo(t.map(c=>c.shape),i);if(0===X(a))return e.makeTensorInfo(a,t[0].dtype,[]);const l=t.filter(c=>X(c.shape)>0);return 1===l.length?Ks({inputs:{x:l[0]},backend:e}):Cm(l,i,e)}const AIe={kernelName:Qy,backendName:"webgl",kernelFunc:O4};class $4{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,a=t.padInfo.left,l=t.strideHeight,c=t.strideWidth,u=t.dilationHeight,d=t.dilationWidth,h=t.filterHeight,f=t.filterWidth,p=4*Math.floor(t.inChannels/4),m=t.inChannels%4,g="channelsLast"===t.dataFormat,y=g?1:2,b=g?2:3,_=g?3:1;let v="",w="";r&&(v=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,w="result = activation(result);");const C=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${o}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${_}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${y}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${g}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===m}) {\n\n              if (${g}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===m}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===m}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${C}\n        ${w}\n        setOutput(result);\n      }\n    `}}class RIe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,r=t.padInfo.top,s=t.padInfo.left,i=t.strideDepth,o=t.strideHeight,a=t.strideWidth,l=t.dilationDepth,c=t.dilationHeight,u=t.dilationWidth,d=t.filterDepth,h=t.filterHeight,f=t.filterWidth,p=4*Math.floor(t.inChannels/4),m=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${i}, ${o}, ${a});\n      const ivec3 pads = ivec3(${e}, ${r}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${l};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${c};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${f}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===m}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class P4{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=hs(this.outputShape.length);const o=t.padInfo.left,a=t.strideWidth,l=t.dilationWidth,c=t.filterHeight,u=t.filterWidth,d=u;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<u;g++)h+=`\n           vec4 xTexelC${2*g};\n           int xTexelC${2*g}Ready;\n           vec4 xTexelC${2*g+1};\n           int xTexelC${2*g+1}Ready;\n           vec4 xC${g};`;h+=`\n     for (int r = 0; r < ${c}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let g=0;g<u;g++)h+=`\n           xTexelC${2*g} = vec4(0.0);\n           xTexelC${2*g}Ready = 0;\n           xTexelC${2*g+1} = vec4(0.0);\n           xTexelC${2*g+1}Ready = 0;\n           xC${g} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let g=0;g<(d+1)/2;g++){const y=2*g;if(h+=`\n           xC = xCCorner + ${y*l};\n           `,1===a){if(y<u&&(o%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n               `,h+=1===l&&y>0?`\n                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);\n                   } else {\n                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xC${y} = xTexelC${y};\n                 `,y+1<u)){const b=o%2==0?$S(l):l;l%2==0&&o%2==1||l%2!=0&&o%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${b};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${y+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${y+1}Ready = 1;\n                   }\n                   `,h+=l>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);\n                     } else {\n                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);\n                     }\n                     `:`\n                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);\n                     `):h+=1===b?`\n                     xC${y+1} = xTexelC${y};\n                     `:`\n                     xCOffset = xC + ${b};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${y+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${y+1}Ready = 1;\n                     }\n\n                     xC${y+1} = xTexelC${y+1};\n                     `}}else y<u&&(o%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n               `,y+1<u&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(\n                   xTexelC${y}.xy, xTexelC${y+1}.xy);\n               `,y+1<u&&(h+=`\n                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n                 `)));y<u&&(h+=`\n             wTexel = getW(r, ${y}, d1, d2);\n             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,y+1<u&&(h+=`\n               wTexel = getW(r, ${y+1}, d1, d2);\n               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let f="",p="";r&&(f=s?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${r}\n         }`:i?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${r}\n         }`:`vec4 activation(vec4 x) {\n           ${r}\n         }`,p="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${f}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${m}\n         ${p}\n         setOutput(result);\n       }\n     `}}class MIe{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=hs(this.outputShape.length);const{dataFormat:r}=e,s=ds(),i="channelsLast"===r,o=i?1:2,a=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let c="";for(let u=0;u<=1;u++)for(let d=0;d<=1;d++)c+=`\n          blockIndex = rc.z + ${d};\n          pos = rc.y + ${u};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${o}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${i}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+d}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+d}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${c}\n\n        ${s.output} = result;\n      }\n    `}}function Pv(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&1===e&&n[0]>1?[n[0],1]:null}function L4({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,c=r.texData.get(n.dataId),u=e.inChannels,d=l[0]*l[1]*l[2],h=e.outChannels,f="channelsLast"===e.dataFormat;let g;const y=[];if(null!=i){const v=Pv(i.shape,f);null!=v&&(i=xe({inputs:{x:i},backend:r,attrs:{shape:v}}),y.push(i))}if(null!=s){const v=Pv(s.shape,f);null!=v&&(s=xe({inputs:{x:s},backend:r,attrs:{shape:v}}),y.push(s))}if((1!==d&&1!==h||!(u>1e3))&&c.isPacked&&f&&null!=c.texture&&l[2]%2!=0&&Rt(c.shape.slice(-3),l.slice(-3))){const w={dataId:n.dataId,shape:[1,l[0]*l[1]*(l[2]+1),e.inChannels],dtype:n.dtype},C=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,S(Iv(c.shape,w.shape),()=>`packed reshape ${c.shape} to ${w.shape} isn't free`);const E=xe({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(E);const D=Mv({a:w,b:E,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),T=r.texData.get(D.dataId);S(T.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=C,T.shape=e.outShape,g=Ks({inputs:{x:D},backend:r}),g.shape=e.outShape,y.push(D)}else{const v=e.outHeight*e.outWidth,w=xe({inputs:{x:n},backend:r,attrs:{shape:f?[e.batchSize,v,e.inChannels]:[e.batchSize,e.inChannels,v]}}),C=xe({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),E=Mv({a:f?w:C,b:f?C:w,transposeA:!f,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o});g=xe({inputs:{x:E},backend:r,attrs:{shape:e.outShape}}),y.push(w),y.push(C),y.push(E)}for(const v of y)r.disposeIntermediateTensorInfo(v);return g}function B4({x:n,filter:t,convInfo:e,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:d,outHeight:h,dataFormat:f}=e,p="channelsLast"===f,m=l*c*u,g=h*d,y=[e.batchSize,m,g],v=[];if(null!=i){const L=Pv(i.shape,p);null!=L&&(i=xe({inputs:{x:i},backend:r,attrs:{shape:L}}),v.push(i))}if(null!=s){const L=Pv(s.shape,p);null!=L&&(s=xe({inputs:{x:s},backend:r,attrs:{shape:L}}),v.push(s))}const w=xe({inputs:{x:t},backend:r,attrs:{shape:[1,m,X(t.shape)/m]}});v.push(w);const C=new MIe(y,e),D=r.runWebGLProgram(C,[n],"float32",[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),T=xe({inputs:{x:D},backend:r,attrs:{shape:y}});v.push(D),v.push(T);const N=null!=s,P=null!=i,U="leakyrelu"===a,j=a?vm(a,!0):null,q=new x4(p?T.shape:w.shape,p?w.shape:T.shape,p?[e.batchSize,g,e.outChannels]:[e.batchSize,e.outChannels,g],!0,!1,N,j,P,U),K=p?[T,w]:[w,T];if(s&&K.push(s),P&&K.push(i),U){const L=r.makeTensorInfo([],"float32",il(o,"float32"));K.push(L),v.push(L)}const $=r.runWebGLProgram(q,K,"float32"),V=xe({inputs:{x:$},backend:r,attrs:{shape:e.outShape}});v.push($);for(const L of v)r.disposeIntermediateTensorInfo(L);return V}const OIe={kernelName:Jy,backendName:"webgl",kernelFunc:function FIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r,d=Ia(l),h=Tr(s.shape,i.shape,o,c,a,u,!1,d);let f;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&G().getBool("WEBGL_EXP_CONV")){const m=new P4(h);f=e.runWebGLProgram(m,[s,i],"float32",[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]])}else if(G().getBool("WEBGL_CONV_IM2COL"))f=B4({x:s,filter:i,convInfo:h,backend:e});else{const m=new $4(h);f=e.runWebGLProgram(m,[s,i],"float32")}else f=L4({x:s,filter:i,convInfo:h,backend:e});const p=xe({inputs:{x:f},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(f),p}};class $Ie{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===t.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class PIe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,o="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${o?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${o?1:2}], coords[${o?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${o}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class LIe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class BIe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,r=t.filterHeight,s=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${r-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${r}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${r} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const zIe={kernelName:QS,backendName:"webgl",kernelFunc:function VIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,d=Ia(l),h=Tr(s.shape,u,o,1,a,c,!1,d),f=new $Ie(h);return e.runWebGLProgram(f,[s,i],"float32")}},HIe={kernelName:eb,backendName:"webgl",kernelFunc:function UIe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r,d=Ia(c),h=Tr(o,i.shape,a,1,l,u,!1,d),f=new PIe(h);return e.runWebGLProgram(f,[s,i],"float32")}},jIe={kernelName:tb,backendName:"webgl",kernelFunc:function WIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l}=r,c=fl(s.shape,i.shape,o,l,a),u=new RIe(c);return e.runWebGLProgram(u,[s,i],"float32")}},qIe={kernelName:JS,backendName:"webgl",kernelFunc:function GIe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,pad:a,filterShape:l}=r,c=fl(s.shape,l,o,1,a),u=new LIe(c);return e.runWebGLProgram(u,[s,i],"float32")}},XIe={kernelName:eI,backendName:"webgl",kernelFunc:function KIe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{pad:o,strides:a,inputShape:l}=r,c=fl(l,i.shape,a,1,o),u=new BIe(c);return e.runWebGLProgram(u,[s,i],"float32")}},ZIe=Ot({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),QIe={kernelName:Hf,backendName:"webgl",kernelFunc:ZIe},JIe=Ot({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),eEe={kernelName:Wf,backendName:"webgl",kernelFunc:JIe};class tEe{constructor(t,e,r,s,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=t,[u]=e,[d,h]=r;this.outputShape=[u,d,h,c];const f="bilinear"===s?1:0,[p,m]=[a-1+".0",l-1+".0"],[g,y,b]=d>1?[""+(a-1)/(d-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[_,v,w]=h>1?[""+(l-1)/(h-1),"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${_});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${y};\n        float width_scale = ${v};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${i}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${m} ) {\n          setOutput(float(${i}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${f} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const nEe={kernelName:nI,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{image:s,boxes:i,boxInd:o}=t,{cropSize:a,method:l,extrapolationValue:c}=r,u=new tEe(s.shape,i.shape,a,l,c);return e.runWebGLProgram(u,[s,i,o],"float32")}};var Qd=(()=>{return(n=Qd||(Qd={})).Prod="*",n.Sum="+",Qd;var n})();class V4{constructor(t,e,r,s){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,a=r?this.op===Qd.Prod?"1.0":"0.0":`getX(${z4(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",u="";r?(c=s?"end != "+(l-1):"end != 0",u=s?"end + 1":"end - 1"):(c=s?`end + pow2 < ${l}`:"end >= pow2",u=s?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${dn(i)} coords = getOutputCoords();\n        int end = ${U4(i,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${c}) {\n          int idx = ${u};\n          ${U4(i,"coords",this.op)} = idx;\n          val ${this.op}= getX(${z4(i,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function z4(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.x, ${t}.y`;if(3===n)return`${t}.x, ${t}.y, ${t}.z`;if(4===n)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function U4(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.y`;if(3===n)return`${t}.z`;if(4===n)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function H4(n,t,e,r,s,i){const o=t.shape.length,a=An([r],o);let l=t;null!=a&&(l=ps({inputs:{x:t},backend:e,attrs:{perm:a}}));const c=Wn(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const u=l.shape[c];let d=Ks({inputs:{x:l},backend:e});for(let h=0;h<=Math.ceil(Math.log2(u))-1;h++){const f=new V4(n,l.shape,!1,i),m=d;d=e.runWebGLProgram(f,[d],d.dtype,[[h]]),e.disposeIntermediateTensorInfo(m)}if(s){const h=new V4(n,l.shape,s,i),f=d;d=e.runWebGLProgram(h,[d],d.dtype),e.disposeIntermediateTensorInfo(f)}if(null!=a){const f=ps({inputs:{x:d},backend:e,attrs:{perm:gl(a)}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(l),f}return d}const sEe={kernelName:tI,backendName:"webgl",kernelFunc:function rEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;return H4(Qd.Prod,s,e,i,o,a)}},oEe={kernelName:nb,backendName:"webgl",kernelFunc:function iEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,exclusive:o,reverse:a}=r;return H4(Qd.Sum,s,e,i,o,a)}},lEe={kernelName:rI,backendName:"webgl",kernelFunc:function aEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,weights:i}=t,{size:o,binaryOutput:a}=r;if(1===s.shape.length){const l=e.readSync(s.dataId),c=e.readSync(i.dataId),u=l4(l,c,i.dtype,i.shape,o);return e.makeTensorInfo([o],i.dtype,u)}if(2===s.shape.length){const l=e.bufferSync(s),c=e.bufferSync(i),u=xwe(l,c,o,a);return e.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class cEe{constructor(t,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=r,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const dEe={kernelName:sI,backendName:"webgl",kernelFunc:function uEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockSize:i,dataFormat:o}=r,a=s.shape[0],d=("NHWC"===o?s.shape[1]:s.shape[2])*i,h=("NHWC"===o?s.shape[2]:s.shape[3])*i,f=("NHWC"===o?s.shape[3]:s.shape[1])/(i*i),m=new cEe("NHWC"===o?[a,d,h,f]:[a,f,d,h],i,o);return e.runWebGLProgram(m,[s],s.dtype)}};class W4{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=hs(this.outputShape.length);const o=t.filterHeight,a=t.filterWidth,l=t.outChannels/t.inChannels;let c="",u="";r&&(c=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:i?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`\n          float activation(float x) {\n            ${r}\n          }\n        `,u="result = activation(result);");const d=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${c}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${o}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${d}\n        ${u}\n        setOutput(result);\n      }\n    `}}class j4{constructor(t,e=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=hs(this.outputShape.length);const o=t.outChannels/t.inChannels,a=t.padInfo.left,l=t.strideWidth,c=t.dilationWidth,u=t.filterHeight,d=t.filterWidth,h=d;let f="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let y=0;y<d;y++)f+=`\n          vec4 xTexelC${2*y};\n          int xTexelC${2*y}Ready;\n          vec4 xTexelC${2*y+1};\n          int xTexelC${2*y+1}Ready;\n          vec4 xC${y};`;f+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let y=0;y<d;y++)f+=`\n          xTexelC${2*y} = vec4(0.0);\n          xTexelC${2*y}Ready = 0;\n          xTexelC${2*y+1} = vec4(0.0);\n          xTexelC${2*y+1}Ready = 0;\n          xC${y} = vec4(0.0);`;f+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let y=0;y<(h+1)/2;y++){const b=2*y;if(f+=`\n          xC = xCCorner + ${b*c};\n          `,1===l){if(b<d&&(a%2==1?(f+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n              `,f+=1===c&&b>0?`\n                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);\n                  } else {\n                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);\n                  }\n                  `):f+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xC${b} = xTexelC${b};\n                `,b+1<d)){const _=a%2==0?$S(c):c;c%2==0&&a%2==1||c%2!=0&&a%2!=1?(f+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${_};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${b+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${b+1}Ready = 1;\n                  }\n                  `,f+=c>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);\n                    } else {\n                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);\n                    }\n                    `:`\n                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);\n                    `):f+=1===_?`\n                    xC${b+1} = xTexelC${b};\n                    `:`\n                    xCOffset = xC + ${_};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${b+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${b+1}Ready = 1;\n                    }\n\n                    xC${b+1} = xTexelC${b+1};\n                    `}}else b<d&&(a%2==1?(f+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n              `,b+1<d&&(f+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);\n                `)):(f+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(\n                  xTexelC${b}.xy, xTexelC${b+1}.xy);\n              `,b+1<d&&(f+=`\n                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n                `)));b<d&&(f+=`\n            wTexel = getW(r, ${b}, d1, q);\n            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);\n          `,b+1<d&&(f+=`\n              wTexel = getW(r, ${b+1}, d1, q);\n              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}f+="\n    }\n  ",f+="\n      }\n    ";let p="",m="";r&&(p=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${r}\n        }`:i?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${r}\n        }`:`vec4 activation(vec4 x) {\n          ${r}\n        }`,m="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${f}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${g}\n        ${m}\n        setOutput(result);\n      }\n    `}}const fEe={kernelName:rb,backendName:"webgl",kernelFunc:function hEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;let u=l;null==u&&(u=[1,1]),S(Pr(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const d=Tr(s.shape,i.shape,o,u,a,c,!0);let h;return h=G().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new j4(d):new W4(d),e.runWebGLProgram(h,[s,i],"float32",[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]])}};class pEe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class mEe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,l=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${r} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${l}; dm++) {\n              int d2 = d1 * ${l} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const yEe={kernelName:iI,backendName:"webgl",kernelFunc:function gEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,dy:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r,d=Tr(s.shape,u,o,a,l,c,!0),h=new pEe(d);return e.runWebGLProgram(h,[s,i],"float32")}},_Ee={kernelName:oI,backendName:"webgl",kernelFunc:function bEe(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,filter:i}=t,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r,d=Tr(u,i.shape,o,a,l,c,!0),h=new mEe(d);return e.runWebGLProgram(h,[s,i],"float32")}};class vEe{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const wEe={kernelName:aI,backendName:"webgl",kernelFunc:function xEe(n){const{inputs:t,backend:e}=n,{x:r}=t,s=[...r.shape,...r.shape],i=X(r.shape),o=xe({inputs:{x:r},backend:e,attrs:{shape:[i]}}),a=new vEe(i),l=e.runWebGLProgram(a,[o],o.dtype),c=xe({inputs:{x:l},backend:e,attrs:{shape:s}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),c}};class CEe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:r,padInfo:s,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=t,{top:d,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${c};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${l}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${r}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const IEe={kernelName:sb,backendName:"webgl",kernelFunc:function SEe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i}=t,{strides:o,pad:a,dilations:l}=r,c=Mp(s.shape,i.shape,o,a,"NHWC",l);let u;const d=new CEe(c);u=e.runWebGLProgram(d,[s,i],"float32");const h=xe({inputs:{x:u},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(u),h}},DEe={kernelName:uI,backendName:"webgl",kernelFunc:function EEe(n){const{inputs:t,backend:e,attrs:r}=n,{equation:s}=r,i=t,{allDims:o,summedDims:a,idDims:l}=YD(s,i.length);QD(o.length,l,i);const{path:c,steps:u}=JD(a,l),d=u.length;let h=null,f=o.length;const p=[];for(let m=0;m<d;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:b}=ZD(f,l[g]);let _;e1(y)?_=i[g]:(_=ps({inputs:{x:i[g]},backend:e,attrs:{perm:y}}),p.push(_));const v=_.shape.slice();for(let w=0;w<b.length;++w)v.splice(b[w],0,1);Rt(_.shape,v)||(_=xe({inputs:{x:_},backend:e,attrs:{shape:v}}),p.push(_)),null===h?h=_:(h=OT({inputs:{a:_,b:h},backend:e}),p.push(h))}m<d-1&&(c[m]>=0&&(h=Rv({inputs:{x:h},backend:e,attrs:{axis:c[m]-(o.length-f),keepDims:!1}}),p.push(h)),f--)}for(const m of p)m!==h&&e.disposeIntermediateTensorInfo(m);return h}},TEe=Ot({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),kEe={kernelName:Gf,backendName:"webgl",kernelFunc:TEe},REe={kernelName:dI,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e}=n,{dy:r,y:s}=t,i=G().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new _m("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new Xd("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,s.shape);return e.runWebGLProgram(i,[r,s],r.dtype)}},MEe=Br({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:Iwe}),FEe={kernelName:ib,backendName:"webgl",kernelFunc:MEe},$Ee=Ot({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${UD};\n  float a1 = ${HD};\n  float a2 = ${WD};\n  float a3 = ${jD};\n  float a4 = ${GD};\n  float a5 = ${qD};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),PEe={kernelName:qf,backendName:"webgl",kernelFunc:$Ee},G4=Ot({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Ewe,dtype:"float32"}),BEe={kernelName:Kf,backendName:"webgl",kernelFunc:G4};function BT(n){const{inputs:t,attrs:e,backend:r}=n,{dim:s}=e,{input:i}=t,o=i.shape.length,a=i.shape.slice();let l=s;return s<0&&(S(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+s+1),a.splice(l,0,1),xe({inputs:{x:i},backend:r,attrs:{shape:a}})}const VEe={kernelName:ob,backendName:"webgl",kernelFunc:BT},q4="return exp(x) - 1.0;",zEe=Ot({opSnippet:q4,packedOpSnippet:q4,cpuKernelImpl:Dwe}),UEe={kernelName:Xf,backendName:"webgl",kernelFunc:zEe};class K4{constructor(t,e,r){this.variableNames=["real","imag"];const s=e[1];this.outputShape=e;const i=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${s}.0`:"1.0";let a;if("real"===t)a="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${i};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function X4(n,t,e){const r=e.texData.get(n.dataId),s=X(n.shape),i=n.shape[n.shape.length-1],a=xe({inputs:{x:n},backend:e,attrs:{shape:[s/i,i]}}),l=a.shape,c=new K4("real",l,t),u=new K4("imag",l,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=e.runWebGLProgram(c,d,"float32"),f=e.runWebGLProgram(u,d,"float32"),p=Ml({inputs:{real:h,imag:f},backend:e});e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f);const m=xe({inputs:{x:p},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(p),m}const WEe={kernelName:"FFT",backendName:"webgl",kernelFunc:function HEe(n){const{inputs:t,backend:e}=n,{input:r}=t;return X4(r,!1,e)}};class jEe{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Sm(n){const{backend:t,attrs:e}=n,{shape:r,value:s}=e;let{dtype:i}=e;if(i=i||Rf(s),"string"===i){const o=Zn(i,X(r));return o.fill(s),t.makeTensorInfo(r,i,o)}{const o=new jEe(r,s);return t.runWebGLProgram(o,[],i,[[s]])}}const GEe={kernelName:fI,backendName:"webgl",kernelFunc:Sm};class qEe{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const KEe={kernelName:pI,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,r=t,s=new qEe(e.shape);return r.runWebGLProgram(s,[e],e.dtype)}},Y4="return floor(x);",XEe=Ot({opSnippet:Y4,packedOpSnippet:Y4,cpuKernelImpl:Twe}),YEe={kernelName:Yf,backendName:"webgl",kernelFunc:XEe},ZEe=Br({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),QEe={kernelName:Zf,backendName:"webgl",kernelFunc:ZEe};class JEe{constructor(t){this.variableNames=["A"];const e=ds(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class eDe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=ds(),[r,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${r}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const tDe={kernelName:XI,backendName:"webgl",kernelFunc:function nDe(n){const{inputs:t,backend:e,attrs:r}=n;let{pixels:s}=t;const{numChannels:i}=r,o=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,c]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],u=[c,l],d=[c,l,i];if(a||o){const m=G().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==Jd||m!==VT)&&(VT=m,Jd=document.createElement("canvas").getContext("2d",{willReadFrequently:VT})),Jd.canvas.width=l,Jd.canvas.height=c,Jd.drawImage(s,0,0,l,c),s=Jd.canvas}const h=e.makeTensorInfo(u,"int32");e.texData.get(h.dataId).usage=qs.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId),s);const f=G().getBool("WEBGL_PACK")?new eDe(d):new JEe(d),p=e.runWebGLProgram(f,[h],"int32");return e.disposeData(h.dataId),p}};let Jd,VT=G().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const sDe={kernelName:jb,backendName:"webgl",kernelFunc:function rDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:p}=r,m=Ia(u),g=Tr(s.shape,i.shape,l,d,c,h,!1,m);let y;const b=[],_=null!=o,v=null!=a,w="leakyrelu"===f,C=()=>{const D=[s,i],T=(N,P)=>{if("NCHW"===P&&1===N.shape.length&&1!==N.shape[0]){const U=xe({inputs:{x:N},backend:e,attrs:{shape:[N.shape[0],1,1]}});return b.push(U),U}return N};if(_&&D.push(T(o,u)),v&&D.push(T(a,u)),w){const N=e.makeTensorInfo([],"float32",il(p,"float32"));D.push(N),b.push(N)}return D};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&G().getBool("WEBGL_EXP_CONV")){const D=f?vm(f,!0):null,T=new P4(g,_,D,v,w),N=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],P=C();y=e.runWebGLProgram(T,P,"float32",N)}else if(G().getBool("WEBGL_CONV_IM2COL"))y=B4({x:s,filter:i,convInfo:g,backend:e,bias:o,activation:f,preluActivationWeights:a,leakyreluAlpha:p});else{const D=f?vm(f,!1):null,T=new $4(g,_,D,v,w),N=C();y=e.runWebGLProgram(T,N,"float32")}else y=L4({x:s,filter:i,convInfo:g,backend:e,bias:o,activation:f,preluActivationWeights:a,leakyreluAlpha:p});const E=xe({inputs:{x:y},backend:e,attrs:{shape:g.outShape}});return b.push(y),b.forEach(D=>e.disposeIntermediateTensorInfo(D)),E}},oDe={kernelName:Gb,backendName:"webgl",kernelFunc:function iDe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=t,{strides:l,pad:c,dilations:u,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,p=[];let m=u;null==m&&(m=[1,1]),S(Pr(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=Tr(s.shape,i.shape,l,m,c,d,!0),y=G().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,b=h?vm(h,y):null,_=[s,i],v=null!=o,w=null!=a,C="leakyrelu"===h;if(v&&_.push(o),w&&_.push(a),C){const N=e.makeTensorInfo([],"float32",il(f,"float32"));_.push(N),p.push(N)}let E;E=y?new j4(g,v,b,w,C):new W4(g,v,b,w,C);const T=e.runWebGLProgram(E,_,"float32",[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]]);return p.forEach(N=>e.disposeIntermediateTensorInfo(N)),T}};class aDe{constructor(t,e,r,s){this.sliceDim=t,this.strides=e,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const i=dn(r.length);let o="\n    int index;";for(let a=0;a<this.sliceDim;a++)o+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${i} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${o}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const cDe={kernelName:mI,backendName:"webgl",kernelFunc:function lDe(n){const{inputs:t,backend:e}=n,{params:r,indices:s}=t,i=s.shape,o=i[i.length-1],a=X(r.shape),[l,c,u,d]=zD(r,s),h=xe({inputs:{x:s},backend:e,attrs:{shape:[c,o]}}),f=xe({inputs:{x:r},backend:e,attrs:{shape:[X(r.shape)/u,u]}});if(e.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const y=e.readSync(s.dataId),b=e.bufferSync(r),_=kwe(y,b,r.dtype,c,o,u,d,r.shape,a);return e.makeTensorInfo(l,r.dtype,_.values)}const p=new aDe(o,d,[c,u],r.shape),m=e.runWebGLProgram(p,[f,h],f.dtype),g=xe({inputs:{x:m},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),g}};class uDe{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=dn(this.rank),s=function dDe(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)r.push(2===s?"index":`${e[s]}`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}function Z4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,indices:i}=t,{axis:o,batchDims:a}=r,l=mt(o,s.shape)[0];if(G().get("DEBUG")){const b=e.readSync(i.dataId),_=s.shape[l];for(let v=0;v<b.length;++v){const w=b[v];S(w<=_-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${_-1}]`)}}const c=r1(s,i,l,a),u=X(i.shape),d=[],h=xe({inputs:{x:s},backend:e,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),f=xe({inputs:{x:i},backend:e,attrs:{shape:[c.batchSize,u/c.batchSize]}});d.push(h),d.push(f);const p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(e.shouldExecuteOnCPU([s,i])||"string"===s.dtype){const b=e.bufferSync(f),_=e.bufferSync(h),v=Nwe(_,b,p);return d.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.makeTensorInfo(c.outputShape,v.dtype,v.values)}const m=new uDe(h.shape,p),g=e.runWebGLProgram(m,[h,f],h.dtype);d.push(g);const y=xe({inputs:{x:g},backend:e,attrs:{shape:c.outputShape}});return d.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}const hDe={kernelName:lb,backendName:"webgl",kernelFunc:Z4},fDe=Br({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Awe,dtype:"bool"}),pDe={kernelName:cb,backendName:"webgl",kernelFunc:fDe},mDe=Br({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:Rwe}),gDe={kernelName:Qf,backendName:"webgl",kernelFunc:mDe},bDe={kernelName:gI,backendName:"webgl",kernelFunc:function yDe(n){const{inputs:t,backend:e}=n,{input:r}=t;return X4(r,!0,e)}},_De=Ot({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),vDe={kernelName:ep,backendName:"webgl",kernelFunc:_De},xDe=Ot({opSnippet:"return float(isinf(x));",dtype:"bool"}),wDe={kernelName:tp,backendName:"webgl",kernelFunc:xDe},CDe=Ot({opSnippet:"return float(isnan(x));",dtype:"bool"}),SDe={kernelName:np,backendName:"webgl",kernelFunc:CDe},IDe=Br({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Mwe,dtype:"bool"}),EDe={kernelName:db,backendName:"webgl",kernelFunc:IDe},DDe=Br({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Fwe,dtype:"bool"}),TDe={kernelName:hb,backendName:"webgl",kernelFunc:DDe},NDe={kernelName:bI,backendName:"webgl",kernelFunc:function kDe(n){const{backend:t,attrs:e}=n,{start:r,stop:s,num:i}=e,o=Owe(r,s,i);return t.makeTensorInfo([o.length],"float32",o)}},RDe=Ot({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:$we}),MDe={kernelName:rp,backendName:"webgl",kernelFunc:RDe},ODe=Ot({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"}),$De={kernelName:sp,backendName:"webgl",kernelFunc:ODe},PDe=Br({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),LDe={kernelName:fb,backendName:"webgl",kernelFunc:PDe},BDe=Ot({opSnippet:"return float(!(x >= 1.0));"}),VDe={kernelName:pb,backendName:"webgl",kernelFunc:BDe},zDe=Br({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),UDe={kernelName:mb,backendName:"webgl",kernelFunc:zDe};class HDe{constructor(t,e,r,s,i){this.variableNames=["x"],this.outputShape=[];const o=e,a=t[3]-1;let l;this.outputShape=t;const c=`float(${r}) + float(${s}) * sum`;l=.5===i?`inversesqrt(${c})`:1===i?`1.0/(${c})`:`exp(log(${c}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${l};\n        setOutput(val);\n      }\n    `}}class WDe{constructor(t,e,r,s,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=e,a=t[3]-1;let l;this.outputShape=t;const c=`float(${r}) + float(${s}) * sum`;l=.5===i?`inversesqrt(${c})`:1===i?`1.0/(${c})`:`exp(log(${c}) * float(-${i}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${l};\n        setOutput(result);\n      }\n    `}}const jDe={kernelName:gb,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{depthRadius:i,bias:o,alpha:a,beta:l}=r,c=G().getBool("WEBGL_PACK_NORMALIZATION")?new WDe(s.shape,i,o,a,l):new HDe(s.shape,i,o,a,l);return e.runWebGLProgram(c,[s],s.dtype)}};class GDe{constructor(t,e,r,s,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=r,this.alpha=s,this.beta=i,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${r});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${i})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${i});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const qDe={kernelName:_I,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s,y:i,dy:o}=t,{depthRadius:a,bias:l,alpha:c,beta:u}=r,d=new GDe(s.shape,a,l,c,u);return e.runWebGLProgram(d,[s,i,o],s.dtype)}};function Q4(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reductionIndices:i,keepDims:o}=r,a=s.shape.length,l=mt(i,s.shape);let c=l;const u=An(c,a),d=null!=u,h=e.shouldExecuteOnCPU([s]);let f=s;if(d){if(h){const _=e.texData.get(f.dataId).values,v=new Array(a);for(let E=0;E<v.length;E++)v[E]=s.shape[u[E]];const w=MT(_,s.shape,s.dtype,u,v);f=e.makeTensorInfo(v,s.dtype),e.texData.get(f.dataId).values=w}else f=Av(s,u,e);c=Wn(c.length,a)}Lr("max",c,a);const[p,m]=kr(f.shape,c);let y,g=p;if(o&&(g=Hn(p,l)),h){const _=e.texData.get(f.dataId).values,v=Pwe(_,X(m),g,s.dtype);y=e.makeTensorInfo(g,s.dtype),e.texData.get(y.dataId).values=v}else y=function KDe(n,t,e,r){const s=X(t),a=xe({inputs:{x:n},attrs:{shape:[X(n.shape)/s,s]},backend:r}),l=Uc(a,n.dtype,"max",r),c=xe({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}(f,m,g,e);return d&&e.disposeIntermediateTensorInfo(f),y}const XDe={kernelName:yb,backendName:"webgl",kernelFunc:Q4},QDe=Br({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Lwe}),JDe={kernelName:ip,backendName:"webgl",kernelFunc:QDe},t1e={kernelName:bb,backendName:"webgl",kernelFunc:function e1e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t;gm(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r;S(Pr(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const u=Li(s.shape,i,o,1,a,l);if(1===u.filterWidth&&1===u.filterHeight&&Rt(u.inShape,u.outShape))return Ks({inputs:{x:s},backend:e});const d=new xm(u,"max",!1);return e.runWebGLProgram(d,[s],s.dtype)}},r1e={kernelName:_b,backendName:"webgl",kernelFunc:function n1e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,d=Sa(s.shape,i,o,[1,1,1],a,c,l),h=new $T(d,"max",!1);return e.runWebGLProgram(h,[s],s.dtype)}};class s1e{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const i=t.effectiveFilterHeight,o=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${i-1-t.padInfo.top}, ${o-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${i*o-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${o} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class i1e{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const l=t.effectiveFilterDepth,c=t.effectiveFilterHeight,u=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${l-1-t.padInfo.front}, ${c-1-t.padInfo.top}, ${u-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${l*c*u-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${c} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const a1e={kernelName:xI,backendName:"webgl",kernelFunc:function o1e(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i}=t,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,h=Sa(o.shape,a,l,[1,1,1],c,u),f=new $T(h,"max",!0),p=e.runWebGLProgram(f,[o],o.dtype),m=new i1e(h),g=e.runWebGLProgram(m,[s,p],o.dtype);return e.disposeIntermediateTensorInfo(p),g}},c1e={kernelName:vI,backendName:"webgl",kernelFunc:function l1e(n){const{inputs:t,backend:e,attrs:r}=n,{dy:s,input:i,output:o}=t,a=i;gm([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=r,h=Li(a.shape,l,c,1,u,d),p=new xm(h,"max",!0),m=e.runWebGLProgram(p,[a],a.dtype),g=new s1e(h),y=e.runWebGLProgram(g,[s,m],a.dtype);return e.disposeIntermediateTensorInfo(m),y}},d1e={kernelName:wI,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=t,l=e;S(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];S(Pr(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const u=Li(r.shape,s,i,c,o),[d,h]=function u1e(n,t,e,r){let s=new xm(e,"max",!1);const i=r.runWebGLProgram(s,[n],"float32");return s=new xm(e,"max",!0,!0,t),[i,r.runWebGLProgram(s,[n],"float32")]}(r,a,u,l);return[d,h]}},f1e={kernelName:vb,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{keepDims:s,axis:i}=t,o=e,a=r.shape.length,l=mt(i,r.shape);let c=l;const u=An(c,a),d=null!=u,h=o.shouldExecuteOnCPU([r]),f=[];let p=r;if(d){if(h){const v=o.texData.get(p.dataId).values,w=new Array(a);for(let D=0;D<w.length;D++)w[D]=r.shape[u[D]];const C=MT(v,r.shape,r.dtype,u,w);p=o.makeTensorInfo(w,r.dtype),o.texData.get(p.dataId).values=C}else p=Av(r,u,o);f.push(p),c=Wn(c.length,a)}Lr("sum",c,a);const[m,g]=kr(p.shape,c);let y=m;s&&(y=Hn(m,l));const b=function h1e(n,t,e,r){const s=X(t),a=xe({inputs:{x:n},attrs:{shape:[X(n.shape)/s,s]},backend:r}),l=Uc(a,"float32","mean",r),c=xe({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}(p,g,y,o);for(const _ of f)o.disposeIntermediateTensorInfo(_);return b}},m1e={kernelName:xb,backendName:"webgl",kernelFunc:function p1e(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,l=mt(i,s.shape);let c=l;const u=An(c,a);let d=s;null!=u&&(d=ps({inputs:{x:s},backend:e,attrs:{perm:u}}),c=Wn(c.length,s.shape.length)),Lr("min",c,a);const[h,f]=kr(d.shape,c),m=xe({inputs:{x:d},backend:e,attrs:{shape:[-1,X(f)]}}),g=Uc(m,m.dtype,"min",e);let y;return y=xe(o?{inputs:{x:g},backend:e,attrs:{shape:Hn(h,l)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(g),null!=u&&e.disposeIntermediateTensorInfo(d),y}},b1e=Br({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:Bwe}),_1e={kernelName:op,backendName:"webgl",kernelFunc:b1e};class v1e{constructor(t,e,r){this.variableNames=["x"],this.outputShape=e.map((u,d)=>u[0]+t[d]+u[1]);const s=t.length,i=dn(s),o=e.map(u=>u[0]).join(","),a=e.map((u,d)=>u[0]+t[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),c="reflect"===r?0:1;this.userCode=1!==s?`\n      ${i} start = ${i}(${o});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${c};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};\n          }\n        }\n        ${i} coords = outC - start;\n        setOutput(getX(${l}));\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${c};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${c};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class x1e{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((p,m)=>p[0]+t[m]+p[1]);const s=t.length,i=dn(s),o=e.map(p=>p[0]).join(","),a=e.map((p,m)=>p[0]+t[m]).join(","),l=fs("rc",s),c=fs("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${c.slice(-2).join()})`,h="reflect"===r?0:1;let f="";if(1===s){const p=`\n        ${i} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;f=`\n        ${i} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${c.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${u}) {\n          ${p}\n          result[1] = getChannel(getX(${c.join()}), ${d});\n        }\n      `}else{const p=`\n        ${i} source = rc;\n        ${i} lt = ${i}(lessThan(source, start));\n        ${i} gte = ${i}(greaterThanEqual(source, end));\n        ${i} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;f=`\n        ${i} rc = outputLoc;\n        ${p}\n        result[0] = getChannel(getX(${c.join()}), ${d});\n        ${l[s-1]} += 1;\n        if(${u}) {\n          ${p}\n          result[1] = getChannel(getX(${c.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${l[s-2]} += 1;\n        if(${l[s-2]} < ${this.outputShape[s-2]}) {\n          ${p}\n          result[2] = getChannel(getX(${c.join()}), ${d});\n          ${l[s-1]} += 1;\n          if(${u}) {\n            ${p}\n            result[3] = getChannel(getX(${c.join()}), ${d});\n          }\n        }\n      `}this.userCode=`\n      const ${i} start = ${i}(${o});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}const w1e={kernelName:wb,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r}=n,{paddings:s,mode:i}=e,o=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new x1e(r.shape,s,i):new v1e(r.shape,s,i);return t.runWebGLProgram(o,[r],r.dtype)}},I1e=Br({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),E1e={kernelName:ap,backendName:"webgl",kernelFunc:I1e};class D1e{constructor(t,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const J4=Br({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),T1e={kernelName:jf,backendName:"webgl",kernelFunc:J4},eH="return a - b;",tH=Br({opSnippet:eH,packedOpSnippet:eH,supportsComplex:!0,cpuKernelImpl:iCe}),k1e={kernelName:Cp,backendName:"webgl",kernelFunc:tH};function nH(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{dim:i}=r,o=mt([i],s.shape),a=Q4({inputs:{x:s},backend:e,attrs:{reductionIndices:o,keepDims:!1}}),l=Hn(a.shape,o),c=xe({inputs:{x:a},backend:e,attrs:{shape:l}}),u=tH({inputs:{a:s,b:c},backend:e}),d=G4({inputs:{x:u},backend:e}),h=Rv({inputs:{x:d},backend:e,attrs:{axis:o,keepDims:!1}}),f=xe({inputs:{x:h},backend:e,attrs:{shape:l}}),p=J4({inputs:{a:d,b:f},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),p}const N1e={kernelName:Vb,backendName:"webgl",kernelFunc:nH},R1e={kernelName:CI,backendName:"webgl",kernelFunc:function A1e(n){const{inputs:t,backend:e,attrs:r}=n,{logits:s}=t,{numSamples:i,seed:o,normalized:a}=r,l=a?s:nH({inputs:{logits:s},backend:e,attrs:{dim:s.shape.length-1}}),d=new D1e(l.shape[0],l.shape[1],i),f=e.runWebGLProgram(d,[l],"int32",[[o]]);return a||e.disposeIntermediateTensorInfo(l),f}},$1e={kernelName:Cb,backendName:"webgl",kernelFunc:function O1e(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])){const i=e.texData.get(r.dataId),[o,a]=zwe(i.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,o)}let s;return s=G().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Rl(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Yo(r.shape,"if (isnan(x)) return x;\n  return -x;\n"),e.runWebGLProgram(s,[r],r.dtype)}},P1e=CD,B1e={kernelName:SI,backendName:"webgl",kernelFunc:function L1e(n){ui("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r,c=e.readSync(s.dataId),u=e.readSync(i.dataId),{selectedIndices:d}=P1e(c,u,o,a,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},V1e=SD,U1e={kernelName:II,backendName:"webgl",kernelFunc:function z1e(n){ui("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r,u=e.readSync(s.dataId),d=e.readSync(i.dataId),{selectedIndices:h,validOutputs:f}=V1e(u,d,o,a,l,c);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},H1e=ID,j1e={kernelName:EI,backendName:"webgl",kernelFunc:function W1e(n){ui("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:s,scores:i}=t,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,u=e.readSync(s.dataId),d=e.readSync(i.dataId),h=o,f=a,p=l,m=c,{selectedIndices:g,selectedScores:y}=H1e(u,d,h,f,p,m);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class G1e{constructor(t,e,r,s){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${r}),\n                      float(index == coords.y)));\n      }\n    `}}const q1e={kernelName:Eb,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{indices:s}=t,{dtype:i,depth:o,onValue:a,offValue:l}=r,c=X(s.shape),u=new G1e(c,o,a,l),d=xe({inputs:{x:s},backend:e,attrs:{shape:[c]}}),h=e.runWebGLProgram(u,[d],i);e.disposeIntermediateTensorInfo(d);const p=xe({inputs:{x:h},backend:e,attrs:{shape:[...s.shape,o]}});return e.disposeIntermediateTensorInfo(h),p}};function Lv(n){const{inputs:t,backend:e}=n,{x:r}=t;if("complex64"===r.dtype){const s=wm({inputs:{input:r},backend:e}),i=Lv({inputs:{x:s},backend:e}),o=$v({inputs:{input:r},backend:e}),a=Lv({inputs:{x:o},backend:e}),l=Ml({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return Sm({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:e})}const K1e={kernelName:Hb,backendName:"webgl",kernelFunc:Lv},X1e={kernelName:Ib,backendName:"webgl",kernelFunc:function rH(n){const{inputs:t,backend:e}=n,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const s=wm({inputs:{input:r},backend:e}),i=rH({inputs:{x:s},backend:e}),o=$v({inputs:{input:r},backend:e}),a=Lv({inputs:{x:o},backend:e}),l=Ml({inputs:{real:i,imag:a},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),l}return Sm({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}},Z1e={kernelName:Db,backendName:"webgl",kernelFunc:function Y1e(n){const{inputs:t,backend:e,attrs:r}=n,{axis:s}=r;if(1===t.length)return BT({inputs:{input:t[0]},backend:e,attrs:{dim:s}});const i=t[0].shape,o=t[0].dtype;t.forEach(u=>{Vs(i,u.shape,"All tensors passed to stack must have matching shapes"),S(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],c=O4({inputs:t.map(u=>{const d=BT({inputs:{input:u},backend:e,attrs:{dim:s}});return a.push(d),d}),backend:e,attrs:{axis:s}});return a.forEach(u=>e.disposeIntermediateTensorInfo(u)),c}};class Q1e{constructor(t,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((c,u)=>c[0]+t[u]+c[1]);const s=t.length,i=dn(s),o=e.map(c=>c[0]).join(","),a=e.map((c,u)=>c[0]+t[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${i} start = ${i}(${o});\n      ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${i} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class J1e{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((m,g)=>m[0]+t[g]+m[1]);const s=t.length,i=dn(s),o=e.map(m=>m[0]).join(","),a=e.map((m,g)=>m[0]+t[g]).join(","),l=fs("rc",s),c=fs("source",s),u=`${l[s-1]} < ${this.outputShape[s-1]}`,d=1===s?"source":`vec2(${c.slice(-2).join()})`,h=[`${i} rc = outputLoc;`,`${l[s-1]} += 1;\n       if(${u}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${l[s-2]} += 1;\n       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${l[s-1]} += 1;\n         if(${u}) {`],f=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let m=0,g=1===s?2:4;m<g;m++)p+=`\n        ${h[m]}\n        if (${f}) {\n          result[${m}] = float(value);\n        } else {\n          ${i} source = rc - start;\n          result[${m}] = getChannel(getX(${c.join()}), ${d});\n        }\n      `;p+=1===s?"} ":"}}",this.userCode=`\n      const ${i} start = ${i}(${o});\n      const ${i} end = ${i}(${a});\n\n      void main() {\n        ${i} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const sH=n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{paddings:i,constantValue:o}=r;if(0===X(s.shape))return Sm({backend:e,attrs:{shape:i.map((u,d)=>u[0]+s.shape[d]+u[1]),value:o,dtype:s.dtype}});const a=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new J1e(s.shape,i,o):new Q1e(s.shape,i,o);return e.runWebGLProgram(a,[s],s.dtype,[[o]])},eTe={kernelName:Tb,backendName:"webgl",kernelFunc:sH},rTe=Br({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),sTe={kernelName:cp,backendName:"webgl",kernelFunc:rTe},oTe={kernelName:Nb,backendName:"webgl",kernelFunc:function iTe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{axis:i,keepDims:o}=r,a=s.shape.length,l=[],c=mt(i,s.shape);let u=c;const d=An(u,a);let f,h=s;if(null!=d&&(h=ps({inputs:{x:s},backend:e,attrs:{perm:d}}),u=Wn(u.length,a),l.push(h)),Lr("prod",u,a),e.shouldExecuteOnCPU([h])){const p=e.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:y}=Hwe(h.shape,h.dtype,p,u);f=e.makeTensorInfo(g,y,m)}else{const[p,m]=kr(h.shape,u),g=X(m),y=xe({inputs:{x:h},backend:e,attrs:{shape:[-1,g]}}),_=Uc(y,rE(s.dtype),"prod",e);f=xe({inputs:{x:_},backend:e,attrs:{shape:p}}),l.push(y),l.push(_)}if(o){l.push(f);const p=Hn(f.shape,c);f=xe({inputs:{x:f},backend:e,attrs:{shape:p}})}return l.forEach(p=>e.disposeIntermediateTensorInfo(p)),f}},lTe={kernelName:DI,backendName:"webgl",kernelFunc:function aTe(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=t,{outputRaggedRank:a}=r,l=s.map(y=>e.readSync(y.dataId)),c=s.map(y=>y.shape),u=e.readSync(i.dataId),d=e.readSync(o.dataId),[h,f,p]=Wwe(l,c,u,i.shape,i.dtype,d,o.shape,a),m=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),g=e.makeTensorInfo(p,i.dtype,f);return m.concat([g])}},uTe={kernelName:TI,backendName:"webgl",kernelFunc:function cTe(n){const{inputs:t,backend:e}=n,{starts:r,limits:s,deltas:i}=t,o=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(i.dataId),[c,u]=jwe(o,r.shape,r.dtype,a,s.shape,l,i.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([u.length],r.dtype,u)]}},hTe={kernelName:kI,backendName:"webgl",kernelFunc:function dTe(n){const{inputs:t,backend:e,attrs:r}=n,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=t,{rowPartitionTypes:l}=r,c=e.readSync(s.dataId),u=e.readSync(i.dataId),d=e.readSync(o.dataId),h=a.map(g=>e.readSync(g.dataId)),f=a.map(g=>g.shape),[p,m]=Gwe(c,s.shape,u,i.shape,i.dtype,d,o.shape,h,f,l);return e.makeTensorInfo(p,i.dtype,m)}},iH=n=>{const{backend:t,attrs:e}=n,{start:r,stop:s,step:i,dtype:o}=e,a=qwe(r,s,i,o);return t.makeTensorInfo([a.length],o,a)},fTe={kernelName:NI,backendName:"webgl",kernelFunc:iH},pTe=Ot({opSnippet:"return 1.0 / x;"}),mTe={kernelName:up,backendName:"webgl",kernelFunc:pTe},yTe=Ot({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),bTe={kernelName:dp,backendName:"webgl",kernelFunc:yTe},vTe=Ot({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),xTe={kernelName:hp,backendName:"webgl",kernelFunc:vTe};class wTe{constructor(t,e,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=i?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class CTe{constructor(t,e,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let h;h=i?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]},\n          ${u[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const ITe={kernelName:Mb,backendName:"webgl",kernelFunc:function STe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=G().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new CTe(s.shape,l,c,i,o):new wTe(s.shape,l,c,i,o);return e.runWebGLProgram(u,[s],"float32")}};class ETe{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,i]=e,[,o,a]=t,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],d=l[1]/c[1],h=1/u,f=1/d,p=2*Math.ceil(h)+2,m=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const TTe={kernelName:MI,backendName:"webgl",kernelFunc:function DTe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r,a=new ETe(i.shape,s.shape,o);return e.runWebGLProgram(a,[i],i.dtype)}};class kTe{constructor(t,e,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let f;f=i?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class NTe{constructor(t,e,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=t;this.outputShape=[o,e,r,c];const u=[s&&e>1?a-1:a,s&&r>1?l-1:l],d=[s&&e>1?e-1:e,s&&r>1?r-1:r];let f;f=i?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/d[0]},\n          ${u[1]/d[1]},\n          ${u[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${s?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${r-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const RTe={kernelName:Rb,backendName:"webgl",kernelFunc:function ATe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s}=t,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,c]=a,u=G().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new NTe(s.shape,l,c,i,o):new kTe(s.shape,l,c,i,o);return e.runWebGLProgram(u,[s],s.dtype)}};class MTe{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,s,i]=e,[,o,a]=t,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],d=l[1]/c[1],h=1/u,f=1/d,p=2*Math.ceil(h)+2,m=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${m});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${l[0]}) *\n                (float(dyR) / float(${c[0]}));\n\n            float sourceFracCol =\n                float(${l[1]}) *\n                  (float(dyC) / float(${c[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${r} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${i}) - 1),\n                ${r} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const OTe={kernelName:RI,backendName:"webgl",kernelFunc:function FTe(n){const{inputs:t,backend:e,attrs:r}=n,{images:s,dy:i}=t,{alignCorners:o}=r,a=new MTe(i.shape,s.shape,o);return e.runWebGLProgram(a,[i],i.dtype)}};class $Te{constructor(t,e){this.variableNames=["x"];const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const i=t.map((a,l)=>(a=>-1!==e.indexOf(a)&&1!==t[a]?`${t[a]} - coords[${a}] - 1`:`coords[${a}]`)(l)).join(","),o=dn(r);this.userCode=`\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}class PTe{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;const s=fs("rc",r),i=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,o=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=dn(r);function h(p){const m=t.map((b,_)=>function f(p,m){return-1!==e.indexOf(p)&&1!==t[p]?`${t[p]} - ${m[p]} - 1`:`${m[p]}`}(_,p));return`getChannel(getX(${m.join(",")}), vec2(${m.slice(-2).join(",")}))`}this.userCode=1===r?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${i}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function l(p){return h(p)}(s.slice())};\n          if(${i}){\n            result.g = ${function c(p){return p[r-1]="("+p[r-1]+" + 1)",h(p)}(s.slice())};\n          }\n          if(${o}) {\n            result.b = ${function u(p){return p[r-2]="("+p[r-2]+" + 1)",h(p)}(s.slice())};\n            if(${i}) {\n              result.a = ${function d(p){return p[r-1]="("+p[r-1]+" + 1)",p[r-2]="("+p[r-2]+" + 1)",h(p)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const BTe={kernelName:Fb,backendName:"webgl",kernelFunc:function LTe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{dims:i}=r,o=s.shape.length,a=mt(i,s.shape);if(0===o)return Ks({inputs:{x:s},backend:e});const l=G().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PTe(s.shape,a):new $Te(s.shape,a);return e.runWebGLProgram(l,[s],s.dtype)}};class VTe{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=t[1],s=t[2];this.outputShape=t;let i="";i="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${i}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const zTe={kernelName:YI,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=t,a=e,l=new VTe(r.shape,i),[c,u]=LD(o,r.shape[1],r.shape[2]),d=[[c,u,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,d)}},UTe=Ot({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),HTe={kernelName:fp,backendName:"webgl",kernelFunc:UTe},WTe=Ot({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Kwe}),jTe={kernelName:pp,backendName:"webgl",kernelFunc:WTe};class oH{constructor(t,e,r,s,i,o,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const l=dn(i.length),c=dn(o.length);let u="";1===r?u="i":2===r&&(u="i, j");let h="";1===s?h="i":2===s&&(h="i, coords[1]"),this.userCode=`\n        ${l} strides = ${l}(${i});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${u}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${h});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const qTe={kernelName:FI,backendName:"webgl",kernelFunc:function GTe(n){const{inputs:t,backend:e,attrs:r}=n,{indices:s,updates:i}=t,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=qp(0,s,o),h=[d/c,c];if(0===d)return e.makeTensorInfo(o,s.dtype);const f=xe({inputs:{x:s},backend:e,attrs:{shape:[l,a]}}),p=xe({inputs:{x:i},backend:e,attrs:{shape:[l,c]}}),m=e.makeTensorInfo([],"float32",new Float32Array([0])),g=new oH(l,a,f.shape.length,p.shape.length,u,h),y=e.runWebGLProgram(g,[p,f,m],p.dtype),b=xe({inputs:{x:y},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(m),b}};class KTe{constructor(t,e,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,r];const o=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=2===G().getNumber("WEBGL_VERSION")?"while (left < right) {":o;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===s?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const YTe={kernelName:OI,backendName:"webgl",kernelFunc:function XTe(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:s,values:i}=t,{side:o}=r,a=new KTe(s.shape[0],s.shape[1],i.shape[1],o);return e.runWebGLProgram(a,[s,i],"int32",[[s.shape[1]]])}};class ZTe{constructor(t,e,r){let s,i;if(this.variableNames=["c","a","b"],this.outputShape=e,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)i="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<e.length;u++)c.push(`${a[u]}`),u<t&&l.push(`${a[u]}`);s=l.join(),i=c.join()}const o=dn(r);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${i}));\n        } else {\n          setOutput(getB(${i}));\n        }\n      }\n    `}}const JTe={kernelName:Ob,backendName:"webgl",kernelFunc:function QTe(n){const{inputs:t,backend:e}=n,{condition:r,t:s,e:i}=t,o=new ZTe(r.shape.length,s.shape,s.shape.length);return e.runWebGLProgram(o,[r,s,i],zs(s.dtype,i.dtype))}},tke=Ot({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${O_};\n  float scale = ${$_};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),nke={kernelName:mp,backendName:"webgl",kernelFunc:tke},ske=Ot({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Ywe}),ike={kernelName:_p,backendName:"webgl",kernelFunc:ske},oke=Ot({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),ake={kernelName:bp,backendName:"webgl",kernelFunc:oke},cke=Ot({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),uke={kernelName:gp,backendName:"webgl",kernelFunc:cke},dke=Ot({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),hke={kernelName:yp,backendName:"webgl",kernelFunc:dke},fke=Ot({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),pke={kernelName:vp,backendName:"webgl",kernelFunc:fke},mke={kernelName:Lb,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{blockShape:i,paddings:o}=r;S(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((y,b)=>y*b),l=[[0,0]];l.push(...o);for(let y=1+i.length;y<s.shape.length;++y)l.push([0,0]);const c=[],u=sH({inputs:{x:s},backend:e,attrs:{paddings:l,constantValue:0}}),d=Kp(u.shape,i,a,!1),h=Xp(d.length,i.length,!1),f=Yp(u.shape,i,a,!1),p=xe({inputs:{x:u},backend:e,attrs:{shape:d}}),m=ps({inputs:{x:p},backend:e,attrs:{perm:h}}),g=xe({inputs:{x:m},backend:e,attrs:{shape:f}});return c.push(u),c.push(p),c.push(m),c.forEach(y=>e.disposeIntermediateTensorInfo(y)),g}},yke={kernelName:$I,backendName:"webgl",kernelFunc:function gke(n){const{inputs:t,backend:e}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${i.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const a=e.readSync(r.dataId),l=e.readSync(s.dataId),c=e.readSync(i.dataId),u=e.readSync(o.dataId)[0],[d,h,f,p,m]=Qwe(a,r.shape,r.dtype,l,s.dtype,c,u);return[e.makeTensorInfo(h,r.dtype,d),e.makeTensorInfo([h[0]],s.dtype,f),e.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(g=>Number(g)))),e.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},_ke={kernelName:PI,backendName:"webgl",kernelFunc:function bke(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:s,newShape:i}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(e.readSync(s.dataId)),a=e.readSync(r.dataId),l=Array.from(e.readSync(i.dataId)),[c,u,d]=Jwe(a,r.shape,r.dtype,o,l);return[e.makeTensorInfo(u,r.dtype,c),e.makeTensorInfo([d.length],i.dtype,new Int32Array(d))]}},xke={kernelName:LI,backendName:"webgl",kernelFunc:function vke(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${i.shape}`);const o=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(i.dataId),[c,u]=u4(o,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(u,r.dtype,c)}},Cke={kernelName:BI,backendName:"webgl",kernelFunc:function wke(n){const{inputs:t,backend:e}=n,{data:r,indices:s,segmentIds:i}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${i.shape}`);const o=e.readSync(r.dataId),a=e.readSync(s.dataId),l=e.readSync(i.dataId),[c,u]=u4(o,r.shape,r.dtype,a,l);return e.makeTensorInfo(u,r.dtype,c)}},Ike={kernelName:VI,backendName:"webgl",kernelFunc:function Ske(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=t,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:h}=qp(0,s,a);if("string"===i.dtype){const y=e.bufferSync(s),b=e.bufferSync(i),_=al(e.readSync(o.dataId)[0]),v=Xwe(y,b,a,h,u,c,l,d,_,!1);return e.makeTensorInfo(a,v.dtype,v.values)}const p=new oH(c,l,s.shape.length,i.shape.length,d,[h,1],!1),m=e.runWebGLProgram(p,[i,s,o],i.dtype),g=xe({inputs:{x:m},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(m),g}},Dke={kernelName:Bb,backendName:"webgl",kernelFunc:function Eke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{numOrSizeSplits:i,axis:o}=r,a=mt(o,s.shape)[0],l=t1(s,i,a),u=new Array(s.shape.length).fill(0),d=s.shape.slice();return l.map(h=>{const f=[...d];f[a]=h;const p=Zd({inputs:{x:s},backend:e,attrs:{begin:u,size:f}});return u[a]+=h,p})}},aH="return sqrt(x);",Tke=Ot({opSnippet:aH,packedOpSnippet:aH,cpuKernelImpl:eCe}),kke={kernelName:xp,backendName:"webgl",kernelFunc:Tke},Ake={kernelName:zI,backendName:"webgl",kernelFunc:Ot({opSnippet:"return x * x;"})},lH="return (a - b) * (a - b);",Rke=Br({opSnippet:lH,packedOpSnippet:lH}),Mke={kernelName:wp,backendName:"webgl",kernelFunc:Rke},Oke={kernelName:Dp,backendName:"webgl",kernelFunc:function Fke({inputs:n,attrs:t,backend:e}){const{x:r}=n,i=new Yo(r.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return e.runWebGLProgram(i,[r],r.dtype)}};class $ke{constructor(t,e,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,i=dn(r.length),o=dn(r.length);let a="";if(1===s)a="coords * strides + begin";else{let l=0;a=r.map((c,u)=>(l++,1===r.length?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`\n      ${i} begin = ${i}(${t});\n      ${i} strides = ${i}(${e});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const Lke={kernelName:UI,backendName:"webgl",kernelFunc:function Pke(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:f,finalShape:p,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:_,strides:v}=FE(s.shape,i,o,a,l,c,u,d,h);let w;if(m)w=xe({inputs:{x:s},backend:e,attrs:{shape:p}});else if(g||y){S(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const E=AE(b,_,v),D=Zd({inputs:{x:s},backend:e,attrs:{begin:b,size:E}});w=xe({inputs:{x:D},backend:e,attrs:{shape:p}}),e.disposeIntermediateTensorInfo(D)}else if(e.shouldExecuteOnCPU([s])){const D=e.readSync(s.dataId),T=lt(s.shape,s.dtype,D),N=tCe(f,T,v,b);w=e.makeTensorInfo(p,s.dtype,N.values)}else{const D=new $ke(b,v,f);w=e.runWebGLProgram(D,[s],s.dtype)}const C=xe({inputs:{x:w},backend:e,attrs:{shape:p}});return e.disposeIntermediateTensorInfo(w),C}},Vke={kernelName:HI,backendName:"webgl",kernelFunc:function Bke(n){const{inputs:t,backend:e,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:d}=t,h=e.readSync(u.dataId),f=e.readSync(d.dataId),[p,m]=nCe(h,f,s,i,o,a,l,c);return[e.makeTensorInfo([p.length],"string",p),e.makeTensorInfo(d.shape,"int32",m)]}},Uke={kernelName:WI,backendName:"webgl",kernelFunc:function zke(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=e.readSync(i.dataId),l=e.readSync(o.dataId)[0],[c,u,d]=rCe(a,l,s),h=u.length;return[e.makeTensorInfo([h,2],"int32",c),e.makeTensorInfo([h],"string",u),e.makeTensorInfo([2],"int32",new Int32Array(d))]}},Wke={kernelName:jI,backendName:"webgl",kernelFunc:function Hke(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:s}=r,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const o=e.readSync(i.dataId),a=sCe(o,s);return e.makeTensorInfo(i.shape,"int32",a)}},jke=Ot({opSnippet:"return tan(x);"}),Gke={kernelName:Sp,backendName:"webgl",kernelFunc:jke},qke=Ot({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),Kke={kernelName:Ip,backendName:"webgl",kernelFunc:qke};class Xke{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let o=0;o<r.length;o++)r[o]=t[o]*e[o];this.outputShape=r,this.rank=r.length;const s=dn(this.rank),i=function Yke(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${e[s]}, ${n[s]})`);return r.join()}(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}function cH(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{reps:i}=r;if("string"===s.dtype||s.shape.length>5){const l=e.readSync(s.dataId),c="string"===s.dtype?l.map(h=>al(h)):l,u=lt(s.shape,s.dtype,c),d=oCe(u,i);return e.makeTensorInfo(d.shape,d.dtype,d.values)}const o=new Xke(s.shape,i);return e.runWebGLProgram(o,[s],s.dtype)}const Zke={kernelName:Ep,backendName:"webgl",kernelFunc:cH};class Qke{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class Jke{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function Hc(n,t){null!==t&&n.disposeIntermediateTensorInfo(t)}function uH(n){let t=1;for(;t<n;)t*=2;return t}const tNe={kernelName:GI,backendName:"webgl",kernelFunc:function eNe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s}=t,{k:i,sorted:o}=r,a=G().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=G().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=s.shape,u=c[c.length-1];if(e.shouldExecuteOnCPU([s])||u<a||i>l){const N=e.readSync(s.dataId),[P,U]=aCe(N,c,s.dtype,i,o);return[e.makeTensorInfo(P.shape,P.dtype,P.values),e.makeTensorInfo(U.shape,U.dtype,U.values)]}if(0===i)return c[c.length-1]=0,[e.makeTensorInfo(c,s.dtype,[]),e.makeTensorInfo(c,"int32",[])];if(1===u)return[s,Sm({attrs:{shape:c,dtype:"int32",value:0},backend:e})];const d=e.texData.get(s.dataId),h=null!==d&&d.isPacked,f=h?e.unpackTensor(s):s,m=X(c)/u,g=xe({inputs:{x:f},attrs:{shape:[m,u]},backend:e});h&&Hc(e,f);const y=uH(i),b=uH(u);let _=null;const v=()=>null===_?[g,g]:[g,_],w=(N,P,U)=>{const j=v(),q=new Qke(U),V=_;_=e.runWebGLProgram(q,j,"int32",[[u],[null===_?1:0],[Number.NEGATIVE_INFINITY],[N],[P]]),Hc(e,V)};for(let N=1;N<y;N*=2){const P=2*N;for(let U=N;U>=1;U/=2)w(P,U,[m,b])}for(let N=b;N>y;N/=2){const P=v(),U=new Jke([m,N/2]),K=_;_=e.runWebGLProgram(U,P,"int32",[[u],[null===_?1:0],[y]]),Hc(e,K);const $=y/2,V=2*$;for(let L=$;L>=1;L/=2)w(V,L,_.shape)}let C=_;_=Zd({inputs:{x:_},backend:e,attrs:{begin:0,size:[m,i]}}),Hc(e,C);let E=Z4({inputs:{x:g,indices:_},backend:e,attrs:{axis:1,batchDims:1}});Hc(e,g);const D=c.slice(0,-1);D.push(i),C=_,_=xe({inputs:{x:_},attrs:{shape:D},backend:e}),Hc(e,C);const T=E;return E=xe({inputs:{x:E},attrs:{shape:D},backend:e}),Hc(e,T),[E,_]}};class nNe{constructor(t,e,r,s,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a="nearest"===r?1:2;let l;switch(s){case"constant":default:l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${l} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${i});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${i});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const sNe={kernelName:qI,backendName:"webgl",kernelFunc:function rNe(n){const{inputs:t,backend:e,attrs:r}=n,{image:s,transforms:i}=t,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=r,[u,d,h,f]=s.shape,[p,m]=c??[d,h],y=new nNe(d,h,o,a,l,[u,p,m,f]);return e.runWebGLProgram(y,[s,i],"float32")}},oNe={kernelName:KI,backendName:"webgl",kernelFunc:function iNe(n){const{inputs:t,attrs:e,backend:r}=n,{axis:s}=e,{x:i}=t;gm(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(i.dataId),{outputValues:a,outputShape:l,indices:c}=lCe(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}},lNe={kernelName:zb,backendName:"webgl",kernelFunc:function aNe(n){const{inputs:t,backend:e,attrs:r}=n,{value:s}=t;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s,a=o.shape.length,l=s.shape[i],c=new Array(a-1);let u=0;for(let m=0;m<a;m++)m!==i&&(c[u++]=o.shape[m]);const d=[],h=new Array(a).fill(0),f=o.shape.slice();f[i]=1;const p=new Array(l);for(let m=0;m<p.length;m++){h[i]=m;const g=Zd({inputs:{x:o},backend:e,attrs:{begin:h,size:f}}),y=xe({inputs:{x:g},backend:e,attrs:{shape:c}});p[m]=y,d.push(g)}return d.forEach(m=>e.disposeIntermediateTensorInfo(m)),p}};class cNe{constructor(t,e){this.variableNames=["x","segmentIds"];const r=t.windowSize,s=t.batchSize,i=t.inSize,o=t.numSegments,a=o*Math.ceil(i/r);this.outputShape=[s,a];const u=4*Math.floor(r/4),d=r%4,h="\n        sumValue += dot(values, segFilter);\n    ";let f="";i%r>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `);let p="";i%r>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${p}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${r}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}const hNe=[nSe,sSe,aSe,uSe,hSe,mSe,ySe,_Se,CSe,ISe,TSe,ASe,FSe,LSe,zSe,HSe,jSe,XSe,ZSe,JSe,nIe,lIe,uIe,hIe,yIe,_Ie,CIe,BCe,EIe,AIe,OIe,zIe,HIe,jIe,qIe,XIe,QIe,eEe,nEe,sEe,oEe,lEe,dEe,fEe,yEe,_Ee,wEe,IEe,DEe,kEe,REe,FEe,PEe,BEe,VEe,UEe,WEe,GEe,KEe,YEe,QEe,tDe,sDe,oDe,cDe,hDe,pDe,gDe,LCe,bDe,kIe,vDe,wDe,SDe,zCe,EDe,TDe,NDe,MDe,$De,LDe,VDe,UDe,jDe,qDe,XDe,JDe,t1e,r1e,a1e,c1e,d1e,f1e,m1e,_1e,w1e,E1e,R1e,WCe,$1e,B1e,U1e,j1e,fIe,q1e,X1e,Z1e,eTe,sTe,HCe,oTe,lTe,uTe,hTe,fTe,pIe,T1e,mTe,bTe,xTe,GCe,ITe,TTe,RTe,OTe,BTe,zTe,HTe,jTe,qTe,YTe,JTe,nke,ike,ake,uke,hke,aIe,N1e,pke,mke,yke,_ke,xke,Cke,Ike,Dke,kke,Ake,Mke,Oke,Lke,Vke,Uke,Wke,k1e,JCe,Gke,Kke,Zke,tNe,sNe,eSe,oNe,lNe,{kernelName:Ub,backendName:"webgl",kernelFunc:function uNe(n){const{inputs:t,backend:e,attrs:r}=n,{x:s,segmentIds:i}=t,{numSegments:o}=r,a=s.shape.length,l=[];let c=0;const u=An([c],a);let d=s;null!=u&&(d=ps({inputs:{x:s},backend:e,attrs:{perm:u}}),l.push(d),c=Wn(1,a)[0]);const h=EV(d.shape,c,o),f=X([d.shape[c]]),p=xe({inputs:{x:d},backend:e,attrs:{shape:[-1,f]}});l.push(p);const m=rE(s.dtype),g=(v,w,C,E,D)=>{const T=v.shape[0],N=v.shape[1],P=IV(N,D),j=new cNe({windowSize:P,inSize:N,batchSize:T,numSegments:D},w),q=e.compileAndRun(j,[v,C],E);if(l.push(q),q.shape[1]===D)return q;const K=iH({backend:e,attrs:{start:0,stop:D,step:1,dtype:"float32"}}),$=cH({inputs:{x:K},backend:e,attrs:{reps:[N/P]}});return l.push(K),l.push($),g(q,w,$,E,D)},b=xe({inputs:{x:g(p,"unsortedSegmentSum",i,m,o)},backend:e,attrs:{shape:h}});let _=b;if(null!=u){l.push(b);const v=gl(u);_=ps({inputs:{x:_},backend:e,attrs:{perm:v}})}return l.forEach(v=>e.disposeIntermediateTensorInfo(v)),_}},K1e];for(const n of hNe)JI(n);const pNe=[500,500];function dH(n,t){const e=new Map;for(let r=0;r<t.length;r++){let s=n.findIndex(i=>i===t[r]);-1!==s&&e.set(s,t[r])}return e}var Zo=(()=>{return(n=Zo||(Zo={}))[n.UNINITIALIZED=0]="UNINITIALIZED",n[n.INITIALIZED=1]="INITIALIZED",n[n.PLAYING=2]="PLAYING",Zo;var n})();const hH=["Person","Sneakers","Chair","Other Shoes","Hat","Car","Lamp","Glasses","Bottle","Desk","Cup","Street Lights","Cabinet/shelf","Handbag/Satchel","Bracelet","Plate","Picture/Frame","Helmet","Book","Gloves","Storage box","Boat","Leather Shoes","Flower","Bench","Potted Plant","Bowl/Basin","Flag","Pillow","Boots","Vase","Microphone","Necklace","Ring","SUV","Wine Glass","Belt","Monitor/TV","Backpack","Umbrella","Traffic Light","Speaker","Watch","Tie","Trash bin Can","Slippers","Bicycle","Stool","Barrel/bucket","Van","Couch","Sandals","Basket","Drum","Pen/Pencil","Bus","Wild Bird","High Heels","Motorcycle","Guitar","Carpet","Cell Phone","Bread","Camera","Canned","Truck","Traffic cone","Cymbal","Lifesaver","Towel","Stuffed Toy","Candle","Sailboat","Laptop","Awning","Bed","Faucet","Tent"],mNe=["Person","Sneakers","Chair","Other Shoes","Hat","Car","Lamp","Glasses","Bottle","Desk","Cup","Street Lights","Cabinet/shelf","Handbag/Satchel","Bracelet","Plate","Picture/Frame","Helmet"];class Bv{constructor(){this.modelLoaded=!0,this.modelLoaded$=new li(!1),this.classMap=new Map,this.font="10px sans-serif",this.classMap=dH(hH,mNe),console.log(navigator.platform),console.log(navigator.userAgent),this.model$=Tn(function $pe(n){return aT.apply(this,arguments)}("assets/model/model.json")).pipe(Ue(e=>(e?.inputs[0]?.shape&&([this.modelWidth,this.modelHeight]=e.inputs[0].shape.slice(1,3)),e)),Fi(e=>(console.log(e),Ae(-1))),$n(1)),this.model$.pipe($n(1)).subscribe(e=>{this.graphModel=e,e?.inputs[0]?.shape&&([this.modelWidth,this.modelHeight]=e.inputs[0].shape.slice(1,3),console.log("model loaded"),this.modelLoaded=!0,this.modelLoaded$.next(!0),this.graphModel.disposeIntermediateTensors())})}isModelLoaded(){return this.modelLoaded}checkiOS(){return["iPad Simulator","iPhone Simulator","iPod Simulator","iPad","iPhone","iPod"].includes(navigator.platform)}predict(t,e,r,s){return wy(()=>{if(s&&r){let o=this.getScaledImageRect(r,t);this.drawImageOnCanvas(r,e,[0,0,r.width,r.height],o)}const i=z(()=>Ta.resizeBilinear(Ire(t),[this.modelWidth,this.modelHeight]).div(255).expandDims(0));return Tn(this.graphModel.executeAsync(i)).pipe(Ue(o=>{Je(i),e.font=this.font,e.textBaseline="top";const[a,l,c,u]=o,d=a.dataSync(),h=l.dataSync(),f=c.dataSync(),p=u.dataSync()[0];var m;for(Je(o),m=0;m<p;++m){const g=h[m].toFixed(2);if(!this.classMap.get(f[m])||g<.5)continue;let[y,b,_,v]=d.slice(4*m,4*(m+1));y*=t.width,_*=t.width,b*=t.height,v*=t.height;const w=_-y,C=v-b,E=this.classMap.get(f[m]);e.strokeStyle="#00FFFF",e.lineWidth=1,e.strokeRect(y,b,w,C),e.fillStyle="#00FFFF";const D=e.measureText(E+":"+g).width,T=parseInt(this.font,10);e.fillRect(y,b,D+4,T+1)}for(m=0;m<p;++m){const g=h[m].toFixed(2);if(!this.classMap.get(f[m])||g<.5)continue;let[y,b,,]=d.slice(4*m,4*(m+1));y*=t.width,b*=t.height;const _=this.classMap.get(f[m]);e.fillStyle="#000000",e.fillText(_+":"+g,y,b)}return Je(d),Je(h),Je(f),Je(p),Ae(1)}),$n(1))})}getClassNames(){return this.classMap}setClassNames(t){this.classMap=dH(hH,t)}getScaledImageRect(t,e){const r=Math.min(e.width/t.naturalWidth,e.height/t.naturalHeight),s=Math.round(t.naturalWidth*r),i=Math.round(t.naturalHeight*r);return[(e.width-s)/2,(e.height-i)/2,s,i]}drawImageOnCanvas(t,e,r,s){const[i,o,a,l]=r,[c,u,d,h]=s;e.fillStyle="#000000",e.fillRect(0,0,e.canvas.width,e.canvas.height),e.drawImage(t,i,o,a,l,c,u,d,h)}static#e=this.\u0275fac=function(e){return new(e||Bv)};static#t=this.\u0275cmp=Ur({type:Bv,selectors:[["app-model-import"]],decls:0,vars:0,template:function(e,r){}})}let zT;try{zT=typeof Intl<"u"&&Intl.v8BreakIterator}catch{zT=!1}let Im,Wc,UT,Xs=(()=>{class n{constructor(e){this._platformId=e,this.isBrowser=this._platformId?function nQ(n){return n===G2}(this._platformId):"object"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!zT)&&typeof CSS<"u"&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!("MSStream"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return n.\u0275fac=function(e){return new(e||n)(Z(wC))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function Vv(n){return function yNe(){if(null==Im&&typeof window<"u")try{window.addEventListener("test",null,Object.defineProperty({},"passive",{get:()=>Im=!0}))}finally{Im=Im||!1}return Im}()?n:!!n.capture}function bNe(){if(null==Wc){if("object"!=typeof document||!document||"function"!=typeof Element||!Element)return Wc=!1,Wc;if("scrollBehavior"in document.documentElement.style)Wc=!0;else{const n=Element.prototype.scrollTo;Wc=!!n&&!/\{\s*\[native code\]\s*\}/.test(n.toString())}}return Wc}function jc(n){return n.composedPath?n.composedPath()[0]:n.target}function HT(){return typeof __karma__<"u"&&!!__karma__||typeof jasmine<"u"&&!!jasmine||typeof jest<"u"&&!!jest||typeof Mocha<"u"&&!!Mocha}function th(n,...t){return t.length?t.some(e=>n[e]):n.altKey||n.shiftKey||n.ctrlKey||n.metaKey}class FNe extends Ve{constructor(t,e){super()}schedule(t,e=0){return this}}const Kv={setInterval(n,t,...e){const{delegate:r}=Kv;return r?.setInterval?r.setInterval(n,t,...e):setInterval(n,t,...e)},clearInterval(n){const{delegate:t}=Kv;return(t?.clearInterval||clearInterval)(n)},delegate:void 0};class WT extends FNe{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){var r;if(this.closed)return this;this.state=t;const s=this.id,i=this.scheduler;return null!=s&&(this.id=this.recycleAsyncId(i,s,e)),this.pending=!0,this.delay=e,this.id=null!==(r=this.id)&&void 0!==r?r:this.requestAsyncId(i,this.id,e),this}requestAsyncId(t,e,r=0){return Kv.setInterval(t.flush.bind(t,this),r)}recycleAsyncId(t,e,r=0){if(null!=r&&this.delay===r&&!1===this.pending)return e;null!=e&&Kv.clearInterval(e)}execute(t,e){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const r=this._execute(t,e);if(r)return r;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let s,r=!1;try{this.work(t)}catch(i){r=!0,s=i||new Error("Scheduled action threw falsy error")}if(r)return this.unsubscribe(),s}unsubscribe(){if(!this.closed){const{id:t,scheduler:e}=this,{actions:r}=e;this.work=this.state=this.scheduler=null,this.pending=!1,dt(r,this),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null,super.unsubscribe()}}}const yH={now:()=>(yH.delegate||Date).now(),delegate:void 0};class Em{constructor(t,e=Em.now){this.schedulerActionCtor=t,this.now=e}schedule(t,e=0,r){return new this.schedulerActionCtor(this,t).schedule(r,e)}}Em.now=yH.now;class jT extends Em{constructor(t,e=Em.now){super(t,e),this.actions=[],this._active=!1}flush(t){const{actions:e}=this;if(this._active)return void e.push(t);let r;this._active=!0;do{if(r=t.execute(t.state,t.delay))break}while(t=e.shift());if(this._active=!1,r){for(;t=e.shift();)t.unsubscribe();throw r}}}const Xv=new jT(WT),ONe=Xv;function bH(n,t=Xv){return Mn((e,r)=>{let s=null,i=null,o=null;const a=()=>{if(s){s.unsubscribe(),s=null;const c=i;i=null,r.next(c)}};function l(){const c=o+n,u=t.now();if(u<c)return s=this.schedule(void 0,c-u),void r.add(s);a()}e.subscribe(xn(r,c=>{i=c,o=t.now(),s||(s=t.schedule(l,n),r.add(s))},()=>{a(),r.complete()},void 0,()=>{i=s=null}))})}function _H(n){return or((t,e)=>n<=e)}function vH(n,t=za){return n=n??$Ne,Mn((e,r)=>{let s,i=!0;e.subscribe(xn(r,o=>{const a=t(o);(i||!n(s,a))&&(i=!1,s=a,r.next(o))}))})}function $Ne(n,t){return n===t}function wi(n){return Mn((t,e)=>{Rs(n).subscribe(xn(e,()=>e.complete(),Mr)),!e.closed&&t.subscribe(e)})}function Ys(n){return null!=n&&"false"!=`${n}`}function Dm(n,t=0){return function PNe(n){return!isNaN(parseFloat(n))&&!isNaN(Number(n))}(n)?Number(n):t}function Yv(n){return Array.isArray(n)?n:[n]}function mr(n){return null==n?"":"string"==typeof n?n:`${n}px`}function nh(n){return n instanceof Kt?n.nativeElement:n}const xH=new Set;let rh,LNe=(()=>{class n{constructor(e){this._platform=e,this._matchMedia=this._platform.isBrowser&&window.matchMedia?window.matchMedia.bind(window):VNe}matchMedia(e){return(this._platform.WEBKIT||this._platform.BLINK)&&function BNe(n){if(!xH.has(n))try{rh||(rh=document.createElement("style"),rh.setAttribute("type","text/css"),document.head.appendChild(rh)),rh.sheet&&(rh.sheet.insertRule(`@media ${n} {body{ }}`,0),xH.add(n))}catch(t){console.error(t)}}(e),this._matchMedia(e)}}return n.\u0275fac=function(e){return new(e||n)(Z(Xs))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function VNe(n){return{matches:"all"===n||""===n,media:n,addListener:()=>{},removeListener:()=>{}}}let GT=(()=>{class n{constructor(e,r){this._mediaMatcher=e,this._zone=r,this._queries=new Map,this._destroySubject=new It}ngOnDestroy(){this._destroySubject.next(),this._destroySubject.complete()}isMatched(e){return wH(Yv(e)).some(s=>this._registerQuery(s).mql.matches)}observe(e){let i=aS(wH(Yv(e)).map(o=>this._registerQuery(o).observable));return i=gf(i.pipe($n(1)),i.pipe(_H(1),bH(0))),i.pipe(Ue(o=>{const a={matches:!1,breakpoints:{}};return o.forEach(({matches:l,query:c})=>{a.matches=a.matches||l,a.breakpoints[c]=l}),a}))}_registerQuery(e){if(this._queries.has(e))return this._queries.get(e);const r=this._mediaMatcher.matchMedia(e),i={observable:new Dn(o=>{const a=l=>this._zone.run(()=>o.next(l));return r.addListener(a),()=>{r.removeListener(a)}}).pipe(pc(r),Ue(({matches:o})=>({query:e,matches:o})),wi(this._destroySubject)),mql:r};return this._queries.set(e,i),i}}return n.\u0275fac=function(e){return new(e||n)(Z(LNe),Z(ft))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function wH(n){return n.map(t=>t.split(",")).reduce((t,e)=>t.concat(e)).map(t=>t.trim())}class IH{constructor(t){this._items=t,this._activeItemIndex=-1,this._activeItem=null,this._wrap=!1,this._letterKeyStream=new It,this._typeaheadSubscription=Ve.EMPTY,this._vertical=!0,this._allowedModifierKeys=[],this._homeAndEnd=!1,this._pageUpAndDown={enabled:!1,delta:10},this._skipPredicateFn=e=>e.disabled,this._pressedLetters=[],this.tabOut=new It,this.change=new It,t instanceof zu&&(this._itemChangesSubscription=t.changes.subscribe(e=>{if(this._activeItem){const s=e.toArray().indexOf(this._activeItem);s>-1&&s!==this._activeItemIndex&&(this._activeItemIndex=s)}}))}skipPredicate(t){return this._skipPredicateFn=t,this}withWrap(t=!0){return this._wrap=t,this}withVerticalOrientation(t=!0){return this._vertical=t,this}withHorizontalOrientation(t){return this._horizontal=t,this}withAllowedModifierKeys(t){return this._allowedModifierKeys=t,this}withTypeAhead(t=200){return this._typeaheadSubscription.unsubscribe(),this._typeaheadSubscription=this._letterKeyStream.pipe(ar(e=>this._pressedLetters.push(e)),bH(t),or(()=>this._pressedLetters.length>0),Ue(()=>this._pressedLetters.join(""))).subscribe(e=>{const r=this._getItemsArray();for(let s=1;s<r.length+1;s++){const i=(this._activeItemIndex+s)%r.length,o=r[i];if(!this._skipPredicateFn(o)&&0===o.getLabel().toUpperCase().trim().indexOf(e)){this.setActiveItem(i);break}}this._pressedLetters=[]}),this}cancelTypeahead(){return this._pressedLetters=[],this}withHomeAndEnd(t=!0){return this._homeAndEnd=t,this}withPageUpDown(t=!0,e=10){return this._pageUpAndDown={enabled:t,delta:e},this}setActiveItem(t){const e=this._activeItem;this.updateActiveItem(t),this._activeItem!==e&&this.change.next(this._activeItemIndex)}onKeydown(t){const e=t.keyCode,s=["altKey","ctrlKey","metaKey","shiftKey"].every(i=>!t[i]||this._allowedModifierKeys.indexOf(i)>-1);switch(e){case 9:return void this.tabOut.next();case 40:if(this._vertical&&s){this.setNextItemActive();break}return;case 38:if(this._vertical&&s){this.setPreviousItemActive();break}return;case 39:if(this._horizontal&&s){"rtl"===this._horizontal?this.setPreviousItemActive():this.setNextItemActive();break}return;case 37:if(this._horizontal&&s){"rtl"===this._horizontal?this.setNextItemActive():this.setPreviousItemActive();break}return;case 36:if(this._homeAndEnd&&s){this.setFirstItemActive();break}return;case 35:if(this._homeAndEnd&&s){this.setLastItemActive();break}return;case 33:if(this._pageUpAndDown.enabled&&s){const i=this._activeItemIndex-this._pageUpAndDown.delta;this._setActiveItemByIndex(i>0?i:0,1);break}return;case 34:if(this._pageUpAndDown.enabled&&s){const i=this._activeItemIndex+this._pageUpAndDown.delta,o=this._getItemsArray().length;this._setActiveItemByIndex(i<o?i:o-1,-1);break}return;default:return void((s||th(t,"shiftKey"))&&(t.key&&1===t.key.length?this._letterKeyStream.next(t.key.toLocaleUpperCase()):(e>=65&&e<=90||e>=48&&e<=57)&&this._letterKeyStream.next(String.fromCharCode(e))))}this._pressedLetters=[],t.preventDefault()}get activeItemIndex(){return this._activeItemIndex}get activeItem(){return this._activeItem}isTyping(){return this._pressedLetters.length>0}setFirstItemActive(){this._setActiveItemByIndex(0,1)}setLastItemActive(){this._setActiveItemByIndex(this._items.length-1,-1)}setNextItemActive(){this._activeItemIndex<0?this.setFirstItemActive():this._setActiveItemByDelta(1)}setPreviousItemActive(){this._activeItemIndex<0&&this._wrap?this.setLastItemActive():this._setActiveItemByDelta(-1)}updateActiveItem(t){const e=this._getItemsArray(),r="number"==typeof t?t:e.indexOf(t);this._activeItem=e[r]??null,this._activeItemIndex=r}destroy(){this._typeaheadSubscription.unsubscribe(),this._itemChangesSubscription?.unsubscribe(),this._letterKeyStream.complete(),this.tabOut.complete(),this.change.complete(),this._pressedLetters=[]}_setActiveItemByDelta(t){this._wrap?this._setActiveInWrapMode(t):this._setActiveInDefaultMode(t)}_setActiveInWrapMode(t){const e=this._getItemsArray();for(let r=1;r<=e.length;r++){const s=(this._activeItemIndex+t*r+e.length)%e.length;if(!this._skipPredicateFn(e[s]))return void this.setActiveItem(s)}}_setActiveInDefaultMode(t){this._setActiveItemByIndex(this._activeItemIndex+t,t)}_setActiveItemByIndex(t,e){const r=this._getItemsArray();if(r[t]){for(;this._skipPredicateFn(r[t]);)if(!r[t+=e])return;this.setActiveItem(t)}}_getItemsArray(){return this._items instanceof zu?this._items.toArray():this._items}}class WNe extends IH{setActiveItem(t){this.activeItem&&this.activeItem.setInactiveStyles(),super.setActiveItem(t),this.activeItem&&this.activeItem.setActiveStyles()}}class jNe extends IH{constructor(){super(...arguments),this._origin="program"}setFocusOrigin(t){return this._origin=t,this}setActiveItem(t){super.setActiveItem(t),this.activeItem&&this.activeItem.focus(this._origin)}}function qT(n){return 0===n.buttons||0===n.offsetX&&0===n.offsetY}function KT(n){const t=n.touches&&n.touches[0]||n.changedTouches&&n.changedTouches[0];return!(!t||-1!==t.identifier||null!=t.radiusX&&1!==t.radiusX||null!=t.radiusY&&1!==t.radiusY)}const ZNe=new me("cdk-input-modality-detector-options"),QNe={ignoreKeys:[18,17,224,91,16]},sh=Vv({passive:!0,capture:!0});let JNe=(()=>{class n{constructor(e,r,s,i){this._platform=e,this._mostRecentTarget=null,this._modality=new li(null),this._lastTouchMs=0,this._onKeydown=o=>{this._options?.ignoreKeys?.some(a=>a===o.keyCode)||(this._modality.next("keyboard"),this._mostRecentTarget=jc(o))},this._onMousedown=o=>{Date.now()-this._lastTouchMs<650||(this._modality.next(qT(o)?"keyboard":"mouse"),this._mostRecentTarget=jc(o))},this._onTouchstart=o=>{KT(o)?this._modality.next("keyboard"):(this._lastTouchMs=Date.now(),this._modality.next("touch"),this._mostRecentTarget=jc(o))},this._options={...QNe,...i},this.modalityDetected=this._modality.pipe(_H(1)),this.modalityChanged=this.modalityDetected.pipe(vH()),e.isBrowser&&r.runOutsideAngular(()=>{s.addEventListener("keydown",this._onKeydown,sh),s.addEventListener("mousedown",this._onMousedown,sh),s.addEventListener("touchstart",this._onTouchstart,sh)})}get mostRecentModality(){return this._modality.value}ngOnDestroy(){this._modality.complete(),this._platform.isBrowser&&(document.removeEventListener("keydown",this._onKeydown,sh),document.removeEventListener("mousedown",this._onMousedown,sh),document.removeEventListener("touchstart",this._onTouchstart,sh))}}return n.\u0275fac=function(e){return new(e||n)(Z(Xs),Z(ft),Z(wt),Z(ZNe,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const eAe=new me("liveAnnouncerElement",{providedIn:"root",factory:function tAe(){return null}}),nAe=new me("LIVE_ANNOUNCER_DEFAULT_OPTIONS");let XT=(()=>{class n{constructor(e,r,s,i){this._ngZone=r,this._defaultOptions=i,this._document=s,this._liveElement=e||this._createLiveElement()}announce(e,...r){const s=this._defaultOptions;let i,o;return 1===r.length&&"number"==typeof r[0]?o=r[0]:[i,o]=r,this.clear(),clearTimeout(this._previousTimeout),i||(i=s&&s.politeness?s.politeness:"polite"),null==o&&s&&(o=s.duration),this._liveElement.setAttribute("aria-live",i),this._ngZone.runOutsideAngular(()=>(this._currentPromise||(this._currentPromise=new Promise(a=>this._currentResolve=a)),clearTimeout(this._previousTimeout),this._previousTimeout=setTimeout(()=>{this._liveElement.textContent=e,"number"==typeof o&&(this._previousTimeout=setTimeout(()=>this.clear(),o)),this._currentResolve(),this._currentPromise=this._currentResolve=void 0},100),this._currentPromise))}clear(){this._liveElement&&(this._liveElement.textContent="")}ngOnDestroy(){clearTimeout(this._previousTimeout),this._liveElement?.remove(),this._liveElement=null,this._currentResolve?.(),this._currentPromise=this._currentResolve=void 0}_createLiveElement(){const e="cdk-live-announcer-element",r=this._document.getElementsByClassName(e),s=this._document.createElement("div");for(let i=0;i<r.length;i++)r[i].remove();return s.classList.add(e),s.classList.add("cdk-visually-hidden"),s.setAttribute("aria-atomic","true"),s.setAttribute("aria-live","polite"),this._document.body.appendChild(s),s}}return n.\u0275fac=function(e){return new(e||n)(Z(eAe,8),Z(ft),Z(wt),Z(nAe,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const rAe=new me("cdk-focus-monitor-default-options"),Zv=Vv({passive:!0,capture:!0});let YT=(()=>{class n{constructor(e,r,s,i,o){this._ngZone=e,this._platform=r,this._inputModalityDetector=s,this._origin=null,this._windowFocused=!1,this._originFromTouchInteraction=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=window.setTimeout(()=>this._windowFocused=!1)},this._stopInputModalityDetector=new It,this._rootNodeFocusAndBlurListener=a=>{for(let c=jc(a);c;c=c.parentElement)"focus"===a.type?this._onFocus(a,c):this._onBlur(a,c)},this._document=i,this._detectionMode=o?.detectionMode||0}monitor(e,r=!1){const s=nh(e);if(!this._platform.isBrowser||1!==s.nodeType)return Ae(null);const i=function vNe(n){if(function _Ne(){if(null==UT){const n=typeof document<"u"?document.head:null;UT=!(!n||!n.createShadowRoot&&!n.attachShadow)}return UT}()){const t=n.getRootNode?n.getRootNode():null;if(typeof ShadowRoot<"u"&&ShadowRoot&&t instanceof ShadowRoot)return t}return null}(s)||this._getDocument(),o=this._elementInfo.get(s);if(o)return r&&(o.checkChildren=!0),o.subject;const a={checkChildren:r,subject:new It,rootNode:i};return this._elementInfo.set(s,a),this._registerGlobalListeners(a),a.subject}stopMonitoring(e){const r=nh(e),s=this._elementInfo.get(r);s&&(s.subject.complete(),this._setClasses(r),this._elementInfo.delete(r),this._removeGlobalListeners(s))}focusVia(e,r,s){const i=nh(e);i===this._getDocument().activeElement?this._getClosestElementsInfo(i).forEach(([a,l])=>this._originChanged(a,r,l)):(this._setOrigin(r),"function"==typeof i.focus&&i.focus(s))}ngOnDestroy(){this._elementInfo.forEach((e,r)=>this.stopMonitoring(r))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_getFocusOrigin(e){return this._origin?this._originFromTouchInteraction?this._shouldBeAttributedToTouch(e)?"touch":"program":this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:e&&this._isLastInteractionFromInputLabel(e)?"mouse":"program"}_shouldBeAttributedToTouch(e){return 1===this._detectionMode||!!e?.contains(this._inputModalityDetector._mostRecentTarget)}_setClasses(e,r){e.classList.toggle("cdk-focused",!!r),e.classList.toggle("cdk-touch-focused","touch"===r),e.classList.toggle("cdk-keyboard-focused","keyboard"===r),e.classList.toggle("cdk-mouse-focused","mouse"===r),e.classList.toggle("cdk-program-focused","program"===r)}_setOrigin(e,r=!1){this._ngZone.runOutsideAngular(()=>{this._origin=e,this._originFromTouchInteraction="touch"===e&&r,0===this._detectionMode&&(clearTimeout(this._originTimeoutId),this._originTimeoutId=setTimeout(()=>this._origin=null,this._originFromTouchInteraction?650:1))})}_onFocus(e,r){const s=this._elementInfo.get(r),i=jc(e);!s||!s.checkChildren&&r!==i||this._originChanged(r,this._getFocusOrigin(i),s)}_onBlur(e,r){const s=this._elementInfo.get(r);!s||s.checkChildren&&e.relatedTarget instanceof Node&&r.contains(e.relatedTarget)||(this._setClasses(r),this._emitOrigin(s,null))}_emitOrigin(e,r){e.subject.observers.length&&this._ngZone.run(()=>e.subject.next(r))}_registerGlobalListeners(e){if(!this._platform.isBrowser)return;const r=e.rootNode,s=this._rootNodeFocusListenerCount.get(r)||0;s||this._ngZone.runOutsideAngular(()=>{r.addEventListener("focus",this._rootNodeFocusAndBlurListener,Zv),r.addEventListener("blur",this._rootNodeFocusAndBlurListener,Zv)}),this._rootNodeFocusListenerCount.set(r,s+1),1==++this._monitoredElementCount&&(this._ngZone.runOutsideAngular(()=>{this._getWindow().addEventListener("focus",this._windowFocusListener)}),this._inputModalityDetector.modalityDetected.pipe(wi(this._stopInputModalityDetector)).subscribe(i=>{this._setOrigin(i,!0)}))}_removeGlobalListeners(e){const r=e.rootNode;if(this._rootNodeFocusListenerCount.has(r)){const s=this._rootNodeFocusListenerCount.get(r);s>1?this._rootNodeFocusListenerCount.set(r,s-1):(r.removeEventListener("focus",this._rootNodeFocusAndBlurListener,Zv),r.removeEventListener("blur",this._rootNodeFocusAndBlurListener,Zv),this._rootNodeFocusListenerCount.delete(r))}--this._monitoredElementCount||(this._getWindow().removeEventListener("focus",this._windowFocusListener),this._stopInputModalityDetector.next(),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._originTimeoutId))}_originChanged(e,r,s){this._setClasses(e,r),this._emitOrigin(s,r),this._lastFocusOrigin=r}_getClosestElementsInfo(e){const r=[];return this._elementInfo.forEach((s,i)=>{(i===e||s.checkChildren&&i.contains(e))&&r.push([i,s])}),r}_isLastInteractionFromInputLabel(e){const{_mostRecentTarget:r,mostRecentModality:s}=this._inputModalityDetector;if("mouse"!==s||!r||r===e||"INPUT"!==e.nodeName&&"TEXTAREA"!==e.nodeName||e.disabled)return!1;const i=e.labels;if(i)for(let o=0;o<i.length;o++)if(i[o].contains(r))return!0;return!1}}return n.\u0275fac=function(e){return new(e||n)(Z(ft),Z(Xs),Z(JNe),Z(wt,8),Z(rAe,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const TH="cdk-high-contrast-black-on-white",kH="cdk-high-contrast-white-on-black",ZT="cdk-high-contrast-active";let sAe=(()=>{class n{constructor(e,r){this._platform=e,this._document=r,this._breakpointSubscription=Bt(GT).observe("(forced-colors: active)").subscribe(()=>{this._hasCheckedHighContrastMode&&(this._hasCheckedHighContrastMode=!1,this._applyBodyHighContrastModeCssClasses())})}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const e=this._document.createElement("div");e.style.backgroundColor="rgb(1,2,3)",e.style.position="absolute",this._document.body.appendChild(e);const r=this._document.defaultView||window,s=r&&r.getComputedStyle?r.getComputedStyle(e):null,i=(s&&s.backgroundColor||"").replace(/ /g,"");switch(e.remove(),i){case"rgb(0,0,0)":case"rgb(45,50,54)":case"rgb(32,32,32)":return 2;case"rgb(255,255,255)":case"rgb(255,250,239)":return 1}return 0}ngOnDestroy(){this._breakpointSubscription.unsubscribe()}_applyBodyHighContrastModeCssClasses(){if(!this._hasCheckedHighContrastMode&&this._platform.isBrowser&&this._document.body){const e=this._document.body.classList;e.remove(ZT,TH,kH),this._hasCheckedHighContrastMode=!0;const r=this.getHighContrastMode();1===r?e.add(ZT,TH):2===r&&e.add(ZT,kH)}}}return n.\u0275fac=function(e){return new(e||n)(Z(Xs),Z(wt))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const iAe=new me("cdk-dir-doc",{providedIn:"root",factory:function oAe(){return Bt(wt)}}),aAe=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;let Qv=(()=>{class n{constructor(e){if(this.value="ltr",this.change=new Et,e){const s=e.documentElement?e.documentElement.dir:null;this.value=function lAe(n){const t=n?.toLowerCase()||"";return"auto"===t&&typeof navigator<"u"&&navigator?.language?aAe.test(navigator.language)?"rtl":"ltr":"rtl"===t?"rtl":"ltr"}((e.body?e.body.dir:null)||s||"ltr")}}ngOnDestroy(){this.change.complete()}}return n.\u0275fac=function(e){return new(e||n)(Z(iAe,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),Tm=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({}),n})();function cAe(n,t){if(1&n&&rr(0,"mat-pseudo-checkbox",4),2&n){const e=en();yt("state",e.selected?"checked":"unchecked")("disabled",e.disabled)}}function uAe(n,t){if(1&n&&(Qe(0,"span",5),rs(1),xt()),2&n){const e=en();gt(1),Lu("(",e.group.label,")")}}const dAe=["*"],fAe=new me("mat-sanity-checks",{providedIn:"root",factory:function hAe(){return!0}});let qr=(()=>{class n{constructor(e,r,s){this._sanityChecks=r,this._document=s,this._hasDoneGlobalChecks=!1,e._applyBodyHighContrastModeCssClasses(),this._hasDoneGlobalChecks||(this._hasDoneGlobalChecks=!0)}_checkIsEnabled(e){return!HT()&&("boolean"==typeof this._sanityChecks?this._sanityChecks:!!this._sanityChecks[e])}}return n.\u0275fac=function(e){return new(e||n)(Z(sAe),Z(fAe,8),Z(wt))},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({imports:[Tm,Tm]}),n})();function QT(n){return class extends n{constructor(...t){super(...t),this._disabled=!1}get disabled(){return this._disabled}set disabled(t){this._disabled=Ys(t)}}}function JT(n,t){return class extends n{constructor(...e){super(...e),this.defaultColor=t,this.color=t}get color(){return this._color}set color(e){const r=e||this.defaultColor;r!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),r&&this._elementRef.nativeElement.classList.add(`mat-${r}`),this._color=r)}}}function ek(n){return class extends n{constructor(...t){super(...t),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=Ys(t)}}}function pAe(n,t=0){return class extends n{constructor(...e){super(...e),this._tabIndex=t,this.defaultTabIndex=t}get tabIndex(){return this.disabled?-1:this._tabIndex}set tabIndex(e){this._tabIndex=null!=e?Dm(e):this.defaultTabIndex}}}function mAe(n){return class extends n{constructor(...t){super(...t),this.errorState=!1}updateErrorState(){const t=this.errorState,i=(this.errorStateMatcher||this._defaultErrorStateMatcher).isErrorState(this.ngControl?this.ngControl.control:null,this._parentFormGroup||this._parentForm);i!==t&&(this.errorState=i,this.stateChanges.next())}}}let yAe=(()=>{class n{isErrorState(e,r){return!!(e&&e.invalid&&(e.touched||r&&r.submitted))}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class bAe{constructor(t,e,r,s=!1){this._renderer=t,this.element=e,this.config=r,this._animationForciblyDisabledThroughCss=s,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const RH={enterDuration:225,exitDuration:150},tk=Vv({passive:!0}),MH=["mousedown","touchstart"],FH=["mouseup","mouseleave","touchend","touchcancel"];class vAe{constructor(t,e,r,s){this._target=t,this._ngZone=e,this._isPointerDown=!1,this._activeRipples=new Map,this._pointerUpEventsRegistered=!1,s.isBrowser&&(this._containerElement=nh(r))}fadeInRipple(t,e,r={}){const s=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),i={...RH,...r.animation};r.centered&&(t=s.left+s.width/2,e=s.top+s.height/2);const o=r.radius||function xAe(n,t,e){const r=Math.max(Math.abs(n-e.left),Math.abs(n-e.right)),s=Math.max(Math.abs(t-e.top),Math.abs(t-e.bottom));return Math.sqrt(r*r+s*s)}(t,e,s),a=t-s.left,l=e-s.top,c=i.enterDuration,u=document.createElement("div");u.classList.add("mat-ripple-element"),u.style.left=a-o+"px",u.style.top=l-o+"px",u.style.height=2*o+"px",u.style.width=2*o+"px",null!=r.color&&(u.style.backgroundColor=r.color),u.style.transitionDuration=`${c}ms`,this._containerElement.appendChild(u);const d=window.getComputedStyle(u),f=d.transitionDuration,p="none"===d.transitionProperty||"0s"===f||"0s, 0s"===f,m=new bAe(this,u,r,p);u.style.transform="scale3d(1, 1, 1)",m.state=0,r.persistent||(this._mostRecentTransientRipple=m);let g=null;return!p&&(c||i.exitDuration)&&this._ngZone.runOutsideAngular(()=>{const y=()=>this._finishRippleTransition(m),b=()=>this._destroyRipple(m);u.addEventListener("transitionend",y),u.addEventListener("transitioncancel",b),g={onTransitionEnd:y,onTransitionCancel:b}}),this._activeRipples.set(m,g),(p||!c)&&this._finishRippleTransition(m),m}fadeOutRipple(t){if(2===t.state||3===t.state)return;const e=t.element,r={...RH,...t.config.animation};e.style.transitionDuration=`${r.exitDuration}ms`,e.style.opacity="0",t.state=2,(t._animationForciblyDisabledThroughCss||!r.exitDuration)&&this._finishRippleTransition(t)}fadeOutAll(){this._getActiveRipples().forEach(t=>t.fadeOut())}fadeOutAllNonPersistent(){this._getActiveRipples().forEach(t=>{t.config.persistent||t.fadeOut()})}setupTriggerEvents(t){const e=nh(t);!e||e===this._triggerElement||(this._removeTriggerEvents(),this._triggerElement=e,this._registerEvents(MH))}handleEvent(t){"mousedown"===t.type?this._onMousedown(t):"touchstart"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._registerEvents(FH),this._pointerUpEventsRegistered=!0)}_finishRippleTransition(t){0===t.state?this._startFadeOutTransition(t):2===t.state&&this._destroyRipple(t)}_startFadeOutTransition(t){const e=t===this._mostRecentTransientRipple,{persistent:r}=t.config;t.state=1,!r&&(!e||!this._isPointerDown)&&t.fadeOut()}_destroyRipple(t){const e=this._activeRipples.get(t)??null;this._activeRipples.delete(t),this._activeRipples.size||(this._containerRect=null),t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),t.state=3,null!==e&&(t.element.removeEventListener("transitionend",e.onTransitionEnd),t.element.removeEventListener("transitioncancel",e.onTransitionCancel)),t.element.remove()}_onMousedown(t){const e=qT(t),r=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;!this._target.rippleDisabled&&!e&&!r&&(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&&!KT(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let r=0;r<e.length;r++)this.fadeInRipple(e[r].clientX,e[r].clientY,this._target.rippleConfig)}}_onPointerUp(){!this._isPointerDown||(this._isPointerDown=!1,this._getActiveRipples().forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_registerEvents(t){this._ngZone.runOutsideAngular(()=>{t.forEach(e=>{this._triggerElement.addEventListener(e,this,tk)})})}_getActiveRipples(){return Array.from(this._activeRipples.keys())}_removeTriggerEvents(){this._triggerElement&&(MH.forEach(t=>{this._triggerElement.removeEventListener(t,this,tk)}),this._pointerUpEventsRegistered&&FH.forEach(t=>{this._triggerElement.removeEventListener(t,this,tk)}))}}const wAe=new me("mat-ripple-global-options");let ih=(()=>{class n{constructor(e,r,s,i,o){this._elementRef=e,this._animationMode=o,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=i||{},this._rippleRenderer=new vAe(this,r,e,s)}get disabled(){return this._disabled}set disabled(e){e&&this.fadeOutAllNonPersistent(),this._disabled=e,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(e){this._trigger=e,this._setupTriggerEventsIfEnabled()}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}fadeOutAllNonPersistent(){this._rippleRenderer.fadeOutAllNonPersistent()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:{...this._globalOptions.animation,..."NoopAnimations"===this._animationMode?{enterDuration:0,exitDuration:0}:{},...this.animation},terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(e,r=0,s){return"number"==typeof e?this._rippleRenderer.fadeInRipple(e,r,{...this.rippleConfig,...s}):this._rippleRenderer.fadeInRipple(0,0,{...this.rippleConfig,...e})}}return n.\u0275fac=function(e){return new(e||n)(B(Kt),B(ft),B(Xs),B(wAe,8),B(ga,8))},n.\u0275dir=Me({type:n,selectors:[["","mat-ripple",""],["","matRipple",""]],hostAttrs:[1,"mat-ripple"],hostVars:2,hostBindings:function(e,r){2&e&&ns("mat-ripple-unbounded",r.unbounded)},inputs:{color:["matRippleColor","color"],unbounded:["matRippleUnbounded","unbounded"],centered:["matRippleCentered","centered"],radius:["matRippleRadius","radius"],animation:["matRippleAnimation","animation"],disabled:["matRippleDisabled","disabled"],trigger:["matRippleTrigger","trigger"]},exportAs:["matRipple"]}),n})(),nk=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({imports:[qr,qr]}),n})(),CAe=(()=>{class n{constructor(e){this._animationMode=e,this.state="unchecked",this.disabled=!1}}return n.\u0275fac=function(e){return new(e||n)(B(ga,8))},n.\u0275cmp=Ur({type:n,selectors:[["mat-pseudo-checkbox"]],hostAttrs:[1,"mat-pseudo-checkbox"],hostVars:8,hostBindings:function(e,r){2&e&&ns("mat-pseudo-checkbox-indeterminate","indeterminate"===r.state)("mat-pseudo-checkbox-checked","checked"===r.state)("mat-pseudo-checkbox-disabled",r.disabled)("_mat-animation-noopable","NoopAnimations"===r._animationMode)},inputs:{state:"state",disabled:"disabled"},decls:0,vars:0,template:function(e,r){},styles:['.mat-pseudo-checkbox{border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border-color:rgba(0,0,0,0)}.mat-pseudo-checkbox._mat-animation-noopable{transition:none !important;animation:none !important}.mat-pseudo-checkbox._mat-animation-noopable::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{left:1px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{left:1px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}.mat-pseudo-checkbox{width:18px;height:18px}.mat-pseudo-checkbox-indeterminate::after{top:6px;width:12px}.mat-pseudo-checkbox-checked::after{top:2.7px;width:10px;height:4px}'],encapsulation:2,changeDetection:0}),n})(),SAe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({imports:[qr]}),n})();const OH=new me("MAT_OPTION_PARENT_COMPONENT"),$H=new me("MatOptgroup");let IAe=0;class EAe{constructor(t,e=!1){this.source=t,this.isUserInput=e}}let DAe=(()=>{class n{constructor(e,r,s,i){this._element=e,this._changeDetectorRef=r,this._parent=s,this.group=i,this._selected=!1,this._active=!1,this._disabled=!1,this._mostRecentViewValue="",this.id="mat-option-"+IAe++,this.onSelectionChange=new Et,this._stateChanges=new It}get multiple(){return this._parent&&this._parent.multiple}get selected(){return this._selected}get disabled(){return this.group&&this.group.disabled||this._disabled}set disabled(e){this._disabled=Ys(e)}get disableRipple(){return!(!this._parent||!this._parent.disableRipple)}get active(){return this._active}get viewValue(){return(this._getHostElement().textContent||"").trim()}select(){this._selected||(this._selected=!0,this._changeDetectorRef.markForCheck(),this._emitSelectionChangeEvent())}deselect(){this._selected&&(this._selected=!1,this._changeDetectorRef.markForCheck(),this._emitSelectionChangeEvent())}focus(e,r){const s=this._getHostElement();"function"==typeof s.focus&&s.focus(r)}setActiveStyles(){this._active||(this._active=!0,this._changeDetectorRef.markForCheck())}setInactiveStyles(){this._active&&(this._active=!1,this._changeDetectorRef.markForCheck())}getLabel(){return this.viewValue}_handleKeydown(e){(13===e.keyCode||32===e.keyCode)&&!th(e)&&(this._selectViaInteraction(),e.preventDefault())}_selectViaInteraction(){this.disabled||(this._selected=!this.multiple||!this._selected,this._changeDetectorRef.markForCheck(),this._emitSelectionChangeEvent(!0))}_getAriaSelected(){return this.selected||!this.multiple&&null}_getTabIndex(){return this.disabled?"-1":"0"}_getHostElement(){return this._element.nativeElement}ngAfterViewChecked(){if(this._selected){const e=this.viewValue;e!==this._mostRecentViewValue&&(this._mostRecentViewValue=e,this._stateChanges.next())}}ngOnDestroy(){this._stateChanges.complete()}_emitSelectionChangeEvent(e=!1){this.onSelectionChange.emit(new EAe(this,e))}}return n.\u0275fac=function(e){Lh()},n.\u0275dir=Me({type:n,inputs:{value:"value",id:"id",disabled:"disabled"},outputs:{onSelectionChange:"onSelectionChange"}}),n})(),PH=(()=>{class n extends DAe{constructor(e,r,s,i){super(e,r,s,i)}}return n.\u0275fac=function(e){return new(e||n)(B(Kt),B(uo),B(OH,8),B($H,8))},n.\u0275cmp=Ur({type:n,selectors:[["mat-option"]],hostAttrs:["role","option",1,"mat-mdc-option","mat-mdc-focus-indicator","mdc-list-item"],hostVars:12,hostBindings:function(e,r){1&e&&Jt("click",function(){return r._selectViaInteraction()})("keydown",function(i){return r._handleKeydown(i)}),2&e&&(eC("id",r.id),Qt("tabindex",r._getTabIndex())("aria-selected",r._getAriaSelected())("aria-disabled",r.disabled.toString()),ns("mdc-list-item--selected",r.selected)("mat-mdc-option-multiple",r.multiple)("mat-mdc-option-active",r.active)("mdc-list-item--disabled",r.disabled))},exportAs:["matOption"],features:[it],ngContentSelectors:dAe,decls:5,vars:4,consts:[["class","mat-mdc-option-pseudo-checkbox",3,"state","disabled",4,"ngIf"],[1,"mdc-list-item__primary-text"],["class","cdk-visually-hidden",4,"ngIf"],["mat-ripple","",1,"mat-mdc-option-ripple",3,"matRippleTrigger","matRippleDisabled"],[1,"mat-mdc-option-pseudo-checkbox",3,"state","disabled"],[1,"cdk-visually-hidden"]],template:function(e,r){1&e&&(ma(),wn(0,cAe,1,2,"mat-pseudo-checkbox",0),Qe(1,"span",1),vs(2),xt(),wn(3,uAe,2,1,"span",2),rr(4,"div",3)),2&e&&(yt("ngIf",r.multiple),gt(3),yt("ngIf",r.group&&r.group._inert),gt(1),yt("matRippleTrigger",r._getHostElement())("matRippleDisabled",r.disabled||r.disableRipple))},dependencies:[ih,hf,CAe],styles:['.mat-mdc-option{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:16px;padding-right:16px;-webkit-user-select:none;user-select:none;cursor:pointer;min-height:48px}.mat-mdc-option:focus{outline:none}[dir=rtl] .mat-mdc-option,.mat-mdc-option[dir=rtl]{padding-left:16px;padding-right:16px}.mat-mdc-option.mdc-list-item{align-items:center}.mat-mdc-option.mdc-list-item--disabled{opacity:.38;cursor:default}.mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:32px}[dir=rtl] .mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:16px;padding-right:32px}.mat-mdc-option .mat-pseudo-checkbox{margin-right:16px}[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox{margin-right:0;margin-left:16px}.mat-mdc-option .mat-mdc-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-mdc-option .mdc-list-item__primary-text{white-space:normal;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit}.cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}[dir=rtl] .cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{right:auto;left:16px}.mat-mdc-option-active::before{content:""}'],encapsulation:2,changeDetection:0}),n})(),LH=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({imports:[nk,fc,qr,SAe]}),n})();const NAe=["mat-button",""],BH=[[["",8,"material-icons",3,"iconPositionEnd",""],["mat-icon",3,"iconPositionEnd",""],["","matButtonIcon","",3,"iconPositionEnd",""]],"*",[["","iconPositionEnd","",8,"material-icons"],["mat-icon","iconPositionEnd",""],["","matButtonIcon","","iconPositionEnd",""]]],VH=[".material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])","*",".material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]"],RAe=["mat-mini-fab",""],FAe=["mat-icon-button",""],OAe=["*"],$Ae=[{selector:"mat-button",mdcClasses:["mdc-button","mat-mdc-button"]},{selector:"mat-flat-button",mdcClasses:["mdc-button","mdc-button--unelevated","mat-mdc-unelevated-button"]},{selector:"mat-raised-button",mdcClasses:["mdc-button","mdc-button--raised","mat-mdc-raised-button"]},{selector:"mat-stroked-button",mdcClasses:["mdc-button","mdc-button--outlined","mat-mdc-outlined-button"]},{selector:"mat-fab",mdcClasses:["mdc-fab","mat-mdc-fab"]},{selector:"mat-mini-fab",mdcClasses:["mdc-fab","mdc-fab--mini","mat-mdc-mini-fab"]},{selector:"mat-icon-button",mdcClasses:["mdc-icon-button","mat-mdc-icon-button"]}],PAe=JT(QT(ek(class{constructor(n){this._elementRef=n}})));let rk=(()=>{class n extends PAe{constructor(e,r,s,i){super(e),this._platform=r,this._ngZone=s,this._animationMode=i,this._focusMonitor=Bt(YT),this._isFab=!1;const o=e.nativeElement.classList;for(const a of $Ae)this._hasHostAttributes(a.selector)&&a.mdcClasses.forEach(l=>{o.add(l)})}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(e="program",r){e?this._focusMonitor.focusVia(this._elementRef.nativeElement,e,r):this._elementRef.nativeElement.focus(r)}_hasHostAttributes(...e){return e.some(r=>this._elementRef.nativeElement.hasAttribute(r))}_isRippleDisabled(){return this.disableRipple||this.disabled}}return n.\u0275fac=function(e){Lh()},n.\u0275dir=Me({type:n,viewQuery:function(e,r){if(1&e&&lo(ih,5),2&e){let s;Or(s=$r())&&(r.ripple=s.first)}},features:[it]}),n})(),BAe=(()=>{class n extends rk{constructor(e,r,s,i){super(e,r,s,i)}}return n.\u0275fac=function(e){return new(e||n)(B(Kt),B(Xs),B(ft),B(ga,8))},n.\u0275cmp=Ur({type:n,selectors:[["button","mat-button",""],["button","mat-raised-button",""],["button","mat-flat-button",""],["button","mat-stroked-button",""]],hostVars:7,hostBindings:function(e,r){2&e&&(Qt("disabled",r.disabled||null),ns("_mat-animation-noopable","NoopAnimations"===r._animationMode)("mat-unthemed",!r.color)("mat-mdc-button-base",!0))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[it],attrs:NAe,ngContentSelectors:VH,decls:8,vars:6,consts:[[1,"mat-mdc-button-persistent-ripple"],[1,"mdc-button__label"],[1,"mat-mdc-focus-indicator"],["matRipple","",1,"mat-mdc-button-ripple",3,"matRippleDisabled","matRippleTrigger"],[1,"mat-mdc-button-touch-target"]],template:function(e,r){1&e&&(ma(BH),rr(0,"span",0),vs(1),Qe(2,"span",1),vs(3,1),xt(),vs(4,2),rr(5,"span",2)(6,"span",3)(7,"span",4)),2&e&&(ns("mdc-button__ripple",!r._isFab)("mdc-fab__ripple",r._isFab),gt(6),yt("matRippleDisabled",r._isRippleDisabled())("matRippleTrigger",r._elementRef.nativeElement))},dependencies:[ih],styles:['.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button{position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;border:none;outline:none;line-height:inherit;user-select:none;-webkit-appearance:none;overflow:visible;vertical-align:middle;background:rgba(0,0,0,0)}.mdc-button .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{cursor:default;pointer-events:none}.mdc-button[hidden]{display:none}.mdc-button .mdc-button__icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top}[dir=rtl] .mdc-button .mdc-button__icon,.mdc-button .mdc-button__icon[dir=rtl]{margin-left:8px;margin-right:0}.mdc-button .mdc-button__progress-indicator{font-size:0;position:absolute;transform:translate(-50%, -50%);top:50%;left:50%}.mdc-button .mdc-button__label{position:relative}.mdc-button .mdc-button__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(\n      100% + 4px\n    );width:calc(\n      100% + 4px\n    );display:none}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring{border-color:CanvasText}}.mdc-button .mdc-button__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring::after{border-color:CanvasText}}@media screen and (forced-colors: active){.mdc-button.mdc-ripple-upgraded--background-focused .mdc-button__focus-ring,.mdc-button:not(.mdc-ripple-upgraded):focus .mdc-button__focus-ring{display:block}}.mdc-button .mdc-button__touch{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mdc-button__label+.mdc-button__icon{margin-left:8px;margin-right:0}[dir=rtl] .mdc-button__label+.mdc-button__icon,.mdc-button__label+.mdc-button__icon[dir=rtl]{margin-left:0;margin-right:8px}svg.mdc-button__icon{fill:currentColor}.mdc-button--touch{margin-top:6px;margin-bottom:6px}.mdc-button{padding:0 8px 0 8px}.mdc-button--unelevated{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--unelevated.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--unelevated.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--raised{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--raised.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--raised.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--outlined{border-style:solid;transition:border 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button--outlined .mdc-button__ripple{border-style:solid;border-color:rgba(0,0,0,0)}.mat-mdc-button{height:var(--mdc-text-button-container-height, 36px);border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-button:not(:disabled){color:var(--mdc-text-button-label-text-color, inherit)}.mat-mdc-button:disabled{color:var(--mdc-text-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-button .mdc-button__ripple{border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button{height:var(--mdc-filled-button-container-height, 36px);border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button:not(:disabled){background-color:var(--mdc-filled-button-container-color, transparent)}.mat-mdc-unelevated-button:disabled{background-color:var(--mdc-filled-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-unelevated-button:not(:disabled){color:var(--mdc-filled-button-label-text-color, inherit)}.mat-mdc-unelevated-button:disabled{color:var(--mdc-filled-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-unelevated-button .mdc-button__ripple{border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button{height:var(--mdc-protected-button-container-height, 36px);border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px));box-shadow:var(--mdc-protected-button-container-elevation, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){background-color:var(--mdc-protected-button-container-color, transparent)}.mat-mdc-raised-button:disabled{background-color:var(--mdc-protected-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){color:var(--mdc-protected-button-label-text-color, inherit)}.mat-mdc-raised-button:disabled{color:var(--mdc-protected-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-raised-button .mdc-button__ripple{border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button.mdc-ripple-upgraded--background-focused,.mat-mdc-raised-button:not(.mdc-ripple-upgraded):focus{box-shadow:var(--mdc-protected-button-focus-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:hover{box-shadow:var(--mdc-protected-button-hover-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled):active{box-shadow:var(--mdc-protected-button-pressed-container-elevation, 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:disabled{box-shadow:var(--mdc-protected-button-disabled-container-elevation, 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button{height:var(--mdc-outlined-button-container-height, 36px);border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px));padding:0 15px 0 15px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button:not(:disabled){color:var(--mdc-outlined-button-label-text-color, inherit)}.mat-mdc-outlined-button:disabled{color:var(--mdc-outlined-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-outlined-button .mdc-button__ripple{border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-outlined-button:not(:disabled){border-color:var(--mdc-outlined-button-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button:disabled{border-color:var(--mdc-outlined-button-disabled-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button.mdc-button--icon-trailing{padding:0 11px 0 15px}.mat-mdc-outlined-button.mdc-button--icon-leading{padding:0 15px 0 11px}.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button .mdc-button__touch{left:calc(-1 * var(--mdc-outlined-button-outline-width, 1px));width:calc(100% + 2 * var(--mdc-outlined-button-outline-width, 1px))}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-button .mat-ripple-element,.mat-mdc-unelevated-button .mat-ripple-element,.mat-mdc-raised-button .mat-ripple-element,.mat-mdc-outlined-button .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-button .mdc-button__label,.mat-mdc-unelevated-button .mdc-button__label,.mat-mdc-raised-button .mdc-button__label,.mat-mdc-outlined-button .mdc-button__label{z-index:1}.mat-mdc-button .mat-mdc-focus-indicator,.mat-mdc-unelevated-button .mat-mdc-focus-indicator,.mat-mdc-raised-button .mat-mdc-focus-indicator,.mat-mdc-outlined-button .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-unelevated-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-raised-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-outlined-button:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-button[disabled],.mat-mdc-unelevated-button[disabled],.mat-mdc-raised-button[disabled],.mat-mdc-outlined-button[disabled]{cursor:default;pointer-events:none}.mat-mdc-button .mat-mdc-button-touch-target,.mat-mdc-unelevated-button .mat-mdc-button-touch-target,.mat-mdc-raised-button .mat-mdc-button-touch-target,.mat-mdc-outlined-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mat-mdc-button._mat-animation-noopable,.mat-mdc-unelevated-button._mat-animation-noopable,.mat-mdc-raised-button._mat-animation-noopable,.mat-mdc-outlined-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem}[dir=rtl] .mat-mdc-button>.mat-icon,.mat-mdc-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}.mat-mdc-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-button .mdc-button__label+.mat-icon,.mat-mdc-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:0;margin-right:8px}.mat-mdc-unelevated-button>.mat-icon,.mat-mdc-raised-button>.mat-icon,.mat-mdc-outlined-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem;margin-left:-4px;margin-right:8px}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:-4px}.mat-mdc-unelevated-button .mdc-button__label+.mat-icon,.mat-mdc-raised-button .mdc-button__label+.mat-icon,.mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:-4px}[dir=rtl] .mat-mdc-unelevated-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-raised-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-outlined-button .mdc-button__label+.mat-icon,.mat-mdc-unelevated-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-raised-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-outlined-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:-4px;margin-right:8px}.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:-1px}.mat-mdc-unelevated-button .mat-mdc-focus-indicator::before,.mat-mdc-raised-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-outlined-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 3px) * -1)}',".cdk-high-contrast-active .mat-mdc-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-unelevated-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-raised-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-outlined-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-icon-button{outline:solid 1px}"],encapsulation:2,changeDetection:0}),n})();const VAe=new me("mat-mdc-fab-default-options",{providedIn:"root",factory:zH});function zH(){return{color:"accent"}}const UH=zH();let zAe=(()=>{class n extends rk{constructor(e,r,s,i,o){super(e,r,s,i),this._options=o,this._isFab=!0,this._options=this._options||UH,this.color=this.defaultColor=this._options.color||UH.color}}return n.\u0275fac=function(e){return new(e||n)(B(Kt),B(Xs),B(ft),B(ga,8),B(VAe,8))},n.\u0275cmp=Ur({type:n,selectors:[["button","mat-mini-fab",""]],hostVars:7,hostBindings:function(e,r){2&e&&(Qt("disabled",r.disabled||null),ns("_mat-animation-noopable","NoopAnimations"===r._animationMode)("mat-unthemed",!r.color)("mat-mdc-button-base",!0))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[it],attrs:RAe,ngContentSelectors:VH,decls:8,vars:6,consts:[[1,"mat-mdc-button-persistent-ripple"],[1,"mdc-button__label"],[1,"mat-mdc-focus-indicator"],["matRipple","",1,"mat-mdc-button-ripple",3,"matRippleDisabled","matRippleTrigger"],[1,"mat-mdc-button-touch-target"]],template:function(e,r){1&e&&(ma(BH),rr(0,"span",0),vs(1),Qe(2,"span",1),vs(3,1),xt(),vs(4,2),rr(5,"span",2)(6,"span",3)(7,"span",4)),2&e&&(ns("mdc-button__ripple",!r._isFab)("mdc-fab__ripple",r._isFab),gt(6),yt("matRippleDisabled",r._isRippleDisabled())("matRippleTrigger",r._elementRef.nativeElement))},dependencies:[ih],styles:['.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-fab{position:relative;display:inline-flex;position:relative;align-items:center;justify-content:center;box-sizing:border-box;width:56px;height:56px;padding:0;border:none;fill:currentColor;text-decoration:none;cursor:pointer;user-select:none;-moz-appearance:none;-webkit-appearance:none;overflow:visible;transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),opacity 15ms linear 30ms,transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-fab .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-fab[hidden]{display:none}.mdc-fab::-moz-focus-inner{padding:0;border:0}.mdc-fab .mdc-fab__focus-ring{position:absolute}.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(\n      100% + 4px\n    );width:calc(\n      100% + 4px\n    )}@media screen and (forced-colors: active){.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{border-color:CanvasText}}.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{border-color:CanvasText}}.mdc-fab:active,.mdc-fab:focus{outline:none}.mdc-fab:hover{cursor:pointer}.mdc-fab>svg{width:100%}.mdc-fab--mini{width:40px;height:40px}.mdc-fab--extended{border-radius:24px;padding-left:20px;padding-right:20px;width:auto;max-width:100%;height:48px;line-height:normal}.mdc-fab--extended .mdc-fab__ripple{border-radius:24px}.mdc-fab--extended .mdc-fab__icon{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mdc-fab--extended .mdc-fab__icon,.mdc-fab--extended .mdc-fab__icon[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mdc-fab--extended .mdc-fab__label+.mdc-fab__icon{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mdc-fab--extended .mdc-fab__label+.mdc-fab__icon,.mdc-fab--extended .mdc-fab__label+.mdc-fab__icon[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mdc-fab--touch{margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}.mdc-fab--touch .mdc-fab__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mdc-fab::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-fab::before{border-color:CanvasText}}.mdc-fab__label{justify-content:flex-start;text-overflow:ellipsis;white-space:nowrap;overflow-x:hidden;overflow-y:visible}.mdc-fab__icon{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mdc-fab .mdc-fab__icon{display:inline-flex;align-items:center;justify-content:center}.mdc-fab--exited{transform:scale(0);opacity:0;transition:opacity 15ms linear 150ms,transform 180ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-fab--exited .mdc-fab__icon{transform:scale(0);transition:transform 135ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-fab .mdc-fab__icon{width:24px;height:24px;font-size:24px}.mdc-fab:not(.mdc-fab--extended){border-radius:50%}.mdc-fab:not(.mdc-fab--extended) .mdc-fab__ripple{border-radius:50%}.mat-mdc-fab,.mat-mdc-mini-fab{background-color:var(--mdc-fab-container-color, transparent);box-shadow:0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12);color:var(--mat-mdc-fab-color, inherit);flex-shrink:0}.mat-mdc-fab .mat-mdc-button-ripple,.mat-mdc-fab .mat-mdc-button-persistent-ripple,.mat-mdc-fab .mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab .mat-mdc-button-ripple,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-fab .mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-fab .mat-ripple-element,.mat-mdc-mini-fab .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-fab .mdc-button__label,.mat-mdc-mini-fab .mdc-button__label{z-index:1}.mat-mdc-fab .mat-mdc-focus-indicator,.mat-mdc-mini-fab .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-fab:focus .mat-mdc-focus-indicator::before,.mat-mdc-mini-fab:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-fab .mat-mdc-button-touch-target,.mat-mdc-mini-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mat-mdc-fab._mat-animation-noopable,.mat-mdc-mini-fab._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-fab:not(:disabled) .mdc-fab__icon,.mat-mdc-mini-fab:not(:disabled) .mdc-fab__icon{color:var(--mdc-fab-icon-color, inherit)}.mat-mdc-fab:not(.mdc-fab--extended),.mat-mdc-mini-fab:not(.mdc-fab--extended){border-radius:var(--mdc-fab-container-shape, 50%)}.mat-mdc-fab:not(.mdc-fab--extended) .mdc-fab__ripple,.mat-mdc-mini-fab:not(.mdc-fab--extended) .mdc-fab__ripple{border-radius:var(--mdc-fab-container-shape, 50%)}.mat-mdc-fab:hover,.mat-mdc-fab:focus,.mat-mdc-mini-fab:hover,.mat-mdc-mini-fab:focus{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12)}.mat-mdc-fab:active,.mat-mdc-fab:focus:active,.mat-mdc-mini-fab:active,.mat-mdc-mini-fab:focus:active{box-shadow:0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 12px 17px 2px rgba(0, 0, 0, 0.14), 0px 5px 22px 4px rgba(0, 0, 0, 0.12)}.mat-mdc-fab[disabled],.mat-mdc-mini-fab[disabled]{cursor:default;pointer-events:none;box-shadow:0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12)}.mat-mdc-fab:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-mini-fab:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}.mat-mdc-fab .mat-icon,.mat-mdc-fab .material-icons,.mat-mdc-mini-fab .mat-icon,.mat-mdc-mini-fab .material-icons{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mat-mdc-fab .mat-mdc-focus-indicator::before,.mat-mdc-mini-fab .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-extended-fab{border-radius:24px;padding-left:20px;padding-right:20px;width:auto;max-width:100%;height:48px;line-height:normal}.mat-mdc-extended-fab .mdc-fab__ripple{border-radius:24px}.mat-mdc-extended-fab .mdc-fab__icon{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mat-mdc-extended-fab .mdc-fab__icon,.mat-mdc-extended-fab .mdc-fab__icon[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mat-mdc-extended-fab .mdc-fab__label+.mdc-fab__icon{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mat-mdc-extended-fab .mdc-fab__label+.mdc-fab__icon,.mat-mdc-extended-fab .mdc-fab__label+.mdc-fab__icon[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mat-mdc-extended-fab>.mat-icon,.mat-mdc-extended-fab>.material-icons{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mat-mdc-extended-fab>.mat-icon,[dir=rtl] .mat-mdc-extended-fab>.material-icons,.mat-mdc-extended-fab>.mat-icon[dir=rtl],.mat-mdc-extended-fab>.material-icons[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mat-mdc-extended-fab .mdc-button__label+.mat-icon,.mat-mdc-extended-fab .mdc-button__label+.material-icons{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.material-icons,.mat-mdc-extended-fab .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-extended-fab .mdc-button__label+.material-icons[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mat-mdc-extended-fab .mat-mdc-button-touch-target{width:100%}'],encapsulation:2,changeDetection:0}),n})(),UAe=(()=>{class n extends rk{constructor(e,r,s,i){super(e,r,s,i)}}return n.\u0275fac=function(e){return new(e||n)(B(Kt),B(Xs),B(ft),B(ga,8))},n.\u0275cmp=Ur({type:n,selectors:[["button","mat-icon-button",""]],hostVars:7,hostBindings:function(e,r){2&e&&(Qt("disabled",r.disabled||null),ns("_mat-animation-noopable","NoopAnimations"===r._animationMode)("mat-unthemed",!r.color)("mat-mdc-button-base",!0))},inputs:{disabled:"disabled",disableRipple:"disableRipple",color:"color"},exportAs:["matButton"],features:[it],attrs:FAe,ngContentSelectors:OAe,decls:5,vars:3,consts:[[1,"mat-mdc-button-persistent-ripple","mdc-icon-button__ripple"],[1,"mat-mdc-focus-indicator"],["matRipple","",1,"mat-mdc-button-ripple",3,"matRippleDisabled","matRippleCentered","matRippleTrigger"],[1,"mat-mdc-button-touch-target"]],template:function(e,r){1&e&&(ma(),rr(0,"span",0),vs(1),rr(2,"span",1)(3,"span",2)(4,"span",3)),2&e&&(gt(3),yt("matRippleDisabled",r._isRippleDisabled())("matRippleCentered",!0)("matRippleTrigger",r._elementRef.nativeElement))},dependencies:[ih],styles:['.mdc-icon-button{font-size:24px;width:48px;height:48px;padding:12px}.mdc-icon-button .mdc-icon-button__focus-ring{max-height:48px;max-width:48px}.mdc-icon-button.mdc-icon-button--reduced-size .mdc-icon-button__ripple{width:40px;height:40px;margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}.mdc-icon-button.mdc-icon-button--reduced-size .mdc-icon-button__focus-ring{max-height:40px;max-width:40px}.mdc-icon-button .mdc-icon-button__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mdc-icon-button svg,.mdc-icon-button img{width:24px;height:24px}.mdc-icon-button{display:inline-block;position:relative;box-sizing:border-box;border:none;outline:none;background-color:rgba(0,0,0,0);fill:currentColor;color:inherit;text-decoration:none;cursor:pointer;user-select:none;z-index:0;overflow:visible}.mdc-icon-button .mdc-icon-button__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}@media screen and (forced-colors: active){.mdc-icon-button.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring,.mdc-icon-button:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring{display:block}}.mdc-icon-button:disabled{cursor:default;pointer-events:none}.mdc-icon-button[hidden]{display:none}.mdc-icon-button--display-flex{align-items:center;display:inline-flex;justify-content:center}.mdc-icon-button__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:100%;width:100%;display:none}@media screen and (forced-colors: active){.mdc-icon-button__focus-ring{border-color:CanvasText}}.mdc-icon-button__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-icon-button__focus-ring::after{border-color:CanvasText}}.mdc-icon-button__icon{display:inline-block}.mdc-icon-button__icon.mdc-icon-button__icon--on{display:none}.mdc-icon-button--on .mdc-icon-button__icon{display:none}.mdc-icon-button--on .mdc-icon-button__icon.mdc-icon-button__icon--on{display:inline-block}.mdc-icon-button__link{height:100%;left:0;outline:none;position:absolute;top:0;width:100%}.mat-mdc-icon-button{height:var(--mdc-icon-button-state-layer-size, 48px);width:var(--mdc-icon-button-state-layer-size, 48px);color:var(--mdc-icon-button-icon-color, inherit);border-radius:50%;flex-shrink:0}.mat-mdc-icon-button .mdc-button__icon{font-size:var(--mdc-icon-button-icon-size, 24px)}.mat-mdc-icon-button svg,.mat-mdc-icon-button img{width:var(--mdc-icon-button-icon-size, 24px);height:var(--mdc-icon-button-icon-size, 24px)}.mat-mdc-icon-button:disabled{opacity:var(--mdc-icon-button-disabled-icon-opacity, 0.38)}.mat-mdc-icon-button:disabled{color:var(--mdc-icon-button-disabled-icon-color, #000)}.mat-mdc-icon-button[disabled]{cursor:default;pointer-events:none;opacity:1}.mat-mdc-icon-button .mat-mdc-button-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-icon-button .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-icon-button .mdc-button__label{z-index:1}.mat-mdc-icon-button .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-icon-button:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-icon-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mat-mdc-icon-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple{border-radius:50%}.mat-mdc-icon-button.mat-unthemed:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-primary:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-accent:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-warn:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}',".cdk-high-contrast-active .mat-mdc-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-unelevated-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-raised-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-outlined-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-icon-button{outline:solid 1px}"],encapsulation:2,changeDetection:0}),n})(),HH=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({imports:[qr,nk,qr]}),n})();class WH{}class HAe{}const Oa="*";function oh(n,t){return{type:7,name:n,definitions:t,options:{}}}function Fl(n,t=null){return{type:4,styles:t,timings:n}}function jH(n,t=null){return{type:2,steps:n,options:t}}function Ns(n){return{type:6,styles:n,offset:null}}function ah(n,t,e){return{type:0,name:n,styles:t,options:e}}function $a(n,t,e=null){return{type:1,expr:n,animation:t,options:e}}function WAe(n=null){return{type:9,options:n}}function jAe(n,t,e=null){return{type:11,selector:n,animation:t,options:e}}function GH(n){Promise.resolve().then(n)}class Nm{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._originalOnDoneFns=[],this._originalOnStartFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){GH(()=>this._onFinish())}_onStart(){this._onStartFns.forEach(t=>t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this._started=!1,this._finished=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class qH{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,r=0,s=0;const i=this.players.length;0==i?GH(()=>this._onFinish()):this.players.forEach(o=>{o.onDone(()=>{++e==i&&this._onFinish()}),o.onDestroy(()=>{++r==i&&this._onDestroy()}),o.onStart(()=>{++s==i&&this._onStart()})}),this.totalTime=this.players.reduce((o,a)=>Math.max(o,a.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this.players.forEach(t=>t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=>t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=>t.play())}pause(){this.players.forEach(t=>t.pause())}restart(){this.players.forEach(t=>t.restart())}finish(){this._onFinish(),this.players.forEach(t=>t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=>t.destroy()),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=>t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(r=>{const s=r.totalTime?Math.min(1,e/r.totalTime):1;r.setPosition(s)})}getPosition(){const t=this.players.reduce((e,r)=>null===e||r.totalTime>e.totalTime?r:e,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=>{t.beforeDestroy&&t.beforeDestroy()})}triggerCallback(t){const e="start"==t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class ik{attach(t){return this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null!=t&&(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class ok extends ik{constructor(t,e,r,s,i){super(),this.component=t,this.viewContainerRef=e,this.injector=r,this.componentFactoryResolver=s,this.projectableNodes=i}}class Jv extends ik{constructor(t,e,r,s){super(),this.templateRef=t,this.viewContainerRef=e,this.context=r,this.injector=s}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class GAe extends ik{constructor(t){super(),this.element=t instanceof Kt?t.nativeElement:t}}class ak{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t instanceof ok?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof Jv?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&&t instanceof GAe?(this._attachedPortal=t,this.attachDomPortal(t)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class qAe extends ak{constructor(t,e,r,s,i){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=r,this._defaultInjector=s,this.attachDomPortal=o=>{const a=o.element,l=this._document.createComment("dom-portal");a.parentNode.insertBefore(l,a),this.outletElement.appendChild(a),this._attachedPortal=o,super.setDisposeFn(()=>{l.parentNode&&l.parentNode.replaceChild(a,l)})},this._document=i}attachComponentPortal(t){const r=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let s;return t.viewContainerRef?(s=t.viewContainerRef.createComponent(r,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector,t.projectableNodes||void 0),this.setDisposeFn(()=>s.destroy())):(s=r.create(t.injector||this._defaultInjector||vr.NULL),this._appRef.attachView(s.hostView),this.setDisposeFn(()=>{this._appRef.viewCount>0&&this._appRef.detachView(s.hostView),s.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(s)),this._attachedPortal=t,s}attachTemplatePortal(t){let e=t.viewContainerRef,r=e.createEmbeddedView(t.templateRef,t.context,{injector:t.injector});return r.rootNodes.forEach(s=>this.outletElement.appendChild(s)),r.detectChanges(),this.setDisposeFn(()=>{let s=e.indexOf(r);-1!==s&&e.remove(s)}),this._attachedPortal=t,r}dispose(){super.dispose(),this.outletElement.remove()}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let KH=(()=>{class n extends ak{constructor(e,r,s){super(),this._componentFactoryResolver=e,this._viewContainerRef=r,this._isInitialized=!1,this.attached=new Et,this.attachDomPortal=i=>{const o=i.element,a=this._document.createComment("dom-portal");i.setAttachedHost(this),o.parentNode.insertBefore(a,o),this._getRootNode().appendChild(o),this._attachedPortal=i,super.setDisposeFn(()=>{a.parentNode&&a.parentNode.replaceChild(o,a)})},this._document=s}get portal(){return this._attachedPortal}set portal(e){this.hasAttached()&&!e&&!this._isInitialized||(this.hasAttached()&&super.detach(),e&&super.attach(e),this._attachedPortal=e||null)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedRef=this._attachedPortal=null}attachComponentPortal(e){e.setAttachedHost(this);const r=null!=e.viewContainerRef?e.viewContainerRef:this._viewContainerRef,i=(e.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(e.component),o=r.createComponent(i,r.length,e.injector||r.injector,e.projectableNodes||void 0);return r!==this._viewContainerRef&&this._getRootNode().appendChild(o.hostView.rootNodes[0]),super.setDisposeFn(()=>o.destroy()),this._attachedPortal=e,this._attachedRef=o,this.attached.emit(o),o}attachTemplatePortal(e){e.setAttachedHost(this);const r=this._viewContainerRef.createEmbeddedView(e.templateRef,e.context,{injector:e.injector});return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=e,this._attachedRef=r,this.attached.emit(r),r}_getRootNode(){const e=this._viewContainerRef.element.nativeElement;return e.nodeType===e.ELEMENT_NODE?e:e.parentNode}}return n.\u0275fac=function(e){return new(e||n)(B(ic),B(Ps),B(wt))},n.\u0275dir=Me({type:n,selectors:[["","cdkPortalOutlet",""]],inputs:{portal:["cdkPortalOutlet","portal"]},outputs:{attached:"attached"},exportAs:["cdkPortalOutlet"],features:[it]}),n})(),XH=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({}),n})();const KAe=["addListener","removeListener"],XAe=["addEventListener","removeEventListener"],YAe=["on","off"];function lk(n,t,e,r){if(ae(e)&&(r=e,e=void 0),r)return lk(n,t,e).pipe(oS(r));const[s,i]=function JAe(n){return ae(n.addEventListener)&&ae(n.removeEventListener)}(n)?XAe.map(o=>a=>n[o](t,a,e)):function ZAe(n){return ae(n.addListener)&&ae(n.removeListener)}(n)?KAe.map(YH(n,t)):function QAe(n){return ae(n.on)&&ae(n.off)}(n)?YAe.map(YH(n,t)):[];if(!s&&Xx(n))return yr(o=>lk(o,t,e))(Rs(n));if(!s)throw new TypeError("Invalid event target");return new Dn(o=>{const a=(...l)=>o.next(1<l.length?l:l[0]);return s(a),()=>i(a)})}function YH(n,t){return e=>r=>n[e](t,r)}const Am={schedule(n){let t=requestAnimationFrame,e=cancelAnimationFrame;const{delegate:r}=Am;r&&(t=r.requestAnimationFrame,e=r.cancelAnimationFrame);const s=t(i=>{e=void 0,n(i)});return new Ve(()=>e?.(s))},requestAnimationFrame(...n){const{delegate:t}=Am;return(t?.requestAnimationFrame||requestAnimationFrame)(...n)},cancelAnimationFrame(...n){const{delegate:t}=Am;return(t?.cancelAnimationFrame||cancelAnimationFrame)(...n)},delegate:void 0};new class tRe extends jT{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let s;t=t||r.shift();do{if(s=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,s){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw s}}}(class eRe extends WT{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=Am.requestAnimationFrame(()=>t.flush(void 0))))}recycleAsyncId(t,e,r=0){var s;if(null!=r?r>0:this.delay>0)return super.recycleAsyncId(t,e,r);const{actions:i}=t;null!=e&&(null===(s=i[i.length-1])||void 0===s?void 0:s.id)!==e&&(Am.cancelAnimationFrame(e),t._scheduled=void 0)}});let ck,rRe=1;const ex={};function ZH(n){return n in ex&&(delete ex[n],!0)}const sRe={setImmediate(n){const t=rRe++;return ex[t]=!0,ck||(ck=Promise.resolve()),ck.then(()=>ZH(t)&&n()),t},clearImmediate(n){ZH(n)}},{setImmediate:iRe,clearImmediate:oRe}=sRe,tx={setImmediate(...n){const{delegate:t}=tx;return(t?.setImmediate||iRe)(...n)},clearImmediate(n){const{delegate:t}=tx;return(t?.clearImmediate||oRe)(n)},delegate:void 0},uk=new class lRe extends jT{flush(t){this._active=!0;const e=this._scheduled;this._scheduled=void 0;const{actions:r}=this;let s;t=t||r.shift();do{if(s=t.execute(t.state,t.delay))break}while((t=r[0])&&t.id===e&&r.shift());if(this._active=!1,s){for(;(t=r[0])&&t.id===e&&r.shift();)t.unsubscribe();throw s}}}(class aRe extends WT{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,r=0){return null!==r&&r>0?super.requestAsyncId(t,e,r):(t.actions.push(this),t._scheduled||(t._scheduled=tx.setImmediate(t.flush.bind(t,void 0))))}recycleAsyncId(t,e,r=0){var s;if(null!=r?r>0:this.delay>0)return super.recycleAsyncId(t,e,r);const{actions:i}=t;null!=e&&(null===(s=i[i.length-1])||void 0===s?void 0:s.id)!==e&&(tx.clearImmediate(e),t._scheduled=void 0)}});function QH(n=0,t,e=ONe){let r=-1;return null!=t&&(RN(t)?e=t:r=t),new Dn(s=>{let i=function uRe(n){return n instanceof Date&&!isNaN(n)}(n)?+n-e.now():n;i<0&&(i=0);let o=0;return e.schedule(function(){s.closed||(s.next(o++),0<=r?this.schedule(void 0,r):s.complete())},i)})}function JH(n,t=Xv){return function cRe(n){return Mn((t,e)=>{let r=!1,s=null,i=null,o=!1;const a=()=>{if(i?.unsubscribe(),i=null,r){r=!1;const c=s;s=null,e.next(c)}o&&e.complete()},l=()=>{i=null,o&&e.complete()};t.subscribe(xn(e,c=>{r=!0,s=c,i||Rs(n(c)).subscribe(i=xn(e,a,l))},()=>{o=!0,(!r||!i||i.closed)&&e.complete()}))})}(()=>QH(n,t))}let hRe=(()=>{class n{constructor(e,r,s){this._ngZone=e,this._platform=r,this._scrolled=new It,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=s}register(e){this.scrollContainers.has(e)||this.scrollContainers.set(e,e.elementScrolled().subscribe(()=>this._scrolled.next(e)))}deregister(e){const r=this.scrollContainers.get(e);r&&(r.unsubscribe(),this.scrollContainers.delete(e))}scrolled(e=20){return this._platform.isBrowser?new Dn(r=>{this._globalSubscription||this._addGlobalListener();const s=e>0?this._scrolled.pipe(JH(e)).subscribe(r):this._scrolled.subscribe(r);return this._scrolledCount++,()=>{s.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):Ae()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((e,r)=>this.deregister(r)),this._scrolled.complete()}ancestorScrolled(e,r){const s=this.getAncestorScrollContainers(e);return this.scrolled(r).pipe(or(i=>!i||s.indexOf(i)>-1))}getAncestorScrollContainers(e){const r=[];return this.scrollContainers.forEach((s,i)=>{this._scrollableContainsElement(i,e)&&r.push(i)}),r}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(e,r){let s=nh(r),i=e.getElementRef().nativeElement;do{if(s==i)return!0}while(s=s.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>lk(this._getWindow().document,"scroll").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return n.\u0275fac=function(e){return new(e||n)(Z(ft),Z(Xs),Z(wt,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),dk=(()=>{class n{constructor(e,r,s){this._platform=e,this._change=new It,this._changeListener=i=>{this._change.next(i)},this._document=s,r.runOutsideAngular(()=>{if(e.isBrowser){const i=this._getWindow();i.addEventListener("resize",this._changeListener),i.addEventListener("orientationchange",this._changeListener)}this.change().subscribe(()=>this._viewportSize=null)})}ngOnDestroy(){if(this._platform.isBrowser){const e=this._getWindow();e.removeEventListener("resize",this._changeListener),e.removeEventListener("orientationchange",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const e={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),e}getViewportRect(){const e=this.getViewportScrollPosition(),{width:r,height:s}=this.getViewportSize();return{top:e.top,left:e.left,bottom:e.top+s,right:e.left+r,height:s,width:r}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const e=this._document,r=this._getWindow(),s=e.documentElement,i=s.getBoundingClientRect();return{top:-i.top||e.body.scrollTop||r.scrollY||s.scrollTop||0,left:-i.left||e.body.scrollLeft||r.scrollX||s.scrollLeft||0}}change(e=20){return e>0?this._change.pipe(JH(e)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const e=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:e.innerWidth,height:e.innerHeight}:{width:0,height:0}}}return n.\u0275fac=function(e){return new(e||n)(Z(Xs),Z(ft),Z(wt,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),nx=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({}),n})(),eW=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({imports:[Tm,nx,Tm,nx]}),n})();const tW=bNe();class pRe{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:"",left:""},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||"",this._previousHTMLStyles.top=t.style.top||"",t.style.left=mr(-this._previousScrollPosition.left),t.style.top=mr(-this._previousScrollPosition.top),t.classList.add("cdk-global-scrollblock"),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,r=t.style,s=this._document.body.style,i=r.scrollBehavior||"",o=s.scrollBehavior||"";this._isEnabled=!1,r.left=this._previousHTMLStyles.left,r.top=this._previousHTMLStyles.top,t.classList.remove("cdk-global-scrollblock"),tW&&(r.scrollBehavior=s.scrollBehavior="auto"),window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),tW&&(r.scrollBehavior=i,s.scrollBehavior=o)}}_canBeEnabled(){if(this._document.documentElement.classList.contains("cdk-global-scrollblock")||this._isEnabled)return!1;const e=this._document.body,r=this._viewportRuler.getViewportSize();return e.scrollHeight>r.height||e.scrollWidth>r.width}}class mRe{constructor(t,e,r,s){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=r,this._config=s,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(t){this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0);this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=>{const e=this._viewportRuler.getViewportScrollPosition().top;Math.abs(e-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class nW{enable(){}disable(){}attach(){}}function hk(n,t){return t.some(e=>n.bottom<e.top||n.top>e.bottom||n.right<e.left||n.left>e.right)}function rW(n,t){return t.some(e=>n.top<e.top||n.bottom>e.bottom||n.left<e.left||n.right>e.right)}class gRe{constructor(t,e,r,s){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=r,this._config=s,this._scrollSubscription=null}attach(t){this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const e=this._overlayRef.overlayElement.getBoundingClientRect(),{width:r,height:s}=this._viewportRuler.getViewportSize();hk(e,[{width:r,height:s,bottom:s,right:r,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let yRe=(()=>{class n{constructor(e,r,s,i){this._scrollDispatcher=e,this._viewportRuler=r,this._ngZone=s,this.noop=()=>new nW,this.close=o=>new mRe(this._scrollDispatcher,this._ngZone,this._viewportRuler,o),this.block=()=>new pRe(this._viewportRuler,this._document),this.reposition=o=>new gRe(this._scrollDispatcher,this._viewportRuler,this._ngZone,o),this._document=i}}return n.\u0275fac=function(e){return new(e||n)(Z(hRe),Z(dk),Z(ft),Z(wt))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class rx{constructor(t){if(this.scrollStrategy=new nW,this.panelClass="",this.hasBackdrop=!1,this.backdropClass="cdk-overlay-dark-backdrop",this.disposeOnNavigation=!1,t){const e=Object.keys(t);for(const r of e)void 0!==t[r]&&(this[r]=t[r])}}}class bRe{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}let sW=(()=>{class n{constructor(e){this._attachedOverlays=[],this._document=e}ngOnDestroy(){this.detach()}add(e){this.remove(e),this._attachedOverlays.push(e)}remove(e){const r=this._attachedOverlays.indexOf(e);r>-1&&this._attachedOverlays.splice(r,1),0===this._attachedOverlays.length&&this.detach()}}return n.\u0275fac=function(e){return new(e||n)(Z(wt))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),_Re=(()=>{class n extends sW{constructor(e,r){super(e),this._ngZone=r,this._keydownListener=s=>{const i=this._attachedOverlays;for(let o=i.length-1;o>-1;o--)if(i[o]._keydownEvents.observers.length>0){const a=i[o]._keydownEvents;this._ngZone?this._ngZone.run(()=>a.next(s)):a.next(s);break}}}add(e){super.add(e),this._isAttached||(this._ngZone?this._ngZone.runOutsideAngular(()=>this._document.body.addEventListener("keydown",this._keydownListener)):this._document.body.addEventListener("keydown",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener("keydown",this._keydownListener),this._isAttached=!1)}}return n.\u0275fac=function(e){return new(e||n)(Z(wt),Z(ft,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),vRe=(()=>{class n extends sW{constructor(e,r,s){super(e),this._platform=r,this._ngZone=s,this._cursorStyleIsSet=!1,this._pointerDownListener=i=>{this._pointerDownEventTarget=jc(i)},this._clickListener=i=>{const o=jc(i),a="click"===i.type&&this._pointerDownEventTarget?this._pointerDownEventTarget:o;this._pointerDownEventTarget=null;const l=this._attachedOverlays.slice();for(let c=l.length-1;c>-1;c--){const u=l[c];if(u._outsidePointerEvents.observers.length<1||!u.hasAttached())continue;if(u.overlayElement.contains(o)||u.overlayElement.contains(a))break;const d=u._outsidePointerEvents;this._ngZone?this._ngZone.run(()=>d.next(i)):d.next(i)}}}add(e){if(super.add(e),!this._isAttached){const r=this._document.body;this._ngZone?this._ngZone.runOutsideAngular(()=>this._addEventListeners(r)):this._addEventListeners(r),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=r.style.cursor,r.style.cursor="pointer",this._cursorStyleIsSet=!0),this._isAttached=!0}}detach(){if(this._isAttached){const e=this._document.body;e.removeEventListener("pointerdown",this._pointerDownListener,!0),e.removeEventListener("click",this._clickListener,!0),e.removeEventListener("auxclick",this._clickListener,!0),e.removeEventListener("contextmenu",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(e.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1}}_addEventListeners(e){e.addEventListener("pointerdown",this._pointerDownListener,!0),e.addEventListener("click",this._clickListener,!0),e.addEventListener("auxclick",this._clickListener,!0),e.addEventListener("contextmenu",this._clickListener,!0)}}return n.\u0275fac=function(e){return new(e||n)(Z(wt),Z(Xs),Z(ft,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),iW=(()=>{class n{constructor(e,r){this._platform=r,this._document=e}ngOnDestroy(){this._containerElement?.remove()}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const e="cdk-overlay-container";if(this._platform.isBrowser||HT()){const s=this._document.querySelectorAll(`.${e}[platform="server"], .${e}[platform="test"]`);for(let i=0;i<s.length;i++)s[i].remove()}const r=this._document.createElement("div");r.classList.add(e),HT()?r.setAttribute("platform","test"):this._platform.isBrowser||r.setAttribute("platform","server"),this._document.body.appendChild(r),this._containerElement=r}}return n.\u0275fac=function(e){return new(e||n)(Z(wt),Z(Xs))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();class xRe{constructor(t,e,r,s,i,o,a,l,c,u=!1){this._portalOutlet=t,this._host=e,this._pane=r,this._config=s,this._ngZone=i,this._keyboardDispatcher=o,this._document=a,this._location=l,this._outsideClickDispatcher=c,this._animationsDisabled=u,this._backdropElement=null,this._backdropClick=new It,this._attachments=new It,this._detachments=new It,this._locationChanges=Ve.EMPTY,this._backdropClickHandler=d=>this._backdropClick.next(d),this._backdropTransitionendHandler=d=>{this._disposeBackdrop(d.target)},this._keydownEvents=new It,this._outsidePointerEvents=new It,s.scrollStrategy&&(this._scrollStrategy=s.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=s.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host);const e=this._portalOutlet.attach(t);return this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.pipe($n(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher.add(this),"function"==typeof e?.onDestroy&&e.onDestroy(()=>{this.hasAttached()&&this._ngZone.runOutsideAngular(()=>Promise.resolve().then(()=>this.detach()))}),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher.remove(this),t}dispose(){const t=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this._disposeBackdrop(this._backdropElement),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher.remove(this),this._host?.remove(),this._previousHostParent=this._pane=this._host=null,t&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&&(t.attach(this),this.updatePosition()))}updateSize(t){this._config={...this._config,...t},this._updateElementSize()}setDirection(t){this._config={...this._config,direction:t},this._updateElementDirection()}addPanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?"string"==typeof t?t:t.value:"ltr"}updateScrollStrategy(t){t!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&&(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute("dir",this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=mr(this._config.width),t.height=mr(this._config.height),t.minWidth=mr(this._config.minWidth),t.minHeight=mr(this._config.minHeight),t.maxWidth=mr(this._config.maxWidth),t.maxHeight=mr(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?"":"none"}_attachBackdrop(){const t="cdk-overlay-backdrop-showing";this._backdropElement=this._document.createElement("div"),this._backdropElement.classList.add("cdk-overlay-backdrop"),this._animationsDisabled&&this._backdropElement.classList.add("cdk-overlay-backdrop-noop-animation"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener("click",this._backdropClickHandler),!this._animationsDisabled&&typeof requestAnimationFrame<"u"?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add(t)})}):this._backdropElement.classList.add(t)}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){const t=this._backdropElement;if(t){if(this._animationsDisabled)return void this._disposeBackdrop(t);t.classList.remove("cdk-overlay-backdrop-showing"),this._ngZone.runOutsideAngular(()=>{t.addEventListener("transitionend",this._backdropTransitionendHandler)}),t.style.pointerEvents="none",this._backdropTimeout=this._ngZone.runOutsideAngular(()=>setTimeout(()=>{this._disposeBackdrop(t)},500))}}_toggleClasses(t,e,r){const s=Yv(e||[]).filter(i=>!!i);s.length&&(r?t.classList.add(...s):t.classList.remove(...s))}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const t=this._ngZone.onStable.pipe(wi(Ua(this._attachments,this._detachments))).subscribe(()=>{(!this._pane||!this._host||0===this._pane.children.length)&&(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._host.remove()),t.unsubscribe())})})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&&(t.disable(),t.detach&&t.detach())}_disposeBackdrop(t){t&&(t.removeEventListener("click",this._backdropClickHandler),t.removeEventListener("transitionend",this._backdropTransitionendHandler),t.remove(),this._backdropElement===t&&(this._backdropElement=null)),this._backdropTimeout&&(clearTimeout(this._backdropTimeout),this._backdropTimeout=void 0)}}const oW="cdk-overlay-connected-position-bounding-box",wRe=/([A-Za-z%]+)$/;class CRe{constructor(t,e,r,s,i){this._viewportRuler=e,this._document=r,this._platform=s,this._overlayContainer=i,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new It,this._resizeSubscription=Ve.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(t)}get positions(){return this._preferredPositions}attach(t){this._validatePositions(),t.hostElement.classList.add(oW),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const t=this._originRect,e=this._overlayRect,r=this._viewportRect,s=this._containerRect,i=[];let o;for(let a of this._preferredPositions){let l=this._getOriginPoint(t,s,a),c=this._getOverlayPoint(l,e,a),u=this._getOverlayFit(c,e,r,a);if(u.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(a,l);this._canFitWithFlexibleDimensions(u,c,r)?i.push({position:a,origin:l,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(l,a)}):(!o||o.overlayFit.visibleArea<u.visibleArea)&&(o={overlayFit:u,overlayPoint:c,originPoint:l,position:a,overlayRect:e})}if(i.length){let a=null,l=-1;for(const c of i){const u=c.boundingBoxRect.width*c.boundingBoxRect.height*(c.position.weight||1);u>l&&(l=u,a=c)}return this._isPushed=!1,void this._applyPosition(a.position,a.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(o.position,o.originPoint);this._applyPosition(o.position,o.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&Gc(this._boundingBox.style,{top:"",left:"",right:"",bottom:"",height:"",width:"",alignItems:"",justifyContent:""}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove(oW),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(this._isDisposed||!this._platform.isBrowser)return;const t=this._lastPosition;if(t){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect(),this._containerRect=this._overlayContainer.getContainerElement().getBoundingClientRect();const e=this._getOriginPoint(this._originRect,this._containerRect,t);this._applyPosition(t,e)}else this.apply()}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e,r){let s,i;if("center"==r.originX)s=t.left+t.width/2;else{const o=this._isRtl()?t.right:t.left,a=this._isRtl()?t.left:t.right;s="start"==r.originX?o:a}return e.left<0&&(s-=e.left),i="center"==r.originY?t.top+t.height/2:"top"==r.originY?t.top:t.bottom,e.top<0&&(i-=e.top),{x:s,y:i}}_getOverlayPoint(t,e,r){let s,i;return s="center"==r.overlayX?-e.width/2:"start"===r.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,i="center"==r.overlayY?-e.height/2:"top"==r.overlayY?0:-e.height,{x:t.x+s,y:t.y+i}}_getOverlayFit(t,e,r,s){const i=lW(e);let{x:o,y:a}=t,l=this._getOffset(s,"x"),c=this._getOffset(s,"y");l&&(o+=l),c&&(a+=c);let h=0-a,f=a+i.height-r.height,p=this._subtractOverflows(i.width,0-o,o+i.width-r.width),m=this._subtractOverflows(i.height,h,f),g=p*m;return{visibleArea:g,isCompletelyWithinViewport:i.width*i.height===g,fitsInViewportVertically:m===i.height,fitsInViewportHorizontally:p==i.width}}_canFitWithFlexibleDimensions(t,e,r){if(this._hasFlexibleDimensions){const s=r.bottom-e.y,i=r.right-e.x,o=aW(this._overlayRef.getConfig().minHeight),a=aW(this._overlayRef.getConfig().minWidth),c=t.fitsInViewportHorizontally||null!=a&&a<=i;return(t.fitsInViewportVertically||null!=o&&o<=s)&&c}return!1}_pushOverlayOnScreen(t,e,r){if(this._previousPushAmount&&this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const s=lW(e),i=this._viewportRect,o=Math.max(t.x+s.width-i.width,0),a=Math.max(t.y+s.height-i.height,0),l=Math.max(i.top-r.top-t.y,0),c=Math.max(i.left-r.left-t.x,0);let u=0,d=0;return u=s.width<=i.width?c||-o:t.x<this._viewportMargin?i.left-r.left-t.x:0,d=s.height<=i.height?l||-a:t.y<this._viewportMargin?i.top-r.top-t.y:0,this._previousPushAmount={x:u,y:d},{x:t.x+u,y:t.y+d}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&&this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const r=this._getScrollVisibility(),s=new bRe(t,r);this._positionChanges.next(s)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let r,s=t.overlayY;r="center"===t.overlayX?"center":this._isRtl()?"start"===t.overlayX?"right":"left":"start"===t.overlayX?"left":"right";for(let i=0;i<e.length;i++)e[i].style.transformOrigin=`${r} ${s}`}_calculateBoundingBoxRect(t,e){const r=this._viewportRect,s=this._isRtl();let i,o,a,u,d,h;if("top"===e.overlayY)o=t.y,i=r.height-o+this._viewportMargin;else if("bottom"===e.overlayY)a=r.height-t.y+2*this._viewportMargin,i=r.height-a+this._viewportMargin;else{const f=Math.min(r.bottom-t.y+r.top,t.y),p=this._lastBoundingBoxSize.height;i=2*f,o=t.y-f,i>p&&!this._isInitialRender&&!this._growAfterOpen&&(o=t.y-p/2)}if("end"===e.overlayX&&!s||"start"===e.overlayX&&s)h=r.width-t.x+this._viewportMargin,u=t.x-this._viewportMargin;else if("start"===e.overlayX&&!s||"end"===e.overlayX&&s)d=t.x,u=r.right-t.x;else{const f=Math.min(r.right-t.x+r.left,t.x),p=this._lastBoundingBoxSize.width;u=2*f,d=t.x-f,u>p&&!this._isInitialRender&&!this._growAfterOpen&&(d=t.x-p/2)}return{top:o,left:d,bottom:a,right:h,width:u,height:i}}_setBoundingBoxStyles(t,e){const r=this._calculateBoundingBoxRect(t,e);!this._isInitialRender&&!this._growAfterOpen&&(r.height=Math.min(r.height,this._lastBoundingBoxSize.height),r.width=Math.min(r.width,this._lastBoundingBoxSize.width));const s={};if(this._hasExactPosition())s.top=s.left="0",s.bottom=s.right=s.maxHeight=s.maxWidth="",s.width=s.height="100%";else{const i=this._overlayRef.getConfig().maxHeight,o=this._overlayRef.getConfig().maxWidth;s.height=mr(r.height),s.top=mr(r.top),s.bottom=mr(r.bottom),s.width=mr(r.width),s.left=mr(r.left),s.right=mr(r.right),s.alignItems="center"===e.overlayX?"center":"end"===e.overlayX?"flex-end":"flex-start",s.justifyContent="center"===e.overlayY?"center":"bottom"===e.overlayY?"flex-end":"flex-start",i&&(s.maxHeight=mr(i)),o&&(s.maxWidth=mr(o))}this._lastBoundingBoxSize=r,Gc(this._boundingBox.style,s)}_resetBoundingBoxStyles(){Gc(this._boundingBox.style,{top:"0",left:"0",right:"0",bottom:"0",height:"",width:"",alignItems:"",justifyContent:""})}_resetOverlayElementStyles(){Gc(this._pane.style,{top:"",left:"",bottom:"",right:"",position:"",transform:""})}_setOverlayElementStyles(t,e){const r={},s=this._hasExactPosition(),i=this._hasFlexibleDimensions,o=this._overlayRef.getConfig();if(s){const u=this._viewportRuler.getViewportScrollPosition();Gc(r,this._getExactOverlayY(e,t,u)),Gc(r,this._getExactOverlayX(e,t,u))}else r.position="static";let a="",l=this._getOffset(e,"x"),c=this._getOffset(e,"y");l&&(a+=`translateX(${l}px) `),c&&(a+=`translateY(${c}px)`),r.transform=a.trim(),o.maxHeight&&(s?r.maxHeight=mr(o.maxHeight):i&&(r.maxHeight="")),o.maxWidth&&(s?r.maxWidth=mr(o.maxWidth):i&&(r.maxWidth="")),Gc(this._pane.style,r)}_getExactOverlayY(t,e,r){let s={top:"",bottom:""},i=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,r)),"bottom"===t.overlayY?s.bottom=this._document.documentElement.clientHeight-(i.y+this._overlayRect.height)+"px":s.top=mr(i.y),s}_getExactOverlayX(t,e,r){let o,s={left:"",right:""},i=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(i=this._pushOverlayOnScreen(i,this._overlayRect,r)),o=this._isRtl()?"end"===t.overlayX?"left":"right":"end"===t.overlayX?"right":"left","right"===o?s.right=this._document.documentElement.clientWidth-(i.x+this._overlayRect.width)+"px":s.left=mr(i.x),s}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),r=this._scrollables.map(s=>s.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:rW(t,r),isOriginOutsideView:hk(t,r),isOverlayClipped:rW(e,r),isOverlayOutsideView:hk(e,r)}}_subtractOverflows(t,...e){return e.reduce((r,s)=>r-Math.max(s,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,r=this._viewportRuler.getViewportScrollPosition();return{top:r.top+this._viewportMargin,left:r.left+this._viewportMargin,right:r.left+t-this._viewportMargin,bottom:r.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return"rtl"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return"x"===e?t.offsetX??this._offsetX:t.offsetY??this._offsetY}_validatePositions(){}_addPanelClasses(t){this._pane&&Yv(t).forEach(e=>{""!==e&&-1===this._appliedPanelClasses.indexOf(e)&&(this._appliedPanelClasses.push(e),this._pane.classList.add(e))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(t=>{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof Kt)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,r=t.height||0;return{top:t.y,bottom:t.y+r,left:t.x,right:t.x+e,height:r,width:e}}}function Gc(n,t){for(let e in t)t.hasOwnProperty(e)&&(n[e]=t[e]);return n}function aW(n){if("number"!=typeof n&&null!=n){const[t,e]=n.split(wRe);return e&&"px"!==e?null:parseFloat(t)}return n||null}function lW(n){return{top:Math.floor(n.top),right:Math.floor(n.right),bottom:Math.floor(n.bottom),left:Math.floor(n.left),width:Math.floor(n.width),height:Math.floor(n.height)}}const cW="cdk-global-overlay-wrapper";class SRe{constructor(){this._cssPosition="static",this._topOffset="",this._bottomOffset="",this._alignItems="",this._xPosition="",this._xOffset="",this._width="",this._height="",this._isDisposed=!1}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&&!e.width&&t.updateSize({width:this._width}),this._height&&!e.height&&t.updateSize({height:this._height}),t.hostElement.classList.add(cW),this._isDisposed=!1}top(t=""){return this._bottomOffset="",this._topOffset=t,this._alignItems="flex-start",this}left(t=""){return this._xOffset=t,this._xPosition="left",this}bottom(t=""){return this._topOffset="",this._bottomOffset=t,this._alignItems="flex-end",this}right(t=""){return this._xOffset=t,this._xPosition="right",this}start(t=""){return this._xOffset=t,this._xPosition="start",this}end(t=""){return this._xOffset=t,this._xPosition="end",this}width(t=""){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=""){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=""){return this.left(t),this._xPosition="center",this}centerVertically(t=""){return this.top(t),this._alignItems="center",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,r=this._overlayRef.getConfig(),{width:s,height:i,maxWidth:o,maxHeight:a}=r,l=!("100%"!==s&&"100vw"!==s||o&&"100%"!==o&&"100vw"!==o),c=!("100%"!==i&&"100vh"!==i||a&&"100%"!==a&&"100vh"!==a),u=this._xPosition,d=this._xOffset,h="rtl"===this._overlayRef.getConfig().direction;let f="",p="",m="";l?m="flex-start":"center"===u?(m="center",h?p=d:f=d):h?"left"===u||"end"===u?(m="flex-end",f=d):("right"===u||"start"===u)&&(m="flex-start",p=d):"left"===u||"start"===u?(m="flex-start",f=d):("right"===u||"end"===u)&&(m="flex-end",p=d),t.position=this._cssPosition,t.marginLeft=l?"0":f,t.marginTop=c?"0":this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=l?"0":p,e.justifyContent=m,e.alignItems=c?"flex-start":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,r=e.style;e.classList.remove(cW),r.justifyContent=r.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position="",this._overlayRef=null,this._isDisposed=!0}}let IRe=(()=>{class n{constructor(e,r,s,i){this._viewportRuler=e,this._document=r,this._platform=s,this._overlayContainer=i}global(){return new SRe}flexibleConnectedTo(e){return new CRe(e,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return n.\u0275fac=function(e){return new(e||n)(Z(dk),Z(wt),Z(Xs),Z(iW))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),ERe=0,Ol=(()=>{class n{constructor(e,r,s,i,o,a,l,c,u,d,h,f){this.scrollStrategies=e,this._overlayContainer=r,this._componentFactoryResolver=s,this._positionBuilder=i,this._keyboardDispatcher=o,this._injector=a,this._ngZone=l,this._document=c,this._directionality=u,this._location=d,this._outsideClickDispatcher=h,this._animationsModuleType=f}create(e){const r=this._createHostElement(),s=this._createPaneElement(r),i=this._createPortalOutlet(s),o=new rx(e);return o.direction=o.direction||this._directionality.value,new xRe(i,r,s,o,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher,"NoopAnimations"===this._animationsModuleType)}position(){return this._positionBuilder}_createPaneElement(e){const r=this._document.createElement("div");return r.id="cdk-overlay-"+ERe++,r.classList.add("cdk-overlay-pane"),e.appendChild(r),r}_createHostElement(){const e=this._document.createElement("div");return this._overlayContainer.getContainerElement().appendChild(e),e}_createPortalOutlet(e){return this._appRef||(this._appRef=this._injector.get(Wu)),new qAe(e,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return n.\u0275fac=function(e){return new(e||n)(Z(yRe),Z(iW),Z(ic),Z(IRe),Z(_Re),Z(vr),Z(ft),Z(wt),Z(Qv),Z(sy),Z(vRe),Z(ga,8))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();const DRe=[{originX:"start",originY:"bottom",overlayX:"start",overlayY:"top"},{originX:"start",originY:"top",overlayX:"start",overlayY:"bottom"},{originX:"end",originY:"top",overlayX:"end",overlayY:"bottom"},{originX:"end",originY:"bottom",overlayX:"end",overlayY:"top"}],uW=new me("cdk-connected-overlay-scroll-strategy");let fk=(()=>{class n{constructor(e){this.elementRef=e}}return n.\u0275fac=function(e){return new(e||n)(B(Kt))},n.\u0275dir=Me({type:n,selectors:[["","cdk-overlay-origin",""],["","overlay-origin",""],["","cdkOverlayOrigin",""]],exportAs:["cdkOverlayOrigin"]}),n})(),dW=(()=>{class n{constructor(e,r,s,i,o){this._overlay=e,this._dir=o,this._hasBackdrop=!1,this._lockPosition=!1,this._growAfterOpen=!1,this._flexibleDimensions=!1,this._push=!1,this._backdropSubscription=Ve.EMPTY,this._attachSubscription=Ve.EMPTY,this._detachSubscription=Ve.EMPTY,this._positionSubscription=Ve.EMPTY,this.viewportMargin=0,this.open=!1,this.disableClose=!1,this.backdropClick=new Et,this.positionChange=new Et,this.attach=new Et,this.detach=new Et,this.overlayKeydown=new Et,this.overlayOutsideClick=new Et,this._templatePortal=new Jv(r,s),this._scrollStrategyFactory=i,this.scrollStrategy=this._scrollStrategyFactory()}get offsetX(){return this._offsetX}set offsetX(e){this._offsetX=e,this._position&&this._updatePositionStrategy(this._position)}get offsetY(){return this._offsetY}set offsetY(e){this._offsetY=e,this._position&&this._updatePositionStrategy(this._position)}get hasBackdrop(){return this._hasBackdrop}set hasBackdrop(e){this._hasBackdrop=Ys(e)}get lockPosition(){return this._lockPosition}set lockPosition(e){this._lockPosition=Ys(e)}get flexibleDimensions(){return this._flexibleDimensions}set flexibleDimensions(e){this._flexibleDimensions=Ys(e)}get growAfterOpen(){return this._growAfterOpen}set growAfterOpen(e){this._growAfterOpen=Ys(e)}get push(){return this._push}set push(e){this._push=Ys(e)}get overlayRef(){return this._overlayRef}get dir(){return this._dir?this._dir.value:"ltr"}ngOnDestroy(){this._attachSubscription.unsubscribe(),this._detachSubscription.unsubscribe(),this._backdropSubscription.unsubscribe(),this._positionSubscription.unsubscribe(),this._overlayRef&&this._overlayRef.dispose()}ngOnChanges(e){this._position&&(this._updatePositionStrategy(this._position),this._overlayRef.updateSize({width:this.width,minWidth:this.minWidth,height:this.height,minHeight:this.minHeight}),e.origin&&this.open&&this._position.apply()),e.open&&(this.open?this._attachOverlay():this._detachOverlay())}_createOverlay(){(!this.positions||!this.positions.length)&&(this.positions=DRe);const e=this._overlayRef=this._overlay.create(this._buildConfig());this._attachSubscription=e.attachments().subscribe(()=>this.attach.emit()),this._detachSubscription=e.detachments().subscribe(()=>this.detach.emit()),e.keydownEvents().subscribe(r=>{this.overlayKeydown.next(r),27===r.keyCode&&!this.disableClose&&!th(r)&&(r.preventDefault(),this._detachOverlay())}),this._overlayRef.outsidePointerEvents().subscribe(r=>{this.overlayOutsideClick.next(r)})}_buildConfig(){const e=this._position=this.positionStrategy||this._createPositionStrategy(),r=new rx({direction:this._dir,positionStrategy:e,scrollStrategy:this.scrollStrategy,hasBackdrop:this.hasBackdrop});return(this.width||0===this.width)&&(r.width=this.width),(this.height||0===this.height)&&(r.height=this.height),(this.minWidth||0===this.minWidth)&&(r.minWidth=this.minWidth),(this.minHeight||0===this.minHeight)&&(r.minHeight=this.minHeight),this.backdropClass&&(r.backdropClass=this.backdropClass),this.panelClass&&(r.panelClass=this.panelClass),r}_updatePositionStrategy(e){const r=this.positions.map(s=>({originX:s.originX,originY:s.originY,overlayX:s.overlayX,overlayY:s.overlayY,offsetX:s.offsetX||this.offsetX,offsetY:s.offsetY||this.offsetY,panelClass:s.panelClass||void 0}));return e.setOrigin(this._getFlexibleConnectedPositionStrategyOrigin()).withPositions(r).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector)}_createPositionStrategy(){const e=this._overlay.position().flexibleConnectedTo(this._getFlexibleConnectedPositionStrategyOrigin());return this._updatePositionStrategy(e),e}_getFlexibleConnectedPositionStrategyOrigin(){return this.origin instanceof fk?this.origin.elementRef:this.origin}_attachOverlay(){this._overlayRef?this._overlayRef.getConfig().hasBackdrop=this.hasBackdrop:this._createOverlay(),this._overlayRef.hasAttached()||this._overlayRef.attach(this._templatePortal),this.hasBackdrop?this._backdropSubscription=this._overlayRef.backdropClick().subscribe(e=>{this.backdropClick.emit(e)}):this._backdropSubscription.unsubscribe(),this._positionSubscription.unsubscribe(),this.positionChange.observers.length>0&&(this._positionSubscription=this._position.positionChanges.pipe(E$(()=>this.positionChange.observers.length>0)).subscribe(e=>{this.positionChange.emit(e),0===this.positionChange.observers.length&&this._positionSubscription.unsubscribe()}))}_detachOverlay(){this._overlayRef&&this._overlayRef.detach(),this._backdropSubscription.unsubscribe(),this._positionSubscription.unsubscribe()}}return n.\u0275fac=function(e){return new(e||n)(B(Ol),B(Ai),B(Ps),B(uW),B(Qv,8))},n.\u0275dir=Me({type:n,selectors:[["","cdk-connected-overlay",""],["","connected-overlay",""],["","cdkConnectedOverlay",""]],inputs:{origin:["cdkConnectedOverlayOrigin","origin"],positions:["cdkConnectedOverlayPositions","positions"],positionStrategy:["cdkConnectedOverlayPositionStrategy","positionStrategy"],offsetX:["cdkConnectedOverlayOffsetX","offsetX"],offsetY:["cdkConnectedOverlayOffsetY","offsetY"],width:["cdkConnectedOverlayWidth","width"],height:["cdkConnectedOverlayHeight","height"],minWidth:["cdkConnectedOverlayMinWidth","minWidth"],minHeight:["cdkConnectedOverlayMinHeight","minHeight"],backdropClass:["cdkConnectedOverlayBackdropClass","backdropClass"],panelClass:["cdkConnectedOverlayPanelClass","panelClass"],viewportMargin:["cdkConnectedOverlayViewportMargin","viewportMargin"],scrollStrategy:["cdkConnectedOverlayScrollStrategy","scrollStrategy"],open:["cdkConnectedOverlayOpen","open"],disableClose:["cdkConnectedOverlayDisableClose","disableClose"],transformOriginSelector:["cdkConnectedOverlayTransformOriginOn","transformOriginSelector"],hasBackdrop:["cdkConnectedOverlayHasBackdrop","hasBackdrop"],lockPosition:["cdkConnectedOverlayLockPosition","lockPosition"],flexibleDimensions:["cdkConnectedOverlayFlexibleDimensions","flexibleDimensions"],growAfterOpen:["cdkConnectedOverlayGrowAfterOpen","growAfterOpen"],push:["cdkConnectedOverlayPush","push"]},outputs:{backdropClick:"backdropClick",positionChange:"positionChange",attach:"attach",detach:"detach",overlayKeydown:"overlayKeydown",overlayOutsideClick:"overlayOutsideClick"},exportAs:["cdkConnectedOverlay"],features:[Os]}),n})();const kRe={provide:uW,deps:[Ol],useFactory:function TRe(n){return()=>n.scrollStrategies.reposition()}};let pk=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({providers:[Ol,kRe],imports:[Tm,XH,eW,eW]}),n})();function NRe(n,t){if(1&n){const e=pa();Qe(0,"div",2)(1,"button",3),Jt("click",function(){return Qr(e),Jr(en().action())}),rs(2),xt()()}if(2&n){const e=en();gt(2),Lu(" ",e.data.action," ")}}const ARe=["label"];function RRe(n,t){}const MRe=Math.pow(2,31)-1;class mk{constructor(t,e){this._overlayRef=e,this._afterDismissed=new It,this._afterOpened=new It,this._onAction=new It,this._dismissedByAction=!1,this.containerInstance=t,t._onExit.subscribe(()=>this._finishDismiss())}dismiss(){this._afterDismissed.closed||this.containerInstance.exit(),clearTimeout(this._durationTimeoutId)}dismissWithAction(){this._onAction.closed||(this._dismissedByAction=!0,this._onAction.next(),this._onAction.complete(),this.dismiss()),clearTimeout(this._durationTimeoutId)}closeWithAction(){this.dismissWithAction()}_dismissAfter(t){this._durationTimeoutId=setTimeout(()=>this.dismiss(),Math.min(t,MRe))}_open(){this._afterOpened.closed||(this._afterOpened.next(),this._afterOpened.complete())}_finishDismiss(){this._overlayRef.dispose(),this._onAction.closed||this._onAction.complete(),this._afterDismissed.next({dismissedByAction:this._dismissedByAction}),this._afterDismissed.complete(),this._dismissedByAction=!1}afterDismissed(){return this._afterDismissed}afterOpened(){return this.containerInstance._onEnter}onAction(){return this._onAction}}const hW=new me("MatSnackBarData");class sx{constructor(){this.politeness="assertive",this.announcementMessage="",this.duration=0,this.data=null,this.horizontalPosition="center",this.verticalPosition="bottom"}}let FRe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=Me({type:n,selectors:[["","matSnackBarLabel",""]],hostAttrs:[1,"mat-mdc-snack-bar-label","mdc-snackbar__label"]}),n})(),ORe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=Me({type:n,selectors:[["","matSnackBarActions",""]],hostAttrs:[1,"mat-mdc-snack-bar-actions","mdc-snackbar__actions"]}),n})(),$Re=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=Me({type:n,selectors:[["","matSnackBarAction",""]],hostAttrs:[1,"mat-mdc-snack-bar-action","mdc-snackbar__action"]}),n})(),PRe=(()=>{class n{constructor(e,r){this.snackBarRef=e,this.data=r}action(){this.snackBarRef.dismissWithAction()}get hasAction(){return!!this.data.action}}return n.\u0275fac=function(e){return new(e||n)(B(mk),B(hW))},n.\u0275cmp=Ur({type:n,selectors:[["simple-snack-bar"]],hostAttrs:[1,"mat-mdc-simple-snack-bar"],exportAs:["matSnackBar"],decls:3,vars:2,consts:[["matSnackBarLabel",""],["matSnackBarActions","",4,"ngIf"],["matSnackBarActions",""],["mat-button","","matSnackBarAction","",3,"click"]],template:function(e,r){1&e&&(Qe(0,"div",0),rs(1),xt(),wn(2,NRe,3,1,"div",1)),2&e&&(gt(1),Lu(" ",r.data.message,"\n"),gt(1),yt("ngIf",r.hasAction))},dependencies:[hf,BAe,FRe,ORe,$Re],styles:[".mat-mdc-simple-snack-bar{display:flex}"],encapsulation:2,changeDetection:0}),n})();const LRe={snackBarState:oh("state",[ah("void, hidden",Ns({transform:"scale(0.8)",opacity:0})),ah("visible",Ns({transform:"scale(1)",opacity:1})),$a("* => visible",Fl("150ms cubic-bezier(0, 0, 0.2, 1)")),$a("* => void, * => hidden",Fl("75ms cubic-bezier(0.4, 0.0, 1, 1)",Ns({opacity:0})))])};let BRe=(()=>{class n extends ak{constructor(e,r,s,i,o){super(),this._ngZone=e,this._elementRef=r,this._changeDetectorRef=s,this._platform=i,this.snackBarConfig=o,this._announceDelay=150,this._destroyed=!1,this._onAnnounce=new It,this._onExit=new It,this._onEnter=new It,this._animationState="void",this.attachDomPortal=a=>{this._assertNotAttached();const l=this._portalOutlet.attachDomPortal(a);return this._afterPortalAttached(),l},this._live="assertive"!==o.politeness||o.announcementMessage?"off"===o.politeness?"off":"polite":"assertive",this._platform.FIREFOX&&("polite"===this._live&&(this._role="status"),"assertive"===this._live&&(this._role="alert"))}attachComponentPortal(e){this._assertNotAttached();const r=this._portalOutlet.attachComponentPortal(e);return this._afterPortalAttached(),r}attachTemplatePortal(e){this._assertNotAttached();const r=this._portalOutlet.attachTemplatePortal(e);return this._afterPortalAttached(),r}onAnimationEnd(e){const{fromState:r,toState:s}=e;if(("void"===s&&"void"!==r||"hidden"===s)&&this._completeExit(),"visible"===s){const i=this._onEnter;this._ngZone.run(()=>{i.next(),i.complete()})}}enter(){this._destroyed||(this._animationState="visible",this._changeDetectorRef.detectChanges(),this._screenReaderAnnounce())}exit(){return this._ngZone.run(()=>{this._animationState="hidden",this._elementRef.nativeElement.setAttribute("mat-exit",""),clearTimeout(this._announceTimeoutId)}),this._onExit}ngOnDestroy(){this._destroyed=!0,this._completeExit()}_completeExit(){this._ngZone.onMicrotaskEmpty.pipe($n(1)).subscribe(()=>{this._ngZone.run(()=>{this._onExit.next(),this._onExit.complete()})})}_afterPortalAttached(){const e=this._elementRef.nativeElement,r=this.snackBarConfig.panelClass;r&&(Array.isArray(r)?r.forEach(s=>e.classList.add(s)):e.classList.add(r))}_assertNotAttached(){this._portalOutlet.hasAttached()}_screenReaderAnnounce(){this._announceTimeoutId||this._ngZone.runOutsideAngular(()=>{this._announceTimeoutId=setTimeout(()=>{const e=this._elementRef.nativeElement.querySelector("[aria-hidden]"),r=this._elementRef.nativeElement.querySelector("[aria-live]");if(e&&r){let s=null;this._platform.isBrowser&&document.activeElement instanceof HTMLElement&&e.contains(document.activeElement)&&(s=document.activeElement),e.removeAttribute("aria-hidden"),r.appendChild(e),s?.focus(),this._onAnnounce.next(),this._onAnnounce.complete()}},this._announceDelay)})}}return n.\u0275fac=function(e){return new(e||n)(B(ft),B(Kt),B(uo),B(Xs),B(sx))},n.\u0275dir=Me({type:n,viewQuery:function(e,r){if(1&e&&lo(KH,7),2&e){let s;Or(s=$r())&&(r._portalOutlet=s.first)}},features:[it]}),n})(),VRe=(()=>{class n extends BRe{_afterPortalAttached(){super._afterPortalAttached();const e=this._label.nativeElement,r="mdc-snackbar__label";e.classList.toggle(r,!e.querySelector(`.${r}`))}}return n.\u0275fac=function(){let t;return function(r){return(t||(t=nr(n)))(r||n)}}(),n.\u0275cmp=Ur({type:n,selectors:[["mat-snack-bar-container"]],viewQuery:function(e,r){if(1&e&&lo(ARe,7),2&e){let s;Or(s=$r())&&(r._label=s.first)}},hostAttrs:[1,"mdc-snackbar","mat-mdc-snack-bar-container","mdc-snackbar--open"],hostVars:1,hostBindings:function(e,r){1&e&&Zw("@state.done",function(i){return r.onAnimationEnd(i)}),2&e&&tC("@state",r._animationState)},features:[it],decls:6,vars:2,consts:[[1,"mdc-snackbar__surface"],[1,"mat-mdc-snack-bar-label"],["label",""],["aria-hidden","true"],["cdkPortalOutlet",""]],template:function(e,r){1&e&&(Qe(0,"div",0)(1,"div",1,2)(3,"div",3),wn(4,RRe,0,0,"ng-template",4),xt(),rr(5,"div"),xt()()),2&e&&(gt(5),Qt("aria-live",r._live)("role",r._role))},dependencies:[KH],styles:['.mdc-snackbar{display:none;position:fixed;right:0;bottom:0;left:0;align-items:center;justify-content:center;box-sizing:border-box;pointer-events:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mdc-snackbar--opening,.mdc-snackbar--open,.mdc-snackbar--closing{display:flex}.mdc-snackbar--open .mdc-snackbar__label,.mdc-snackbar--open .mdc-snackbar__actions{visibility:visible}.mdc-snackbar__surface{padding-left:0;padding-right:8px;display:flex;align-items:center;justify-content:flex-start;box-sizing:border-box;transform:scale(0.8);opacity:0}.mdc-snackbar__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-snackbar__surface::before{border-color:CanvasText}}[dir=rtl] .mdc-snackbar__surface,.mdc-snackbar__surface[dir=rtl]{padding-left:8px;padding-right:0}.mdc-snackbar--open .mdc-snackbar__surface{transform:scale(1);opacity:1;pointer-events:auto}.mdc-snackbar--closing .mdc-snackbar__surface{transform:scale(1)}.mdc-snackbar__label{padding-left:16px;padding-right:8px;width:100%;flex-grow:1;box-sizing:border-box;margin:0;visibility:hidden;padding-top:14px;padding-bottom:14px}[dir=rtl] .mdc-snackbar__label,.mdc-snackbar__label[dir=rtl]{padding-left:8px;padding-right:16px}.mdc-snackbar__label::before{display:inline;content:attr(data-mdc-snackbar-label-text)}.mdc-snackbar__actions{display:flex;flex-shrink:0;align-items:center;box-sizing:border-box;visibility:hidden}.mdc-snackbar__action+.mdc-snackbar__dismiss{margin-left:8px;margin-right:0}[dir=rtl] .mdc-snackbar__action+.mdc-snackbar__dismiss,.mdc-snackbar__action+.mdc-snackbar__dismiss[dir=rtl]{margin-left:0;margin-right:8px}.mat-mdc-snack-bar-container{margin:8px;position:static}.mat-mdc-snack-bar-container .mdc-snackbar__surface{min-width:344px}@media(max-width: 480px),(max-width: 344px){.mat-mdc-snack-bar-container .mdc-snackbar__surface{min-width:100%}}.mat-mdc-snack-bar-container .mdc-snackbar__surface{max-width:672px}.mat-mdc-snack-bar-container .mdc-snackbar__surface{box-shadow:0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12)}.mat-mdc-snack-bar-container .mdc-snackbar__dismiss .mdc-button__icon{font-size:var(--mdc-icon-button-icon-size, 24px)}.mat-mdc-snack-bar-container .mdc-snackbar__dismiss svg,.mat-mdc-snack-bar-container .mdc-snackbar__dismiss img{width:var(--mdc-icon-button-icon-size, 24px);height:var(--mdc-icon-button-icon-size, 24px)}.mat-mdc-snack-bar-container .mdc-snackbar__surface{background-color:var(--mdc-snackbar-container-color, inherit)}.mat-mdc-snack-bar-container .mdc-snackbar__surface{border-radius:var(--mdc-snackbar-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-snack-bar-container .mdc-snackbar__label{color:var(--mdc-snackbar-supporting-text-color, inherit)}.mat-mdc-snack-bar-container .mdc-snackbar__label{font-size:var(--mdc-snackbar-supporting-text-size, inherit);font-family:var(--mdc-snackbar-supporting-text-font, inherit);font-weight:var(--mdc-snackbar-supporting-text-weight, inherit);line-height:var(--mdc-snackbar-supporting-text-line-height, inherit)}.cdk-high-contrast-active .mat-mdc-snack-bar-container{border:solid 1px}.mat-mdc-snack-bar-container .mat-mdc-button.mat-mdc-snack-bar-action:not(:disabled){color:var(--mat-mdc-snack-bar-button-color, transparent);--mat-mdc-button-persistent-ripple-color: currentColor}.mat-mdc-snack-bar-container .mat-mdc-button.mat-mdc-snack-bar-action:not(:disabled) .mat-ripple-element{background-color:currentColor;opacity:.1}.mat-mdc-snack-bar-handset,.mat-mdc-snack-bar-container,.mat-mdc-snack-bar-label{flex:1 1 auto}.mat-mdc-snack-bar-handset .mdc-snackbar__surface{width:100%}'],encapsulation:2,data:{animation:[LRe.snackBarState]}}),n})(),fW=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({imports:[pk,XH,fc,HH,qr,qr]}),n})();const pW=new me("mat-snack-bar-default-options",{providedIn:"root",factory:function zRe(){return new sx}});let URe=(()=>{class n{constructor(e,r,s,i,o,a){this._overlay=e,this._live=r,this._injector=s,this._breakpointObserver=i,this._parentSnackBar=o,this._defaultConfig=a,this._snackBarRefAtThisLevel=null}get _openedSnackBarRef(){const e=this._parentSnackBar;return e?e._openedSnackBarRef:this._snackBarRefAtThisLevel}set _openedSnackBarRef(e){this._parentSnackBar?this._parentSnackBar._openedSnackBarRef=e:this._snackBarRefAtThisLevel=e}openFromComponent(e,r){return this._attach(e,r)}openFromTemplate(e,r){return this._attach(e,r)}open(e,r="",s){const i={...this._defaultConfig,...s};return i.data={message:e,action:r},i.announcementMessage===e&&(i.announcementMessage=void 0),this.openFromComponent(this.simpleSnackBarComponent,i)}dismiss(){this._openedSnackBarRef&&this._openedSnackBarRef.dismiss()}ngOnDestroy(){this._snackBarRefAtThisLevel&&this._snackBarRefAtThisLevel.dismiss()}_attachSnackBarContainer(e,r){const i=vr.create({parent:r&&r.viewContainerRef&&r.viewContainerRef.injector||this._injector,providers:[{provide:sx,useValue:r}]}),o=new ok(this.snackBarContainerComponent,r.viewContainerRef,i),a=e.attach(o);return a.instance.snackBarConfig=r,a.instance}_attach(e,r){const s={...new sx,...this._defaultConfig,...r},i=this._createOverlay(s),o=this._attachSnackBarContainer(i,s),a=new mk(o,i);if(e instanceof Ai){const l=new Jv(e,null,{$implicit:s.data,snackBarRef:a});a.instance=o.attachTemplatePortal(l)}else{const l=this._createInjector(s,a),c=new ok(e,void 0,l),u=o.attachComponentPortal(c);a.instance=u.instance}return this._breakpointObserver.observe("(max-width: 599.98px) and (orientation: portrait)").pipe(wi(i.detachments())).subscribe(l=>{i.overlayElement.classList.toggle(this.handsetCssClass,l.matches)}),s.announcementMessage&&o._onAnnounce.subscribe(()=>{this._live.announce(s.announcementMessage,s.politeness)}),this._animateSnackBar(a,s),this._openedSnackBarRef=a,this._openedSnackBarRef}_animateSnackBar(e,r){e.afterDismissed().subscribe(()=>{this._openedSnackBarRef==e&&(this._openedSnackBarRef=null),r.announcementMessage&&this._live.clear()}),this._openedSnackBarRef?(this._openedSnackBarRef.afterDismissed().subscribe(()=>{e.containerInstance.enter()}),this._openedSnackBarRef.dismiss()):e.containerInstance.enter(),r.duration&&r.duration>0&&e.afterOpened().subscribe(()=>e._dismissAfter(r.duration))}_createOverlay(e){const r=new rx;r.direction=e.direction;let s=this._overlay.position().global();const i="rtl"===e.direction,o="left"===e.horizontalPosition||"start"===e.horizontalPosition&&!i||"end"===e.horizontalPosition&&i,a=!o&&"center"!==e.horizontalPosition;return o?s.left("0"):a?s.right("0"):s.centerHorizontally(),"top"===e.verticalPosition?s.top("0"):s.bottom("0"),r.positionStrategy=s,this._overlay.create(r)}_createInjector(e,r){return vr.create({parent:e&&e.viewContainerRef&&e.viewContainerRef.injector||this._injector,providers:[{provide:mk,useValue:r},{provide:hW,useValue:e.data}]})}}return n.\u0275fac=function(e){return new(e||n)(Z(Ol),Z(XT),Z(vr),Z(GT),Z(n,12),Z(pW))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})(),HRe=(()=>{class n extends URe{constructor(e,r,s,i,o,a){super(e,r,s,i,o,a),this.simpleSnackBarComponent=PRe,this.snackBarContainerComponent=VRe,this.handsetCssClass="mat-mdc-snack-bar-handset"}}return n.\u0275fac=function(e){return new(e||n)(Z(Ol),Z(XT),Z(vr),Z(GT),Z(n,12),Z(pW))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:fW}),n})();const WRe=["determinateSpinner"];function jRe(n,t){if(1&n&&(cu(),Qe(0,"svg",11),rr(1,"circle",12),xt()),2&n){const e=en();Qt("viewBox",e._viewBox()),gt(1),Kh("stroke-dasharray",e._strokeCircumference(),"px")("stroke-dashoffset",e._strokeCircumference()/2,"px")("stroke-width",e._circleStrokeWidth(),"%"),Qt("r",e._circleRadius())}}const GRe=JT(class{constructor(n){this._elementRef=n}},"primary"),qRe=new me("mat-progress-spinner-default-options",{providedIn:"root",factory:function KRe(){return{diameter:mW}}}),mW=100;let YRe=(()=>{class n extends GRe{constructor(e,r,s){super(e),this.mode="mat-spinner"===this._elementRef.nativeElement.nodeName.toLowerCase()?"indeterminate":"determinate",this._value=0,this._diameter=mW,this._noopAnimations="NoopAnimations"===r&&!!s&&!s._forceAnimations,s&&(s.color&&(this.color=this.defaultColor=s.color),s.diameter&&(this.diameter=s.diameter),s.strokeWidth&&(this.strokeWidth=s.strokeWidth))}get value(){return"determinate"===this.mode?this._value:0}set value(e){this._value=Math.max(0,Math.min(100,Dm(e)))}get diameter(){return this._diameter}set diameter(e){this._diameter=Dm(e)}get strokeWidth(){return this._strokeWidth??this.diameter/10}set strokeWidth(e){this._strokeWidth=Dm(e)}_circleRadius(){return(this.diameter-10)/2}_viewBox(){const e=2*this._circleRadius()+this.strokeWidth;return`0 0 ${e} ${e}`}_strokeCircumference(){return 2*Math.PI*this._circleRadius()}_strokeDashOffset(){return"determinate"===this.mode?this._strokeCircumference()*(100-this._value)/100:null}_circleStrokeWidth(){return this.strokeWidth/this.diameter*100}}return n.\u0275fac=function(e){return new(e||n)(B(Kt),B(ga,8),B(qRe))},n.\u0275cmp=Ur({type:n,selectors:[["mat-progress-spinner"],["mat-spinner"]],viewQuery:function(e,r){if(1&e&&lo(WRe,5),2&e){let s;Or(s=$r())&&(r._determinateCircle=s.first)}},hostAttrs:["role","progressbar","tabindex","-1",1,"mat-mdc-progress-spinner","mdc-circular-progress"],hostVars:12,hostBindings:function(e,r){2&e&&(Qt("aria-valuemin",0)("aria-valuemax",100)("aria-valuenow","determinate"===r.mode?r.value:null)("mode",r.mode),Kh("width",r.diameter,"px")("height",r.diameter,"px"),ns("_mat-animation-noopable",r._noopAnimations)("mdc-circular-progress--indeterminate","indeterminate"===r.mode))},inputs:{color:"color",mode:"mode",value:"value",diameter:"diameter",strokeWidth:"strokeWidth"},exportAs:["matProgressSpinner"],features:[it],decls:14,vars:11,consts:[["circle",""],["aria-hidden","true",1,"mdc-circular-progress__determinate-container"],["determinateSpinner",""],["xmlns","http://www.w3.org/2000/svg","focusable","false",1,"mdc-circular-progress__determinate-circle-graphic"],["cx","50%","cy","50%",1,"mdc-circular-progress__determinate-circle"],["aria-hidden","true",1,"mdc-circular-progress__indeterminate-container"],[1,"mdc-circular-progress__spinner-layer"],[1,"mdc-circular-progress__circle-clipper","mdc-circular-progress__circle-left"],[3,"ngTemplateOutlet"],[1,"mdc-circular-progress__gap-patch"],[1,"mdc-circular-progress__circle-clipper","mdc-circular-progress__circle-right"],["xmlns","http://www.w3.org/2000/svg","focusable","false",1,"mdc-circular-progress__indeterminate-circle-graphic"],["cx","50%","cy","50%"]],template:function(e,r){if(1&e&&(wn(0,jRe,2,8,"ng-template",null,0,qg),Qe(2,"div",1,2),cu(),Qe(4,"svg",3),rr(5,"circle",4),xt()(),I0(),Qe(6,"div",5)(7,"div",6)(8,"div",7),Gh(9,8),xt(),Qe(10,"div",9),Gh(11,8),xt(),Qe(12,"div",10),Gh(13,8),xt()()()),2&e){const s=fa(1);gt(4),Qt("viewBox",r._viewBox()),gt(1),Kh("stroke-dasharray",r._strokeCircumference(),"px")("stroke-dashoffset",r._strokeDashOffset(),"px")("stroke-width",r._circleStrokeWidth(),"%"),Qt("r",r._circleRadius()),gt(4),yt("ngTemplateOutlet",s),gt(2),yt("ngTemplateOutlet",s),gt(2),yt("ngTemplateOutlet",s)}},dependencies:[H2],styles:["@keyframes mdc-circular-progress-container-rotate{to{transform:rotate(360deg)}}@keyframes mdc-circular-progress-spinner-layer-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}@keyframes mdc-circular-progress-color-1-fade-in-out{from{opacity:.99}25%{opacity:.99}26%{opacity:0}89%{opacity:0}90%{opacity:.99}to{opacity:.99}}@keyframes mdc-circular-progress-color-2-fade-in-out{from{opacity:0}15%{opacity:0}25%{opacity:.99}50%{opacity:.99}51%{opacity:0}to{opacity:0}}@keyframes mdc-circular-progress-color-3-fade-in-out{from{opacity:0}40%{opacity:0}50%{opacity:.99}75%{opacity:.99}76%{opacity:0}to{opacity:0}}@keyframes mdc-circular-progress-color-4-fade-in-out{from{opacity:0}65%{opacity:0}75%{opacity:.99}90%{opacity:.99}to{opacity:0}}@keyframes mdc-circular-progress-left-spin{from{transform:rotate(265deg)}50%{transform:rotate(130deg)}to{transform:rotate(265deg)}}@keyframes mdc-circular-progress-right-spin{from{transform:rotate(-265deg)}50%{transform:rotate(-130deg)}to{transform:rotate(-265deg)}}.mdc-circular-progress{display:inline-flex;position:relative;direction:ltr;line-height:0;transition:opacity 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-circular-progress__determinate-container,.mdc-circular-progress__indeterminate-circle-graphic,.mdc-circular-progress__indeterminate-container,.mdc-circular-progress__spinner-layer{position:absolute;width:100%;height:100%}.mdc-circular-progress__determinate-container{transform:rotate(-90deg)}.mdc-circular-progress__indeterminate-container{font-size:0;letter-spacing:0;white-space:nowrap;opacity:0}.mdc-circular-progress__determinate-circle-graphic,.mdc-circular-progress__indeterminate-circle-graphic{fill:rgba(0,0,0,0)}.mdc-circular-progress__determinate-circle{transition:stroke-dashoffset 500ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-circular-progress__gap-patch{position:absolute;top:0;left:47.5%;box-sizing:border-box;width:5%;height:100%;overflow:hidden}.mdc-circular-progress__gap-patch .mdc-circular-progress__indeterminate-circle-graphic{left:-900%;width:2000%;transform:rotate(180deg)}.mdc-circular-progress__circle-clipper{display:inline-flex;position:relative;width:50%;height:100%;overflow:hidden}.mdc-circular-progress__circle-clipper .mdc-circular-progress__indeterminate-circle-graphic{width:200%}.mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{left:-100%}.mdc-circular-progress--indeterminate .mdc-circular-progress__determinate-container{opacity:0}.mdc-circular-progress--indeterminate .mdc-circular-progress__indeterminate-container{opacity:1}.mdc-circular-progress--indeterminate .mdc-circular-progress__indeterminate-container{animation:mdc-circular-progress-container-rotate 1568.2352941176ms linear infinite}.mdc-circular-progress--indeterminate .mdc-circular-progress__spinner-layer{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-1{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-1-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-2{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-2-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-3{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-3-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-4{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-4-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-left .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--closed{opacity:0}.mat-mdc-progress-spinner{display:block;overflow:hidden;line-height:0}.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:var(--mdc-circular-progress-active-indicator-color, transparent)}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-1 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-2 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-3 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mat-mdc-progress-spinner .mdc-circular-progress--four-color .mdc-circular-progress__color-4 .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}.mat-mdc-progress-spinner._mat-animation-noopable,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__determinate-circle{transition:none}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-circle-graphic,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__spinner-layer,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container{animation:none}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container circle{stroke-dasharray:0 !important}.cdk-high-contrast-active .mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic,.cdk-high-contrast-active .mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle{stroke:currentColor;stroke:CanvasText}"],encapsulation:2,changeDetection:0}),n})(),ZRe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({imports:[fc,qr]}),n})();function gW(...n){const t=MN(n),{args:e,keys:r}=_$(n),s=new Dn(i=>{const{length:o}=e;if(!o)return void i.complete();const a=new Array(o);let l=o,c=o;for(let u=0;u<o;u++){let d=!1;Rs(e[u]).subscribe(xn(i,h=>{d||(d=!0,c--),a[u]=h},()=>l--,void 0,()=>{(!l||!d)&&(c||i.next(r?v$(r,a):a),i.complete())}))}});return t?s.pipe(oS(t)):s}class gk{}class $l{constructor(t){this.normalizedNames=new Map,this.lazyUpdate=null,t?this.lazyInit="string"==typeof t?()=>{this.headers=new Map,t.split("\n").forEach(e=>{const r=e.indexOf(":");if(r>0){const s=e.slice(0,r),i=s.toLowerCase(),o=e.slice(r+1).trim();this.maybeSetNormalizedName(s,i),this.headers.has(i)?this.headers.get(i).push(o):this.headers.set(i,[o])}})}:()=>{this.headers=new Map,Object.keys(t).forEach(e=>{let r=t[e];const s=e.toLowerCase();"string"==typeof r&&(r=[r]),r.length>0&&(this.headers.set(s,r),this.maybeSetNormalizedName(e,s))})}:this.headers=new Map}has(t){return this.init(),this.headers.has(t.toLowerCase())}get(t){this.init();const e=this.headers.get(t.toLowerCase());return e&&e.length>0?e[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(t){return this.init(),this.headers.get(t.toLowerCase())||null}append(t,e){return this.clone({name:t,value:e,op:"a"})}set(t,e){return this.clone({name:t,value:e,op:"s"})}delete(t,e){return this.clone({name:t,value:e,op:"d"})}maybeSetNormalizedName(t,e){this.normalizedNames.has(e)||this.normalizedNames.set(e,t)}init(){this.lazyInit&&(this.lazyInit instanceof $l?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&&(this.lazyUpdate.forEach(t=>this.applyUpdate(t)),this.lazyUpdate=null))}copyFrom(t){t.init(),Array.from(t.headers.keys()).forEach(e=>{this.headers.set(e,t.headers.get(e)),this.normalizedNames.set(e,t.normalizedNames.get(e))})}clone(t){const e=new $l;return e.lazyInit=this.lazyInit&&this.lazyInit instanceof $l?this.lazyInit:this,e.lazyUpdate=(this.lazyUpdate||[]).concat([t]),e}applyUpdate(t){const e=t.name.toLowerCase();switch(t.op){case"a":case"s":let r=t.value;if("string"==typeof r&&(r=[r]),0===r.length)return;this.maybeSetNormalizedName(t.name,e);const s=("a"===t.op?this.headers.get(e):void 0)||[];s.push(...r),this.headers.set(e,s);break;case"d":const i=t.value;if(i){let o=this.headers.get(e);if(!o)return;o=o.filter(a=>-1===i.indexOf(a)),0===o.length?(this.headers.delete(e),this.normalizedNames.delete(e)):this.headers.set(e,o)}else this.headers.delete(e),this.normalizedNames.delete(e)}}forEach(t){this.init(),Array.from(this.normalizedNames.keys()).forEach(e=>t(this.normalizedNames.get(e),this.headers.get(e)))}}class QRe{encodeKey(t){return bW(t)}encodeValue(t){return bW(t)}decodeKey(t){return decodeURIComponent(t)}decodeValue(t){return decodeURIComponent(t)}}const eMe=/%(\d[a-f0-9])/gi,tMe={40:"@","3A":":",24:"$","2C":",","3B":";","3D":"=","3F":"?","2F":"/"};function bW(n){return encodeURIComponent(n).replace(eMe,(t,e)=>tMe[e]??t)}function ix(n){return`${n}`}class Pl{constructor(t={}){if(this.updates=null,this.cloneFrom=null,this.encoder=t.encoder||new QRe,t.fromString){if(t.fromObject)throw new Error("Cannot specify both fromString and fromObject.");this.map=function JRe(n,t){const e=new Map;return n.length>0&&n.replace(/^\?/,"").split("&").forEach(s=>{const i=s.indexOf("="),[o,a]=-1==i?[t.decodeKey(s),""]:[t.decodeKey(s.slice(0,i)),t.decodeValue(s.slice(i+1))],l=e.get(o)||[];l.push(a),e.set(o,l)}),e}(t.fromString,this.encoder)}else t.fromObject?(this.map=new Map,Object.keys(t.fromObject).forEach(e=>{const r=t.fromObject[e],s=Array.isArray(r)?r.map(ix):[ix(r)];this.map.set(e,s)})):this.map=null}has(t){return this.init(),this.map.has(t)}get(t){this.init();const e=this.map.get(t);return e?e[0]:null}getAll(t){return this.init(),this.map.get(t)||null}keys(){return this.init(),Array.from(this.map.keys())}append(t,e){return this.clone({param:t,value:e,op:"a"})}appendAll(t){const e=[];return Object.keys(t).forEach(r=>{const s=t[r];Array.isArray(s)?s.forEach(i=>{e.push({param:r,value:i,op:"a"})}):e.push({param:r,value:s,op:"a"})}),this.clone(e)}set(t,e){return this.clone({param:t,value:e,op:"s"})}delete(t,e){return this.clone({param:t,value:e,op:"d"})}toString(){return this.init(),this.keys().map(t=>{const e=this.encoder.encodeKey(t);return this.map.get(t).map(r=>e+"="+this.encoder.encodeValue(r)).join("&")}).filter(t=>""!==t).join("&")}clone(t){const e=new Pl({encoder:this.encoder});return e.cloneFrom=this.cloneFrom||this,e.updates=(this.updates||[]).concat(t),e}init(){null===this.map&&(this.map=new Map),null!==this.cloneFrom&&(this.cloneFrom.init(),this.cloneFrom.keys().forEach(t=>this.map.set(t,this.cloneFrom.map.get(t))),this.updates.forEach(t=>{switch(t.op){case"a":case"s":const e=("a"===t.op?this.map.get(t.param):void 0)||[];e.push(ix(t.value)),this.map.set(t.param,e);break;case"d":if(void 0===t.value){this.map.delete(t.param);break}{let r=this.map.get(t.param)||[];const s=r.indexOf(ix(t.value));-1!==s&&r.splice(s,1),r.length>0?this.map.set(t.param,r):this.map.delete(t.param)}}}),this.cloneFrom=this.updates=null)}}class nMe{constructor(){this.map=new Map}set(t,e){return this.map.set(t,e),this}get(t){return this.map.has(t)||this.map.set(t,t.defaultValue()),this.map.get(t)}delete(t){return this.map.delete(t),this}has(t){return this.map.has(t)}keys(){return this.map.keys()}}function _W(n){return typeof ArrayBuffer<"u"&&n instanceof ArrayBuffer}function vW(n){return typeof Blob<"u"&&n instanceof Blob}function xW(n){return typeof FormData<"u"&&n instanceof FormData}class Rm{constructor(t,e,r,s){let i;if(this.url=e,this.body=null,this.reportProgress=!1,this.withCredentials=!1,this.responseType="json",this.method=t.toUpperCase(),function rMe(n){switch(n){case"DELETE":case"GET":case"HEAD":case"OPTIONS":case"JSONP":return!1;default:return!0}}(this.method)||s?(this.body=void 0!==r?r:null,i=s):i=r,i&&(this.reportProgress=!!i.reportProgress,this.withCredentials=!!i.withCredentials,i.responseType&&(this.responseType=i.responseType),i.headers&&(this.headers=i.headers),i.context&&(this.context=i.context),i.params&&(this.params=i.params)),this.headers||(this.headers=new $l),this.context||(this.context=new nMe),this.params){const o=this.params.toString();if(0===o.length)this.urlWithParams=e;else{const a=e.indexOf("?");this.urlWithParams=e+(-1===a?"?":a<e.length-1?"&":"")+o}}else this.params=new Pl,this.urlWithParams=e}serializeBody(){return null===this.body?null:_W(this.body)||vW(this.body)||xW(this.body)||function sMe(n){return typeof URLSearchParams<"u"&&n instanceof URLSearchParams}(this.body)||"string"==typeof this.body?this.body:this.body instanceof Pl?this.body.toString():"object"==typeof this.body||"boolean"==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||xW(this.body)?null:vW(this.body)?this.body.type||null:_W(this.body)?null:"string"==typeof this.body?"text/plain":this.body instanceof Pl?"application/x-www-form-urlencoded;charset=UTF-8":"object"==typeof this.body||"number"==typeof this.body||"boolean"==typeof this.body?"application/json":null}clone(t={}){const e=t.method||this.method,r=t.url||this.url,s=t.responseType||this.responseType,i=void 0!==t.body?t.body:this.body,o=void 0!==t.withCredentials?t.withCredentials:this.withCredentials,a=void 0!==t.reportProgress?t.reportProgress:this.reportProgress;let l=t.headers||this.headers,c=t.params||this.params;const u=t.context??this.context;return void 0!==t.setHeaders&&(l=Object.keys(t.setHeaders).reduce((d,h)=>d.set(h,t.setHeaders[h]),l)),t.setParams&&(c=Object.keys(t.setParams).reduce((d,h)=>d.set(h,t.setParams[h]),c)),new Rm(e,r,i,{params:c,headers:l,context:u,reportProgress:a,responseType:s,withCredentials:o})}}var Kr=(()=>((Kr=Kr||{})[Kr.Sent=0]="Sent",Kr[Kr.UploadProgress=1]="UploadProgress",Kr[Kr.ResponseHeader=2]="ResponseHeader",Kr[Kr.DownloadProgress=3]="DownloadProgress",Kr[Kr.Response=4]="Response",Kr[Kr.User=5]="User",Kr))();class iMe{constructor(t,e=200,r="OK"){this.headers=t.headers||new $l,this.status=void 0!==t.status?t.status:e,this.statusText=t.statusText||r,this.url=t.url||null,this.ok=this.status>=200&&this.status<300}}class yk extends iMe{constructor(t={}){super(t),this.type=Kr.Response,this.body=void 0!==t.body?t.body:null}clone(t={}){return new yk({body:void 0!==t.body?t.body:this.body,headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}function bk(n,t){return{body:t,headers:n.headers,context:n.context,observe:n.observe,params:n.params,reportProgress:n.reportProgress,responseType:n.responseType,withCredentials:n.withCredentials}}let _k=(()=>{class n{constructor(e){this.handler=e}request(e,r,s={}){let i;if(e instanceof Rm)i=e;else{let l,c;l=s.headers instanceof $l?s.headers:new $l(s.headers),s.params&&(c=s.params instanceof Pl?s.params:new Pl({fromObject:s.params})),i=new Rm(e,r,void 0!==s.body?s.body:null,{headers:l,context:s.context,params:c,reportProgress:s.reportProgress,responseType:s.responseType||"json",withCredentials:s.withCredentials})}const o=Ae(i).pipe(el(l=>this.handler.handle(l)));if(e instanceof Rm||"events"===s.observe)return o;const a=o.pipe(or(l=>l instanceof yk));switch(s.observe||"body"){case"body":switch(i.responseType){case"arraybuffer":return a.pipe(Ue(l=>{if(null!==l.body&&!(l.body instanceof ArrayBuffer))throw new Error("Response is not an ArrayBuffer.");return l.body}));case"blob":return a.pipe(Ue(l=>{if(null!==l.body&&!(l.body instanceof Blob))throw new Error("Response is not a Blob.");return l.body}));case"text":return a.pipe(Ue(l=>{if(null!==l.body&&"string"!=typeof l.body)throw new Error("Response is not a string.");return l.body}));default:return a.pipe(Ue(l=>l.body))}case"response":return a;default:throw new Error(`Unreachable: unhandled observe type ${s.observe}}`)}}delete(e,r={}){return this.request("DELETE",e,r)}get(e,r={}){return this.request("GET",e,r)}head(e,r={}){return this.request("HEAD",e,r)}jsonp(e,r){return this.request("JSONP",e,{params:(new Pl).append(r,"JSONP_CALLBACK"),observe:"body",responseType:"json"})}options(e,r={}){return this.request("OPTIONS",e,r)}patch(e,r,s={}){return this.request("PATCH",e,bk(s,r))}post(e,r,s={}){return this.request("POST",e,bk(s,r))}put(e,r,s={}){return this.request("PUT",e,bk(s,r))}}return n.\u0275fac=function(e){return new(e||n)(Z(gk))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();const bMe=["*"];let ax;function Mm(n){return function _Me(){if(void 0===ax&&(ax=null,typeof window<"u")){const n=window;void 0!==n.trustedTypes&&(ax=n.trustedTypes.createPolicy("angular#components",{createHTML:t=>t}))}return ax}()?.createHTML(n)||n}function kW(n){return Error(`Unable to find icon with the name "${n}"`)}function NW(n){return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${n}".`)}function AW(n){return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${n}".`)}class qc{constructor(t,e,r){this.url=t,this.svgText=e,this.options=r}}let lx=(()=>{class n{constructor(e,r,s,i){this._httpClient=e,this._sanitizer=r,this._errorHandler=i,this._svgIconConfigs=new Map,this._iconSetConfigs=new Map,this._cachedIconsByUrl=new Map,this._inProgressUrlFetches=new Map,this._fontCssClassesByAlias=new Map,this._resolvers=[],this._defaultFontSetClass=["material-icons","mat-ligature-font"],this._document=s}addSvgIcon(e,r,s){return this.addSvgIconInNamespace("",e,r,s)}addSvgIconLiteral(e,r,s){return this.addSvgIconLiteralInNamespace("",e,r,s)}addSvgIconInNamespace(e,r,s,i){return this._addSvgIconConfig(e,r,new qc(s,null,i))}addSvgIconResolver(e){return this._resolvers.push(e),this}addSvgIconLiteralInNamespace(e,r,s,i){const o=this._sanitizer.sanitize(Ut.HTML,s);if(!o)throw AW(s);const a=Mm(o);return this._addSvgIconConfig(e,r,new qc("",a,i))}addSvgIconSet(e,r){return this.addSvgIconSetInNamespace("",e,r)}addSvgIconSetLiteral(e,r){return this.addSvgIconSetLiteralInNamespace("",e,r)}addSvgIconSetInNamespace(e,r,s){return this._addSvgIconSetConfig(e,new qc(r,null,s))}addSvgIconSetLiteralInNamespace(e,r,s){const i=this._sanitizer.sanitize(Ut.HTML,r);if(!i)throw AW(r);const o=Mm(i);return this._addSvgIconSetConfig(e,new qc("",o,s))}registerFontClassAlias(e,r=e){return this._fontCssClassesByAlias.set(e,r),this}classNameForFontAlias(e){return this._fontCssClassesByAlias.get(e)||e}setDefaultFontSetClass(...e){return this._defaultFontSetClass=e,this}getDefaultFontSetClass(){return this._defaultFontSetClass}getSvgIconFromUrl(e){const r=this._sanitizer.sanitize(Ut.RESOURCE_URL,e);if(!r)throw NW(e);const s=this._cachedIconsByUrl.get(r);return s?Ae(cx(s)):this._loadSvgIconFromConfig(new qc(e,null)).pipe(ar(i=>this._cachedIconsByUrl.set(r,i)),Ue(i=>cx(i)))}getNamedSvgIcon(e,r=""){const s=RW(r,e);let i=this._svgIconConfigs.get(s);if(i)return this._getSvgFromConfig(i);if(i=this._getIconConfigFromResolvers(r,e),i)return this._svgIconConfigs.set(s,i),this._getSvgFromConfig(i);const o=this._iconSetConfigs.get(r);return o?this._getSvgFromIconSetConfigs(e,o):Gu(kW(s))}ngOnDestroy(){this._resolvers=[],this._svgIconConfigs.clear(),this._iconSetConfigs.clear(),this._cachedIconsByUrl.clear()}_getSvgFromConfig(e){return e.svgText?Ae(cx(this._svgElementFromConfig(e))):this._loadSvgIconFromConfig(e).pipe(Ue(r=>cx(r)))}_getSvgFromIconSetConfigs(e,r){const s=this._extractIconWithNameFromAnySet(e,r);return s?Ae(s):gW(r.filter(o=>!o.svgText).map(o=>this._loadSvgIconSetFromConfig(o).pipe(Fi(a=>{const c=`Loading icon set URL: ${this._sanitizer.sanitize(Ut.RESOURCE_URL,o.url)} failed: ${a.message}`;return this._errorHandler.handleError(new Error(c)),Ae(null)})))).pipe(Ue(()=>{const o=this._extractIconWithNameFromAnySet(e,r);if(!o)throw kW(e);return o}))}_extractIconWithNameFromAnySet(e,r){for(let s=r.length-1;s>=0;s--){const i=r[s];if(i.svgText&&i.svgText.toString().indexOf(e)>-1){const o=this._svgElementFromConfig(i),a=this._extractSvgIconFromSet(o,e,i.options);if(a)return a}}return null}_loadSvgIconFromConfig(e){return this._fetchIcon(e).pipe(ar(r=>e.svgText=r),Ue(()=>this._svgElementFromConfig(e)))}_loadSvgIconSetFromConfig(e){return e.svgText?Ae(null):this._fetchIcon(e).pipe(ar(r=>e.svgText=r))}_extractSvgIconFromSet(e,r,s){const i=e.querySelector(`[id="${r}"]`);if(!i)return null;const o=i.cloneNode(!0);if(o.removeAttribute("id"),"svg"===o.nodeName.toLowerCase())return this._setSvgAttributes(o,s);if("symbol"===o.nodeName.toLowerCase())return this._setSvgAttributes(this._toSvgElement(o),s);const a=this._svgElementFromString(Mm("<svg></svg>"));return a.appendChild(o),this._setSvgAttributes(a,s)}_svgElementFromString(e){const r=this._document.createElement("DIV");r.innerHTML=e;const s=r.querySelector("svg");if(!s)throw Error("<svg> tag not found");return s}_toSvgElement(e){const r=this._svgElementFromString(Mm("<svg></svg>")),s=e.attributes;for(let i=0;i<s.length;i++){const{name:o,value:a}=s[i];"id"!==o&&r.setAttribute(o,a)}for(let i=0;i<e.childNodes.length;i++)e.childNodes[i].nodeType===this._document.ELEMENT_NODE&&r.appendChild(e.childNodes[i].cloneNode(!0));return r}_setSvgAttributes(e,r){return e.setAttribute("fit",""),e.setAttribute("height","100%"),e.setAttribute("width","100%"),e.setAttribute("preserveAspectRatio","xMidYMid meet"),e.setAttribute("focusable","false"),r&&r.viewBox&&e.setAttribute("viewBox",r.viewBox),e}_fetchIcon(e){const{url:r,options:s}=e,i=s?.withCredentials??!1;if(!this._httpClient)throw function vMe(){return Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.")}();if(null==r)throw Error(`Cannot fetch icon from URL "${r}".`);const o=this._sanitizer.sanitize(Ut.RESOURCE_URL,r);if(!o)throw NW(r);const a=this._inProgressUrlFetches.get(o);if(a)return a;const l=this._httpClient.get(o,{responseType:"text",withCredentials:i}).pipe(Ue(c=>Mm(c)),Sy(()=>this._inProgressUrlFetches.delete(o)),PN());return this._inProgressUrlFetches.set(o,l),l}_addSvgIconConfig(e,r,s){return this._svgIconConfigs.set(RW(e,r),s),this}_addSvgIconSetConfig(e,r){const s=this._iconSetConfigs.get(e);return s?s.push(r):this._iconSetConfigs.set(e,[r]),this}_svgElementFromConfig(e){if(!e.svgElement){const r=this._svgElementFromString(e.svgText);this._setSvgAttributes(r,e.options),e.svgElement=r}return e.svgElement}_getIconConfigFromResolvers(e,r){for(let s=0;s<this._resolvers.length;s++){const i=this._resolvers[s](r,e);if(i)return wMe(i)?new qc(i.url,null,i.options):new qc(i,null)}}}return n.\u0275fac=function(e){return new(e||n)(Z(_k,8),Z(iS),Z(wt,8),Z(ca))},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})();function cx(n){return n.cloneNode(!0)}function RW(n,t){return n+":"+t}function wMe(n){return!(!n.url||!n.options)}const CMe=JT(class{constructor(n){this._elementRef=n}}),SMe=new me("MAT_ICON_DEFAULT_OPTIONS"),IMe=new me("mat-icon-location",{providedIn:"root",factory:function EMe(){const n=Bt(wt),t=n?n.location:null;return{getPathname:()=>t?t.pathname+t.search:""}}}),MW=["clip-path","color-profile","src","cursor","fill","filter","marker","marker-start","marker-mid","marker-end","mask","stroke"],DMe=MW.map(n=>`[${n}]`).join(", "),TMe=/^url\(['"]?#(.*?)['"]?\)$/;let kMe=(()=>{class n extends CMe{constructor(e,r,s,i,o,a){super(e),this._iconRegistry=r,this._location=i,this._errorHandler=o,this._inline=!1,this._previousFontSetClass=[],this._currentIconFetch=Ve.EMPTY,a&&(a.color&&(this.color=this.defaultColor=a.color),a.fontSet&&(this.fontSet=a.fontSet)),s||e.nativeElement.setAttribute("aria-hidden","true")}get inline(){return this._inline}set inline(e){this._inline=Ys(e)}get svgIcon(){return this._svgIcon}set svgIcon(e){e!==this._svgIcon&&(e?this._updateSvgIcon(e):this._svgIcon&&this._clearSvgElement(),this._svgIcon=e)}get fontSet(){return this._fontSet}set fontSet(e){const r=this._cleanupFontValue(e);r!==this._fontSet&&(this._fontSet=r,this._updateFontIconClasses())}get fontIcon(){return this._fontIcon}set fontIcon(e){const r=this._cleanupFontValue(e);r!==this._fontIcon&&(this._fontIcon=r,this._updateFontIconClasses())}_splitIconName(e){if(!e)return["",""];const r=e.split(":");switch(r.length){case 1:return["",r[0]];case 2:return r;default:throw Error(`Invalid icon name: "${e}"`)}}ngOnInit(){this._updateFontIconClasses()}ngAfterViewChecked(){const e=this._elementsWithExternalReferences;if(e&&e.size){const r=this._location.getPathname();r!==this._previousPath&&(this._previousPath=r,this._prependPathToReferences(r))}}ngOnDestroy(){this._currentIconFetch.unsubscribe(),this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear()}_usingFontIcon(){return!this.svgIcon}_setSvgElement(e){this._clearSvgElement();const r=this._location.getPathname();this._previousPath=r,this._cacheChildrenWithExternalReferences(e),this._prependPathToReferences(r),this._elementRef.nativeElement.appendChild(e)}_clearSvgElement(){const e=this._elementRef.nativeElement;let r=e.childNodes.length;for(this._elementsWithExternalReferences&&this._elementsWithExternalReferences.clear();r--;){const s=e.childNodes[r];(1!==s.nodeType||"svg"===s.nodeName.toLowerCase())&&s.remove()}}_updateFontIconClasses(){if(!this._usingFontIcon())return;const e=this._elementRef.nativeElement,r=(this.fontSet?this._iconRegistry.classNameForFontAlias(this.fontSet).split(/ +/):this._iconRegistry.getDefaultFontSetClass()).filter(s=>s.length>0);this._previousFontSetClass.forEach(s=>e.classList.remove(s)),r.forEach(s=>e.classList.add(s)),this._previousFontSetClass=r,this.fontIcon!==this._previousFontIconClass&&!r.includes("mat-ligature-font")&&(this._previousFontIconClass&&e.classList.remove(this._previousFontIconClass),this.fontIcon&&e.classList.add(this.fontIcon),this._previousFontIconClass=this.fontIcon)}_cleanupFontValue(e){return"string"==typeof e?e.trim().split(" ")[0]:e}_prependPathToReferences(e){const r=this._elementsWithExternalReferences;r&&r.forEach((s,i)=>{s.forEach(o=>{i.setAttribute(o.name,`url('${e}#${o.value}')`)})})}_cacheChildrenWithExternalReferences(e){const r=e.querySelectorAll(DMe),s=this._elementsWithExternalReferences=this._elementsWithExternalReferences||new Map;for(let i=0;i<r.length;i++)MW.forEach(o=>{const a=r[i],l=a.getAttribute(o),c=l?l.match(TMe):null;if(c){let u=s.get(a);u||(u=[],s.set(a,u)),u.push({name:o,value:c[1]})}})}_updateSvgIcon(e){if(this._svgNamespace=null,this._svgName=null,this._currentIconFetch.unsubscribe(),e){const[r,s]=this._splitIconName(e);r&&(this._svgNamespace=r),s&&(this._svgName=s),this._currentIconFetch=this._iconRegistry.getNamedSvgIcon(s,r).pipe($n(1)).subscribe(i=>this._setSvgElement(i),i=>{this._errorHandler.handleError(new Error(`Error retrieving icon ${r}:${s}! ${i.message}`))})}}}return n.\u0275fac=function(e){return new(e||n)(B(Kt),B(lx),pu("aria-hidden"),B(IMe),B(ca),B(SMe,8))},n.\u0275cmp=Ur({type:n,selectors:[["mat-icon"]],hostAttrs:["role","img",1,"mat-icon","notranslate"],hostVars:8,hostBindings:function(e,r){2&e&&(Qt("data-mat-icon-type",r._usingFontIcon()?"font":"svg")("data-mat-icon-name",r._svgName||r.fontIcon)("data-mat-icon-namespace",r._svgNamespace||r.fontSet)("fontIcon",r._usingFontIcon()?r.fontIcon:null),ns("mat-icon-inline",r.inline)("mat-icon-no-color","primary"!==r.color&&"accent"!==r.color&&"warn"!==r.color))},inputs:{color:"color",inline:"inline",svgIcon:"svgIcon",fontSet:"fontSet",fontIcon:"fontIcon"},exportAs:["matIcon"],features:[it],ngContentSelectors:bMe,decls:1,vars:0,template:function(e,r){1&e&&(ma(),vs(0))},styles:[".mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}"],encapsulation:2,changeDetection:0}),n})(),NMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({imports:[qr,qr]}),n})(),AMe=(()=>{class n{create(e){return typeof MutationObserver>"u"?null:new MutationObserver(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac,providedIn:"root"}),n})(),RMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({providers:[AMe]}),n})(),BMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=Me({type:n}),n})();const VMe=new me("MatFormField");let zMe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({imports:[qr,fc,RMe,qr]}),n})();class UMe{constructor(t=!1,e,r=!0,s){this._multiple=t,this._emitChanges=r,this.compareWith=s,this._selection=new Set,this._deselectedToEmit=[],this._selectedToEmit=[],this.changed=new It,e&&e.length&&(t?e.forEach(i=>this._markSelected(i)):this._markSelected(e[0]),this._selectedToEmit.length=0)}get selected(){return this._selected||(this._selected=Array.from(this._selection.values())),this._selected}select(...t){this._verifyValueAssignment(t),t.forEach(r=>this._markSelected(r));const e=this._hasQueuedChanges();return this._emitChangeEvent(),e}deselect(...t){this._verifyValueAssignment(t),t.forEach(r=>this._unmarkSelected(r));const e=this._hasQueuedChanges();return this._emitChangeEvent(),e}setSelection(...t){this._verifyValueAssignment(t);const e=this.selected,r=new Set(t);t.forEach(i=>this._markSelected(i)),e.filter(i=>!r.has(i)).forEach(i=>this._unmarkSelected(i));const s=this._hasQueuedChanges();return this._emitChangeEvent(),s}toggle(t){return this.isSelected(t)?this.deselect(t):this.select(t)}clear(t=!0){this._unmarkAll();const e=this._hasQueuedChanges();return t&&this._emitChangeEvent(),e}isSelected(t){if(this.compareWith){for(const e of this._selection)if(this.compareWith(e,t))return!0;return!1}return this._selection.has(t)}isEmpty(){return 0===this._selection.size}hasValue(){return!this.isEmpty()}sort(t){this._multiple&&this.selected&&this._selected.sort(t)}isMultipleSelection(){return this._multiple}_emitChangeEvent(){this._selected=null,(this._selectedToEmit.length||this._deselectedToEmit.length)&&(this.changed.next({source:this,added:this._selectedToEmit,removed:this._deselectedToEmit}),this._deselectedToEmit=[],this._selectedToEmit=[])}_markSelected(t){this.isSelected(t)||(this._multiple||this._unmarkAll(),this.isSelected(t)||this._selection.add(t),this._emitChanges&&this._selectedToEmit.push(t))}_unmarkSelected(t){this.isSelected(t)&&(this._selection.delete(t),this._emitChanges&&this._deselectedToEmit.push(t))}_unmarkAll(){this.isEmpty()||this._selection.forEach(t=>this._unmarkSelected(t))}_verifyValueAssignment(t){}_hasQueuedChanges(){return!(!this._deselectedToEmit.length&&!this._selectedToEmit.length)}}let FW=(()=>{class n{constructor(e,r){this._renderer=e,this._elementRef=r,this.onChange=s=>{},this.onTouched=()=>{}}setProperty(e,r){this._renderer.setProperty(this._elementRef.nativeElement,e,r)}registerOnTouched(e){this.onTouched=e}registerOnChange(e){this.onChange=e}setDisabledState(e){this.setProperty("disabled",e)}}return n.\u0275fac=function(e){return new(e||n)(B(la),B(Kt))},n.\u0275dir=Me({type:n}),n})(),Kc=(()=>{class n extends FW{}return n.\u0275fac=function(){let t;return function(r){return(t||(t=nr(n)))(r||n)}}(),n.\u0275dir=Me({type:n,features:[it]}),n})();const Qo=new me("NgValueAccessor"),WMe={provide:Qo,useExisting:fn(()=>xk),multi:!0},GMe=new me("CompositionEventMode");let xk=(()=>{class n extends FW{constructor(e,r,s){super(e,r),this._compositionMode=s,this._composing=!1,null==this._compositionMode&&(this._compositionMode=!function jMe(){const n=Mo()?Mo().getUserAgent():"";return/android (\d+)/.test(n.toLowerCase())}())}writeValue(e){this.setProperty("value",e??"")}_handleInput(e){(!this._compositionMode||this._compositionMode&&!this._composing)&&this.onChange(e)}_compositionStart(){this._composing=!0}_compositionEnd(e){this._composing=!1,this._compositionMode&&this.onChange(e)}}return n.\u0275fac=function(e){return new(e||n)(B(la),B(Kt),B(GMe,8))},n.\u0275dir=Me({type:n,selectors:[["input","formControlName","",3,"type","checkbox"],["textarea","formControlName",""],["input","formControl","",3,"type","checkbox"],["textarea","formControl",""],["input","ngModel","",3,"type","checkbox"],["textarea","ngModel",""],["","ngDefaultControl",""]],hostBindings:function(e,r){1&e&&Jt("input",function(i){return r._handleInput(i.target.value)})("blur",function(){return r.onTouched()})("compositionstart",function(){return r._compositionStart()})("compositionend",function(i){return r._compositionEnd(i.target.value)})},features:[gn([WMe]),it]}),n})();function Ll(n){return null==n||("string"==typeof n||Array.isArray(n))&&0===n.length}function $W(n){return null!=n&&"number"==typeof n.length}const ms=new me("NgValidators"),Bl=new me("NgAsyncValidators"),KMe=/^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;class XMe{static min(t){return function PW(n){return t=>{if(Ll(t.value)||Ll(n))return null;const e=parseFloat(t.value);return!isNaN(e)&&e<n?{min:{min:n,actual:t.value}}:null}}(t)}static max(t){return function LW(n){return t=>{if(Ll(t.value)||Ll(n))return null;const e=parseFloat(t.value);return!isNaN(e)&&e>n?{max:{max:n,actual:t.value}}:null}}(t)}static required(t){return function BW(n){return Ll(n.value)?{required:!0}:null}(t)}static requiredTrue(t){return function VW(n){return!0===n.value?null:{required:!0}}(t)}static email(t){return function zW(n){return Ll(n.value)||KMe.test(n.value)?null:{email:!0}}(t)}static minLength(t){return function UW(n){return t=>Ll(t.value)||!$W(t.value)?null:t.value.length<n?{minlength:{requiredLength:n,actualLength:t.value.length}}:null}(t)}static maxLength(t){return function HW(n){return t=>$W(t.value)&&t.value.length>n?{maxlength:{requiredLength:n,actualLength:t.value.length}}:null}(t)}static pattern(t){return function WW(n){if(!n)return ux;let t,e;return"string"==typeof n?(e="","^"!==n.charAt(0)&&(e+="^"),e+=n,"$"!==n.charAt(n.length-1)&&(e+="$"),t=new RegExp(e)):(e=n.toString(),t=n),r=>{if(Ll(r.value))return null;const s=r.value;return t.test(s)?null:{pattern:{requiredPattern:e,actualValue:s}}}}(t)}static nullValidator(t){return null}static compose(t){return YW(t)}static composeAsync(t){return ZW(t)}}function ux(n){return null}function jW(n){return null!=n}function GW(n){return qh(n)?Tn(n):n}function qW(n){let t={};return n.forEach(e=>{t=null!=e?{...t,...e}:t}),0===Object.keys(t).length?null:t}function KW(n,t){return t.map(e=>e(n))}function XW(n){return n.map(t=>function YMe(n){return!n.validate}(t)?t:e=>t.validate(e))}function YW(n){if(!n)return null;const t=n.filter(jW);return 0==t.length?null:function(e){return qW(KW(e,t))}}function wk(n){return null!=n?YW(XW(n)):null}function ZW(n){if(!n)return null;const t=n.filter(jW);return 0==t.length?null:function(e){return gW(KW(e,t).map(GW)).pipe(Ue(qW))}}function Ck(n){return null!=n?ZW(XW(n)):null}function QW(n,t){return null===n?[t]:Array.isArray(n)?[...n,t]:[n,t]}function JW(n){return n._rawValidators}function ej(n){return n._rawAsyncValidators}function Sk(n){return n?Array.isArray(n)?n:[n]:[]}function dx(n,t){return Array.isArray(n)?n.includes(t):n===t}function tj(n,t){const e=Sk(t);return Sk(n).forEach(s=>{dx(e,s)||e.push(s)}),e}function nj(n,t){return Sk(t).filter(e=>!dx(n,e))}class rj{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(t){this._rawValidators=t||[],this._composedValidatorFn=wk(this._rawValidators)}_setAsyncValidators(t){this._rawAsyncValidators=t||[],this._composedAsyncValidatorFn=Ck(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(t){this._onDestroyCallbacks.push(t)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(t=>t()),this._onDestroyCallbacks=[]}reset(t){this.control&&this.control.reset(t)}hasError(t,e){return!!this.control&&this.control.hasError(t,e)}getError(t,e){return this.control?this.control.getError(t,e):null}}class As extends rj{get formDirective(){return null}get path(){return null}}class Pa extends rj{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}class sj{constructor(t){this._cd=t}get isTouched(){return!!this._cd?.control?.touched}get isUntouched(){return!!this._cd?.control?.untouched}get isPristine(){return!!this._cd?.control?.pristine}get isDirty(){return!!this._cd?.control?.dirty}get isValid(){return!!this._cd?.control?.valid}get isInvalid(){return!!this._cd?.control?.invalid}get isPending(){return!!this._cd?.control?.pending}get isSubmitted(){return!!this._cd?.submitted}}let ij=(()=>{class n extends sj{constructor(e){super(e)}}return n.\u0275fac=function(e){return new(e||n)(B(Pa,2))},n.\u0275dir=Me({type:n,selectors:[["","formControlName",""],["","ngModel",""],["","formControl",""]],hostVars:14,hostBindings:function(e,r){2&e&&ns("ng-untouched",r.isUntouched)("ng-touched",r.isTouched)("ng-pristine",r.isPristine)("ng-dirty",r.isDirty)("ng-valid",r.isValid)("ng-invalid",r.isInvalid)("ng-pending",r.isPending)},features:[it]}),n})();const Fm="VALID",fx="INVALID",uh="PENDING",Om="DISABLED";function Tk(n){return(px(n)?n.validators:n)||null}function kk(n,t){return(px(t)?t.asyncValidators:n)||null}function px(n){return null!=n&&!Array.isArray(n)&&"object"==typeof n}class cj{constructor(t,e){this._pendingDirty=!1,this._hasOwnPendingAsyncValidator=!1,this._pendingTouched=!1,this._onCollectionChange=()=>{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._assignValidators(t),this._assignAsyncValidators(e)}get validator(){return this._composedValidatorFn}set validator(t){this._rawValidators=this._composedValidatorFn=t}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(t){this._rawAsyncValidators=this._composedAsyncValidatorFn=t}get parent(){return this._parent}get valid(){return this.status===Fm}get invalid(){return this.status===fx}get pending(){return this.status==uh}get disabled(){return this.status===Om}get enabled(){return this.status!==Om}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:"change"}setValidators(t){this._assignValidators(t)}setAsyncValidators(t){this._assignAsyncValidators(t)}addValidators(t){this.setValidators(tj(t,this._rawValidators))}addAsyncValidators(t){this.setAsyncValidators(tj(t,this._rawAsyncValidators))}removeValidators(t){this.setValidators(nj(t,this._rawValidators))}removeAsyncValidators(t){this.setAsyncValidators(nj(t,this._rawAsyncValidators))}hasValidator(t){return dx(this._rawValidators,t)}hasAsyncValidator(t){return dx(this._rawAsyncValidators,t)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(t={}){this.touched=!0,this._parent&&!t.onlySelf&&this._parent.markAsTouched(t)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(t=>t.markAllAsTouched())}markAsUntouched(t={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(e=>{e.markAsUntouched({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}markAsDirty(t={}){this.pristine=!1,this._parent&&!t.onlySelf&&this._parent.markAsDirty(t)}markAsPristine(t={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(e=>{e.markAsPristine({onlySelf:!0})}),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}markAsPending(t={}){this.status=uh,!1!==t.emitEvent&&this.statusChanges.emit(this.status),this._parent&&!t.onlySelf&&this._parent.markAsPending(t)}disable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=Om,this.errors=null,this._forEachChild(r=>{r.disable({...t,onlySelf:!0})}),this._updateValue(),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors({...t,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!0))}enable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=Fm,this._forEachChild(r=>{r.enable({...t,onlySelf:!0})}),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent}),this._updateAncestors({...t,skipPristineCheck:e}),this._onDisabledChange.forEach(r=>r(!1))}_updateAncestors(t){this._parent&&!t.onlySelf&&(this._parent.updateValueAndValidity(t),t.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(t){this._parent=t}getRawValue(){return this.value}updateValueAndValidity(t={}){this._setInitialStatus(),this._updateValue(),this.enabled&&(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),(this.status===Fm||this.status===uh)&&this._runAsyncValidator(t.emitEvent)),!1!==t.emitEvent&&(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&&!t.onlySelf&&this._parent.updateValueAndValidity(t)}_updateTreeValidity(t={emitEvent:!0}){this._forEachChild(e=>e._updateTreeValidity(t)),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?Om:Fm}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(t){if(this.asyncValidator){this.status=uh,this._hasOwnPendingAsyncValidator=!0;const e=GW(this.asyncValidator(this));this._asyncValidationSubscription=e.subscribe(r=>{this._hasOwnPendingAsyncValidator=!1,this.setErrors(r,{emitEvent:t})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&&(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(t,e={}){this.errors=t,this._updateControlsErrors(!1!==e.emitEvent)}get(t){let e=t;return null==e||(Array.isArray(e)||(e=e.split(".")),0===e.length)?null:e.reduce((r,s)=>r&&r._find(s),this)}getError(t,e){const r=e?this.get(e):this;return r&&r.errors?r.errors[t]:null}hasError(t,e){return!!this.getError(t,e)}get root(){let t=this;for(;t._parent;)t=t._parent;return t}_updateControlsErrors(t){this.status=this._calculateStatus(),t&&this.statusChanges.emit(this.status),this._parent&&this._parent._updateControlsErrors(t)}_initObservables(){this.valueChanges=new Et,this.statusChanges=new Et}_calculateStatus(){return this._allControlsDisabled()?Om:this.errors?fx:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(uh)?uh:this._anyControlsHaveStatus(fx)?fx:Fm}_anyControlsHaveStatus(t){return this._anyControls(e=>e.status===t)}_anyControlsDirty(){return this._anyControls(t=>t.dirty)}_anyControlsTouched(){return this._anyControls(t=>t.touched)}_updatePristine(t={}){this.pristine=!this._anyControlsDirty(),this._parent&&!t.onlySelf&&this._parent._updatePristine(t)}_updateTouched(t={}){this.touched=this._anyControlsTouched(),this._parent&&!t.onlySelf&&this._parent._updateTouched(t)}_registerOnCollectionChange(t){this._onCollectionChange=t}_setUpdateStrategy(t){px(t)&&null!=t.updateOn&&(this._updateOn=t.updateOn)}_parentMarkedDirty(t){return!t&&!(!this._parent||!this._parent.dirty)&&!this._parent._anyControlsDirty()}_find(t){return null}_assignValidators(t){this._rawValidators=Array.isArray(t)?t.slice():t,this._composedValidatorFn=function sFe(n){return Array.isArray(n)?wk(n):n||null}(this._rawValidators)}_assignAsyncValidators(t){this._rawAsyncValidators=Array.isArray(t)?t.slice():t,this._composedAsyncValidatorFn=function iFe(n){return Array.isArray(n)?Ck(n):n||null}(this._rawAsyncValidators)}}class Nk extends cj{constructor(t,e,r){super(Tk(e),kk(r,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}registerControl(t,e){return this.controls[t]?this.controls[t]:(this.controls[t]=e,e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange),e)}addControl(t,e,r={}){this.registerControl(t,e),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}removeControl(t,e={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],this.updateValueAndValidity({emitEvent:e.emitEvent}),this._onCollectionChange()}setControl(t,e,r={}){this.controls[t]&&this.controls[t]._registerOnCollectionChange(()=>{}),delete this.controls[t],e&&this.registerControl(t,e),this.updateValueAndValidity({emitEvent:r.emitEvent}),this._onCollectionChange()}contains(t){return this.controls.hasOwnProperty(t)&&this.controls[t].enabled}setValue(t,e={}){(function lj(n,t,e){n._forEachChild((r,s)=>{if(void 0===e[s])throw new te(1002,"")})})(this,0,t),Object.keys(t).forEach(r=>{(function aj(n,t,e){const r=n.controls;if(!(t?Object.keys(r):r).length)throw new te(1e3,"");if(!r[e])throw new te(1001,"")})(this,!0,r),this.controls[r].setValue(t[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){null!=t&&(Object.keys(t).forEach(r=>{const s=this.controls[r];s&&s.patchValue(t[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(t={},e={}){this._forEachChild((r,s)=>{r.reset(t[s],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this._reduceChildren({},(t,e,r)=>(t[r]=e.getRawValue(),t))}_syncPendingControls(){let t=this._reduceChildren(!1,(e,r)=>!!r._syncPendingControls()||e);return t&&this.updateValueAndValidity({onlySelf:!0}),t}_forEachChild(t){Object.keys(this.controls).forEach(e=>{const r=this.controls[e];r&&t(r,e)})}_setUpControls(){this._forEachChild(t=>{t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(t){for(const[e,r]of Object.entries(this.controls))if(this.contains(e)&&t(r))return!0;return!1}_reduceValue(){return this._reduceChildren({},(e,r,s)=>((r.enabled||this.disabled)&&(e[s]=r.value),e))}_reduceChildren(t,e){let r=t;return this._forEachChild((s,i)=>{r=e(r,s,i)}),r}_allControlsDisabled(){for(const t of Object.keys(this.controls))if(this.controls[t].enabled)return!1;return Object.keys(this.controls).length>0||this.disabled}_find(t){return this.controls.hasOwnProperty(t)?this.controls[t]:null}}const dh=new me("CallSetDisabledState",{providedIn:"root",factory:()=>mx}),mx="always";function $m(n,t,e=mx){Ak(n,t),t.valueAccessor.writeValue(n.value),(n.disabled||"always"===e)&&t.valueAccessor.setDisabledState?.(n.disabled),function lFe(n,t){t.valueAccessor.registerOnChange(e=>{n._pendingValue=e,n._pendingChange=!0,n._pendingDirty=!0,"change"===n.updateOn&&uj(n,t)})}(n,t),function uFe(n,t){const e=(r,s)=>{t.valueAccessor.writeValue(r),s&&t.viewToModelUpdate(r)};n.registerOnChange(e),t._registerOnDestroy(()=>{n._unregisterOnChange(e)})}(n,t),function cFe(n,t){t.valueAccessor.registerOnTouched(()=>{n._pendingTouched=!0,"blur"===n.updateOn&&n._pendingChange&&uj(n,t),"submit"!==n.updateOn&&n.markAsTouched()})}(n,t),function aFe(n,t){if(t.valueAccessor.setDisabledState){const e=r=>{t.valueAccessor.setDisabledState(r)};n.registerOnDisabledChange(e),t._registerOnDestroy(()=>{n._unregisterOnDisabledChange(e)})}}(n,t)}function yx(n,t,e=!0){const r=()=>{};t.valueAccessor&&(t.valueAccessor.registerOnChange(r),t.valueAccessor.registerOnTouched(r)),_x(n,t),n&&(t._invokeOnDestroyCallbacks(),n._registerOnCollectionChange(()=>{}))}function bx(n,t){n.forEach(e=>{e.registerOnValidatorChange&&e.registerOnValidatorChange(t)})}function Ak(n,t){const e=JW(n);null!==t.validator?n.setValidators(QW(e,t.validator)):"function"==typeof e&&n.setValidators([e]);const r=ej(n);null!==t.asyncValidator?n.setAsyncValidators(QW(r,t.asyncValidator)):"function"==typeof r&&n.setAsyncValidators([r]);const s=()=>n.updateValueAndValidity();bx(t._rawValidators,s),bx(t._rawAsyncValidators,s)}function _x(n,t){let e=!1;if(null!==n){if(null!==t.validator){const s=JW(n);if(Array.isArray(s)&&s.length>0){const i=s.filter(o=>o!==t.validator);i.length!==s.length&&(e=!0,n.setValidators(i))}}if(null!==t.asyncValidator){const s=ej(n);if(Array.isArray(s)&&s.length>0){const i=s.filter(o=>o!==t.asyncValidator);i.length!==s.length&&(e=!0,n.setAsyncValidators(i))}}}const r=()=>{};return bx(t._rawValidators,r),bx(t._rawAsyncValidators,r),e}function uj(n,t){n._pendingDirty&&n.markAsDirty(),n.setValue(n._pendingValue,{emitModelToViewChange:!1}),t.viewToModelUpdate(n._pendingValue),n._pendingChange=!1}function dj(n,t){Ak(n,t)}function hj(n,t){n._syncPendingControls(),t.forEach(e=>{const r=e.control;"submit"===r.updateOn&&r._pendingChange&&(e.viewToModelUpdate(r._pendingValue),r._pendingChange=!1)})}const mFe={provide:As,useExisting:fn(()=>vx)},Pm=(()=>Promise.resolve())();let vx=(()=>{class n extends As{constructor(e,r,s){super(),this.callSetDisabledState=s,this.submitted=!1,this._directives=new Set,this.ngSubmit=new Et,this.form=new Nk({},wk(e),Ck(r))}ngAfterViewInit(){this._setUpdateStrategy()}get formDirective(){return this}get control(){return this.form}get path(){return[]}get controls(){return this.form.controls}addControl(e){Pm.then(()=>{const r=this._findContainer(e.path);e.control=r.registerControl(e.name,e.control),$m(e.control,e,this.callSetDisabledState),e.control.updateValueAndValidity({emitEvent:!1}),this._directives.add(e)})}getControl(e){return this.form.get(e.path)}removeControl(e){Pm.then(()=>{const r=this._findContainer(e.path);r&&r.removeControl(e.name),this._directives.delete(e)})}addFormGroup(e){Pm.then(()=>{const r=this._findContainer(e.path),s=new Nk({});dj(s,e),r.registerControl(e.name,s),s.updateValueAndValidity({emitEvent:!1})})}removeFormGroup(e){Pm.then(()=>{const r=this._findContainer(e.path);r&&r.removeControl(e.name)})}getFormGroup(e){return this.form.get(e.path)}updateModel(e,r){Pm.then(()=>{this.form.get(e.path).setValue(r)})}setValue(e){this.control.setValue(e)}onSubmit(e){return this.submitted=!0,hj(this.form,this._directives),this.ngSubmit.emit(e),"dialog"===e?.target?.method}onReset(){this.resetForm()}resetForm(e){this.form.reset(e),this.submitted=!1}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.form._updateOn=this.options.updateOn)}_findContainer(e){return e.pop(),e.length?this.form.get(e):this.form}}return n.\u0275fac=function(e){return new(e||n)(B(ms,10),B(Bl,10),B(dh,8))},n.\u0275dir=Me({type:n,selectors:[["form",3,"ngNoForm","",3,"formGroup",""],["ng-form"],["","ngForm",""]],hostBindings:function(e,r){1&e&&Jt("submit",function(i){return r.onSubmit(i)})("reset",function(){return r.onReset()})},inputs:{options:["ngFormOptions","options"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[gn([mFe]),it]}),n})();function fj(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}function pj(n){return"object"==typeof n&&null!==n&&2===Object.keys(n).length&&"value"in n&&"disabled"in n}const mj=class extends cj{constructor(t=null,e,r){super(Tk(e),kk(r,e)),this.defaultValue=null,this._onChange=[],this._pendingChange=!1,this._applyFormState(t),this._setUpdateStrategy(e),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator}),px(e)&&(e.nonNullable||e.initialValueIsDefault)&&(this.defaultValue=pj(t)?t.value:t)}setValue(t,e={}){this.value=this._pendingValue=t,this._onChange.length&&!1!==e.emitModelToViewChange&&this._onChange.forEach(r=>r(this.value,!1!==e.emitViewToModelChange)),this.updateValueAndValidity(e)}patchValue(t,e={}){this.setValue(t,e)}reset(t=this.defaultValue,e={}){this._applyFormState(t),this.markAsPristine(e),this.markAsUntouched(e),this.setValue(this.value,e),this._pendingChange=!1}_updateValue(){}_anyControls(t){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(t){this._onChange.push(t)}_unregisterOnChange(t){fj(this._onChange,t)}registerOnDisabledChange(t){this._onDisabledChange.push(t)}_unregisterOnDisabledChange(t){fj(this._onDisabledChange,t)}_forEachChild(t){}_syncPendingControls(){return!("submit"!==this.updateOn||(this._pendingDirty&&this.markAsDirty(),this._pendingTouched&&this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(t){pj(t)?(this.value=this._pendingValue=t.value,t.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=t}},bFe={provide:Pa,useExisting:fn(()=>Ok)},bj=(()=>Promise.resolve())();let Ok=(()=>{class n extends Pa{constructor(e,r,s,i,o,a){super(),this._changeDetectorRef=o,this.callSetDisabledState=a,this.control=new mj,this._registered=!1,this.update=new Et,this._parent=e,this._setValidators(r),this._setAsyncValidators(s),this.valueAccessor=function Fk(n,t){if(!t)return null;let e,r,s;return Array.isArray(t),t.forEach(i=>{i.constructor===xk?e=i:function fFe(n){return Object.getPrototypeOf(n.constructor)===Kc}(i)?r=i:s=i}),s||r||e||null}(0,i)}ngOnChanges(e){if(this._checkForErrors(),!this._registered||"name"in e){if(this._registered&&(this._checkName(),this.formDirective)){const r=e.name.previousValue;this.formDirective.removeControl({name:r,path:this._getPath(r)})}this._setUpControl()}"isDisabled"in e&&this._updateDisabled(e),function Mk(n,t){if(!n.hasOwnProperty("model"))return!1;const e=n.model;return!!e.isFirstChange()||!Object.is(t,e.currentValue)}(e,this.viewModel)&&(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&&this.formDirective.removeControl(this)}get path(){return this._getPath(this.name)}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&&null!=this.options.updateOn&&(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){$m(this.control,this,this.callSetDisabledState),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&&this.options.name&&(this.name=this.options.name),this._isStandalone()}_updateValue(e){bj.then(()=>{this.control.setValue(e,{emitViewToModelChange:!1}),this._changeDetectorRef?.markForCheck()})}_updateDisabled(e){const r=e.isDisabled.currentValue,s=0!==r&&function ju(n){return"boolean"==typeof n?n:null!=n&&"false"!==n}(r);bj.then(()=>{s&&!this.control.disabled?this.control.disable():!s&&this.control.disabled&&this.control.enable(),this._changeDetectorRef?.markForCheck()})}_getPath(e){return this._parent?function gx(n,t){return[...t.path,n]}(e,this._parent):[e]}}return n.\u0275fac=function(e){return new(e||n)(B(As,9),B(ms,10),B(Bl,10),B(Qo,10),B(uo,8),B(dh,8))},n.\u0275dir=Me({type:n,selectors:[["","ngModel","",3,"formControlName","",3,"formControl",""]],inputs:{name:"name",isDisabled:["disabled","isDisabled"],model:["ngModel","model"],options:["ngModelOptions","options"]},outputs:{update:"ngModelChange"},exportAs:["ngModel"],features:[gn([bFe]),it,Os]}),n})(),vj=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({}),n})();const $k=new me("NgModelWithFormControlWarning"),IFe={provide:As,useExisting:fn(()=>xx)};let xx=(()=>{class n extends As{constructor(e,r,s){super(),this.callSetDisabledState=s,this.submitted=!1,this._onCollectionChange=()=>this._updateDomValue(),this.directives=[],this.form=null,this.ngSubmit=new Et,this._setValidators(e),this._setAsyncValidators(r)}ngOnChanges(e){this._checkFormPresent(),e.hasOwnProperty("form")&&(this._updateValidators(),this._updateDomValue(),this._updateRegistrations(),this._oldForm=this.form)}ngOnDestroy(){this.form&&(_x(this.form,this),this.form._onCollectionChange===this._onCollectionChange&&this.form._registerOnCollectionChange(()=>{}))}get formDirective(){return this}get control(){return this.form}get path(){return[]}addControl(e){const r=this.form.get(e.path);return $m(r,e,this.callSetDisabledState),r.updateValueAndValidity({emitEvent:!1}),this.directives.push(e),r}getControl(e){return this.form.get(e.path)}removeControl(e){yx(e.control||null,e,!1),function pFe(n,t){const e=n.indexOf(t);e>-1&&n.splice(e,1)}(this.directives,e)}addFormGroup(e){this._setUpFormContainer(e)}removeFormGroup(e){this._cleanUpFormContainer(e)}getFormGroup(e){return this.form.get(e.path)}addFormArray(e){this._setUpFormContainer(e)}removeFormArray(e){this._cleanUpFormContainer(e)}getFormArray(e){return this.form.get(e.path)}updateModel(e,r){this.form.get(e.path).setValue(r)}onSubmit(e){return this.submitted=!0,hj(this.form,this.directives),this.ngSubmit.emit(e),"dialog"===e?.target?.method}onReset(){this.resetForm()}resetForm(e){this.form.reset(e),this.submitted=!1}_updateDomValue(){this.directives.forEach(e=>{const r=e.control,s=this.form.get(e.path);r!==s&&(yx(r||null,e),(n=>n instanceof mj)(s)&&($m(s,e,this.callSetDisabledState),e.control=s))}),this.form._updateTreeValidity({emitEvent:!1})}_setUpFormContainer(e){const r=this.form.get(e.path);dj(r,e),r.updateValueAndValidity({emitEvent:!1})}_cleanUpFormContainer(e){if(this.form){const r=this.form.get(e.path);r&&function dFe(n,t){return _x(n,t)}(r,e)&&r.updateValueAndValidity({emitEvent:!1})}}_updateRegistrations(){this.form._registerOnCollectionChange(this._onCollectionChange),this._oldForm&&this._oldForm._registerOnCollectionChange(()=>{})}_updateValidators(){Ak(this.form,this),this._oldForm&&_x(this._oldForm,this)}_checkFormPresent(){}}return n.\u0275fac=function(e){return new(e||n)(B(ms,10),B(Bl,10),B(dh,8))},n.\u0275dir=Me({type:n,selectors:[["","formGroup",""]],hostBindings:function(e,r){1&e&&Jt("submit",function(i){return r.onSubmit(i)})("reset",function(){return r.onReset()})},inputs:{form:["formGroup","form"]},outputs:{ngSubmit:"ngSubmit"},exportAs:["ngForm"],features:[gn([IFe]),it,Os]}),n})(),Pj=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({imports:[vj]}),n})(),HFe=(()=>{class n{static withConfig(e){return{ngModule:n,providers:[{provide:dh,useValue:e.callSetDisabledState??mx}]}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({imports:[Pj]}),n})(),WFe=(()=>{class n{static withConfig(e){return{ngModule:n,providers:[{provide:$k,useValue:e.warnOnNgModelWithFormControl??"always"},{provide:dh,useValue:e.callSetDisabledState??mx}]}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({imports:[Pj]}),n})();const GFe=["trigger"],qFe=["panel"];function KFe(n,t){if(1&n&&(Qe(0,"span",10),rs(1),xt()),2&n){const e=en();gt(1),Yh(e.placeholder)}}function XFe(n,t){if(1&n&&(Qe(0,"span",14),rs(1),xt()),2&n){const e=en(2);gt(1),Yh(e.triggerValue)}}function YFe(n,t){1&n&&vs(0,0,["*ngSwitchCase","true"])}function ZFe(n,t){1&n&&(Qe(0,"span",11),wn(1,XFe,2,1,"span",12),wn(2,YFe,1,0,"ng-content",13),xt()),2&n&&(yt("ngSwitch",!!en().customTrigger),gt(2),yt("ngSwitchCase",!0))}function QFe(n,t){if(1&n){const e=pa();cu(),I0(),Qe(0,"div",15,16),Jt("@transformPanel.done",function(s){return Qr(e),Jr(en()._panelDoneAnimatingStream.next(s.toState))})("keydown",function(s){return Qr(e),Jr(en()._handleKeydown(s))}),vs(2,1),xt()}if(2&n){const e=en();vF("mat-mdc-select-panel mdc-menu-surface mdc-menu-surface--open ",e._getPanelTheme(),""),yt("ngClass",e.panelClass)("@transformPanel","showing"),Qt("id",e.id+"-panel")("aria-multiselectable",e.multiple)("aria-label",e.ariaLabel||null)("aria-labelledby",e._getPanelAriaLabelledby())}}const JFe=[[["mat-select-trigger"]],"*"],eOe=["mat-select-trigger","*"],tOe={transformPanelWrap:oh("transformPanelWrap",[$a("* => void",jAe("@transformPanel",[WAe()],{optional:!0}))]),transformPanel:oh("transformPanel",[ah("void",Ns({opacity:0,transform:"scale(1, 0.8)"})),$a("void => showing",Fl("120ms cubic-bezier(0, 0, 0.2, 1)",Ns({opacity:1,transform:"scale(1, 1)"}))),$a("* => void",Fl("100ms linear",Ns({opacity:0})))])};let Lj=0;const Bj=new me("mat-select-scroll-strategy"),rOe=new me("MAT_SELECT_CONFIG"),sOe={provide:Bj,deps:[Ol],useFactory:function nOe(n){return()=>n.scrollStrategies.reposition()}},iOe=new me("MatSelectTrigger");class oOe{constructor(t,e){this.source=t,this.value=e}}const aOe=ek(pAe(QT(mAe(class{constructor(n,t,e,r,s){this._elementRef=n,this._defaultErrorStateMatcher=t,this._parentForm=e,this._parentFormGroup=r,this.ngControl=s,this.stateChanges=new It}}))));let lOe=(()=>{class n extends aOe{constructor(e,r,s,i,o,a,l,c,u,d,h,f,p,m){super(o,i,l,c,d),this._viewportRuler=e,this._changeDetectorRef=r,this._ngZone=s,this._dir=a,this._parentFormField=u,this._liveAnnouncer=p,this._defaultOptions=m,this._panelOpen=!1,this._compareWith=(g,y)=>g===y,this._uid="mat-select-"+Lj++,this._triggerAriaLabelledBy=null,this._destroy=new It,this._onChange=()=>{},this._onTouched=()=>{},this._valueId="mat-select-value-"+Lj++,this._panelDoneAnimatingStream=new It,this._overlayPanelClass=this._defaultOptions?.overlayPanelClass||"",this._focused=!1,this.controlType="mat-select",this._multiple=!1,this._disableOptionCentering=this._defaultOptions?.disableOptionCentering??!1,this.ariaLabel="",this.optionSelectionChanges=wy(()=>{const g=this.options;return g?g.changes.pipe(pc(g),ss(()=>Ua(...g.map(y=>y.onSelectionChange)))):this._ngZone.onStable.pipe($n(1),ss(()=>this.optionSelectionChanges))}),this.openedChange=new Et,this._openedStream=this.openedChange.pipe(or(g=>g),Ue(()=>{})),this._closedStream=this.openedChange.pipe(or(g=>!g),Ue(()=>{})),this.selectionChange=new Et,this.valueChange=new Et,this.ngControl&&(this.ngControl.valueAccessor=this),null!=m?.typeaheadDebounceInterval&&(this._typeaheadDebounceInterval=m.typeaheadDebounceInterval),this._scrollStrategyFactory=f,this._scrollStrategy=this._scrollStrategyFactory(),this.tabIndex=parseInt(h)||0,this.id=this.id}get focused(){return this._focused||this._panelOpen}get placeholder(){return this._placeholder}set placeholder(e){this._placeholder=e,this.stateChanges.next()}get required(){return this._required??this.ngControl?.control?.hasValidator(XMe.required)??!1}set required(e){this._required=Ys(e),this.stateChanges.next()}get multiple(){return this._multiple}set multiple(e){this._multiple=Ys(e)}get disableOptionCentering(){return this._disableOptionCentering}set disableOptionCentering(e){this._disableOptionCentering=Ys(e)}get compareWith(){return this._compareWith}set compareWith(e){this._compareWith=e,this._selectionModel&&this._initializeSelection()}get value(){return this._value}set value(e){this._assignValue(e)&&this._onChange(e)}get typeaheadDebounceInterval(){return this._typeaheadDebounceInterval}set typeaheadDebounceInterval(e){this._typeaheadDebounceInterval=Dm(e)}get id(){return this._id}set id(e){this._id=e||this._uid,this.stateChanges.next()}ngOnInit(){this._selectionModel=new UMe(this.multiple),this.stateChanges.next(),this._panelDoneAnimatingStream.pipe(vH(),wi(this._destroy)).subscribe(()=>this._panelDoneAnimating(this.panelOpen))}ngAfterContentInit(){this._initKeyManager(),this._selectionModel.changed.pipe(wi(this._destroy)).subscribe(e=>{e.added.forEach(r=>r.select()),e.removed.forEach(r=>r.deselect())}),this.options.changes.pipe(pc(null),wi(this._destroy)).subscribe(()=>{this._resetOptions(),this._initializeSelection()})}ngDoCheck(){const e=this._getTriggerAriaLabelledby(),r=this.ngControl;if(e!==this._triggerAriaLabelledBy){const s=this._elementRef.nativeElement;this._triggerAriaLabelledBy=e,e?s.setAttribute("aria-labelledby",e):s.removeAttribute("aria-labelledby")}r&&(this._previousControl!==r.control&&(void 0!==this._previousControl&&null!==r.disabled&&r.disabled!==this.disabled&&(this.disabled=r.disabled),this._previousControl=r.control),this.updateErrorState())}ngOnChanges(e){(e.disabled||e.userAriaDescribedBy)&&this.stateChanges.next(),e.typeaheadDebounceInterval&&this._keyManager&&this._keyManager.withTypeAhead(this._typeaheadDebounceInterval)}ngOnDestroy(){this._keyManager?.destroy(),this._destroy.next(),this._destroy.complete(),this.stateChanges.complete()}toggle(){this.panelOpen?this.close():this.open()}open(){this._canOpen()&&(this._panelOpen=!0,this._keyManager.withHorizontalOrientation(null),this._highlightCorrectOption(),this._changeDetectorRef.markForCheck())}close(){this._panelOpen&&(this._panelOpen=!1,this._keyManager.withHorizontalOrientation(this._isRtl()?"rtl":"ltr"),this._changeDetectorRef.markForCheck(),this._onTouched())}writeValue(e){this._assignValue(e)}registerOnChange(e){this._onChange=e}registerOnTouched(e){this._onTouched=e}setDisabledState(e){this.disabled=e,this._changeDetectorRef.markForCheck(),this.stateChanges.next()}get panelOpen(){return this._panelOpen}get selected(){return this.multiple?this._selectionModel?.selected||[]:this._selectionModel?.selected[0]}get triggerValue(){if(this.empty)return"";if(this._multiple){const e=this._selectionModel.selected.map(r=>r.viewValue);return this._isRtl()&&e.reverse(),e.join(", ")}return this._selectionModel.selected[0].viewValue}_isRtl(){return!!this._dir&&"rtl"===this._dir.value}_handleKeydown(e){this.disabled||(this.panelOpen?this._handleOpenKeydown(e):this._handleClosedKeydown(e))}_handleClosedKeydown(e){const r=e.keyCode,s=40===r||38===r||37===r||39===r,i=13===r||32===r,o=this._keyManager;if(!o.isTyping()&&i&&!th(e)||(this.multiple||e.altKey)&&s)e.preventDefault(),this.open();else if(!this.multiple){const a=this.selected;o.onKeydown(e);const l=this.selected;l&&a!==l&&this._liveAnnouncer.announce(l.viewValue,1e4)}}_handleOpenKeydown(e){const r=this._keyManager,s=e.keyCode,i=40===s||38===s,o=r.isTyping();if(i&&e.altKey)e.preventDefault(),this.close();else if(o||13!==s&&32!==s||!r.activeItem||th(e))if(!o&&this._multiple&&65===s&&e.ctrlKey){e.preventDefault();const a=this.options.some(l=>!l.disabled&&!l.selected);this.options.forEach(l=>{l.disabled||(a?l.select():l.deselect())})}else{const a=r.activeItemIndex;r.onKeydown(e),this._multiple&&i&&e.shiftKey&&r.activeItem&&r.activeItemIndex!==a&&r.activeItem._selectViaInteraction()}else e.preventDefault(),r.activeItem._selectViaInteraction()}_onFocus(){this.disabled||(this._focused=!0,this.stateChanges.next())}_onBlur(){this._focused=!1,this._keyManager?.cancelTypeahead(),!this.disabled&&!this.panelOpen&&(this._onTouched(),this._changeDetectorRef.markForCheck(),this.stateChanges.next())}_onAttached(){this._overlayDir.positionChange.pipe($n(1)).subscribe(()=>{this._changeDetectorRef.detectChanges(),this._positioningSettled()})}_getPanelTheme(){return this._parentFormField?`mat-${this._parentFormField.color}`:""}get empty(){return!this._selectionModel||this._selectionModel.isEmpty()}_initializeSelection(){Promise.resolve().then(()=>{this.ngControl&&(this._value=this.ngControl.value),this._setSelectionByValue(this._value),this.stateChanges.next()})}_setSelectionByValue(e){if(this._selectionModel.selected.forEach(r=>r.setInactiveStyles()),this._selectionModel.clear(),this.multiple&&e)Array.isArray(e),e.forEach(r=>this._selectOptionByValue(r)),this._sortValues();else{const r=this._selectOptionByValue(e);r?this._keyManager.updateActiveItem(r):this.panelOpen||this._keyManager.updateActiveItem(-1)}this._changeDetectorRef.markForCheck()}_selectOptionByValue(e){const r=this.options.find(s=>{if(this._selectionModel.isSelected(s))return!1;try{return null!=s.value&&this._compareWith(s.value,e)}catch{return!1}});return r&&this._selectionModel.select(r),r}_assignValue(e){return!!(e!==this._value||this._multiple&&Array.isArray(e))&&(this.options&&this._setSelectionByValue(e),this._value=e,!0)}_initKeyManager(){this._keyManager=new WNe(this.options).withTypeAhead(this._typeaheadDebounceInterval).withVerticalOrientation().withHorizontalOrientation(this._isRtl()?"rtl":"ltr").withHomeAndEnd().withPageUpDown().withAllowedModifierKeys(["shiftKey"]),this._keyManager.tabOut.subscribe(()=>{this.panelOpen&&(!this.multiple&&this._keyManager.activeItem&&this._keyManager.activeItem._selectViaInteraction(),this.focus(),this.close())}),this._keyManager.change.subscribe(()=>{this._panelOpen&&this.panel?this._scrollOptionIntoView(this._keyManager.activeItemIndex||0):!this._panelOpen&&!this.multiple&&this._keyManager.activeItem&&this._keyManager.activeItem._selectViaInteraction()})}_resetOptions(){const e=Ua(this.options.changes,this._destroy);this.optionSelectionChanges.pipe(wi(e)).subscribe(r=>{this._onSelect(r.source,r.isUserInput),r.isUserInput&&!this.multiple&&this._panelOpen&&(this.close(),this.focus())}),Ua(...this.options.map(r=>r._stateChanges)).pipe(wi(e)).subscribe(()=>{this._changeDetectorRef.markForCheck(),this.stateChanges.next()})}_onSelect(e,r){const s=this._selectionModel.isSelected(e);null!=e.value||this._multiple?(s!==e.selected&&(e.selected?this._selectionModel.select(e):this._selectionModel.deselect(e)),r&&this._keyManager.setActiveItem(e),this.multiple&&(this._sortValues(),r&&this.focus())):(e.deselect(),this._selectionModel.clear(),null!=this.value&&this._propagateChanges(e.value)),s!==this._selectionModel.isSelected(e)&&this._propagateChanges(),this.stateChanges.next()}_sortValues(){if(this.multiple){const e=this.options.toArray();this._selectionModel.sort((r,s)=>this.sortComparator?this.sortComparator(r,s,e):e.indexOf(r)-e.indexOf(s)),this.stateChanges.next()}}_propagateChanges(e){let r=null;r=this.multiple?this.selected.map(s=>s.value):this.selected?this.selected.value:e,this._value=r,this.valueChange.emit(r),this._onChange(r),this.selectionChange.emit(this._getChangeEvent(r)),this._changeDetectorRef.markForCheck()}_highlightCorrectOption(){this._keyManager&&(this.empty?this._keyManager.setFirstItemActive():this._keyManager.setActiveItem(this._selectionModel.selected[0]))}_canOpen(){return!this._panelOpen&&!this.disabled&&this.options?.length>0}focus(e){this._elementRef.nativeElement.focus(e)}_getPanelAriaLabelledby(){if(this.ariaLabel)return null;const e=this._parentFormField?.getLabelId();return this.ariaLabelledby?(e?e+" ":"")+this.ariaLabelledby:e}_getAriaActiveDescendant(){return this.panelOpen&&this._keyManager&&this._keyManager.activeItem?this._keyManager.activeItem.id:null}_getTriggerAriaLabelledby(){if(this.ariaLabel)return null;const e=this._parentFormField?.getLabelId();let r=(e?e+" ":"")+this._valueId;return this.ariaLabelledby&&(r+=" "+this.ariaLabelledby),r}_panelDoneAnimating(e){this.openedChange.emit(e)}setDescribedByIds(e){e.length?this._elementRef.nativeElement.setAttribute("aria-describedby",e.join(" ")):this._elementRef.nativeElement.removeAttribute("aria-describedby")}onContainerClick(){this.focus(),this.open()}get shouldLabelFloat(){return this._panelOpen||!this.empty||this._focused&&!!this._placeholder}}return n.\u0275fac=function(e){return new(e||n)(B(dk),B(uo),B(ft),B(yAe),B(Kt),B(Qv,8),B(vx,8),B(xx,8),B(VMe,8),B(Pa,10),pu("tabindex"),B(Bj),B(XT),B(rOe,8))},n.\u0275dir=Me({type:n,viewQuery:function(e,r){if(1&e&&(lo(GFe,5),lo(qFe,5),lo(dW,5)),2&e){let s;Or(s=$r())&&(r.trigger=s.first),Or(s=$r())&&(r.panel=s.first),Or(s=$r())&&(r._overlayDir=s.first)}},inputs:{userAriaDescribedBy:["aria-describedby","userAriaDescribedBy"],panelClass:"panelClass",placeholder:"placeholder",required:"required",multiple:"multiple",disableOptionCentering:"disableOptionCentering",compareWith:"compareWith",value:"value",ariaLabel:["aria-label","ariaLabel"],ariaLabelledby:["aria-labelledby","ariaLabelledby"],errorStateMatcher:"errorStateMatcher",typeaheadDebounceInterval:"typeaheadDebounceInterval",sortComparator:"sortComparator",id:"id"},outputs:{openedChange:"openedChange",_openedStream:"opened",_closedStream:"closed",selectionChange:"selectionChange",valueChange:"valueChange"},features:[it,Os]}),n})(),cOe=(()=>{class n extends lOe{constructor(){super(...arguments),this._positions=[{originX:"start",originY:"bottom",overlayX:"start",overlayY:"top"},{originX:"start",originY:"top",overlayX:"start",overlayY:"bottom",panelClass:"mat-mdc-select-panel-above"}]}get shouldLabelFloat(){return this.panelOpen||!this.empty||this.focused&&!!this.placeholder}ngOnInit(){super.ngOnInit(),this._viewportRuler.change().pipe(wi(this._destroy)).subscribe(()=>{this.panelOpen&&(this._overlayWidth=this._getOverlayWidth(),this._changeDetectorRef.detectChanges())})}ngAfterViewInit(){this._parentFormField&&(this._preferredOverlayOrigin=this._parentFormField.getConnectedOverlayOrigin())}open(){this._overlayWidth=this._getOverlayWidth(),super.open(),this.stateChanges.next()}close(){super.close(),this.stateChanges.next()}_scrollOptionIntoView(e){const r=this.options.toArray()[e];if(r){const s=this.panel.nativeElement,i=function TAe(n,t,e){if(e.length){let r=t.toArray(),s=e.toArray(),i=0;for(let o=0;o<n+1;o++)r[o].group&&r[o].group===s[i]&&i++;return i}return 0}(e,this.options,this.optionGroups),o=r._getHostElement();s.scrollTop=0===e&&1===i?0:function kAe(n,t,e,r){return n<e?n:n+t>e+r?Math.max(0,n-r+t):e}(o.offsetTop,o.offsetHeight,s.scrollTop,s.offsetHeight)}}_positioningSettled(){this._scrollOptionIntoView(this._keyManager.activeItemIndex||0)}_getChangeEvent(e){return new oOe(this,e)}_getOverlayWidth(){return(this._preferredOverlayOrigin instanceof fk?this._preferredOverlayOrigin.elementRef:this._preferredOverlayOrigin||this._elementRef).nativeElement.getBoundingClientRect().width}}return n.\u0275fac=function(){let t;return function(r){return(t||(t=nr(n)))(r||n)}}(),n.\u0275cmp=Ur({type:n,selectors:[["mat-select"]],contentQueries:function(e,r,s){if(1&e&&(Ya(s,iOe,5),Ya(s,PH,5),Ya(s,$H,5)),2&e){let i;Or(i=$r())&&(r.customTrigger=i.first),Or(i=$r())&&(r.options=i),Or(i=$r())&&(r.optionGroups=i)}},hostAttrs:["role","combobox","aria-autocomplete","none","aria-haspopup","listbox",1,"mat-mdc-select"],hostVars:19,hostBindings:function(e,r){1&e&&Jt("keydown",function(i){return r._handleKeydown(i)})("focus",function(){return r._onFocus()})("blur",function(){return r._onBlur()}),2&e&&(Qt("id",r.id)("tabindex",r.tabIndex)("aria-controls",r.panelOpen?r.id+"-panel":null)("aria-expanded",r.panelOpen)("aria-label",r.ariaLabel||null)("aria-required",r.required.toString())("aria-disabled",r.disabled.toString())("aria-invalid",r.errorState)("aria-activedescendant",r._getAriaActiveDescendant()),ns("mat-mdc-select-disabled",r.disabled)("mat-mdc-select-invalid",r.errorState)("mat-mdc-select-required",r.required)("mat-mdc-select-empty",r.empty)("mat-mdc-select-multiple",r.multiple))},inputs:{disabled:"disabled",disableRipple:"disableRipple",tabIndex:"tabIndex"},exportAs:["matSelect"],features:[gn([{provide:BMe,useExisting:n},{provide:OH,useExisting:n}]),it],ngContentSelectors:eOe,decls:11,vars:11,consts:[["cdk-overlay-origin","",1,"mat-mdc-select-trigger",3,"click"],["fallbackOverlayOrigin","cdkOverlayOrigin","trigger",""],[1,"mat-mdc-select-value",3,"ngSwitch"],["class","mat-mdc-select-placeholder mat-mdc-select-min-line",4,"ngSwitchCase"],["class","mat-mdc-select-value-text",3,"ngSwitch",4,"ngSwitchCase"],[1,"mat-mdc-select-arrow-wrapper"],[1,"mat-mdc-select-arrow"],["viewBox","0 0 24 24","width","24px","height","24px","focusable","false"],["d","M7 10l5 5 5-5z"],["cdk-connected-overlay","","cdkConnectedOverlayLockPosition","","cdkConnectedOverlayHasBackdrop","","cdkConnectedOverlayBackdropClass","cdk-overlay-transparent-backdrop",3,"cdkConnectedOverlayPanelClass","cdkConnectedOverlayScrollStrategy","cdkConnectedOverlayOrigin","cdkConnectedOverlayOpen","cdkConnectedOverlayPositions","cdkConnectedOverlayWidth","backdropClick","attach","detach"],[1,"mat-mdc-select-placeholder","mat-mdc-select-min-line"],[1,"mat-mdc-select-value-text",3,"ngSwitch"],["class","mat-mdc-select-min-line",4,"ngSwitchDefault"],[4,"ngSwitchCase"],[1,"mat-mdc-select-min-line"],["role","listbox","tabindex","-1",3,"ngClass","keydown"],["panel",""]],template:function(e,r){if(1&e&&(ma(JFe),Qe(0,"div",0,1),Jt("click",function(){return r.toggle()}),Qe(3,"div",2),wn(4,KFe,2,1,"span",3),wn(5,ZFe,3,2,"span",4),xt(),Qe(6,"div",5)(7,"div",6),cu(),Qe(8,"svg",7),rr(9,"path",8),xt()()()(),wn(10,QFe,3,9,"ng-template",9),Jt("backdropClick",function(){return r.close()})("attach",function(){return r._onAttached()})("detach",function(){return r.close()})),2&e){const s=fa(1);Qt("aria-owns",r.panelOpen?r.id+"-panel":null),gt(3),yt("ngSwitch",r.empty),Qt("id",r._valueId),gt(1),yt("ngSwitchCase",!0),gt(1),yt("ngSwitchCase",!1),gt(5),yt("cdkConnectedOverlayPanelClass",r._overlayPanelClass)("cdkConnectedOverlayScrollStrategy",r._scrollStrategy)("cdkConnectedOverlayOrigin",r._preferredOverlayOrigin||s)("cdkConnectedOverlayOpen",r.panelOpen)("cdkConnectedOverlayPositions",r._positions)("cdkConnectedOverlayWidth",r._overlayWidth)}},dependencies:[qC,py,V2,z2,dW,fk],styles:['.mdc-menu-surface{display:none;position:absolute;box-sizing:border-box;max-width:calc(100vw - 32px);max-width:var(--mdc-menu-max-width, calc(100vw - 32px));max-height:calc(100vh - 32px);max-height:var(--mdc-menu-max-height, calc(100vh - 32px));margin:0;padding:0;transform:scale(1);transform-origin:top left;opacity:0;overflow:auto;will-change:transform,opacity;z-index:8;border-radius:4px;border-radius:var(--mdc-shape-medium, 4px);transform-origin-left:top left;transform-origin-right:top right}.mdc-menu-surface:focus{outline:none}.mdc-menu-surface--animating-open{display:inline-block;transform:scale(0.8);opacity:0}.mdc-menu-surface--open{display:inline-block;transform:scale(1);opacity:1}.mdc-menu-surface--animating-closed{display:inline-block;opacity:0}[dir=rtl] .mdc-menu-surface,.mdc-menu-surface[dir=rtl]{transform-origin-left:top right;transform-origin-right:top left}.mdc-menu-surface--anchor{position:relative;overflow:visible}.mdc-menu-surface--fixed{position:fixed}.mdc-menu-surface--fullwidth{width:100%}.mat-mdc-select{display:inline-block;width:100%;outline:none}.mat-mdc-select-trigger{display:inline-flex;align-items:center;cursor:pointer;position:relative;box-sizing:border-box;width:100%}.mat-mdc-select-disabled .mat-mdc-select-trigger{-webkit-user-select:none;user-select:none;cursor:default}.mat-mdc-select-value{width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-mdc-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-mdc-select-arrow-wrapper{height:24px;flex-shrink:0;display:inline-flex;align-items:center}.mat-form-field-appearance-fill .mat-mdc-select-arrow-wrapper{transform:translateY(-8px)}.mat-form-field-appearance-fill .mdc-text-field--no-label .mat-mdc-select-arrow-wrapper{transform:none}.mat-mdc-select-arrow{width:10px;height:5px;position:relative}.mat-mdc-select-arrow svg{fill:currentColor;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}.cdk-high-contrast-active .mat-mdc-select-arrow svg{fill:CanvasText}.mat-mdc-select-disabled .cdk-high-contrast-active .mat-mdc-select-arrow svg{fill:GrayText}.mdc-menu-surface.mat-mdc-select-panel{width:100%;max-height:275px;position:static;outline:0;margin:0;padding:8px 0;list-style-type:none}.mdc-menu-surface.mat-mdc-select-panel:focus{outline:none}.cdk-high-contrast-active .mdc-menu-surface.mat-mdc-select-panel{outline:solid 1px}.cdk-overlay-pane:not(.mat-mdc-select-panel-above) .mdc-menu-surface.mat-mdc-select-panel{border-top-left-radius:0;border-top-right-radius:0;transform-origin:top center}.mat-mdc-select-panel-above .mdc-menu-surface.mat-mdc-select-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:bottom center}.mat-mdc-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable .mat-mdc-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-mdc-select-placeholder{color:rgba(0,0,0,0);-webkit-text-fill-color:rgba(0,0,0,0);transition:none;display:block}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mat-mdc-floating-label{max-width:calc(100% - 18px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 24px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-text-field--label-floating .mdc-notched-outline__notch{max-width:calc(100% - 24px)}.mat-mdc-select-min-line:empty::before{content:" ";white-space:pre;width:1px;display:inline-block;visibility:hidden}'],encapsulation:2,data:{animation:[tOe.transformPanel]},changeDetection:0}),n})(),uOe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({providers:[sOe],imports:[fc,pk,LH,qr,nx,zMe,LH,qr]}),n})();function Vj(n,t){return t?e=>gf(t.pipe($n(1),function dOe(){return Mn((n,t)=>{n.subscribe(xn(t,Mr))})}()),e.pipe(Vj(n))):yr((e,r)=>n(e,r).pipe($n(1),D$(e)))}function zj(n,t=Xv){const e=QH(n,t);return Vj(()=>e)}const hOe=["mat-menu-item",""];function fOe(n,t){1&n&&(cu(),Qe(0,"svg",3),rr(1,"polygon",4),xt())}const pOe=[[["mat-icon"]],"*"],mOe=["mat-icon","*"];function gOe(n,t){if(1&n){const e=pa();Qe(0,"div",0),Jt("keydown",function(s){return Qr(e),Jr(en()._handleKeydown(s))})("click",function(){return Qr(e),Jr(en().closed.emit("click"))})("@transformMenu.start",function(s){return Qr(e),Jr(en()._onAnimationStart(s))})("@transformMenu.done",function(s){return Qr(e),Jr(en()._onAnimationDone(s))}),Qe(1,"div",1),vs(2),xt()()}if(2&n){const e=en();yt("id",e.panelId)("ngClass",e._classList)("@transformMenu",e._panelAnimationState),Qt("aria-label",e.ariaLabel||null)("aria-labelledby",e.ariaLabelledby||null)("aria-describedby",e.ariaDescribedby||null)}}const yOe=["*"],Uk=new me("MAT_MENU_PANEL"),bOe=ek(QT(class{}));let wx=(()=>{class n extends bOe{constructor(e,r,s,i,o){super(),this._elementRef=e,this._document=r,this._focusMonitor=s,this._parentMenu=i,this._changeDetectorRef=o,this.role="menuitem",this._hovered=new It,this._focused=new It,this._highlighted=!1,this._triggersSubmenu=!1,i?.addItem?.(this)}focus(e,r){this._focusMonitor&&e?this._focusMonitor.focusVia(this._getHostElement(),e,r):this._getHostElement().focus(r),this._focused.next(this)}ngAfterViewInit(){this._focusMonitor&&this._focusMonitor.monitor(this._elementRef,!1)}ngOnDestroy(){this._focusMonitor&&this._focusMonitor.stopMonitoring(this._elementRef),this._parentMenu&&this._parentMenu.removeItem&&this._parentMenu.removeItem(this),this._hovered.complete(),this._focused.complete()}_getTabIndex(){return this.disabled?"-1":"0"}_getHostElement(){return this._elementRef.nativeElement}_checkDisabled(e){this.disabled&&(e.preventDefault(),e.stopPropagation())}_handleMouseEnter(){this._hovered.next(this)}getLabel(){const e=this._elementRef.nativeElement.cloneNode(!0),r=e.querySelectorAll("mat-icon, .material-icons");for(let s=0;s<r.length;s++)r[s].remove();return e.textContent?.trim()||""}_setHighlighted(e){this._highlighted=e,this._changeDetectorRef?.markForCheck()}_setTriggersSubmenu(e){this._triggersSubmenu=e,this._changeDetectorRef?.markForCheck()}_hasFocus(){return this._document&&this._document.activeElement===this._getHostElement()}}return n.\u0275fac=function(e){return new(e||n)(B(Kt),B(wt),B(YT),B(Uk,8),B(uo))},n.\u0275cmp=Ur({type:n,selectors:[["","mat-menu-item",""]],hostAttrs:[1,"mat-mdc-menu-item","mat-mdc-focus-indicator","mdc-list-item"],hostVars:8,hostBindings:function(e,r){1&e&&Jt("click",function(i){return r._checkDisabled(i)})("mouseenter",function(){return r._handleMouseEnter()}),2&e&&(Qt("role",r.role)("tabindex",r._getTabIndex())("aria-disabled",r.disabled)("disabled",r.disabled||null),ns("mat-mdc-menu-item-highlighted",r._highlighted)("mat-mdc-menu-item-submenu-trigger",r._triggersSubmenu))},inputs:{disabled:"disabled",disableRipple:"disableRipple",role:"role"},exportAs:["matMenuItem"],features:[it],attrs:hOe,ngContentSelectors:mOe,decls:5,vars:3,consts:[[1,"mdc-list-item__primary-text"],["matRipple","",1,"mat-mdc-menu-ripple",3,"matRippleDisabled","matRippleTrigger"],["class","mat-mdc-menu-submenu-icon","viewBox","0 0 5 10","focusable","false",4,"ngIf"],["viewBox","0 0 5 10","focusable","false",1,"mat-mdc-menu-submenu-icon"],["points","0,0 5,5 0,10"]],template:function(e,r){1&e&&(ma(pOe),vs(0),Qe(1,"span",0),vs(2,1),xt(),rr(3,"div",1),wn(4,fOe,2,0,"svg",2)),2&e&&(gt(3),yt("matRippleDisabled",r.disableRipple||r.disabled)("matRippleTrigger",r._getHostElement()),gt(1),yt("ngIf",r._triggersSubmenu))},dependencies:[hf,ih],encapsulation:2,changeDetection:0}),n})();const _Oe=new me("MatMenuContent"),Cx={transformMenu:oh("transformMenu",[ah("void",Ns({opacity:0,transform:"scale(0.8)"})),$a("void => enter",Fl("120ms cubic-bezier(0, 0, 0.2, 1)",Ns({opacity:1,transform:"scale(1)"}))),$a("* => void",Fl("100ms 25ms linear",Ns({opacity:0})))]),fadeInItems:oh("fadeInItems",[ah("showing",Ns({opacity:1})),$a("void => *",[Ns({opacity:0}),Fl("400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)")])])};let vOe=0;const Uj=new me("mat-menu-default-options",{providedIn:"root",factory:function xOe(){return{overlapTrigger:!1,xPosition:"after",yPosition:"below",backdropClass:"cdk-overlay-transparent-backdrop"}}});let Lm=(()=>{class n{constructor(e,r,s,i){this._elementRef=e,this._ngZone=r,this._defaultOptions=s,this._changeDetectorRef=i,this._xPosition=this._defaultOptions.xPosition,this._yPosition=this._defaultOptions.yPosition,this._directDescendantItems=new zu,this._classList={},this._panelAnimationState="void",this._animationDone=new It,this.overlayPanelClass=this._defaultOptions.overlayPanelClass||"",this.backdropClass=this._defaultOptions.backdropClass,this._overlapTrigger=this._defaultOptions.overlapTrigger,this._hasBackdrop=this._defaultOptions.hasBackdrop,this.closed=new Et,this.close=this.closed,this.panelId="mat-menu-panel-"+vOe++}get xPosition(){return this._xPosition}set xPosition(e){this._xPosition=e,this.setPositionClasses()}get yPosition(){return this._yPosition}set yPosition(e){this._yPosition=e,this.setPositionClasses()}get overlapTrigger(){return this._overlapTrigger}set overlapTrigger(e){this._overlapTrigger=Ys(e)}get hasBackdrop(){return this._hasBackdrop}set hasBackdrop(e){this._hasBackdrop=Ys(e)}set panelClass(e){const r=this._previousPanelClass;r&&r.length&&r.split(" ").forEach(s=>{this._classList[s]=!1}),this._previousPanelClass=e,e&&e.length&&(e.split(" ").forEach(s=>{this._classList[s]=!0}),this._elementRef.nativeElement.className="")}get classList(){return this.panelClass}set classList(e){this.panelClass=e}ngOnInit(){this.setPositionClasses()}ngAfterContentInit(){this._updateDirectDescendants(),this._keyManager=new jNe(this._directDescendantItems).withWrap().withTypeAhead().withHomeAndEnd(),this._keyManager.tabOut.subscribe(()=>this.closed.emit("tab")),this._directDescendantItems.changes.pipe(pc(this._directDescendantItems),ss(e=>Ua(...e.map(r=>r._focused)))).subscribe(e=>this._keyManager.updateActiveItem(e)),this._directDescendantItems.changes.subscribe(e=>{const r=this._keyManager;if("enter"===this._panelAnimationState&&r.activeItem?._hasFocus()){const s=e.toArray(),i=Math.max(0,Math.min(s.length-1,r.activeItemIndex||0));s[i]&&!s[i].disabled?r.setActiveItem(i):r.setNextItemActive()}})}ngOnDestroy(){this._keyManager?.destroy(),this._directDescendantItems.destroy(),this.closed.complete(),this._firstItemFocusSubscription?.unsubscribe()}_hovered(){return this._directDescendantItems.changes.pipe(pc(this._directDescendantItems),ss(r=>Ua(...r.map(s=>s._hovered))))}addItem(e){}removeItem(e){}_handleKeydown(e){const r=e.keyCode,s=this._keyManager;switch(r){case 27:th(e)||(e.preventDefault(),this.closed.emit("keydown"));break;case 37:this.parentMenu&&"ltr"===this.direction&&this.closed.emit("keydown");break;case 39:this.parentMenu&&"rtl"===this.direction&&this.closed.emit("keydown");break;default:return(38===r||40===r)&&s.setFocusOrigin("keyboard"),void s.onKeydown(e)}e.stopPropagation()}focusFirstItem(e="program"){this._firstItemFocusSubscription?.unsubscribe(),this._firstItemFocusSubscription=this._ngZone.onStable.pipe($n(1)).subscribe(()=>{let r=null;if(this._directDescendantItems.length&&(r=this._directDescendantItems.first._getHostElement().closest('[role="menu"]')),!r||!r.contains(document.activeElement)){const s=this._keyManager;s.setFocusOrigin(e).setFirstItemActive(),!s.activeItem&&r&&r.focus()}})}resetActiveItem(){this._keyManager.setActiveItem(-1)}setElevation(e){const r=Math.min(this._baseElevation+e,24),s=`${this._elevationPrefix}${r}`,i=Object.keys(this._classList).find(o=>o.startsWith(this._elevationPrefix));(!i||i===this._previousElevation)&&(this._previousElevation&&(this._classList[this._previousElevation]=!1),this._classList[s]=!0,this._previousElevation=s)}setPositionClasses(e=this.xPosition,r=this.yPosition){const s=this._classList;s["mat-menu-before"]="before"===e,s["mat-menu-after"]="after"===e,s["mat-menu-above"]="above"===r,s["mat-menu-below"]="below"===r,this._changeDetectorRef?.markForCheck()}_startAnimation(){this._panelAnimationState="enter"}_resetAnimation(){this._panelAnimationState="void"}_onAnimationDone(e){this._animationDone.next(e),this._isAnimating=!1}_onAnimationStart(e){this._isAnimating=!0,"enter"===e.toState&&0===this._keyManager.activeItemIndex&&(e.element.scrollTop=0)}_updateDirectDescendants(){this._allItems.changes.pipe(pc(this._allItems)).subscribe(e=>{this._directDescendantItems.reset(e.filter(r=>r._parentMenu===this)),this._directDescendantItems.notifyOnChanges()})}}return n.\u0275fac=function(e){return new(e||n)(B(Kt),B(ft),B(Uj),B(uo))},n.\u0275dir=Me({type:n,contentQueries:function(e,r,s){if(1&e&&(Ya(s,_Oe,5),Ya(s,wx,5),Ya(s,wx,4)),2&e){let i;Or(i=$r())&&(r.lazyContent=i.first),Or(i=$r())&&(r._allItems=i),Or(i=$r())&&(r.items=i)}},viewQuery:function(e,r){if(1&e&&lo(Ai,5),2&e){let s;Or(s=$r())&&(r.templateRef=s.first)}},inputs:{backdropClass:"backdropClass",ariaLabel:["aria-label","ariaLabel"],ariaLabelledby:["aria-labelledby","ariaLabelledby"],ariaDescribedby:["aria-describedby","ariaDescribedby"],xPosition:"xPosition",yPosition:"yPosition",overlapTrigger:"overlapTrigger",hasBackdrop:"hasBackdrop",panelClass:["class","panelClass"],classList:"classList"},outputs:{closed:"closed",close:"close"}}),n})(),wOe=(()=>{class n extends Lm{constructor(e,r,s,i){super(e,r,s,i),this._elevationPrefix="mat-elevation-z",this._baseElevation=8}}return n.\u0275fac=function(e){return new(e||n)(B(Kt),B(ft),B(Uj),B(uo))},n.\u0275cmp=Ur({type:n,selectors:[["mat-menu"]],hostVars:3,hostBindings:function(e,r){2&e&&Qt("aria-label",null)("aria-labelledby",null)("aria-describedby",null)},exportAs:["matMenu"],features:[gn([{provide:Uk,useExisting:n}]),it],ngContentSelectors:yOe,decls:1,vars:0,consts:[["tabindex","-1","role","menu",1,"mat-mdc-menu-panel","mdc-menu-surface","mdc-menu-surface--open","mat-mdc-elevation-specific",3,"id","ngClass","keydown","click"],[1,"mat-mdc-menu-content","mdc-list"]],template:function(e,r){1&e&&(ma(),wn(0,gOe,3,6,"ng-template"))},dependencies:[qC],styles:['.mdc-menu-surface{display:none;position:absolute;box-sizing:border-box;max-width:var(--mdc-menu-max-width, calc(100vw - 32px));max-height:var(--mdc-menu-max-height, calc(100vh - 32px));margin:0;padding:0;transform:scale(1);transform-origin:top left;opacity:0;overflow:auto;will-change:transform,opacity;z-index:8;border-radius:var(--mdc-shape-medium, 4px);transform-origin-left:top left;transform-origin-right:top right}.mdc-menu-surface:focus{outline:none}.mdc-menu-surface--animating-open{display:inline-block;transform:scale(0.8);opacity:0}.mdc-menu-surface--open{display:inline-block;transform:scale(1);opacity:1}.mdc-menu-surface--animating-closed{display:inline-block;opacity:0}[dir=rtl] .mdc-menu-surface,.mdc-menu-surface[dir=rtl]{transform-origin-left:top right;transform-origin-right:top left}.mdc-menu-surface--anchor{position:relative;overflow:visible}.mdc-menu-surface--fixed{position:fixed}.mdc-menu-surface--fullwidth{width:100%}mat-menu{display:none}.mat-mdc-menu-content{margin:0;padding:8px 0;list-style-type:none}.mat-mdc-menu-content:focus{outline:none}.cdk-high-contrast-active .mat-mdc-menu-panel{outline:solid 1px}.mat-mdc-menu-panel.mat-mdc-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;position:relative}.mat-mdc-menu-item{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:16px;padding-right:16px;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0);cursor:pointer;width:100%;text-align:left;box-sizing:border-box;color:inherit;font-size:inherit;background:none;text-decoration:none;margin:0;min-height:48px}.mat-mdc-menu-item:focus{outline:none}[dir=rtl] .mat-mdc-menu-item,.mat-mdc-menu-item[dir=rtl]{padding-left:16px;padding-right:16px}.mat-mdc-menu-item::-moz-focus-inner{border:0}.mat-mdc-menu-item.mdc-list-item{align-items:center}.mat-mdc-menu-item[disabled]{cursor:default;opacity:.38}.mat-mdc-menu-item[disabled]::after{display:block;position:absolute;content:"";top:0;left:0;bottom:0;right:0}.mat-mdc-menu-item .mat-icon{margin-right:16px}[dir=rtl] .mat-mdc-menu-item{text-align:right}[dir=rtl] .mat-mdc-menu-item .mat-icon{margin-right:0;margin-left:16px}.mat-mdc-menu-item .mdc-list-item__primary-text{white-space:normal}.mat-mdc-menu-item.mat-mdc-menu-item-submenu-trigger{padding-right:32px}[dir=rtl] .mat-mdc-menu-item.mat-mdc-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}.cdk-high-contrast-active .mat-mdc-menu-item{margin-top:1px}.mat-mdc-menu-submenu-icon{position:absolute;top:50%;right:16px;transform:translateY(-50%);width:5px;height:10px;fill:currentColor}[dir=rtl] .mat-mdc-menu-submenu-icon{right:auto;left:16px;transform:translateY(-50%) scaleX(-1)}.cdk-high-contrast-active .mat-mdc-menu-submenu-icon{fill:CanvasText}.mat-mdc-menu-item .mat-mdc-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}'],encapsulation:2,data:{animation:[Cx.transformMenu,Cx.fadeInItems]},changeDetection:0}),n})();const Hj=new me("mat-menu-scroll-strategy"),SOe={provide:Hj,deps:[Ol],useFactory:function COe(n){return()=>n.scrollStrategies.reposition()}},Wj=Vv({passive:!0});let IOe=(()=>{class n{constructor(e,r,s,i,o,a,l,c,u){this._overlay=e,this._element=r,this._viewContainerRef=s,this._menuItemInstance=a,this._dir=l,this._focusMonitor=c,this._ngZone=u,this._overlayRef=null,this._menuOpen=!1,this._closingActionsSubscription=Ve.EMPTY,this._hoverSubscription=Ve.EMPTY,this._menuCloseSubscription=Ve.EMPTY,this._handleTouchStart=d=>{KT(d)||(this._openedBy="touch")},this._openedBy=void 0,this.restoreFocus=!0,this.menuOpened=new Et,this.onMenuOpen=this.menuOpened,this.menuClosed=new Et,this.onMenuClose=this.menuClosed,this._scrollStrategy=i,this._parentMaterialMenu=o instanceof Lm?o:void 0,r.nativeElement.addEventListener("touchstart",this._handleTouchStart,Wj)}get _deprecatedMatMenuTriggerFor(){return this.menu}set _deprecatedMatMenuTriggerFor(e){this.menu=e}get menu(){return this._menu}set menu(e){e!==this._menu&&(this._menu=e,this._menuCloseSubscription.unsubscribe(),e&&(this._menuCloseSubscription=e.close.subscribe(r=>{this._destroyMenu(r),("click"===r||"tab"===r)&&this._parentMaterialMenu&&this._parentMaterialMenu.closed.emit(r)})),this._menuItemInstance?._setTriggersSubmenu(this.triggersSubmenu()))}ngAfterContentInit(){this._handleHover()}ngOnDestroy(){this._overlayRef&&(this._overlayRef.dispose(),this._overlayRef=null),this._element.nativeElement.removeEventListener("touchstart",this._handleTouchStart,Wj),this._menuCloseSubscription.unsubscribe(),this._closingActionsSubscription.unsubscribe(),this._hoverSubscription.unsubscribe()}get menuOpen(){return this._menuOpen}get dir(){return this._dir&&"rtl"===this._dir.value?"rtl":"ltr"}triggersSubmenu(){return!!(this._menuItemInstance&&this._parentMaterialMenu&&this.menu)}toggleMenu(){return this._menuOpen?this.closeMenu():this.openMenu()}openMenu(){const e=this.menu;if(this._menuOpen||!e)return;const r=this._createOverlay(e),s=r.getConfig(),i=s.positionStrategy;this._setPosition(e,i),s.hasBackdrop=e.hasBackdrop??!this.triggersSubmenu(),r.attach(this._getPortal(e)),e.lazyContent&&e.lazyContent.attach(this.menuData),this._closingActionsSubscription=this._menuClosingActions().subscribe(()=>this.closeMenu()),this._initMenu(e),e instanceof Lm&&(e._startAnimation(),e._directDescendantItems.changes.pipe(wi(e.close)).subscribe(()=>{i.withLockedPosition(!1).reapplyLastPosition(),i.withLockedPosition(!0)}))}closeMenu(){this.menu?.close.emit()}focus(e,r){this._focusMonitor&&e?this._focusMonitor.focusVia(this._element,e,r):this._element.nativeElement.focus(r)}updatePosition(){this._overlayRef?.updatePosition()}_destroyMenu(e){if(!this._overlayRef||!this.menuOpen)return;const r=this.menu;this._closingActionsSubscription.unsubscribe(),this._overlayRef.detach(),this.restoreFocus&&("keydown"===e||!this._openedBy||!this.triggersSubmenu())&&this.focus(this._openedBy),this._openedBy=void 0,r instanceof Lm?(r._resetAnimation(),r.lazyContent?r._animationDone.pipe(or(s=>"void"===s.toState),$n(1),wi(r.lazyContent._attached)).subscribe({next:()=>r.lazyContent.detach(),complete:()=>this._setIsMenuOpen(!1)}):this._setIsMenuOpen(!1)):(this._setIsMenuOpen(!1),r?.lazyContent?.detach())}_initMenu(e){e.parentMenu=this.triggersSubmenu()?this._parentMaterialMenu:void 0,e.direction=this.dir,this._setMenuElevation(e),e.focusFirstItem(this._openedBy||"program"),this._setIsMenuOpen(!0)}_setMenuElevation(e){if(e.setElevation){let r=0,s=e.parentMenu;for(;s;)r++,s=s.parentMenu;e.setElevation(r)}}_setIsMenuOpen(e){this._menuOpen=e,this._menuOpen?this.menuOpened.emit():this.menuClosed.emit(),this.triggersSubmenu()&&this._menuItemInstance._setHighlighted(e)}_createOverlay(e){if(!this._overlayRef){const r=this._getOverlayConfig(e);this._subscribeToPositions(e,r.positionStrategy),this._overlayRef=this._overlay.create(r),this._overlayRef.keydownEvents().subscribe()}return this._overlayRef}_getOverlayConfig(e){return new rx({positionStrategy:this._overlay.position().flexibleConnectedTo(this._element).withLockedPosition().withGrowAfterOpen().withTransformOriginOn(".mat-menu-panel, .mat-mdc-menu-panel"),backdropClass:e.backdropClass||"cdk-overlay-transparent-backdrop",panelClass:e.overlayPanelClass,scrollStrategy:this._scrollStrategy(),direction:this._dir})}_subscribeToPositions(e,r){e.setPositionClasses&&r.positionChanges.subscribe(s=>{const i="start"===s.connectionPair.overlayX?"after":"before",o="top"===s.connectionPair.overlayY?"below":"above";this._ngZone?this._ngZone.run(()=>e.setPositionClasses(i,o)):e.setPositionClasses(i,o)})}_setPosition(e,r){let[s,i]="before"===e.xPosition?["end","start"]:["start","end"],[o,a]="above"===e.yPosition?["bottom","top"]:["top","bottom"],[l,c]=[o,a],[u,d]=[s,i],h=0;if(this.triggersSubmenu()){if(d=s="before"===e.xPosition?"start":"end",i=u="end"===s?"start":"end",this._parentMaterialMenu){if(null==this._parentInnerPadding){const f=this._parentMaterialMenu.items.first;this._parentInnerPadding=f?f._getHostElement().offsetTop:0}h="bottom"===o?this._parentInnerPadding:-this._parentInnerPadding}}else e.overlapTrigger||(l="top"===o?"bottom":"top",c="top"===a?"bottom":"top");r.withPositions([{originX:s,originY:l,overlayX:u,overlayY:o,offsetY:h},{originX:i,originY:l,overlayX:d,overlayY:o,offsetY:h},{originX:s,originY:c,overlayX:u,overlayY:a,offsetY:-h},{originX:i,originY:c,overlayX:d,overlayY:a,offsetY:-h}])}_menuClosingActions(){const e=this._overlayRef.backdropClick(),r=this._overlayRef.detachments();return Ua(e,this._parentMaterialMenu?this._parentMaterialMenu.closed:Ae(),this._parentMaterialMenu?this._parentMaterialMenu._hovered().pipe(or(o=>o!==this._menuItemInstance),or(()=>this._menuOpen)):Ae(),r)}_handleMousedown(e){qT(e)||(this._openedBy=0===e.button?"mouse":void 0,this.triggersSubmenu()&&e.preventDefault())}_handleKeydown(e){const r=e.keyCode;(13===r||32===r)&&(this._openedBy="keyboard"),this.triggersSubmenu()&&(39===r&&"ltr"===this.dir||37===r&&"rtl"===this.dir)&&(this._openedBy="keyboard",this.openMenu())}_handleClick(e){this.triggersSubmenu()?(e.stopPropagation(),this.openMenu()):this.toggleMenu()}_handleHover(){!this.triggersSubmenu()||!this._parentMaterialMenu||(this._hoverSubscription=this._parentMaterialMenu._hovered().pipe(or(e=>e===this._menuItemInstance&&!e.disabled),zj(0,uk)).subscribe(()=>{this._openedBy="mouse",this.menu instanceof Lm&&this.menu._isAnimating?this.menu._animationDone.pipe($n(1),zj(0,uk),wi(this._parentMaterialMenu._hovered())).subscribe(()=>this.openMenu()):this.openMenu()}))}_getPortal(e){return(!this._portal||this._portal.templateRef!==e.templateRef)&&(this._portal=new Jv(e.templateRef,this._viewContainerRef)),this._portal}}return n.\u0275fac=function(e){return new(e||n)(B(Ol),B(Kt),B(Ps),B(Hj),B(Uk,8),B(wx,10),B(Qv,8),B(YT),B(ft))},n.\u0275dir=Me({type:n,hostVars:3,hostBindings:function(e,r){1&e&&Jt("click",function(i){return r._handleClick(i)})("mousedown",function(i){return r._handleMousedown(i)})("keydown",function(i){return r._handleKeydown(i)}),2&e&&Qt("aria-haspopup",r.menu?"menu":null)("aria-expanded",r.menuOpen||null)("aria-controls",r.menuOpen?r.menu.panelId:null)},inputs:{_deprecatedMatMenuTriggerFor:["mat-menu-trigger-for","_deprecatedMatMenuTriggerFor"],menu:["matMenuTriggerFor","menu"],menuData:["matMenuTriggerData","menuData"],restoreFocus:["matMenuTriggerRestoreFocus","restoreFocus"]},outputs:{menuOpened:"menuOpened",onMenuOpen:"onMenuOpen",menuClosed:"menuClosed",onMenuClose:"onMenuClose"}}),n})(),EOe=(()=>{class n extends IOe{}return n.\u0275fac=function(){let t;return function(r){return(t||(t=nr(n)))(r||n)}}(),n.\u0275dir=Me({type:n,selectors:[["","mat-menu-trigger-for",""],["","matMenuTriggerFor",""]],hostAttrs:[1,"mat-mdc-menu-trigger"],exportAs:["matMenuTrigger"],features:[it]}),n})(),DOe=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({providers:[SOe],imports:[fc,nk,qr,pk,nx,qr]}),n})();const TOe=["inferenceCanvas"],kOe=["video"];function NOe(n,t){1&n&&rr(0,"mat-spinner",20),2&n&&yt("diameter",40)}function AOe(n,t){if(1&n){const e=pa();Qe(0,"button",22),Jt("click",function(){return Qr(e),en(2),Jr(fa(2).click())}),Qe(1,"mat-icon"),rs(2,"add_a_photo"),xt()()}}function ROe(n,t){if(1&n&&(Wh(0),wn(1,AOe,3,0,"button",21),jh()),2&n){const e=en(3);gt(1),yt("ngIf",!e.loadingInference)}}function MOe(n,t){1&n&&(Qe(0,"button",26)(1,"mat-icon"),rs(2,"add_a_photo"),xt()()),2&n&&(en(),yt("matMenuTriggerFor",fa(3)))}function FOe(n,t){if(1&n){const e=pa();Qe(0,"button",22),Jt("click",function(){return Qr(e),Jr(en(4).toggleWebcam())}),Qe(1,"mat-icon"),rs(2,"camera"),xt()()}}function OOe(n,t){if(1&n){const e=pa();Wh(0),wn(1,MOe,3,1,"button",23),Qe(2,"mat-menu",null,24)(4,"button",25),Jt("click",function(){return Qr(e),Jr(en(3).toggleWebcam())}),rs(5," WebCam "),xt(),Qe(6,"button",25),Jt("click",function(){return Qr(e),en(),Jr(fa(2).click())}),rs(7," Upload Image "),xt()(),wn(8,FOe,3,0,"button",21),jh()}if(2&n){const e=en(3);gt(1),yt("ngIf",!e.loadingInference&&2!==e.webCamState),gt(7),yt("ngIf",!e.loadingInference&&2===e.webCamState)}}function $Oe(n,t){1&n&&(Qe(0,"mat-icon",27),rs(1,"sort"),xt())}function POe(n,t){if(1&n&&(Qe(0,"mat-option",28),rs(1),xt()),2&n){const e=t.$implicit;yt("value",e.value),gt(1),Yh(e.value)}}function LOe(n,t){if(1&n){const e=pa();Qe(0,"div",7)(1,"input",8,9),Jt("change",function(s){return Qr(e),Jr(en(2).inputEvent(s))}),xt(),Qe(3,"div",10),wn(4,NOe,1,1,"mat-spinner",11),rr(5,"canvas",12,13),wn(7,ROe,2,1,"ng-container",14),wn(8,OOe,9,2,"ng-container",14),Qe(9,"button",15),Jt("click",function(){return Qr(e),Jr(fa(12).open())}),wn(10,$Oe,2,0,"mat-icon",16),Qe(11,"mat-select",17,18),Jt("selectionChange",function(s){return Qr(e),Jr(en(2).selectChange(s.value))}),wn(13,POe,2,2,"mat-option",19),function bO(n,t){const e=$t();let r;const s=n+22;e.firstCreatePass?(r=function f7(n,t){if(t)for(let e=t.length-1;e>=0;e--){const r=t[e];if(n===r.name)return r}}(t,e.pipeRegistry),e.data[s]=r,r.onDestroy&&(e.destroyHooks||(e.destroyHooks=[])).push(s,r.onDestroy)):r=e.data[s];const i=r.factory||(r.factory=Ql(r.type)),o=Di(B);try{const a=ug(!1),l=i();return ug(a),function oX(n,t,e,r){e>=n.data.length&&(n.data[e]=null,n.blueprint[e]=null),t[e]=r}(e,oe(),s,l),l}finally{Di(o)}}(14,"keyvalue"),xt()()()()}if(2&n){const e=en(2);gt(1),yt("disabled",!e.importer.isModelLoaded()||e.loadingInference),gt(3),yt("ngIf",e.loadingInference),gt(1),yt("width",e.canvasResolution[0])("height",e.canvasResolution[1]),gt(2),yt("ngIf",!e.useWebcam),gt(1),yt("ngIf",e.useWebcam),gt(2),yt("ngIf",!e.loadingInference),gt(1),yt("ngModel",e.selectedClasses),gt(2),yt("ngForOf",_O(14,9,e.classNamesMap))}}function BOe(n,t){if(1&n&&(Qe(0,"div",3),wn(1,LOe,15,11,"div",4),rr(2,"video",5,6),xt()),2&n){const e=en(),r=fa(2);gt(1),yt("ngIf",e.loaded)("ngIfElse",r)}}function VOe(n,t){if(1&n){const e=pa();Qe(0,"div",29)(1,"button",30),Jt("click",function(){return Qr(e),Jr(en().init())}),Qe(2,"mat-icon",31),rs(3," play_circle_outline "),xt()()()}}function zOe(n,t){1&n&&(Qe(0,"div",29)(1,"div")(2,"mat-icon"),rs(3," error "),xt()(),Qe(4,"div"),rs(5," Currently the demo is only available in the Chrome browser for iOS devices. "),xt()())}class Sx{constructor(t,e){this.snackBar=t,this.changeDetectorRef=e,this.FONT_SIZE=12,this.FONT=this.FONT_SIZE+"px comic-sans",this.classNamesMap=new Map,this.loadingInference=!0,this.loaded=!1,this.selectedClasses=[],this.paintCanvas=!1,this.validConfiguration=!1,this.useWebcam=!1,this.webCamState=Zo.UNINITIALIZED,this.canvasResolution=pNe,this.validConfiguration=this.checkConfiguration(),this.currentPlatform=this.checkPlatform(),console.log(this.currentPlatform),this.currentPlatform&&-1!=["Windows","Mac OS","Linux"].indexOf(this.currentPlatform)&&(this.useWebcam=!0,console.log("set webcam true"))}init(){if(this.importer=new Bv,this.validConfiguration){this.loaded=!0,this.changeDetectorRef.detectChanges(),this.ctx=this.inferenceCanvas.nativeElement.getContext("2d"),this.ctx.font=this.FONT,this.ctx.textBaseline="top",this.ctx.clearRect(0,0,this.inferenceCanvas.nativeElement.width,this.inferenceCanvas.nativeElement.height),this.classNamesMap=this.importer.getClassNames(),this.selectedClasses=[...this.classNamesMap.values()];var t=new Image;t.src="assets/factory.jpg",null!=t&&(t.onload=()=>{this.importer.modelLoaded$.pipe(or(Boolean),ss(()=>this.importer.predict(this.inferenceCanvas.nativeElement,this.ctx,t,!0)),$n(1)).subscribe(()=>{this.loadingInference=!1})})}}toggleWebcam(){const t={audio:!1,video:{width:this.canvasResolution[0],height:this.canvasResolution[1]}};if(this.webCamState===Zo.UNINITIALIZED){let r=()=>{this.paintCanvas&&(this.ctx.drawImage(this.video.nativeElement,0,0,this.inferenceCanvas.nativeElement.width,this.inferenceCanvas.nativeElement.height),this.requestId=requestAnimationFrame(r),console.log("step"))};this.video.nativeElement.addEventListener("play",()=>{this.paintCanvas=!0,this.requestId=requestAnimationFrame(r)}),Tn(navigator.mediaDevices.getUserMedia(t)).pipe($n(1),Fi(s=>(console.log(s),this.snackBar.open(s,"OK",{duration:2e3,panelClass:"snackbar-red"}),Ae(void 0)))).subscribe(s=>{s&&(this.video.nativeElement.srcObject=s,this.video.nativeElement.play(),this.webCamState=Zo.PLAYING)})}else this.webCamState===Zo.INITIALIZED?Tn(navigator.mediaDevices.getUserMedia(t)).pipe($n(1),Fi(r=>(console.log(r),Ae(void 0)))).subscribe(r=>{r&&(this.video.nativeElement.srcObject=r,this.video.nativeElement.play(),this.webCamState=Zo.PLAYING)}):this.webCamState===Zo.PLAYING&&(this.paintCanvas=!1,cancelAnimationFrame(this.requestId),this.importer.modelLoaded$.pipe(or(Boolean),ss(()=>this.importer.predict(this.inferenceCanvas.nativeElement,this.ctx)),$n(1)).subscribe(()=>{this.loadingInference=!1,this.video.nativeElement.srcObject.getTracks().forEach(r=>r.stop())}),this.webCamState=Zo.INITIALIZED)}checkPlatform(){var t=window.navigator.userAgent,e=window.navigator.platform,o=null;return console.log("platform: ",e),-1!==["Macintosh","MacIntel","MacPPC","Mac68K"].indexOf(e)?o="Mac OS":-1!==["iPhone","iPad","iPod"].indexOf(e)?o="iOS":-1!==["Win32","Win64","Windows","WinCE"].indexOf(e)?o="Windows":/Android/.test(t)?o="Android":/Linux/.test(e)?o="Linux":console.error("unknown platform!"),o}checkConfiguration(){return!["iPad Simulator","iPhone Simulator","iPod Simulator","iPad","iPhone","iPod"].includes(navigator.platform)||!!navigator.userAgent.match("CriOS")}selectChange(t){this.selectedClasses=t,this.importer.setClassNames(t)}inputEvent(t){let e=t.target.files[0];if(e)if(t.target.files[0].type.includes("image/")){this.loadingInference=!0;var r=new FileReader;r.readAsDataURL(e),r.onloadend=s=>{var i=new Image;s.target&&(i.src=s?.target?.result),i.onload=o=>{this.importer.predict(this.inferenceCanvas.nativeElement,this.ctx,i,!0).subscribe(()=>{this.loadingInference=!1})}}}else this.snackBar.open("Invalid filetype!","OK",{duration:2e3,panelClass:"snackbar-red"});else console.log("No file selected!")}static#e=this.\u0275fac=function(e){return new(e||Sx)(B(HRe),B(uo))};static#t=this.\u0275cmp=Ur({type:Sx,selectors:[["app-root"]],viewQuery:function(e,r){if(1&e&&(lo(TOe,5),lo(kOe,5)),2&e){let s;Or(s=$r())&&(r.inferenceCanvas=s.first),Or(s=$r())&&(r.video=s.first)}},decls:5,vars:2,consts:[["style","width: 100%; height: 100%; border: none",4,"ngIf","ngIfElse"],["unloaded",""],["invalid_configuration",""],[2,"width","100%","height","100%","border","none"],["class","content",4,"ngIf","ngIfElse"],["width","canvasResolution[0]","height","canvasResolution[0]","autoplay","",2,"display","none"],["video",""],[1,"content"],["name","imageInput","type","file","accept","image/*","capture","environment",2,"display","none",3,"disabled","change"],["imageInput",""],[2,"width","100%","position","relative"],["class","spinner",3,"diameter",4,"ngIf"],[2,"width","100%",3,"width","height"],["inferenceCanvas",""],[4,"ngIf"],["mat-icon-button","",2,"position","absolute","top","5%","left","4%",3,"click"],["style","color: white",4,"ngIf"],["multiple","","color","accent",1,"langSelect",3,"ngModel","selectionChange"],["select",""],[3,"value",4,"ngFor","ngForOf"],[1,"spinner",3,"diameter"],["mat-mini-fab","","class","cameraBtn",3,"click",4,"ngIf"],["mat-mini-fab","",1,"cameraBtn",3,"click"],["mat-mini-fab","","class","cameraBtn",3,"matMenuTriggerFor",4,"ngIf"],["menu","matMenu"],["mat-menu-item","",3,"click"],["mat-mini-fab","",1,"cameraBtn",3,"matMenuTriggerFor"],[2,"color","white"],[3,"value"],[2,"min-height","100vh","display","flex","flex-direction","column","justify-content","center","align-items","center"],["mat-icon-button","",2,"transform","scale(2)",3,"click"],[2,"transform","scale(2.4)"]],template:function(e,r){if(1&e&&(wn(0,BOe,4,2,"div",0),wn(1,VOe,4,0,"ng-template",null,1,qg),wn(3,zOe,6,0,"ng-template",null,2,qg)),2&e){const s=fa(4);yt("ngIf",r.validConfiguration)("ngIfElse",s)}},dependencies:[P2,hf,YRe,kMe,UAe,zAe,cOe,PH,wOe,wx,EOe,ij,Ok,W2],styles:[".langSelect div.mat-mdc-select-arrow-wrapper{display:none}  .langSelect.mat-select{display:inline}  #cdk-overlay-0{width:250px!important}  #mat-select-0{display:none}  .mat-pseudo-checkbox-checked{background:blue}  .mdc-list-item--selected .mdc-list-item__primary-text{color:#000}  .mat-mdc-snack-bar-container .mdc-snackbar__surface{background-color:red!important;color:#fff!important}.cameraBtn[_ngcontent-%COMP%]{position:absolute;margin-left:auto;margin-right:auto;left:0;right:0;text-align:center;bottom:5%;background-color:#fff}.spinner[_ngcontent-%COMP%]{position:absolute;top:45%;margin-left:auto;margin-right:auto;left:0;right:0;text-align:center}"]})}function jj(n){return new te(3e3,!1)}function w2e(){return typeof window<"u"&&typeof window.document<"u"}function Hk(){return typeof process<"u"&&"[object process]"==={}.toString.call(process)}function Vl(n){switch(n.length){case 0:return new Nm;case 1:return n[0];default:return new qH(n)}}function Gj(n,t,e,r,s=new Map,i=new Map){const o=[],a=[];let l=-1,c=null;if(r.forEach(u=>{const d=u.get("offset"),h=d==l,f=h&&c||new Map;u.forEach((p,m)=>{let g=m,y=p;if("offset"!==m)switch(g=t.normalizePropertyName(g,o),y){case"!":y=s.get(m);break;case Oa:y=i.get(m);break;default:y=t.normalizeStyleValue(m,g,y,o)}f.set(g,y)}),h||a.push(f),c=f,l=d}),o.length)throw function u2e(n){return new te(3502,!1)}();return a}function Wk(n,t,e,r){switch(t){case"start":n.onStart(()=>r(e&&jk(e,"start",n)));break;case"done":n.onDone(()=>r(e&&jk(e,"done",n)));break;case"destroy":n.onDestroy(()=>r(e&&jk(e,"destroy",n)))}}function jk(n,t,e){const i=Gk(n.element,n.triggerName,n.fromState,n.toState,t||n.phaseName,e.totalTime??n.totalTime,!!e.disabled),o=n._data;return null!=o&&(i._data=o),i}function Gk(n,t,e,r,s="",i=0,o){return{element:n,triggerName:t,fromState:e,toState:r,phaseName:s,totalTime:i,disabled:!!o}}function Ci(n,t,e){let r=n.get(t);return r||n.set(t,r=e),r}function qj(n){const t=n.indexOf(":");return[n.substring(1,t),n.slice(t+1)]}let qk=(n,t)=>!1,Kj=(n,t,e)=>[],Xj=null;function Kk(n){const t=n.parentNode||n.host;return t===Xj?null:t}(Hk()||typeof Element<"u")&&(w2e()?(Xj=(()=>document.documentElement)(),qk=(n,t)=>{for(;t;){if(t===n)return!0;t=Kk(t)}return!1}):qk=(n,t)=>n.contains(t),Kj=(n,t,e)=>{if(e)return Array.from(n.querySelectorAll(t));const r=n.querySelector(t);return r?[r]:[]});let Yc=null,Yj=!1;const Zj=qk,Qj=Kj;let Jj=(()=>{class n{validateStyleProperty(e){return function S2e(n){Yc||(Yc=function I2e(){return typeof document<"u"?document.body:null}()||{},Yj=!!Yc.style&&"WebkitAppearance"in Yc.style);let t=!0;return Yc.style&&!function C2e(n){return"ebkit"==n.substring(1,6)}(n)&&(t=n in Yc.style,!t&&Yj&&(t="Webkit"+n.charAt(0).toUpperCase()+n.slice(1)in Yc.style)),t}(e)}matchesElement(e,r){return!1}containsElement(e,r){return Zj(e,r)}getParentElement(e){return Kk(e)}query(e,r,s){return Qj(e,r,s)}computeStyle(e,r,s){return s||""}animate(e,r,s,i,o,a=[],l){return new Nm(s,i)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})(),Xk=(()=>{class n{}return n.NOOP=new Jj,n})();const Yk="ng-enter",Ix="ng-leave",Ex="ng-trigger",Dx=".ng-trigger",tG="ng-animating",Zk=".ng-animating";function La(n){if("number"==typeof n)return n;const t=n.match(/^(-?[\.\d]+)(m?s)/);return!t||t.length<2?0:Qk(parseFloat(t[1]),t[2])}function Qk(n,t){return"s"===t?1e3*n:n}function Tx(n,t,e){return n.hasOwnProperty("duration")?n:function T2e(n,t,e){let s,i=0,o="";if("string"==typeof n){const a=n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===a)return t.push(jj()),{duration:0,delay:0,easing:""};s=Qk(parseFloat(a[1]),a[2]);const l=a[3];null!=l&&(i=Qk(parseFloat(l),a[4]));const c=a[5];c&&(o=c)}else s=n;if(!e){let a=!1,l=t.length;s<0&&(t.push(function UOe(){return new te(3100,!1)}()),a=!0),i<0&&(t.push(function HOe(){return new te(3101,!1)}()),a=!0),a&&t.splice(l,0,jj())}return{duration:s,delay:i,easing:o}}(n,t,e)}function Bm(n,t={}){return Object.keys(n).forEach(e=>{t[e]=n[e]}),t}function nG(n){const t=new Map;return Object.keys(n).forEach(e=>{t.set(e,n[e])}),t}function zl(n,t=new Map,e){if(e)for(let[r,s]of e)t.set(r,s);for(let[r,s]of n)t.set(r,s);return t}function sG(n,t,e){return e?t+":"+e+";":""}function iG(n){let t="";for(let e=0;e<n.style.length;e++){const r=n.style.item(e);t+=sG(0,r,n.style.getPropertyValue(r))}for(const e in n.style)n.style.hasOwnProperty(e)&&!e.startsWith("_")&&(t+=sG(0,R2e(e),n.style[e]));n.setAttribute("style",t)}function Jo(n,t,e){n.style&&(t.forEach((r,s)=>{const i=eN(s);e&&!e.has(s)&&e.set(s,n.style[i]),n.style[i]=r}),Hk()&&iG(n))}function Zc(n,t){n.style&&(t.forEach((e,r)=>{const s=eN(r);n.style[s]=""}),Hk()&&iG(n))}function Vm(n){return Array.isArray(n)?1==n.length?n[0]:jH(n):n}const Jk=new RegExp("{{\\s*(.+?)\\s*}}","g");function oG(n){let t=[];if("string"==typeof n){let e;for(;e=Jk.exec(n);)t.push(e[1]);Jk.lastIndex=0}return t}function zm(n,t,e){const r=n.toString(),s=r.replace(Jk,(i,o)=>{let a=t[o];return null==a&&(e.push(function jOe(n){return new te(3003,!1)}()),a=""),a.toString()});return s==r?n:s}function kx(n){const t=[];let e=n.next();for(;!e.done;)t.push(e.value),e=n.next();return t}const A2e=/-+([a-z0-9])/g;function eN(n){return n.replace(A2e,(...t)=>t[1].toUpperCase())}function R2e(n){return n.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}function Si(n,t,e){switch(t.type){case 7:return n.visitTrigger(t,e);case 0:return n.visitState(t,e);case 1:return n.visitTransition(t,e);case 2:return n.visitSequence(t,e);case 3:return n.visitGroup(t,e);case 4:return n.visitAnimate(t,e);case 5:return n.visitKeyframes(t,e);case 6:return n.visitStyle(t,e);case 8:return n.visitReference(t,e);case 9:return n.visitAnimateChild(t,e);case 10:return n.visitAnimateRef(t,e);case 11:return n.visitQuery(t,e);case 12:return n.visitStagger(t,e);default:throw function GOe(n){return new te(3004,!1)}()}}function aG(n,t){return window.getComputedStyle(n)[t]}function L2e(n,t){const e=[];return"string"==typeof n?n.split(/\s*,\s*/).forEach(r=>function B2e(n,t,e){if(":"==n[0]){const l=function V2e(n,t){switch(n){case":enter":return"void => *";case":leave":return"* => void";case":increment":return(e,r)=>parseFloat(r)>parseFloat(e);case":decrement":return(e,r)=>parseFloat(r)<parseFloat(e);default:return t.push(function o2e(n){return new te(3016,!1)}()),"* => *"}}(n,e);if("function"==typeof l)return void t.push(l);n=l}const r=n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);if(null==r||r.length<4)return e.push(function i2e(n){return new te(3015,!1)}()),t;const s=r[1],i=r[2],o=r[3];t.push(lG(s,o));"<"==i[0]&&!("*"==s&&"*"==o)&&t.push(lG(o,s))}(r,e,t)):e.push(n),e}const Mx=new Set(["true","1"]),Fx=new Set(["false","0"]);function lG(n,t){const e=Mx.has(n)||Fx.has(n),r=Mx.has(t)||Fx.has(t);return(s,i)=>{let o="*"==n||n==s,a="*"==t||t==i;return!o&&e&&"boolean"==typeof s&&(o=s?Mx.has(n):Fx.has(n)),!a&&r&&"boolean"==typeof i&&(a=i?Mx.has(t):Fx.has(t)),o&&a}}const z2e=new RegExp("s*:selfs*,?","g");function tN(n,t,e,r){return new U2e(n).build(t,e,r)}class U2e{constructor(t){this._driver=t}build(t,e,r){const s=new j2e(e);return this._resetContextStyleTimingState(s),Si(this,Vm(t),s)}_resetContextStyleTimingState(t){t.currentQuerySelector="",t.collectedStyles=new Map,t.collectedStyles.set("",new Map),t.currentTime=0}visitTrigger(t,e){let r=e.queryCount=0,s=e.depCount=0;const i=[],o=[];return"@"==t.name.charAt(0)&&e.errors.push(function KOe(){return new te(3006,!1)}()),t.definitions.forEach(a=>{if(this._resetContextStyleTimingState(e),0==a.type){const l=a,c=l.name;c.toString().split(/\s*,\s*/).forEach(u=>{l.name=u,i.push(this.visitState(l,e))}),l.name=c}else if(1==a.type){const l=this.visitTransition(a,e);r+=l.queryCount,s+=l.depCount,o.push(l)}else e.errors.push(function XOe(){return new te(3007,!1)}())}),{type:7,name:t.name,states:i,transitions:o,queryCount:r,depCount:s,options:null}}visitState(t,e){const r=this.visitStyle(t.styles,e),s=t.options&&t.options.params||null;if(r.containsDynamicStyles){const i=new Set,o=s||{};r.styles.forEach(a=>{a instanceof Map&&a.forEach(l=>{oG(l).forEach(c=>{o.hasOwnProperty(c)||i.add(c)})})}),i.size&&(kx(i.values()),e.errors.push(function YOe(n,t){return new te(3008,!1)}()))}return{type:0,name:t.name,style:r,options:s?{params:s}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const r=Si(this,Vm(t.animation),e);return{type:1,matchers:L2e(t.expr,e.errors),animation:r,queryCount:e.queryCount,depCount:e.depCount,options:Qc(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(r=>Si(this,r,e)),options:Qc(t.options)}}visitGroup(t,e){const r=e.currentTime;let s=0;const i=t.steps.map(o=>{e.currentTime=r;const a=Si(this,o,e);return s=Math.max(s,e.currentTime),a});return e.currentTime=s,{type:3,steps:i,options:Qc(t.options)}}visitAnimate(t,e){const r=function q2e(n,t){if(n.hasOwnProperty("duration"))return n;if("number"==typeof n)return nN(Tx(n,t).duration,0,"");const e=n;if(e.split(/\s+/).some(i=>"{"==i.charAt(0)&&"{"==i.charAt(1))){const i=nN(0,0,"");return i.dynamic=!0,i.strValue=e,i}const s=Tx(e,t);return nN(s.duration,s.delay,s.easing)}(t.timings,e.errors);e.currentAnimateTimings=r;let s,i=t.styles?t.styles:Ns({});if(5==i.type)s=this.visitKeyframes(i,e);else{let o=t.styles,a=!1;if(!o){a=!0;const c={};r.easing&&(c.easing=r.easing),o=Ns(c)}e.currentTime+=r.duration+r.delay;const l=this.visitStyle(o,e);l.isEmptyStep=a,s=l}return e.currentAnimateTimings=null,{type:4,timings:r,style:s,options:null}}visitStyle(t,e){const r=this._makeStyleAst(t,e);return this._validateStyleAst(r,e),r}_makeStyleAst(t,e){const r=[],s=Array.isArray(t.styles)?t.styles:[t.styles];for(let a of s)"string"==typeof a?a===Oa?r.push(a):e.errors.push(new te(3002,!1)):r.push(nG(a));let i=!1,o=null;return r.forEach(a=>{if(a instanceof Map&&(a.has("easing")&&(o=a.get("easing"),a.delete("easing")),!i))for(let l of a.values())if(l.toString().indexOf("{{")>=0){i=!0;break}}),{type:6,styles:r,easing:o,offset:t.offset,containsDynamicStyles:i,options:null}}_validateStyleAst(t,e){const r=e.currentAnimateTimings;let s=e.currentTime,i=e.currentTime;r&&i>0&&(i-=r.duration+r.delay),t.styles.forEach(o=>{"string"!=typeof o&&o.forEach((a,l)=>{const c=e.collectedStyles.get(e.currentQuerySelector),u=c.get(l);let d=!0;u&&(i!=s&&i>=u.startTime&&s<=u.endTime&&(e.errors.push(function QOe(n,t,e,r,s){return new te(3010,!1)}()),d=!1),i=u.startTime),d&&c.set(l,{startTime:i,endTime:s}),e.options&&function N2e(n,t,e){const r=t.params||{},s=oG(n);s.length&&s.forEach(i=>{r.hasOwnProperty(i)||e.push(function WOe(n){return new te(3001,!1)}())})}(a,e.options,e.errors)})})}visitKeyframes(t,e){const r={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push(function JOe(){return new te(3011,!1)}()),r;let i=0;const o=[];let a=!1,l=!1,c=0;const u=t.steps.map(y=>{const b=this._makeStyleAst(y,e);let _=null!=b.offset?b.offset:function G2e(n){if("string"==typeof n)return null;let t=null;if(Array.isArray(n))n.forEach(e=>{if(e instanceof Map&&e.has("offset")){const r=e;t=parseFloat(r.get("offset")),r.delete("offset")}});else if(n instanceof Map&&n.has("offset")){const e=n;t=parseFloat(e.get("offset")),e.delete("offset")}return t}(b.styles),v=0;return null!=_&&(i++,v=b.offset=_),l=l||v<0||v>1,a=a||v<c,c=v,o.push(v),b});l&&e.errors.push(function e2e(){return new te(3012,!1)}()),a&&e.errors.push(function t2e(){return new te(3200,!1)}());const d=t.steps.length;let h=0;i>0&&i<d?e.errors.push(function n2e(){return new te(3202,!1)}()):0==i&&(h=1/(d-1));const f=d-1,p=e.currentTime,m=e.currentAnimateTimings,g=m.duration;return u.forEach((y,b)=>{const _=h>0?b==f?1:h*b:o[b],v=_*g;e.currentTime=p+m.delay+v,m.duration=v,this._validateStyleAst(y,e),y.offset=_,r.styles.push(y)}),r}visitReference(t,e){return{type:8,animation:Si(this,Vm(t.animation),e),options:Qc(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:Qc(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:Qc(t.options)}}visitQuery(t,e){const r=e.currentQuerySelector,s=t.options||{};e.queryCount++,e.currentQuery=t;const[i,o]=function H2e(n){const t=!!n.split(/\s*,\s*/).find(e=>":self"==e);return t&&(n=n.replace(z2e,"")),n=n.replace(/@\*/g,Dx).replace(/@\w+/g,e=>Dx+"-"+e.slice(1)).replace(/:animating/g,Zk),[n,t]}(t.selector);e.currentQuerySelector=r.length?r+" "+i:i,Ci(e.collectedStyles,e.currentQuerySelector,new Map);const a=Si(this,Vm(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=r,{type:11,selector:i,limit:s.limit||0,optional:!!s.optional,includeSelf:o,animation:a,originalSelector:t.selector,options:Qc(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push(function r2e(){return new te(3013,!1)}());const r="full"===t.timings?{duration:0,delay:0,easing:"full"}:Tx(t.timings,e.errors,!0);return{type:12,animation:Si(this,Vm(t.animation),e),timings:r,options:null}}}class j2e{constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles=new Map,this.options=null,this.unsupportedCSSPropertiesFound=new Set}}function Qc(n){return n?(n=Bm(n)).params&&(n.params=function W2e(n){return n?Bm(n):null}(n.params)):n={},n}function nN(n,t,e){return{duration:n,delay:t,easing:e}}function rN(n,t,e,r,s,i,o=null,a=!1){return{type:1,element:n,keyframes:t,preStyleProps:e,postStyleProps:r,duration:s,delay:i,totalTime:s+i,easing:o,subTimeline:a}}class Ox{constructor(){this._map=new Map}get(t){return this._map.get(t)||[]}append(t,e){let r=this._map.get(t);r||this._map.set(t,r=[]),r.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const Y2e=new RegExp(":enter","g"),Q2e=new RegExp(":leave","g");function sN(n,t,e,r,s,i=new Map,o=new Map,a,l,c=[]){return(new J2e).buildKeyframes(n,t,e,r,s,i,o,a,l,c)}class J2e{buildKeyframes(t,e,r,s,i,o,a,l,c,u=[]){c=c||new Ox;const d=new iN(t,e,c,s,i,u,[]);d.options=l;const h=l.delay?La(l.delay):0;d.currentTimeline.delayNextStep(h),d.currentTimeline.setStyles([o],null,d.errors,l),Si(this,r,d);const f=d.timelines.filter(p=>p.containsAnimation());if(f.length&&a.size){let p;for(let m=f.length-1;m>=0;m--){const g=f[m];if(g.element===e){p=g;break}}p&&!p.allowOnlyTimelineStyles()&&p.setStyles([a],null,d.errors,l)}return f.length?f.map(p=>p.buildKeyframes()):[rN(e,[],[],[],0,h,"",!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const r=e.subInstructions.get(e.element);if(r){const s=e.createSubContext(t.options),i=e.currentTimeline.currentTime,o=this._visitSubInstructions(r,s,s.options);i!=o&&e.transformIntoNewTimeline(o)}e.previousNode=t}visitAnimateRef(t,e){const r=e.createSubContext(t.options);r.transformIntoNewTimeline(),this._applyAnimationRefDelays([t.options,t.animation.options],e,r),this.visitReference(t.animation,r),e.transformIntoNewTimeline(r.currentTimeline.currentTime),e.previousNode=t}_applyAnimationRefDelays(t,e,r){for(const s of t){const i=s?.delay;if(i){const o="number"==typeof i?i:La(zm(i,s?.params??{},e.errors));r.delayNextStep(o)}}}_visitSubInstructions(t,e,r){let i=e.currentTimeline.currentTime;const o=null!=r.duration?La(r.duration):null,a=null!=r.delay?La(r.delay):null;return 0!==o&&t.forEach(l=>{const c=e.appendInstructionToTimeline(l,o,a);i=Math.max(i,c.duration+c.delay)}),i}visitReference(t,e){e.updateOptions(t.options,!0),Si(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const r=e.subContextCount;let s=e;const i=t.options;if(i&&(i.params||i.delay)&&(s=e.createSubContext(i),s.transformIntoNewTimeline(),null!=i.delay)){6==s.previousNode.type&&(s.currentTimeline.snapshotCurrentStyles(),s.previousNode=$x);const o=La(i.delay);s.delayNextStep(o)}t.steps.length&&(t.steps.forEach(o=>Si(this,o,s)),s.currentTimeline.applyStylesToKeyframe(),s.subContextCount>r&&s.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const r=[];let s=e.currentTimeline.currentTime;const i=t.options&&t.options.delay?La(t.options.delay):0;t.steps.forEach(o=>{const a=e.createSubContext(t.options);i&&a.delayNextStep(i),Si(this,o,a),s=Math.max(s,a.currentTimeline.currentTime),r.push(a.currentTimeline)}),r.forEach(o=>e.currentTimeline.mergeTimelineCollectedStyles(o)),e.transformIntoNewTimeline(s),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const r=t.strValue;return Tx(e.params?zm(r,e.params,e.errors):r,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const r=e.currentAnimateTimings=this._visitTiming(t.timings,e),s=e.currentTimeline;r.delay&&(e.incrementTime(r.delay),s.snapshotCurrentStyles());const i=t.style;5==i.type?this.visitKeyframes(i,e):(e.incrementTime(r.duration),this.visitStyle(i,e),s.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const r=e.currentTimeline,s=e.currentAnimateTimings;!s&&r.hasCurrentStyleProperties()&&r.forwardFrame();const i=s&&s.easing||t.easing;t.isEmptyStep?r.applyEmptyStep(i):r.setStyles(t.styles,i,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const r=e.currentAnimateTimings,s=e.currentTimeline.duration,i=r.duration,a=e.createSubContext().currentTimeline;a.easing=r.easing,t.styles.forEach(l=>{a.forwardTime((l.offset||0)*i),a.setStyles(l.styles,l.easing,e.errors,e.options),a.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(a),e.transformIntoNewTimeline(s+i),e.previousNode=t}visitQuery(t,e){const r=e.currentTimeline.currentTime,s=t.options||{},i=s.delay?La(s.delay):0;i&&(6===e.previousNode.type||0==r&&e.currentTimeline.hasCurrentStyleProperties())&&(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=$x);let o=r;const a=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!s.optional,e.errors);e.currentQueryTotal=a.length;let l=null;a.forEach((c,u)=>{e.currentQueryIndex=u;const d=e.createSubContext(t.options,c);i&&d.delayNextStep(i),c===e.element&&(l=d.currentTimeline),Si(this,t.animation,d),d.currentTimeline.applyStylesToKeyframe(),o=Math.max(o,d.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(o),l&&(e.currentTimeline.mergeTimelineCollectedStyles(l),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const r=e.parentContext,s=e.currentTimeline,i=t.timings,o=Math.abs(i.duration),a=o*(e.currentQueryTotal-1);let l=o*e.currentQueryIndex;switch(i.duration<0?"reverse":i.easing){case"reverse":l=a-l;break;case"full":l=r.currentStaggerTime}const u=e.currentTimeline;l&&u.delayNextStep(l);const d=u.currentTime;Si(this,t.animation,e),e.previousNode=t,r.currentStaggerTime=s.currentTime-d+(s.startTime-r.currentTimeline.startTime)}}const $x={};class iN{constructor(t,e,r,s,i,o,a,l){this._driver=t,this.element=e,this.subInstructions=r,this._enterClassName=s,this._leaveClassName=i,this.errors=o,this.timelines=a,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=$x,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=l||new Px(this._driver,e,0),a.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const r=t;let s=this.options;null!=r.duration&&(s.duration=La(r.duration)),null!=r.delay&&(s.delay=La(r.delay));const i=r.params;if(i){let o=s.params;o||(o=this.options.params={}),Object.keys(i).forEach(a=>{(!e||!o.hasOwnProperty(a))&&(o[a]=zm(i[a],o,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const r=t.params={};Object.keys(e).forEach(s=>{r[s]=e[s]})}}return t}createSubContext(t=null,e,r){const s=e||this.element,i=new iN(this._driver,s,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(s,r||0));return i.previousNode=this.previousNode,i.currentAnimateTimings=this.currentAnimateTimings,i.options=this._copyOptions(),i.updateOptions(t),i.currentQueryIndex=this.currentQueryIndex,i.currentQueryTotal=this.currentQueryTotal,i.parentContext=this,this.subContextCount++,i}transformIntoNewTimeline(t){return this.previousNode=$x,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,r){const s={duration:e??t.duration,delay:this.currentTimeline.currentTime+(r??0)+t.delay,easing:""},i=new e$e(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,s,t.stretchStartingKeyframe);return this.timelines.push(i),s}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t>0&&this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,r,s,i,o){let a=[];if(s&&a.push(this.element),t.length>0){t=(t=t.replace(Y2e,"."+this._enterClassName)).replace(Q2e,"."+this._leaveClassName);let c=this._driver.query(this.element,t,1!=r);0!==r&&(c=r<0?c.slice(c.length+r,c.length):c.slice(0,r)),a.push(...c)}return!i&&0==a.length&&o.push(function s2e(n){return new te(3014,!1)}()),a}}class Px{constructor(t,e,r,s){this._driver=t,this.element=e,this.startTime=r,this._elementTimelineStylesLookup=s,this.duration=0,this._previousKeyframe=new Map,this._currentKeyframe=new Map,this._keyframes=new Map,this._styleSummary=new Map,this._localTimelineStyles=new Map,this._pendingStyles=new Map,this._backFill=new Map,this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.hasCurrentStyleProperties();default:return!0}}hasCurrentStyleProperties(){return this._currentKeyframe.size>0}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1===this._keyframes.size&&this._pendingStyles.size;this.duration||e?(this.forwardTime(this.currentTime+t),e&&this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new Px(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&&(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=new Map,this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles.set(t,e),this._globalTimelineStyles.set(t,e),this._styleSummary.set(t,{time:this.currentTime,value:e})}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&&this._previousKeyframe.set("easing",t);for(let[e,r]of this._globalTimelineStyles)this._backFill.set(e,r||Oa),this._currentKeyframe.set(e,Oa);this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,r,s){e&&this._previousKeyframe.set("easing",e);const i=s&&s.params||{},o=function t$e(n,t){const e=new Map;let r;return n.forEach(s=>{if("*"===s){r=r||t.keys();for(let i of r)e.set(i,Oa)}else zl(s,e)}),e}(t,this._globalTimelineStyles);for(let[a,l]of o){const c=zm(l,i,r);this._pendingStyles.set(a,c),this._localTimelineStyles.has(a)||this._backFill.set(a,this._globalTimelineStyles.get(a)??Oa),this._updateStyle(a,c)}}applyStylesToKeyframe(){0!=this._pendingStyles.size&&(this._pendingStyles.forEach((t,e)=>{this._currentKeyframe.set(e,t)}),this._pendingStyles.clear(),this._localTimelineStyles.forEach((t,e)=>{this._currentKeyframe.has(e)||this._currentKeyframe.set(e,t)}))}snapshotCurrentStyles(){for(let[t,e]of this._localTimelineStyles)this._pendingStyles.set(t,e),this._updateStyle(t,e)}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){t._styleSummary.forEach((e,r)=>{const s=this._styleSummary.get(r);(!s||e.time>s.time)&&this._updateStyle(r,e.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,r=1===this._keyframes.size&&0===this.duration;let s=[];this._keyframes.forEach((a,l)=>{const c=zl(a,new Map,this._backFill);c.forEach((u,d)=>{"!"===u?t.add(d):u===Oa&&e.add(d)}),r||c.set("offset",l/this.duration),s.push(c)});const i=t.size?kx(t.values()):[],o=e.size?kx(e.values()):[];if(r){const a=s[0],l=new Map(a);a.set("offset",0),l.set("offset",1),s=[a,l]}return rN(this.element,s,i,o,this.duration,this.startTime,this.easing,!1)}}class e$e extends Px{constructor(t,e,r,s,i,o,a=!1){super(t,e,o.delay),this.keyframes=r,this.preStyleProps=s,this.postStyleProps=i,this._stretchStartingKeyframe=a,this.timings={duration:o.duration,delay:o.delay,easing:o.easing}}containsAnimation(){return this.keyframes.length>1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:r,easing:s}=this.timings;if(this._stretchStartingKeyframe&&e){const i=[],o=r+e,a=e/o,l=zl(t[0]);l.set("offset",0),i.push(l);const c=zl(t[0]);c.set("offset",dG(a)),i.push(c);const u=t.length-1;for(let d=1;d<=u;d++){let h=zl(t[d]);const f=h.get("offset");h.set("offset",dG((e+f*r)/o)),i.push(h)}r=o,e=0,s="",t=i}return rN(this.element,t,this.preStyleProps,this.postStyleProps,r,e,s,!0)}}function dG(n,t=3){const e=Math.pow(10,t-1);return Math.round(n*e)/e}class oN{}const n$e=new Set(["width","height","minWidth","minHeight","maxWidth","maxHeight","left","top","bottom","right","fontSize","outlineWidth","outlineOffset","paddingTop","paddingLeft","paddingBottom","paddingRight","marginTop","marginLeft","marginBottom","marginRight","borderRadius","borderWidth","borderTopWidth","borderLeftWidth","borderRightWidth","borderBottomWidth","textIndent","perspective"]);class r$e extends oN{normalizePropertyName(t,e){return eN(t)}normalizeStyleValue(t,e,r,s){let i="";const o=r.toString().trim();if(n$e.has(e)&&0!==r&&"0"!==r)if("number"==typeof r)i="px";else{const a=r.match(/^[+-]?[\d\.]+([a-z]*)$/);a&&0==a[1].length&&s.push(function qOe(n,t){return new te(3005,!1)}())}return o+i}}function hG(n,t,e,r,s,i,o,a,l,c,u,d,h){return{type:0,element:n,triggerName:t,isRemovalTransition:s,fromState:e,fromStyles:i,toState:r,toStyles:o,timelines:a,queriedElements:l,preStyleProps:c,postStyleProps:u,totalTime:d,errors:h}}const aN={};class fG{constructor(t,e,r){this._triggerName=t,this.ast=e,this._stateStyles=r}match(t,e,r,s){return function s$e(n,t,e,r,s){return n.some(i=>i(t,e,r,s))}(this.ast.matchers,t,e,r,s)}buildStyles(t,e,r){let s=this._stateStyles.get("*");return void 0!==t&&(s=this._stateStyles.get(t?.toString())||s),s?s.buildStyles(e,r):new Map}build(t,e,r,s,i,o,a,l,c,u){const d=[],h=this.ast.options&&this.ast.options.params||aN,p=this.buildStyles(r,a&&a.params||aN,d),m=l&&l.params||aN,g=this.buildStyles(s,m,d),y=new Set,b=new Map,_=new Map,v="void"===s,w={params:i$e(m,h),delay:this.ast.options?.delay},C=u?[]:sN(t,e,this.ast.animation,i,o,p,g,w,c,d);let E=0;if(C.forEach(T=>{E=Math.max(T.duration+T.delay,E)}),d.length)return hG(e,this._triggerName,r,s,v,p,g,[],[],b,_,E,d);C.forEach(T=>{const N=T.element,P=Ci(b,N,new Set);T.preStyleProps.forEach(j=>P.add(j));const U=Ci(_,N,new Set);T.postStyleProps.forEach(j=>U.add(j)),N!==e&&y.add(N)});const D=kx(y.values());return hG(e,this._triggerName,r,s,v,p,g,C,D,b,_,E)}}function i$e(n,t){const e=Bm(t);for(const r in n)n.hasOwnProperty(r)&&null!=n[r]&&(e[r]=n[r]);return e}class o$e{constructor(t,e,r){this.styles=t,this.defaultParams=e,this.normalizer=r}buildStyles(t,e){const r=new Map,s=Bm(this.defaultParams);return Object.keys(t).forEach(i=>{const o=t[i];null!==o&&(s[i]=o)}),this.styles.styles.forEach(i=>{"string"!=typeof i&&i.forEach((o,a)=>{o&&(o=zm(o,s,e));const l=this.normalizer.normalizePropertyName(a,e);o=this.normalizer.normalizeStyleValue(a,l,o,e),r.set(l,o)})}),r}}class l$e{constructor(t,e,r){this.name=t,this.ast=e,this._normalizer=r,this.transitionFactories=[],this.states=new Map,e.states.forEach(s=>{this.states.set(s.name,new o$e(s.style,s.options&&s.options.params||{},r))}),pG(this.states,"true","1"),pG(this.states,"false","0"),e.transitions.forEach(s=>{this.transitionFactories.push(new fG(t,s,this.states))}),this.fallbackTransition=function c$e(n,t,e){return new fG(n,{type:1,animation:{type:2,steps:[],options:null},matchers:[(o,a)=>!0],options:null,queryCount:0,depCount:0},t)}(t,this.states)}get containsQueries(){return this.ast.queryCount>0}matchTransition(t,e,r,s){return this.transitionFactories.find(o=>o.match(t,e,r,s))||null}matchStyles(t,e,r){return this.fallbackTransition.buildStyles(t,e,r)}}function pG(n,t,e){n.has(t)?n.has(e)||n.set(e,n.get(t)):n.has(e)&&n.set(t,n.get(e))}const u$e=new Ox;class d$e{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._animations=new Map,this._playersById=new Map,this.players=[]}register(t,e){const r=[],i=tN(this._driver,e,r,[]);if(r.length)throw function d2e(n){return new te(3503,!1)}();this._animations.set(t,i)}_buildPlayer(t,e,r){const s=t.element,i=Gj(0,this._normalizer,0,t.keyframes,e,r);return this._driver.animate(s,i,t.duration,t.delay,t.easing,[],!0)}create(t,e,r={}){const s=[],i=this._animations.get(t);let o;const a=new Map;if(i?(o=sN(this._driver,e,i,Yk,Ix,new Map,new Map,r,u$e,s),o.forEach(u=>{const d=Ci(a,u.element,new Map);u.postStyleProps.forEach(h=>d.set(h,null))})):(s.push(function h2e(){return new te(3300,!1)}()),o=[]),s.length)throw function f2e(n){return new te(3504,!1)}();a.forEach((u,d)=>{u.forEach((h,f)=>{u.set(f,this._driver.computeStyle(d,f,Oa))})});const c=Vl(o.map(u=>{const d=a.get(u.element);return this._buildPlayer(u,new Map,d)}));return this._playersById.set(t,c),c.onDestroy(()=>this.destroy(t)),this.players.push(c),c}destroy(t){const e=this._getPlayer(t);e.destroy(),this._playersById.delete(t);const r=this.players.indexOf(e);r>=0&&this.players.splice(r,1)}_getPlayer(t){const e=this._playersById.get(t);if(!e)throw function p2e(n){return new te(3301,!1)}();return e}listen(t,e,r,s){const i=Gk(e,"","","");return Wk(this._getPlayer(t),r,i,s),()=>{}}command(t,e,r,s){if("register"==r)return void this.register(t,s[0]);if("create"==r)return void this.create(t,e,s[0]||{});const i=this._getPlayer(t);switch(r){case"play":i.play();break;case"pause":i.pause();break;case"reset":i.reset();break;case"restart":i.restart();break;case"finish":i.finish();break;case"init":i.init();break;case"setPosition":i.setPosition(parseFloat(s[0]));break;case"destroy":this.destroy(t)}}}const mG="ng-animate-queued",lN="ng-animate-disabled",g$e=[],gG={namespaceId:"",setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},y$e={namespaceId:"",setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0},Yi="__ng_removed";class cN{constructor(t,e=""){this.namespaceId=e;const r=t&&t.hasOwnProperty("value");if(this.value=function x$e(n){return n??null}(r?t.value:t),r){const i=Bm(t);delete i.value,this.options=i}else this.options={};this.options.params||(this.options.params={})}get params(){return this.options.params}absorbOptions(t){const e=t.params;if(e){const r=this.options.params;Object.keys(e).forEach(s=>{null==r[s]&&(r[s]=e[s])})}}}const Um="void",uN=new cN(Um);class b$e{constructor(t,e,r){this.id=t,this.hostElement=e,this._engine=r,this.players=[],this._triggers=new Map,this._queue=[],this._elementListeners=new Map,this._hostClassName="ng-tns-"+t,Zi(e,this._hostClassName)}listen(t,e,r,s){if(!this._triggers.has(e))throw function m2e(n,t){return new te(3302,!1)}();if(null==r||0==r.length)throw function g2e(n){return new te(3303,!1)}();if(!function w$e(n){return"start"==n||"done"==n}(r))throw function y2e(n,t){return new te(3400,!1)}();const i=Ci(this._elementListeners,t,[]),o={name:e,phase:r,callback:s};i.push(o);const a=Ci(this._engine.statesByElement,t,new Map);return a.has(e)||(Zi(t,Ex),Zi(t,Ex+"-"+e),a.set(e,uN)),()=>{this._engine.afterFlush(()=>{const l=i.indexOf(o);l>=0&&i.splice(l,1),this._triggers.has(e)||a.delete(e)})}}register(t,e){return!this._triggers.has(t)&&(this._triggers.set(t,e),!0)}_getTrigger(t){const e=this._triggers.get(t);if(!e)throw function b2e(n){return new te(3401,!1)}();return e}trigger(t,e,r,s=!0){const i=this._getTrigger(e),o=new dN(this.id,e,t);let a=this._engine.statesByElement.get(t);a||(Zi(t,Ex),Zi(t,Ex+"-"+e),this._engine.statesByElement.set(t,a=new Map));let l=a.get(e);const c=new cN(r,this.id);if(!(r&&r.hasOwnProperty("value"))&&l&&c.absorbOptions(l.options),a.set(e,c),l||(l=uN),c.value!==Um&&l.value===c.value){if(!function I$e(n,t){const e=Object.keys(n),r=Object.keys(t);if(e.length!=r.length)return!1;for(let s=0;s<e.length;s++){const i=e[s];if(!t.hasOwnProperty(i)||n[i]!==t[i])return!1}return!0}(l.params,c.params)){const m=[],g=i.matchStyles(l.value,l.params,m),y=i.matchStyles(c.value,c.params,m);m.length?this._engine.reportError(m):this._engine.afterFlush(()=>{Zc(t,g),Jo(t,y)})}return}const h=Ci(this._engine.playersByElement,t,[]);h.forEach(m=>{m.namespaceId==this.id&&m.triggerName==e&&m.queued&&m.destroy()});let f=i.matchTransition(l.value,c.value,t,c.params),p=!1;if(!f){if(!s)return;f=i.fallbackTransition,p=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:f,fromState:l,toState:c,player:o,isFallbackTransition:p}),p||(Zi(t,mG),o.onStart(()=>{hh(t,mG)})),o.onDone(()=>{let m=this.players.indexOf(o);m>=0&&this.players.splice(m,1);const g=this._engine.playersByElement.get(t);if(g){let y=g.indexOf(o);y>=0&&g.splice(y,1)}}),this.players.push(o),h.push(o),o}deregister(t){this._triggers.delete(t),this._engine.statesByElement.forEach(e=>e.delete(t)),this._elementListeners.forEach((e,r)=>{this._elementListeners.set(r,e.filter(s=>s.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&&(e.forEach(r=>r.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const r=this._engine.driver.query(t,Dx,!0);r.forEach(s=>{if(s[Yi])return;const i=this._engine.fetchNamespacesByElement(s);i.size?i.forEach(o=>o.triggerLeaveAnimation(s,e,!1,!0)):this.clearElementCache(s)}),this._engine.afterFlushAnimationsDone(()=>r.forEach(s=>this.clearElementCache(s)))}triggerLeaveAnimation(t,e,r,s){const i=this._engine.statesByElement.get(t),o=new Map;if(i){const a=[];if(i.forEach((l,c)=>{if(o.set(c,l.value),this._triggers.has(c)){const u=this.trigger(t,c,Um,s);u&&a.push(u)}}),a.length)return this._engine.markElementAsRemoved(this.id,t,!0,e,o),r&&Vl(a).onDone(()=>this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),r=this._engine.statesByElement.get(t);if(e&&r){const s=new Set;e.forEach(i=>{const o=i.name;if(s.has(o))return;s.add(o);const l=this._triggers.get(o).fallbackTransition,c=r.get(o)||uN,u=new cN(Um),d=new dN(this.id,o,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:o,transition:l,fromState:c,toState:u,player:d,isFallbackTransition:!0})})}}removeNode(t,e){const r=this._engine;if(t.childElementCount&&this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let s=!1;if(r.totalAnimations){const i=r.players.length?r.playersByQueriedElement.get(t):[];if(i&&i.length)s=!0;else{let o=t;for(;o=o.parentNode;)if(r.statesByElement.get(o)){s=!0;break}}}if(this.prepareLeaveAnimationListeners(t),s)r.markElementAsRemoved(this.id,t,!1,e);else{const i=t[Yi];(!i||i===gG)&&(r.afterFlush(()=>this.clearElementCache(t)),r.destroyInnerAnimations(t),r._onRemovalComplete(t,e))}}insertNode(t,e){Zi(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(r=>{const s=r.player;if(s.destroyed)return;const i=r.element,o=this._elementListeners.get(i);o&&o.forEach(a=>{if(a.name==r.triggerName){const l=Gk(i,r.triggerName,r.fromState.value,r.toState.value);l._data=t,Wk(r.player,a.phase,l,a.callback)}}),s.markedForDestroy?this._engine.afterFlush(()=>{s.destroy()}):e.push(r)}),this._queue=[],e.sort((r,s)=>{const i=r.transition.ast.depCount,o=s.transition.ast.depCount;return 0==i||0==o?i-o:this._engine.driver.containsElement(r.element,s.element)?1:-1})}destroy(t){this.players.forEach(e=>e.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&&(e=!0),e=!!this._queue.find(r=>r.element===t)||e,e}}class _$e{constructor(t,e,r){this.bodyNode=t,this.driver=e,this._normalizer=r,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(s,i)=>{}}_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=>{e.players.forEach(r=>{r.queued&&t.push(r)})}),t}createNamespace(t,e){const r=new b$e(t,e,this);return this.bodyNode&&this.driver.containsElement(this.bodyNode,e)?this._balanceNamespaceList(r,e):(this.newHostElements.set(e,r),this.collectEnterElement(e)),this._namespaceLookup[t]=r}_balanceNamespaceList(t,e){const r=this._namespaceList,s=this.namespacesByHostElement;if(r.length-1>=0){let o=!1,a=this.driver.getParentElement(e);for(;a;){const l=s.get(a);if(l){const c=r.indexOf(l);r.splice(c+1,0,t),o=!0;break}a=this.driver.getParentElement(a)}o||r.unshift(t)}else r.push(t);return s.set(e,t),t}register(t,e){let r=this._namespaceLookup[t];return r||(r=this.createNamespace(t,e)),r}registerTrigger(t,e,r){let s=this._namespaceLookup[t];s&&s.register(e,r)&&this.totalAnimations++}destroy(t,e){if(!t)return;const r=this._fetchNamespace(t);this.afterFlush(()=>{this.namespacesByHostElement.delete(r.hostElement),delete this._namespaceLookup[t];const s=this._namespaceList.indexOf(r);s>=0&&this._namespaceList.splice(s,1)}),this.afterFlushAnimationsDone(()=>r.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,r=this.statesByElement.get(t);if(r)for(let s of r.values())if(s.namespaceId){const i=this._fetchNamespace(s.namespaceId);i&&e.add(i)}return e}trigger(t,e,r,s){if(Lx(e)){const i=this._fetchNamespace(t);if(i)return i.trigger(e,r,s),!0}return!1}insertNode(t,e,r,s){if(!Lx(e))return;const i=e[Yi];if(i&&i.setForRemoval){i.setForRemoval=!1,i.setForMove=!0;const o=this.collectedLeaveElements.indexOf(e);o>=0&&this.collectedLeaveElements.splice(o,1)}if(t){const o=this._fetchNamespace(t);o&&o.insertNode(e,r)}s&&this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),Zi(t,lN)):this.disabledNodes.has(t)&&(this.disabledNodes.delete(t),hh(t,lN))}removeNode(t,e,r,s){if(Lx(e)){const i=t?this._fetchNamespace(t):null;if(i?i.removeNode(e,s):this.markElementAsRemoved(t,e,!1,s),r){const o=this.namespacesByHostElement.get(e);o&&o.id!==t&&o.removeNode(e,s)}}else this._onRemovalComplete(e,s)}markElementAsRemoved(t,e,r,s,i){this.collectedLeaveElements.push(e),e[Yi]={namespaceId:t,setForRemoval:s,hasAnimation:r,removedBeforeQueried:!1,previousTriggersValues:i}}listen(t,e,r,s,i){return Lx(e)?this._fetchNamespace(t).listen(e,r,s,i):()=>{}}_buildInstruction(t,e,r,s,i){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,r,s,t.fromState.options,t.toState.options,e,i)}destroyInnerAnimations(t){let e=this.driver.query(t,Dx,!0);e.forEach(r=>this.destroyActiveAnimationsForElement(r)),0!=this.playersByQueriedElement.size&&(e=this.driver.query(t,Zk,!0),e.forEach(r=>this.finishActiveQueriedAnimationOnElement(r)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&&e.forEach(r=>{r.queued?r.markedForDestroy=!0:r.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&&e.forEach(r=>r.finish())}whenRenderingDone(){return new Promise(t=>{if(this.players.length)return Vl(this.players).onDone(()=>t());t()})}processLeaveNode(t){const e=t[Yi];if(e&&e.setForRemoval){if(t[Yi]=gG,e.namespaceId){this.destroyInnerAnimations(t);const r=this._fetchNamespace(e.namespaceId);r&&r.clearElementCache(t)}this._onRemovalComplete(t,e.setForRemoval)}t.classList?.contains(lN)&&this.markElementAsDisabled(t,!1),this.driver.query(t,".ng-animate-disabled",!0).forEach(r=>{this.markElementAsDisabled(r,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&&(this.newHostElements.forEach((r,s)=>this._balanceNamespaceList(r,s)),this.newHostElements.clear()),this.totalAnimations&&this.collectedEnterElements.length)for(let r=0;r<this.collectedEnterElements.length;r++)Zi(this.collectedEnterElements[r],"ng-star-inserted");if(this._namespaceList.length&&(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const r=[];try{e=this._flushAnimations(r,t)}finally{for(let s=0;s<r.length;s++)r[s]()}}else for(let r=0;r<this.collectedLeaveElements.length;r++)this.processLeaveNode(this.collectedLeaveElements[r]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(r=>r()),this._flushFns=[],this._whenQuietFns.length){const r=this._whenQuietFns;this._whenQuietFns=[],e.length?Vl(e).onDone(()=>{r.forEach(s=>s())}):r.forEach(s=>s())}}reportError(t){throw function _2e(n){return new te(3402,!1)}()}_flushAnimations(t,e){const r=new Ox,s=[],i=new Map,o=[],a=new Map,l=new Map,c=new Map,u=new Set;this.disabledNodes.forEach($=>{u.add($);const V=this.driver.query($,".ng-animate-queued",!0);for(let L=0;L<V.length;L++)u.add(V[L])});const d=this.bodyNode,h=Array.from(this.statesByElement.keys()),f=_G(h,this.collectedEnterElements),p=new Map;let m=0;f.forEach(($,V)=>{const L=Yk+m++;p.set(V,L),$.forEach(W=>Zi(W,L))});const g=[],y=new Set,b=new Set;for(let $=0;$<this.collectedLeaveElements.length;$++){const V=this.collectedLeaveElements[$],L=V[Yi];L&&L.setForRemoval&&(g.push(V),y.add(V),L.hasAnimation?this.driver.query(V,".ng-star-inserted",!0).forEach(W=>y.add(W)):b.add(V))}const _=new Map,v=_G(h,Array.from(y));v.forEach(($,V)=>{const L=Ix+m++;_.set(V,L),$.forEach(W=>Zi(W,L))}),t.push(()=>{f.forEach(($,V)=>{const L=p.get(V);$.forEach(W=>hh(W,L))}),v.forEach(($,V)=>{const L=_.get(V);$.forEach(W=>hh(W,L))}),g.forEach($=>{this.processLeaveNode($)})});const w=[],C=[];for(let $=this._namespaceList.length-1;$>=0;$--)this._namespaceList[$].drainQueuedTransitions(e).forEach(L=>{const W=L.player,ne=L.element;if(w.push(W),this.collectedEnterElements.length){const _e=ne[Yi];if(_e&&_e.setForMove){if(_e.previousTriggersValues&&_e.previousTriggersValues.has(L.triggerName)){const Oe=_e.previousTriggersValues.get(L.triggerName),ke=this.statesByElement.get(L.element);if(ke&&ke.has(L.triggerName)){const Ze=ke.get(L.triggerName);Ze.value=Oe,ke.set(L.triggerName,Ze)}}return void W.destroy()}}const ie=!d||!this.driver.containsElement(d,ne),de=_.get(ne),ue=p.get(ne),he=this._buildInstruction(L,r,ue,de,ie);if(he.errors&&he.errors.length)return void C.push(he);if(ie)return W.onStart(()=>Zc(ne,he.fromStyles)),W.onDestroy(()=>Jo(ne,he.toStyles)),void s.push(W);if(L.isFallbackTransition)return W.onStart(()=>Zc(ne,he.fromStyles)),W.onDestroy(()=>Jo(ne,he.toStyles)),void s.push(W);const ge=[];he.timelines.forEach(_e=>{_e.stretchStartingKeyframe=!0,this.disabledNodes.has(_e.element)||ge.push(_e)}),he.timelines=ge,r.append(ne,he.timelines),o.push({instruction:he,player:W,element:ne}),he.queriedElements.forEach(_e=>Ci(a,_e,[]).push(W)),he.preStyleProps.forEach((_e,Oe)=>{if(_e.size){let ke=l.get(Oe);ke||l.set(Oe,ke=new Set),_e.forEach((Ze,ct)=>ke.add(ct))}}),he.postStyleProps.forEach((_e,Oe)=>{let ke=c.get(Oe);ke||c.set(Oe,ke=new Set),_e.forEach((Ze,ct)=>ke.add(ct))})});if(C.length){const $=[];C.forEach(V=>{$.push(function v2e(n,t){return new te(3505,!1)}())}),w.forEach(V=>V.destroy()),this.reportError($)}const E=new Map,D=new Map;o.forEach($=>{const V=$.element;r.has(V)&&(D.set(V,V),this._beforeAnimationBuild($.player.namespaceId,$.instruction,E))}),s.forEach($=>{const V=$.element;this._getPreviousPlayers(V,!1,$.namespaceId,$.triggerName,null).forEach(W=>{Ci(E,V,[]).push(W),W.destroy()})});const T=g.filter($=>xG($,l,c)),N=new Map;bG(N,this.driver,b,c,Oa).forEach($=>{xG($,l,c)&&T.push($)});const U=new Map;f.forEach(($,V)=>{bG(U,this.driver,new Set($),l,"!")}),T.forEach($=>{const V=N.get($),L=U.get($);N.set($,new Map([...Array.from(V?.entries()??[]),...Array.from(L?.entries()??[])]))});const j=[],q=[],K={};o.forEach($=>{const{element:V,player:L,instruction:W}=$;if(r.has(V)){if(u.has(V))return L.onDestroy(()=>Jo(V,W.toStyles)),L.disabled=!0,L.overrideTotalTime(W.totalTime),void s.push(L);let ne=K;if(D.size>1){let de=V;const ue=[];for(;de=de.parentNode;){const he=D.get(de);if(he){ne=he;break}ue.push(de)}ue.forEach(he=>D.set(he,ne))}const ie=this._buildAnimation(L.namespaceId,W,E,i,U,N);if(L.setRealPlayer(ie),ne===K)j.push(L);else{const de=this.playersByElement.get(ne);de&&de.length&&(L.parentPlayer=Vl(de)),s.push(L)}}else Zc(V,W.fromStyles),L.onDestroy(()=>Jo(V,W.toStyles)),q.push(L),u.has(V)&&s.push(L)}),q.forEach($=>{const V=i.get($.element);if(V&&V.length){const L=Vl(V);$.setRealPlayer(L)}}),s.forEach($=>{$.parentPlayer?$.syncPlayerEvents($.parentPlayer):$.destroy()});for(let $=0;$<g.length;$++){const V=g[$],L=V[Yi];if(hh(V,Ix),L&&L.hasAnimation)continue;let W=[];if(a.size){let ie=a.get(V);ie&&ie.length&&W.push(...ie);let de=this.driver.query(V,Zk,!0);for(let ue=0;ue<de.length;ue++){let he=a.get(de[ue]);he&&he.length&&W.push(...he)}}const ne=W.filter(ie=>!ie.destroyed);ne.length?C$e(this,V,ne):this.processLeaveNode(V)}return g.length=0,j.forEach($=>{this.players.push($),$.onDone(()=>{$.destroy();const V=this.players.indexOf($);this.players.splice(V,1)}),$.play()}),j}elementContainsData(t,e){let r=!1;const s=e[Yi];return s&&s.setForRemoval&&(r=!0),this.playersByElement.has(e)&&(r=!0),this.playersByQueriedElement.has(e)&&(r=!0),this.statesByElement.has(e)&&(r=!0),this._fetchNamespace(t).elementContainsData(e)||r}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,r,s,i){let o=[];if(e){const a=this.playersByQueriedElement.get(t);a&&(o=a)}else{const a=this.playersByElement.get(t);if(a){const l=!i||i==Um;a.forEach(c=>{c.queued||!l&&c.triggerName!=s||o.push(c)})}}return(r||s)&&(o=o.filter(a=>!(r&&r!=a.namespaceId||s&&s!=a.triggerName))),o}_beforeAnimationBuild(t,e,r){const i=e.element,o=e.isRemovalTransition?void 0:t,a=e.isRemovalTransition?void 0:e.triggerName;for(const l of e.timelines){const c=l.element,u=c!==i,d=Ci(r,c,[]);this._getPreviousPlayers(c,u,o,a,e.toState).forEach(f=>{const p=f.getRealPlayer();p.beforeDestroy&&p.beforeDestroy(),f.destroy(),d.push(f)})}Zc(i,e.fromStyles)}_buildAnimation(t,e,r,s,i,o){const a=e.triggerName,l=e.element,c=[],u=new Set,d=new Set,h=e.timelines.map(p=>{const m=p.element;u.add(m);const g=m[Yi];if(g&&g.removedBeforeQueried)return new Nm(p.duration,p.delay);const y=m!==l,b=function S$e(n){const t=[];return vG(n,t),t}((r.get(m)||g$e).map(E=>E.getRealPlayer())).filter(E=>!!E.element&&E.element===m),_=i.get(m),v=o.get(m),w=Gj(0,this._normalizer,0,p.keyframes,_,v),C=this._buildPlayer(p,w,b);if(p.subTimeline&&s&&d.add(m),y){const E=new dN(t,a,m);E.setRealPlayer(C),c.push(E)}return C});c.forEach(p=>{Ci(this.playersByQueriedElement,p.element,[]).push(p),p.onDone(()=>function v$e(n,t,e){let r=n.get(t);if(r){if(r.length){const s=r.indexOf(e);r.splice(s,1)}0==r.length&&n.delete(t)}return r}(this.playersByQueriedElement,p.element,p))}),u.forEach(p=>Zi(p,tG));const f=Vl(h);return f.onDestroy(()=>{u.forEach(p=>hh(p,tG)),Jo(l,e.toStyles)}),d.forEach(p=>{Ci(s,p,[]).push(f)}),f}_buildPlayer(t,e,r){return e.length>0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,r):new Nm(t.duration,t.delay)}}class dN{constructor(t,e,r){this.namespaceId=t,this.triggerName=e,this.element=r,this._player=new Nm,this._containsRealPlayer=!1,this._queuedCallbacks=new Map,this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,this._queuedCallbacks.forEach((e,r)=>{e.forEach(s=>Wk(t,r,void 0,s))}),this._queuedCallbacks.clear(),this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&&t.onStart(()=>e.triggerCallback("start")),t.onDone(()=>this.finish()),t.onDestroy(()=>this.destroy())}_queueEvent(t,e){Ci(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&&this._queueEvent("done",t),this._player.onDone(t)}onStart(t){this.queued&&this._queueEvent("start",t),this._player.onStart(t)}onDestroy(t){this.queued&&this._queueEvent("destroy",t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&&this._player.hasStarted()}play(){!this.queued&&this._player.play()}pause(){!this.queued&&this._player.pause()}restart(){!this.queued&&this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&&this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&&e.triggerCallback(t)}}function Lx(n){return n&&1===n.nodeType}function yG(n,t){const e=n.style.display;return n.style.display=t??"none",e}function bG(n,t,e,r,s){const i=[];e.forEach(l=>i.push(yG(l)));const o=[];r.forEach((l,c)=>{const u=new Map;l.forEach(d=>{const h=t.computeStyle(c,d,s);u.set(d,h),(!h||0==h.length)&&(c[Yi]=y$e,o.push(c))}),n.set(c,u)});let a=0;return e.forEach(l=>yG(l,i[a++])),o}function _G(n,t){const e=new Map;if(n.forEach(a=>e.set(a,[])),0==t.length)return e;const s=new Set(t),i=new Map;function o(a){if(!a)return 1;let l=i.get(a);if(l)return l;const c=a.parentNode;return l=e.has(c)?c:s.has(c)?1:o(c),i.set(a,l),l}return t.forEach(a=>{const l=o(a);1!==l&&e.get(l).push(a)}),e}function Zi(n,t){n.classList?.add(t)}function hh(n,t){n.classList?.remove(t)}function C$e(n,t,e){Vl(e).onDone(()=>n.processLeaveNode(t))}function vG(n,t){for(let e=0;e<n.length;e++){const r=n[e];r instanceof qH?vG(r.players,t):t.push(r)}}function xG(n,t,e){const r=e.get(n);if(!r)return!1;let s=t.get(n);return s?r.forEach(i=>s.add(i)):t.set(n,r),e.delete(n),!0}class Bx{constructor(t,e,r){this.bodyNode=t,this._driver=e,this._normalizer=r,this._triggerCache={},this.onRemovalComplete=(s,i)=>{},this._transitionEngine=new _$e(t,e,r),this._timelineEngine=new d$e(t,e,r),this._transitionEngine.onRemovalComplete=(s,i)=>this.onRemovalComplete(s,i)}registerTrigger(t,e,r,s,i){const o=t+"-"+s;let a=this._triggerCache[o];if(!a){const l=[],u=tN(this._driver,i,l,[]);if(l.length)throw function c2e(n,t){return new te(3404,!1)}();a=function a$e(n,t,e){return new l$e(n,t,e)}(s,u,this._normalizer),this._triggerCache[o]=a}this._transitionEngine.registerTrigger(e,s,a)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,r,s){this._transitionEngine.insertNode(t,e,r,s)}onRemove(t,e,r,s){this._transitionEngine.removeNode(t,e,s||!1,r)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,r,s){if("@"==r.charAt(0)){const[i,o]=qj(r);this._timelineEngine.command(i,e,o,s)}else this._transitionEngine.trigger(t,e,r,s)}listen(t,e,r,s,i){if("@"==r.charAt(0)){const[o,a]=qj(r);return this._timelineEngine.listen(o,e,a,i)}return this._transitionEngine.listen(t,e,r,s,i)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}let D$e=(()=>{class n{constructor(e,r,s){this._element=e,this._startStyles=r,this._endStyles=s,this._state=0;let i=n.initialStylesByElement.get(e);i||n.initialStylesByElement.set(e,i=new Map),this._initialStyles=i}start(){this._state<1&&(this._startStyles&&Jo(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state<2&&(Jo(this._element,this._initialStyles),this._endStyles&&(Jo(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state<3&&(n.initialStylesByElement.delete(this._element),this._startStyles&&(Zc(this._element,this._startStyles),this._endStyles=null),this._endStyles&&(Zc(this._element,this._endStyles),this._endStyles=null),Jo(this._element,this._initialStyles),this._state=3)}}return n.initialStylesByElement=new WeakMap,n})();function hN(n){let t=null;return n.forEach((e,r)=>{(function T$e(n){return"display"===n||"position"===n})(r)&&(t=t||new Map,t.set(r,e))}),t}class wG{constructor(t,e,r,s){this.element=t,this.keyframes=e,this.options=r,this._specialStyles=s,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this._originalOnDoneFns=[],this._originalOnStartFns=[],this.time=0,this.parentPlayer=null,this.currentSnapshot=new Map,this._duration=r.duration,this._delay=r.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=>t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:new Map,this.domPlayer.addEventListener("finish",()=>this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_convertKeyframesToObject(t){const e=[];return t.forEach(r=>{e.push(Object.fromEntries(r))}),e}_triggerWebAnimation(t,e,r){return t.animate(this._convertKeyframesToObject(e),r)}onStart(t){this._originalOnStartFns.push(t),this._onStartFns.push(t)}onDone(t){this._originalOnDoneFns.push(t),this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=>t()),this._onStartFns=[],this._started=!0,this._specialStyles&&this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&&this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1,this._onStartFns=this._originalOnStartFns,this._onDoneFns=this._originalOnDoneFns}_resetDomPlayerState(){this.domPlayer&&this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&&this._specialStyles.destroy(),this._onDestroyFns.forEach(t=>t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&&this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t=new Map;this.hasStarted()&&this._finalKeyframe.forEach((r,s)=>{"offset"!==s&&t.set(s,this._finished?r:aG(this.element,s))}),this.currentSnapshot=t}triggerCallback(t){const e="start"===t?this._onStartFns:this._onDoneFns;e.forEach(r=>r()),e.length=0}}class k$e{validateStyleProperty(t){return!0}validateAnimatableStyleProperty(t){return!0}matchesElement(t,e){return!1}containsElement(t,e){return Zj(t,e)}getParentElement(t){return Kk(t)}query(t,e,r){return Qj(t,e,r)}computeStyle(t,e,r){return window.getComputedStyle(t)[e]}animate(t,e,r,s,i,o=[]){const l={duration:r,delay:s,fill:0==s?"both":"forwards"};i&&(l.easing=i);const c=new Map,u=o.filter(f=>f instanceof wG);(function M2e(n,t){return 0===n||0===t})(r,s)&&u.forEach(f=>{f.currentSnapshot.forEach((p,m)=>c.set(m,p))});let d=function k2e(n){return n.length?n[0]instanceof Map?n:n.map(t=>nG(t)):[]}(e).map(f=>zl(f));d=function F2e(n,t,e){if(e.size&&t.length){let r=t[0],s=[];if(e.forEach((i,o)=>{r.has(o)||s.push(o),r.set(o,i)}),s.length)for(let i=1;i<t.length;i++){let o=t[i];s.forEach(a=>o.set(a,aG(n,a)))}}return t}(t,d,c);const h=function E$e(n,t){let e=null,r=null;return Array.isArray(t)&&t.length?(e=hN(t[0]),t.length>1&&(r=hN(t[t.length-1]))):t instanceof Map&&(e=hN(t)),e||r?new D$e(n,e,r):null}(t,d);return new wG(t,d,l,h)}}let N$e=(()=>{class n extends WH{constructor(e,r){super(),this._nextAnimationId=0,this._renderer=e.createRenderer(r.body,{id:"0",encapsulation:Ji.None,styles:[],data:{animation:[]}})}build(e){const r=this._nextAnimationId.toString();this._nextAnimationId++;const s=Array.isArray(e)?jH(e):e;return CG(this._renderer,null,r,"register",[s]),new A$e(r,this._renderer)}}return n.\u0275fac=function(e){return new(e||n)(Z(Ph),Z(wt))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();class A$e extends HAe{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new R$e(this._id,t,e||{},this._renderer)}}class R$e{constructor(t,e,r,s){this.id=t,this.element=e,this._renderer=s,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command("create",r)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return CG(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen("done",t)}onStart(t){this._listen("start",t)}onDestroy(t){this._listen("destroy",t)}init(){this._command("init")}hasStarted(){return this._started}play(){this._command("play"),this._started=!0}pause(){this._command("pause")}restart(){this._command("restart")}finish(){this._command("finish")}destroy(){this._command("destroy")}reset(){this._command("reset"),this._started=!1}setPosition(t){this._command("setPosition",t)}getPosition(){return this._renderer.engine.players[+this.id]?.getPosition()??0}}function CG(n,t,e,r,s){return n.setProperty(t,`@@${e}:${r}`,s)}const SG="@.disabled";let M$e=(()=>{class n{constructor(e,r,s){this.delegate=e,this.engine=r,this._zone=s,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),r.onRemovalComplete=(i,o)=>{const a=o?.parentNode(i);a&&o.removeChild(a,i)}}createRenderer(e,r){const i=this.delegate.createRenderer(e,r);if(!(e&&r&&r.data&&r.data.animation)){let u=this._rendererCache.get(i);return u||(u=new IG("",i,this.engine,()=>this._rendererCache.delete(i)),this._rendererCache.set(i,u)),u}const o=r.id,a=r.id+"-"+this._currentId;this._currentId++,this.engine.register(a,e);const l=u=>{Array.isArray(u)?u.forEach(l):this.engine.registerTrigger(o,a,e,u.name,u)};return r.data.animation.forEach(l),new F$e(this,a,i,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&&this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=>{this._microtaskId++})}scheduleListenerCallback(e,r,s){e>=0&&e<this._microtaskId?this._zone.run(()=>r(s)):(0==this._animationCallbacksBuffer.length&&Promise.resolve(null).then(()=>{this._zone.run(()=>{this._animationCallbacksBuffer.forEach(i=>{const[o,a]=i;o(a)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([r,s]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&&this._zone.runOutsideAngular(()=>{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&&this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return n.\u0275fac=function(e){return new(e||n)(Z(Ph),Z(Bx),Z(ft))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})();class IG{constructor(t,e,r,s){this.namespaceId=t,this.delegate=e,this.engine=r,this._onDestroy=s,this.destroyNode=this.delegate.destroyNode?i=>e.destroyNode(i):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy(),this._onDestroy?.()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,r,s=!0){this.delegate.insertBefore(t,e,r),this.engine.onInsert(this.namespaceId,e,t,s)}removeChild(t,e,r){this.engine.onRemove(this.namespaceId,e,this.delegate,r)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,r,s){this.delegate.setAttribute(t,e,r,s)}removeAttribute(t,e,r){this.delegate.removeAttribute(t,e,r)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,r,s){this.delegate.setStyle(t,e,r,s)}removeStyle(t,e,r){this.delegate.removeStyle(t,e,r)}setProperty(t,e,r){"@"==e.charAt(0)&&e==SG?this.disableAnimations(t,!!r):this.delegate.setProperty(t,e,r)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,r){return this.delegate.listen(t,e,r)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class F$e extends IG{constructor(t,e,r,s,i){super(e,r,s,i),this.factory=t,this.namespaceId=e}setProperty(t,e,r){"@"==e.charAt(0)?"."==e.charAt(1)&&e==SG?this.disableAnimations(t,r=void 0===r||!!r):this.engine.process(this.namespaceId,t,e.slice(1),r):this.delegate.setProperty(t,e,r)}listen(t,e,r){if("@"==e.charAt(0)){const s=function O$e(n){switch(n){case"body":return document.body;case"document":return document;case"window":return window;default:return n}}(t);let i=e.slice(1),o="";return"@"!=i.charAt(0)&&([i,o]=function $$e(n){const t=n.indexOf(".");return[n.substring(0,t),n.slice(t+1)]}(i)),this.engine.listen(this.namespaceId,s,i,o,a=>{this.factory.scheduleListenerCallback(a._data||-1,r,a)})}return this.delegate.listen(t,e,r)}}const EG=[{provide:WH,useClass:N$e},{provide:oN,useFactory:function L$e(){return new r$e}},{provide:Bx,useClass:(()=>{class n extends Bx{constructor(e,r,s,i){super(e.body,r,s)}ngOnDestroy(){this.flush()}}return n.\u0275fac=function(e){return new(e||n)(Z(wt),Z(Xk),Z(oN),Z(Wu))},n.\u0275prov=we({token:n,factory:n.\u0275fac}),n})()},{provide:Ph,useFactory:function B$e(n,t,e){return new M$e(n,t,e)},deps:[vy,Bx,ft]}],fN=[{provide:Xk,useFactory:()=>new k$e},{provide:ga,useValue:"BrowserAnimations"},...EG],DG=[{provide:Xk,useClass:Jj},{provide:ga,useValue:"NoopAnimations"},...EG];let V$e=(()=>{class n{static withConfig(e){return{ngModule:n,providers:e.disableAnimations?DG:fN}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=Zt({type:n}),n.\u0275inj=Gt({providers:fN,imports:[p$]}),n})();class zx{static#e=this.\u0275fac=function(e){return new(e||zx)};static#t=this.\u0275mod=Zt({type:zx,bootstrap:[Sx]});static#n=this.\u0275inj=Gt({imports:[p$,Uy,ZRe,V$e,NMe,HH,uOe,DOe,HFe,WFe,fW]})}eJ().bootstrapModule(zx).catch(n=>console.error(n))},658:kt=>{kt.exports=Q;var St=null;try{St=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Q(J,k,ae){this.low=0|J,this.high=0|k,this.unsigned=!!ae}function He(J){return!0===(J&&J.__isLong__)}Object.defineProperty(Q.prototype,"__isLong__",{value:!0}),Q.isLong=He;var er={},Ke={};function vn(J,k){var ae,je,At;return k?(At=0<=(J>>>=0)&&J<256)&&(je=Ke[J])?je:(ae=ze(J,(0|J)<0?-1:0,!0),At&&(Ke[J]=ae),ae):(At=-128<=(J|=0)&&J<128)&&(je=er[J])?je:(ae=ze(J,J<0?-1:0,!1),At&&(er[J]=ae),ae)}function ut(J,k){if(isNaN(J))return k?tr:Ht;if(k){if(J<0)return tr;if(J>=fe)return Pt}else{if(J<=-Ne)return Lt;if(J+1>=Ne)return Nt}return J<0?ut(-J,k).neg():ze(J%re|0,J/re|0,k)}function ze(J,k,ae){return new Q(J,k,ae)}Q.fromInt=vn,Q.fromNumber=ut,Q.fromBits=ze;var ot=Math.pow;function Ee(J,k,ae){if(0===J.length)throw Error("empty string");if("NaN"===J||"Infinity"===J||"+Infinity"===J||"-Infinity"===J)return Ht;if("number"==typeof k?(ae=k,k=!1):k=!!k,(ae=ae||10)<2||36<ae)throw RangeError("radix");var je;if((je=J.indexOf("-"))>0)throw Error("interior hyphen");if(0===je)return Ee(J.substring(1),k,ae).neg();for(var At=ut(ot(ae,8)),dt=Ht,Ve=0;Ve<J.length;Ve+=8){var Vn=Math.min(8,J.length-Ve),Kn=parseInt(J.substring(Ve,Ve+Vn),ae);if(Vn<8){var gr=ut(ot(ae,Vn));dt=dt.mul(gr).add(ut(Kn))}else dt=(dt=dt.mul(At)).add(ut(Kn))}return dt.unsigned=k,dt}function H(J,k){return"number"==typeof J?ut(J,k):"string"==typeof J?Ee(J,k):ze(J.low,J.high,"boolean"==typeof k?k:J.unsigned)}Q.fromString=Ee,Q.fromValue=H;var re=4294967296,fe=re*re,Ne=fe/2,$e=vn(1<<24),Ht=vn(0);Q.ZERO=Ht;var tr=vn(0,!0);Q.UZERO=tr;var qn=vn(1);Q.ONE=qn;var Ei=vn(1,!0);Q.UONE=Ei;var Zs=vn(-1);Q.NEG_ONE=Zs;var Nt=ze(-1,2147483647,!1);Q.MAX_VALUE=Nt;var Pt=ze(-1,-1,!0);Q.MAX_UNSIGNED_VALUE=Pt;var Lt=ze(0,-2147483648,!1);Q.MIN_VALUE=Lt;var ce=Q.prototype;ce.toInt=function(){return this.unsigned?this.low>>>0:this.low},ce.toNumber=function(){return this.unsigned?(this.high>>>0)*re+(this.low>>>0):this.high*re+(this.low>>>0)},ce.toString=function(k){if((k=k||10)<2||36<k)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Lt)){var ae=ut(k),je=this.div(ae),At=je.mul(ae).sub(this);return je.toString(k)+At.toInt().toString(k)}return"-"+this.neg().toString(k)}for(var dt=ut(ot(k,6),this.unsigned),Ve=this,Vn="";;){var Kn=Ve.div(dt),nn=(Ve.sub(Kn.mul(dt)).toInt()>>>0).toString(k);if((Ve=Kn).isZero())return nn+Vn;for(;nn.length<6;)nn="0"+nn;Vn=""+nn+Vn}},ce.getHighBits=function(){return this.high},ce.getHighBitsUnsigned=function(){return this.high>>>0},ce.getLowBits=function(){return this.low},ce.getLowBitsUnsigned=function(){return this.low>>>0},ce.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Lt)?64:this.neg().getNumBitsAbs();for(var k=0!=this.high?this.high:this.low,ae=31;ae>0&&0==(k&1<<ae);ae--);return 0!=this.high?ae+33:ae+1},ce.isZero=function(){return 0===this.high&&0===this.low},ce.eqz=ce.isZero,ce.isNegative=function(){return!this.unsigned&&this.high<0},ce.isPositive=function(){return this.unsigned||this.high>=0},ce.isOdd=function(){return 1==(1&this.low)},ce.isEven=function(){return 0==(1&this.low)},ce.equals=function(k){return He(k)||(k=H(k)),(this.unsigned===k.unsigned||this.high>>>31!=1||k.high>>>31!=1)&&this.high===k.high&&this.low===k.low},ce.eq=ce.equals,ce.notEquals=function(k){return!this.eq(k)},ce.neq=ce.notEquals,ce.ne=ce.notEquals,ce.lessThan=function(k){return this.comp(k)<0},ce.lt=ce.lessThan,ce.lessThanOrEqual=function(k){return this.comp(k)<=0},ce.lte=ce.lessThanOrEqual,ce.le=ce.lessThanOrEqual,ce.greaterThan=function(k){return this.comp(k)>0},ce.gt=ce.greaterThan,ce.greaterThanOrEqual=function(k){return this.comp(k)>=0},ce.gte=ce.greaterThanOrEqual,ce.ge=ce.greaterThanOrEqual,ce.compare=function(k){if(He(k)||(k=H(k)),this.eq(k))return 0;var ae=this.isNegative(),je=k.isNegative();return ae&&!je?-1:!ae&&je?1:this.unsigned?k.high>>>0>this.high>>>0||k.high===this.high&&k.low>>>0>this.low>>>0?-1:1:this.sub(k).isNegative()?-1:1},ce.comp=ce.compare,ce.negate=function(){return!this.unsigned&&this.eq(Lt)?Lt:this.not().add(qn)},ce.neg=ce.negate,ce.add=function(k){He(k)||(k=H(k));var nn=0,zr=0,Xn=0,Mr=0;return Xn+=(Mr+=(65535&this.low)+(65535&k.low))>>>16,zr+=(Xn+=(this.low>>>16)+(k.low>>>16))>>>16,nn+=(zr+=(65535&this.high)+(65535&k.high))>>>16,nn+=(this.high>>>16)+(k.high>>>16),ze((Xn&=65535)<<16|(Mr&=65535),(nn&=65535)<<16|(zr&=65535),this.unsigned)},ce.subtract=function(k){return He(k)||(k=H(k)),this.add(k.neg())},ce.sub=ce.subtract,ce.multiply=function(k){if(this.isZero())return Ht;if(He(k)||(k=H(k)),St)return ze(St.mul(this.low,this.high,k.low,k.high),St.get_high(),this.unsigned);if(k.isZero())return Ht;if(this.eq(Lt))return k.isOdd()?Lt:Ht;if(k.eq(Lt))return this.isOdd()?Lt:Ht;if(this.isNegative())return k.isNegative()?this.neg().mul(k.neg()):this.neg().mul(k).neg();if(k.isNegative())return this.mul(k.neg()).neg();if(this.lt($e)&&k.lt($e))return ut(this.toNumber()*k.toNumber(),this.unsigned);var At=65535&this.high,dt=this.low>>>16,Ve=65535&this.low,Kn=65535&k.high,gr=k.low>>>16,nn=65535&k.low,zr=0,Xn=0,Mr=0,eu=0;return Mr+=(eu+=Ve*nn)>>>16,Xn+=(Mr+=dt*nn)>>>16,Mr&=65535,Xn+=(Mr+=Ve*gr)>>>16,zr+=(Xn+=At*nn)>>>16,Xn&=65535,zr+=(Xn+=dt*gr)>>>16,Xn&=65535,zr+=(Xn+=Ve*Kn)>>>16,zr+=(this.high>>>16)*nn+At*gr+dt*Kn+Ve*(k.high>>>16),ze((Mr&=65535)<<16|(eu&=65535),(zr&=65535)<<16|(Xn&=65535),this.unsigned)},ce.mul=ce.multiply,ce.divide=function(k){if(He(k)||(k=H(k)),k.isZero())throw Error("division by zero");var je,At,dt;if(St)return this.unsigned||-2147483648!==this.high||-1!==k.low||-1!==k.high?ze((this.unsigned?St.div_u:St.div_s)(this.low,this.high,k.low,k.high),St.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?tr:Ht;if(this.unsigned){if(k.unsigned||(k=k.toUnsigned()),k.gt(this))return tr;if(k.gt(this.shru(1)))return Ei;dt=tr}else{if(this.eq(Lt))return k.eq(qn)||k.eq(Zs)?Lt:k.eq(Lt)?qn:(je=this.shr(1).div(k).shl(1)).eq(Ht)?k.isNegative()?qn:Zs:(At=this.sub(k.mul(je)),dt=je.add(At.div(k)));if(k.eq(Lt))return this.unsigned?tr:Ht;if(this.isNegative())return k.isNegative()?this.neg().div(k.neg()):this.neg().div(k).neg();if(k.isNegative())return this.div(k.neg()).neg();dt=Ht}for(At=this;At.gte(k);){je=Math.max(1,Math.floor(At.toNumber()/k.toNumber()));for(var Vn=Math.ceil(Math.log(je)/Math.LN2),Kn=Vn<=48?1:ot(2,Vn-48),gr=ut(je),nn=gr.mul(k);nn.isNegative()||nn.gt(At);)nn=(gr=ut(je-=Kn,this.unsigned)).mul(k);gr.isZero()&&(gr=qn),dt=dt.add(gr),At=At.sub(nn)}return dt},ce.div=ce.divide,ce.modulo=function(k){return He(k)||(k=H(k)),St?ze((this.unsigned?St.rem_u:St.rem_s)(this.low,this.high,k.low,k.high),St.get_high(),this.unsigned):this.sub(this.div(k).mul(k))},ce.mod=ce.modulo,ce.rem=ce.modulo,ce.not=function(){return ze(~this.low,~this.high,this.unsigned)},ce.and=function(k){return He(k)||(k=H(k)),ze(this.low&k.low,this.high&k.high,this.unsigned)},ce.or=function(k){return He(k)||(k=H(k)),ze(this.low|k.low,this.high|k.high,this.unsigned)},ce.xor=function(k){return He(k)||(k=H(k)),ze(this.low^k.low,this.high^k.high,this.unsigned)},ce.shiftLeft=function(k){return He(k)&&(k=k.toInt()),0==(k&=63)?this:k<32?ze(this.low<<k,this.high<<k|this.low>>>32-k,this.unsigned):ze(0,this.low<<k-32,this.unsigned)},ce.shl=ce.shiftLeft,ce.shiftRight=function(k){return He(k)&&(k=k.toInt()),0==(k&=63)?this:k<32?ze(this.low>>>k|this.high<<32-k,this.high>>k,this.unsigned):ze(this.high>>k-32,this.high>=0?0:-1,this.unsigned)},ce.shr=ce.shiftRight,ce.shiftRightUnsigned=function(k){if(He(k)&&(k=k.toInt()),0==(k&=63))return this;var ae=this.high;return k<32?ze(this.low>>>k|ae<<32-k,ae>>>k,this.unsigned):ze(32===k?ae:ae>>>k-32,0,this.unsigned)},ce.shru=ce.shiftRightUnsigned,ce.shr_u=ce.shiftRightUnsigned,ce.toSigned=function(){return this.unsigned?ze(this.low,this.high,!1):this},ce.toUnsigned=function(){return this.unsigned?this:ze(this.low,this.high,!0)},ce.toBytes=function(k){return k?this.toBytesLE():this.toBytesBE()},ce.toBytesLE=function(){var k=this.high,ae=this.low;return[255&ae,ae>>>8&255,ae>>>16&255,ae>>>24,255&k,k>>>8&255,k>>>16&255,k>>>24]},ce.toBytesBE=function(){var k=this.high,ae=this.low;return[k>>>24,k>>>16&255,k>>>8&255,255&k,ae>>>24,ae>>>16&255,ae>>>8&255,255&ae]},Q.fromBytes=function(k,ae,je){return je?Q.fromBytesLE(k,ae):Q.fromBytesBE(k,ae)},Q.fromBytesLE=function(k,ae){return new Q(k[0]|k[1]<<8|k[2]<<16|k[3]<<24,k[4]|k[5]<<8|k[6]<<16|k[7]<<24,ae)},Q.fromBytesBE=function(k,ae){return new Q(k[4]<<24|k[5]<<16|k[6]<<8|k[7],k[0]<<24|k[1]<<16|k[2]<<8|k[3],ae)}},340:(kt,St,Q)=>{var He=Q(471),er=Q(992),Ke=Q(657),vn=Q(583),ut=Q(929),ze=Q(83),ot=Q(818);ot.alea=He,ot.xor128=er,ot.xorwow=Ke,ot.xorshift7=vn,ot.xor4096=ut,ot.tychei=ze,kt.exports=ot},471:function(kt,St,Q){var He;!function(er,Ke,vn){function ut(H){var pe=this,be=function Ee(){var H=4022871197;return function(be){be=String(be);for(var re=0;re<be.length;re++){var fe=.02519603282416938*(H+=be.charCodeAt(re));fe-=H=fe>>>0,H=(fe*=H)>>>0,H+=4294967296*(fe-=H)}return 2.3283064365386963e-10*(H>>>0)}}();pe.next=function(){var re=2091639*pe.s0+2.3283064365386963e-10*pe.c;return pe.s0=pe.s1,pe.s1=pe.s2,pe.s2=re-(pe.c=0|re)},pe.c=1,pe.s0=be(" "),pe.s1=be(" "),pe.s2=be(" "),pe.s0-=be(H),pe.s0<0&&(pe.s0+=1),pe.s1-=be(H),pe.s1<0&&(pe.s1+=1),pe.s2-=be(H),pe.s2<0&&(pe.s2+=1),be=null}function ze(H,pe){return pe.c=H.c,pe.s0=H.s0,pe.s1=H.s1,pe.s2=H.s2,pe}function ot(H,pe){var be=new ut(H),re=pe&&pe.state,fe=be.next;return fe.int32=function(){return 4294967296*be.next()|0},fe.double=function(){return fe()+11102230246251565e-32*(2097152*fe()|0)},fe.quick=fe,re&&("object"==typeof re&&ze(re,be),fe.state=function(){return ze(be,{})}),fe}Ke&&Ke.exports?Ke.exports=ot:Q.amdD&&Q.amdO?void 0!==(He=function(){return ot}.call(St,Q,St,Ke))&&(Ke.exports=He):this.alea=ot}(0,kt=Q.nmd(kt))},83:function(kt,St,Q){var He;!function(er,Ke,vn){function ut(Ee){var H=this,pe="";H.next=function(){var re=H.b,fe=H.c,Ne=H.d,$e=H.a;return re=re<<25^re>>>7^fe,fe=fe-Ne|0,Ne=Ne<<24^Ne>>>8^$e,$e=$e-re|0,H.b=re=re<<20^re>>>12^fe,H.c=fe=fe-Ne|0,H.d=Ne<<16^fe>>>16^$e,H.a=$e-re|0},H.a=0,H.b=0,H.c=-1640531527,H.d=1367130551,Ee===Math.floor(Ee)?(H.a=Ee/4294967296|0,H.b=0|Ee):pe+=Ee;for(var be=0;be<pe.length+20;be++)H.b^=0|pe.charCodeAt(be),H.next()}function ze(Ee,H){return H.a=Ee.a,H.b=Ee.b,H.c=Ee.c,H.d=Ee.d,H}function ot(Ee,H){var pe=new ut(Ee),be=H&&H.state,re=function(){return(pe.next()>>>0)/4294967296};return re.double=function(){do{var $e=((pe.next()>>>11)+(pe.next()>>>0)/4294967296)/(1<<21)}while(0===$e);return $e},re.int32=pe.next,re.quick=re,be&&("object"==typeof be&&ze(be,pe),re.state=function(){return ze(pe,{})}),re}Ke&&Ke.exports?Ke.exports=ot:Q.amdD&&Q.amdO?void 0!==(He=function(){return ot}.call(St,Q,St,Ke))&&(Ke.exports=He):this.tychei=ot}(0,kt=Q.nmd(kt))},992:function(kt,St,Q){var He;!function(er,Ke,vn){function ut(Ee){var H=this,pe="";H.x=0,H.y=0,H.z=0,H.w=0,H.next=function(){var re=H.x^H.x<<11;return H.x=H.y,H.y=H.z,H.z=H.w,H.w^=H.w>>>19^re^re>>>8},Ee===(0|Ee)?H.x=Ee:pe+=Ee;for(var be=0;be<pe.length+64;be++)H.x^=0|pe.charCodeAt(be),H.next()}function ze(Ee,H){return H.x=Ee.x,H.y=Ee.y,H.z=Ee.z,H.w=Ee.w,H}function ot(Ee,H){var pe=new ut(Ee),be=H&&H.state,re=function(){return(pe.next()>>>0)/4294967296};return re.double=function(){do{var $e=((pe.next()>>>11)+(pe.next()>>>0)/4294967296)/(1<<21)}while(0===$e);return $e},re.int32=pe.next,re.quick=re,be&&("object"==typeof be&&ze(be,pe),re.state=function(){return ze(pe,{})}),re}Ke&&Ke.exports?Ke.exports=ot:Q.amdD&&Q.amdO?void 0!==(He=function(){return ot}.call(St,Q,St,Ke))&&(Ke.exports=He):this.xor128=ot}(0,kt=Q.nmd(kt))},929:function(kt,St,Q){var He;!function(er,Ke,vn){function ut(Ee){var H=this;H.next=function(){var Ne,$e,be=H.w,re=H.X,fe=H.i;return H.w=be=be+1640531527|0,$e=re[fe+34&127],Ne=re[fe=fe+1&127],$e^=$e<<13,Ne^=Ne<<17,$e=re[fe]=($e^=$e>>>15)^(Ne^=Ne>>>12),H.i=fe,$e+(be^be>>>16)|0},function pe(be,re){var fe,Ne,$e,Ht,tr,qn=[],Ei=128;for(re===(0|re)?(Ne=re,re=null):(re+="\0",Ne=0,Ei=Math.max(Ei,re.length)),$e=0,Ht=-32;Ht<Ei;++Ht)re&&(Ne^=re.charCodeAt((Ht+32)%re.length)),0===Ht&&(tr=Ne),Ne^=Ne<<10,Ne^=Ne>>>15,Ne^=Ne<<4,Ne^=Ne>>>13,Ht>=0&&($e=0==(fe=qn[127&Ht]^=Ne+(tr=tr+1640531527|0))?$e+1:0);for($e>=128&&(qn[127&(re&&re.length||0)]=-1),$e=127,Ht=512;Ht>0;--Ht)Ne=qn[$e+34&127],fe=qn[$e=$e+1&127],Ne^=Ne<<13,fe^=fe<<17,qn[$e]=(Ne^=Ne>>>15)^(fe^=fe>>>12);be.w=tr,be.X=qn,be.i=$e}(H,Ee)}function ze(Ee,H){return H.i=Ee.i,H.w=Ee.w,H.X=Ee.X.slice(),H}function ot(Ee,H){null==Ee&&(Ee=+new Date);var pe=new ut(Ee),be=H&&H.state,re=function(){return(pe.next()>>>0)/4294967296};return re.double=function(){do{var $e=((pe.next()>>>11)+(pe.next()>>>0)/4294967296)/(1<<21)}while(0===$e);return $e},re.int32=pe.next,re.quick=re,be&&(be.X&&ze(be,pe),re.state=function(){return ze(pe,{})}),re}Ke&&Ke.exports?Ke.exports=ot:Q.amdD&&Q.amdO?void 0!==(He=function(){return ot}.call(St,Q,St,Ke))&&(Ke.exports=He):this.xor4096=ot}(0,kt=Q.nmd(kt))},583:function(kt,St,Q){var He;!function(er,Ke,vn){function ut(Ee){var H=this;H.next=function(){var fe,Ne,be=H.x,re=H.i;return fe=be[re],Ne=(fe^=fe>>>7)^fe<<24,Ne^=(fe=be[re+1&7])^fe>>>10,Ne^=(fe=be[re+3&7])^fe>>>3,Ne^=(fe=be[re+4&7])^fe<<7,fe=be[re+7&7],be[re]=Ne^=(fe^=fe<<13)^fe<<9,H.i=re+1&7,Ne},function pe(be,re){var fe,$e=[];if(re===(0|re))$e[0]=re;else for(re=""+re,fe=0;fe<re.length;++fe)$e[7&fe]=$e[7&fe]<<15^re.charCodeAt(fe)+$e[fe+1&7]<<13;for(;$e.length<8;)$e.push(0);for(fe=0;fe<8&&0===$e[fe];++fe);for(8==fe&&($e[7]=-1),be.x=$e,be.i=0,fe=256;fe>0;--fe)be.next()}(H,Ee)}function ze(Ee,H){return H.x=Ee.x.slice(),H.i=Ee.i,H}function ot(Ee,H){null==Ee&&(Ee=+new Date);var pe=new ut(Ee),be=H&&H.state,re=function(){return(pe.next()>>>0)/4294967296};return re.double=function(){do{var $e=((pe.next()>>>11)+(pe.next()>>>0)/4294967296)/(1<<21)}while(0===$e);return $e},re.int32=pe.next,re.quick=re,be&&(be.x&&ze(be,pe),re.state=function(){return ze(pe,{})}),re}Ke&&Ke.exports?Ke.exports=ot:Q.amdD&&Q.amdO?void 0!==(He=function(){return ot}.call(St,Q,St,Ke))&&(Ke.exports=He):this.xorshift7=ot}(0,kt=Q.nmd(kt))},657:function(kt,St,Q){var He;!function(er,Ke,vn){function ut(Ee){var H=this,pe="";H.next=function(){var re=H.x^H.x>>>2;return H.x=H.y,H.y=H.z,H.z=H.w,H.w=H.v,(H.d=H.d+362437|0)+(H.v=H.v^H.v<<4^re^re<<1)|0},H.x=0,H.y=0,H.z=0,H.w=0,H.v=0,Ee===(0|Ee)?H.x=Ee:pe+=Ee;for(var be=0;be<pe.length+64;be++)H.x^=0|pe.charCodeAt(be),be==pe.length&&(H.d=H.x<<10^H.x>>>4),H.next()}function ze(Ee,H){return H.x=Ee.x,H.y=Ee.y,H.z=Ee.z,H.w=Ee.w,H.v=Ee.v,H.d=Ee.d,H}function ot(Ee,H){var pe=new ut(Ee),be=H&&H.state,re=function(){return(pe.next()>>>0)/4294967296};return re.double=function(){do{var $e=((pe.next()>>>11)+(pe.next()>>>0)/4294967296)/(1<<21)}while(0===$e);return $e},re.int32=pe.next,re.quick=re,be&&("object"==typeof be&&ze(be,pe),re.state=function(){return ze(pe,{})}),re}Ke&&Ke.exports?Ke.exports=ot:Q.amdD&&Q.amdO?void 0!==(He=function(){return ot}.call(St,Q,St,Ke))&&(Ke.exports=He):this.xorwow=ot}(0,kt=Q.nmd(kt))},818:function(kt,St,Q){var He;!function(er,Ke,vn){var fe,ut=256,H=vn.pow(ut,6),pe=vn.pow(2,52),be=2*pe;function Ne(Nt,Pt,Lt){var ce=[],J=qn(tr((Pt=1==Pt?{entropy:!0}:Pt||{}).entropy?[Nt,Zs(Ke)]:Nt??function Ei(){try{var Nt;return fe&&(Nt=fe.randomBytes)?Nt=Nt(ut):(Nt=new Uint8Array(ut),(er.crypto||er.msCrypto).getRandomValues(Nt)),Zs(Nt)}catch{var Pt=er.navigator,Lt=Pt&&Pt.plugins;return[+new Date,er,Lt,er.screen,Zs(Ke)]}}(),3),ce),k=new $e(ce),ae=function(){for(var je=k.g(6),At=H,dt=0;je<pe;)je=(je+dt)*ut,At*=ut,dt=k.g(1);for(;je>=be;)je/=2,At/=2,dt>>>=1;return(je+dt)/At};return ae.int32=function(){return 0|k.g(4)},ae.quick=function(){return k.g(4)/4294967296},ae.double=ae,qn(Zs(k.S),Ke),(Pt.pass||Lt||function(je,At,dt,Ve){return Ve&&(Ve.S&&Ht(Ve,k),je.state=function(){return Ht(k,{})}),dt?(vn.random=je,At):je})(ae,J,"global"in Pt?Pt.global:this==vn,Pt.state)}function $e(Nt){var Pt,Lt=Nt.length,ce=this,J=0,k=ce.i=ce.j=0,ae=ce.S=[];for(Lt||(Nt=[Lt++]);J<ut;)ae[J]=J++;for(J=0;J<ut;J++)ae[J]=ae[k=255&k+Nt[J%Lt]+(Pt=ae[J])],ae[k]=Pt;(ce.g=function(je){for(var At,dt=0,Ve=ce.i,Vn=ce.j,Kn=ce.S;je--;)At=Kn[Ve=255&Ve+1],dt=dt*ut+Kn[255&(Kn[Ve]=Kn[Vn=255&Vn+At])+(Kn[Vn]=At)];return ce.i=Ve,ce.j=Vn,dt})(ut)}function Ht(Nt,Pt){return Pt.i=Nt.i,Pt.j=Nt.j,Pt.S=Nt.S.slice(),Pt}function tr(Nt,Pt){var J,Lt=[],ce=typeof Nt;if(Pt&&"object"==ce)for(J in Nt)try{Lt.push(tr(Nt[J],Pt-1))}catch{}return Lt.length?Lt:"string"==ce?Nt:Nt+"\0"}function qn(Nt,Pt){for(var ce,Lt=Nt+"",J=0;J<Lt.length;)Pt[255&J]=255&(ce^=19*Pt[255&J])+Lt.charCodeAt(J++);return Zs(Pt)}function Zs(Nt){return String.fromCharCode.apply(0,Nt)}if(qn(vn.random(),Ke),kt.exports){kt.exports=Ne;try{fe=Q(42)}catch{}}else void 0!==(He=function(){return Ne}.call(St,Q,St,kt))&&(kt.exports=He)}(typeof self<"u"?self:this,[],Math)},410:()=>{},628:()=>{},601:()=>{},792:()=>{},977:()=>{},42:()=>{}},kt=>{kt(kt.s=903)}]);